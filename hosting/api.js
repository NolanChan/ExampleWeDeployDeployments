!function(t,e){"object"==typeof exports&&"object"==typeof module?module.exports=e():"function"==typeof define&&define.amd?define([],e):"object"==typeof exports?exports.io=e():t.io=e()}(this,function(){return function(t){function e(n){if(r[n])return r[n].exports;var o=r[n]={exports:{},id:n,loaded:!1};return t[n].call(o.exports,o,o.exports,e),o.loaded=!0,o.exports}var r={};return e.m=t,e.c=r,e.p="",e(0)}([function(t,e,r){"use strict";function n(t,e){"object"===("undefined"==typeof t?"undefined":o(t))&&(e=t,t=void 0),e=e||{};var r,n=i(t),s=n.source,h=n.id,p=n.path,u=c[h]&&p in c[h].nsps,f=e.forceNew||e["force new connection"]||!1===e.multiplex||u;return f?r=a(s,e):(c[h]||(c[h]=a(s,e)),r=c[h]),n.query&&!e.query&&(e.query=n.query),r.socket(n.path,e)}var o="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(t){return typeof t}:function(t){return t&&"function"==typeof Symbol&&t.constructor===Symbol&&t!==Symbol.prototype?"symbol":typeof t},i=r(1),s=r(4),a=r(10);r(3)("socket.io-client");t.exports=e=n;var c=e.managers={};e.protocol=s.protocol,e.connect=n,e.Manager=r(10),e.Socket=r(36)},function(t,e,r){(function(e){"use strict";function n(t,r){var n=t;r=r||e.location,null==t&&(t=r.protocol+"//"+r.host),"string"==typeof t&&("/"===t.charAt(0)&&(t="/"===t.charAt(1)?r.protocol+t:r.host+t),/^(https?|wss?):\/\//.test(t)||(t="undefined"!=typeof r?r.protocol+"//"+t:"https://"+t),n=o(t)),n.port||(/^(http|ws)$/.test(n.protocol)?n.port="80":/^(http|ws)s$/.test(n.protocol)&&(n.port="443")),n.path=n.path||"/";var i=n.host.indexOf(":")!==-1,s=i?"["+n.host+"]":n.host;return n.id=n.protocol+"://"+s+":"+n.port,n.href=n.protocol+"://"+s+(r&&r.port===n.port?"":":"+n.port),n}var o=r(2);r(3)("socket.io-client:url");t.exports=n}).call(e,function(){return this}())},function(t,e){var r=/^(?:(?![^:@]+:[^:@\/]*@)(http|https|ws|wss):\/\/)?((?:(([^:@]*)(?::([^:@]*))?)?@)?((?:[a-f0-9]{0,4}:){2,7}[a-f0-9]{0,4}|[^:\/?#]*)(?::(\d*))?)(((\/(?:[^?#](?![^?#\/]*\.[^?#\/.]+(?:[?#]|$)))*\/?)?([^?#\/]*))(?:\?([^#]*))?(?:#(.*))?)/,n=["source","protocol","authority","userInfo","user","password","host","port","relative","path","directory","file","query","anchor"];t.exports=function(t){var e=t,o=t.indexOf("["),i=t.indexOf("]");o!=-1&&i!=-1&&(t=t.substring(0,o)+t.substring(o,i).replace(/:/g,";")+t.substring(i,t.length));for(var s=r.exec(t||""),a={},c=14;c--;)a[n[c]]=s[c]||"";return o!=-1&&i!=-1&&(a.source=e,a.host=a.host.substring(1,a.host.length-1).replace(/;/g,":"),a.authority=a.authority.replace("[","").replace("]","").replace(/;/g,":"),a.ipv6uri=!0),a}},function(t,e){"use strict";t.exports=function(){return function(){}}},function(t,e,r){function n(){}function o(t){var r=""+t.type;return e.BINARY_EVENT!==t.type&&e.BINARY_ACK!==t.type||(r+=t.attachments+"-"),t.nsp&&"/"!==t.nsp&&(r+=t.nsp+","),null!=t.id&&(r+=t.id),null!=t.data&&(r+=JSON.stringify(t.data)),r}function i(t,e){function r(t){var r=l.deconstructPacket(t),n=o(r.packet),i=r.buffers;i.unshift(n),e(i)}l.removeBlobs(t,r)}function s(){this.reconstructor=null}function a(t){var r=0,n={type:Number(t.charAt(0))};if(null==e.types[n.type])return p();if(e.BINARY_EVENT===n.type||e.BINARY_ACK===n.type){for(var o="";"-"!==t.charAt(++r)&&(o+=t.charAt(r),r!=t.length););if(o!=Number(o)||"-"!==t.charAt(r))throw new Error("Illegal attachments");n.attachments=Number(o)}if("/"===t.charAt(r+1))for(n.nsp="";++r;){var i=t.charAt(r);if(","===i)break;if(n.nsp+=i,r===t.length)break}else n.nsp="/";var s=t.charAt(r+1);if(""!==s&&Number(s)==s){for(n.id="";++r;){var i=t.charAt(r);if(null==i||Number(i)!=i){--r;break}if(n.id+=t.charAt(r),r===t.length)break}n.id=Number(n.id)}return t.charAt(++r)&&(n=c(n,t.substr(r))),n}function c(t,e){try{t.data=JSON.parse(e)}catch(t){return p()}return t}function h(t){this.reconPack=t,this.buffers=[]}function p(){return{type:e.ERROR,data:"parser error"}}var u=(r(3)("socket.io-parser"),r(5)),f=r(6),l=r(8),d=r(9);e.protocol=4,e.types=["CONNECT","DISCONNECT","EVENT","ACK","ERROR","BINARY_EVENT","BINARY_ACK"],e.CONNECT=0,e.DISCONNECT=1,e.EVENT=2,e.ACK=3,e.ERROR=4,e.BINARY_EVENT=5,e.BINARY_ACK=6,e.Encoder=n,e.Decoder=s,n.prototype.encode=function(t,r){if(t.type!==e.EVENT&&t.type!==e.ACK||!f(t.data)||(t.type=t.type===e.EVENT?e.BINARY_EVENT:e.BINARY_ACK),e.BINARY_EVENT===t.type||e.BINARY_ACK===t.type)i(t,r);else{var n=o(t);r([n])}},u(s.prototype),s.prototype.add=function(t){var r;if("string"==typeof t)r=a(t),e.BINARY_EVENT===r.type||e.BINARY_ACK===r.type?(this.reconstructor=new h(r),0===this.reconstructor.reconPack.attachments&&this.emit("decoded",r)):this.emit("decoded",r);else{if(!d(t)&&!t.base64)throw new Error("Unknown type: "+t);if(!this.reconstructor)throw new Error("got binary data when not reconstructing a packet");r=this.reconstructor.takeBinaryData(t),r&&(this.reconstructor=null,this.emit("decoded",r))}},s.prototype.destroy=function(){this.reconstructor&&this.reconstructor.finishedReconstruction()},h.prototype.takeBinaryData=function(t){if(this.buffers.push(t),this.buffers.length===this.reconPack.attachments){var e=l.reconstructPacket(this.reconPack,this.buffers);return this.finishedReconstruction(),e}return null},h.prototype.finishedReconstruction=function(){this.reconPack=null,this.buffers=[]}},function(t,e,r){function n(t){if(t)return o(t)}function o(t){for(var e in n.prototype)t[e]=n.prototype[e];return t}t.exports=n,n.prototype.on=n.prototype.addEventListener=function(t,e){return this._callbacks=this._callbacks||{},(this._callbacks["$"+t]=this._callbacks["$"+t]||[]).push(e),this},n.prototype.once=function(t,e){function r(){this.off(t,r),e.apply(this,arguments)}return r.fn=e,this.on(t,r),this},n.prototype.off=n.prototype.removeListener=n.prototype.removeAllListeners=n.prototype.removeEventListener=function(t,e){if(this._callbacks=this._callbacks||{},0==arguments.length)return this._callbacks={},this;var r=this._callbacks["$"+t];if(!r)return this;if(1==arguments.length)return delete this._callbacks["$"+t],this;for(var n,o=0;o<r.length;o++)if(n=r[o],n===e||n.fn===e){r.splice(o,1);break}return this},n.prototype.emit=function(t){this._callbacks=this._callbacks||{};var e=[].slice.call(arguments,1),r=this._callbacks["$"+t];if(r){r=r.slice(0);for(var n=0,o=r.length;n<o;++n)r[n].apply(this,e)}return this},n.prototype.listeners=function(t){return this._callbacks=this._callbacks||{},this._callbacks["$"+t]||[]},n.prototype.hasListeners=function(t){return!!this.listeners(t).length}},function(t,e,r){(function(e){function n(t){if(!t||"object"!=typeof t)return!1;if(o(t)){for(var r=0,i=t.length;r<i;r++)if(n(t[r]))return!0;return!1}if("function"==typeof e.Buffer&&e.Buffer.isBuffer&&e.Buffer.isBuffer(t)||"function"==typeof e.ArrayBuffer&&t instanceof ArrayBuffer||s&&t instanceof Blob||a&&t instanceof File)return!0;if(t.toJSON&&"function"==typeof t.toJSON&&1===arguments.length)return n(t.toJSON(),!0);for(var c in t)if(Object.prototype.hasOwnProperty.call(t,c)&&n(t[c]))return!0;return!1}var o=r(7),i=Object.prototype.toString,s="function"==typeof e.Blob||"[object BlobConstructor]"===i.call(e.Blob),a="function"==typeof e.File||"[object FileConstructor]"===i.call(e.File);t.exports=n}).call(e,function(){return this}())},function(t,e){var r={}.toString;t.exports=Array.isArray||function(t){return"[object Array]"==r.call(t)}},function(t,e,r){(function(t){function n(t,e){if(!t)return t;if(s(t)){var r={_placeholder:!0,num:e.length};return e.push(t),r}if(i(t)){for(var o=new Array(t.length),a=0;a<t.length;a++)o[a]=n(t[a],e);return o}if("object"==typeof t&&!(t instanceof Date)){var o={};for(var c in t)o[c]=n(t[c],e);return o}return t}function o(t,e){if(!t)return t;if(t&&t._placeholder)return e[t.num];if(i(t))for(var r=0;r<t.length;r++)t[r]=o(t[r],e);else if("object"==typeof t)for(var n in t)t[n]=o(t[n],e);return t}var i=r(7),s=r(9),a=Object.prototype.toString,c="function"==typeof t.Blob||"[object BlobConstructor]"===a.call(t.Blob),h="function"==typeof t.File||"[object FileConstructor]"===a.call(t.File);e.deconstructPacket=function(t){var e=[],r=t.data,o=t;return o.data=n(r,e),o.attachments=e.length,{packet:o,buffers:e}},e.reconstructPacket=function(t,e){return t.data=o(t.data,e),t.attachments=void 0,t},e.removeBlobs=function(t,e){function r(t,a,p){if(!t)return t;if(c&&t instanceof Blob||h&&t instanceof File){n++;var u=new FileReader;u.onload=function(){p?p[a]=this.result:o=this.result,--n||e(o)},u.readAsArrayBuffer(t)}else if(i(t))for(var f=0;f<t.length;f++)r(t[f],f,t);else if("object"==typeof t&&!s(t))for(var l in t)r(t[l],l,t)}var n=0,o=t;r(o),n||e(o)}}).call(e,function(){return this}())},function(t,e){(function(e){function r(t){return e.Buffer&&e.Buffer.isBuffer(t)||e.ArrayBuffer&&t instanceof ArrayBuffer}t.exports=r}).call(e,function(){return this}())},function(t,e,r){"use strict";function n(t,e){if(!(this instanceof n))return new n(t,e);t&&"object"===("undefined"==typeof t?"undefined":o(t))&&(e=t,t=void 0),e=e||{},e.path=e.path||"/socket.io",this.nsps={},this.subs=[],this.opts=e,this.reconnection(e.reconnection!==!1),this.reconnectionAttempts(e.reconnectionAttempts||1/0),this.reconnectionDelay(e.reconnectionDelay||1e3),this.reconnectionDelayMax(e.reconnectionDelayMax||5e3),this.randomizationFactor(e.randomizationFactor||.5),this.backoff=new f({min:this.reconnectionDelay(),max:this.reconnectionDelayMax(),jitter:this.randomizationFactor()}),this.timeout(null==e.timeout?2e4:e.timeout),this.readyState="closed",this.uri=t,this.connecting=[],this.lastPing=null,this.encoding=!1,this.packetBuffer=[];var r=e.parser||c;this.encoder=new r.Encoder,this.decoder=new r.Decoder,this.autoConnect=e.autoConnect!==!1,this.autoConnect&&this.open()}var o="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(t){return typeof t}:function(t){return t&&"function"==typeof Symbol&&t.constructor===Symbol&&t!==Symbol.prototype?"symbol":typeof t},i=r(11),s=r(36),a=r(5),c=r(4),h=r(38),p=r(39),u=(r(3)("socket.io-client:manager"),r(34)),f=r(40),l=Object.prototype.hasOwnProperty;t.exports=n,n.prototype.emitAll=function(){this.emit.apply(this,arguments);for(var t in this.nsps)l.call(this.nsps,t)&&this.nsps[t].emit.apply(this.nsps[t],arguments)},n.prototype.updateSocketIds=function(){for(var t in this.nsps)l.call(this.nsps,t)&&(this.nsps[t].id=this.generateId(t))},n.prototype.generateId=function(t){return("/"===t?"":t+"#")+this.engine.id},a(n.prototype),n.prototype.reconnection=function(t){return arguments.length?(this._reconnection=!!t,this):this._reconnection},n.prototype.reconnectionAttempts=function(t){return arguments.length?(this._reconnectionAttempts=t,this):this._reconnectionAttempts},n.prototype.reconnectionDelay=function(t){return arguments.length?(this._reconnectionDelay=t,this.backoff&&this.backoff.setMin(t),this):this._reconnectionDelay},n.prototype.randomizationFactor=function(t){return arguments.length?(this._randomizationFactor=t,this.backoff&&this.backoff.setJitter(t),this):this._randomizationFactor},n.prototype.reconnectionDelayMax=function(t){return arguments.length?(this._reconnectionDelayMax=t,this.backoff&&this.backoff.setMax(t),this):this._reconnectionDelayMax},n.prototype.timeout=function(t){return arguments.length?(this._timeout=t,this):this._timeout},n.prototype.maybeReconnectOnOpen=function(){!this.reconnecting&&this._reconnection&&0===this.backoff.attempts&&this.reconnect()},n.prototype.open=n.prototype.connect=function(t,e){if(~this.readyState.indexOf("open"))return this;this.engine=i(this.uri,this.opts);var r=this.engine,n=this;this.readyState="opening",this.skipReconnect=!1;var o=h(r,"open",function(){n.onopen(),t&&t()}),s=h(r,"error",function(e){if(n.cleanup(),n.readyState="closed",n.emitAll("connect_error",e),t){var r=new Error("Connection error");r.data=e,t(r)}else n.maybeReconnectOnOpen()});if(!1!==this._timeout){var a=this._timeout,c=setTimeout(function(){o.destroy(),r.close(),r.emit("error","timeout"),n.emitAll("connect_timeout",a)},a);this.subs.push({destroy:function(){clearTimeout(c)}})}return this.subs.push(o),this.subs.push(s),this},n.prototype.onopen=function(){this.cleanup(),this.readyState="open",this.emit("open");var t=this.engine;this.subs.push(h(t,"data",p(this,"ondata"))),this.subs.push(h(t,"ping",p(this,"onping"))),this.subs.push(h(t,"pong",p(this,"onpong"))),this.subs.push(h(t,"error",p(this,"onerror"))),this.subs.push(h(t,"close",p(this,"onclose"))),this.subs.push(h(this.decoder,"decoded",p(this,"ondecoded")))},n.prototype.onping=function(){this.lastPing=new Date,this.emitAll("ping")},n.prototype.onpong=function(){this.emitAll("pong",new Date-this.lastPing)},n.prototype.ondata=function(t){this.decoder.add(t)},n.prototype.ondecoded=function(t){this.emit("packet",t)},n.prototype.onerror=function(t){this.emitAll("error",t)},n.prototype.socket=function(t,e){function r(){~u(o.connecting,n)||o.connecting.push(n)}var n=this.nsps[t];if(!n){n=new s(this,t,e),this.nsps[t]=n;var o=this;n.on("connecting",r),n.on("connect",function(){n.id=o.generateId(t)}),this.autoConnect&&r()}return n},n.prototype.destroy=function(t){var e=u(this.connecting,t);~e&&this.connecting.splice(e,1),this.connecting.length||this.close()},n.prototype.packet=function(t){var e=this;t.query&&0===t.type&&(t.nsp+="?"+t.query),e.encoding?e.packetBuffer.push(t):(e.encoding=!0,this.encoder.encode(t,function(r){for(var n=0;n<r.length;n++)e.engine.write(r[n],t.options);e.encoding=!1,e.processPacketQueue()}))},n.prototype.processPacketQueue=function(){if(this.packetBuffer.length>0&&!this.encoding){var t=this.packetBuffer.shift();this.packet(t)}},n.prototype.cleanup=function(){for(var t=this.subs.length,e=0;e<t;e++){var r=this.subs.shift();r.destroy()}this.packetBuffer=[],this.encoding=!1,this.lastPing=null,this.decoder.destroy()},n.prototype.close=n.prototype.disconnect=function(){this.skipReconnect=!0,this.reconnecting=!1,"opening"===this.readyState&&this.cleanup(),this.backoff.reset(),this.readyState="closed",this.engine&&this.engine.close()},n.prototype.onclose=function(t){this.cleanup(),this.backoff.reset(),this.readyState="closed",this.emit("close",t),this._reconnection&&!this.skipReconnect&&this.reconnect()},n.prototype.reconnect=function(){if(this.reconnecting||this.skipReconnect)return this;var t=this;if(this.backoff.attempts>=this._reconnectionAttempts)this.backoff.reset(),this.emitAll("reconnect_failed"),this.reconnecting=!1;else{var e=this.backoff.duration();this.reconnecting=!0;var r=setTimeout(function(){t.skipReconnect||(t.emitAll("reconnect_attempt",t.backoff.attempts),t.emitAll("reconnecting",t.backoff.attempts),t.skipReconnect||t.open(function(e){e?(t.reconnecting=!1,t.reconnect(),t.emitAll("reconnect_error",e.data)):t.onreconnect()}))},e);this.subs.push({destroy:function(){clearTimeout(r)}})}},n.prototype.onreconnect=function(){var t=this.backoff.attempts;this.reconnecting=!1,this.backoff.reset(),this.updateSocketIds(),this.emitAll("reconnect",t)}},function(t,e,r){t.exports=r(12)},function(t,e,r){t.exports=r(13),t.exports.parser=r(20)},function(t,e,r){(function(e){function n(t,r){if(!(this instanceof n))return new n(t,r);r=r||{},t&&"object"==typeof t&&(r=t,t=null),t?(t=h(t),r.hostname=t.host,r.secure="https"===t.protocol||"wss"===t.protocol,r.port=t.port,t.query&&(r.query=t.query)):r.host&&(r.hostname=h(r.host).host),this.secure=null!=r.secure?r.secure:e.location&&"https:"===location.protocol,r.hostname&&!r.port&&(r.port=this.secure?"443":"80"),this.agent=r.agent||!1,this.hostname=r.hostname||(e.location?location.hostname:"localhost"),this.port=r.port||(e.location&&location.port?location.port:this.secure?443:80),this.query=r.query||{},"string"==typeof this.query&&(this.query=u.decode(this.query)),this.upgrade=!1!==r.upgrade,this.path=(r.path||"/engine.io").replace(/\/$/,"")+"/",this.forceJSONP=!!r.forceJSONP,this.jsonp=!1!==r.jsonp,this.forceBase64=!!r.forceBase64,this.enablesXDR=!!r.enablesXDR,this.timestampParam=r.timestampParam||"t",this.timestampRequests=r.timestampRequests,this.transports=r.transports||["polling","websocket"],this.transportOptions=r.transportOptions||{},this.readyState="",this.writeBuffer=[],this.prevBufferLen=0,this.policyPort=r.policyPort||843,this.rememberUpgrade=r.rememberUpgrade||!1,this.binaryType=null,this.onlyBinaryUpgrades=r.onlyBinaryUpgrades,this.perMessageDeflate=!1!==r.perMessageDeflate&&(r.perMessageDeflate||{}),!0===this.perMessageDeflate&&(this.perMessageDeflate={}),this.perMessageDeflate&&null==this.perMessageDeflate.threshold&&(this.perMessageDeflate.threshold=1024),this.pfx=r.pfx||null,this.key=r.key||null,this.passphrase=r.passphrase||null,this.cert=r.cert||null,this.ca=r.ca||null,this.ciphers=r.ciphers||null,this.rejectUnauthorized=void 0===r.rejectUnauthorized||r.rejectUnauthorized,this.forceNode=!!r.forceNode;var o="object"==typeof e&&e;o.global===o&&(r.extraHeaders&&Object.keys(r.extraHeaders).length>0&&(this.extraHeaders=r.extraHeaders),r.localAddress&&(this.localAddress=r.localAddress)),this.id=null,this.upgrades=null,this.pingInterval=null,this.pingTimeout=null,this.pingIntervalTimer=null,this.pingTimeoutTimer=null,this.open()}function o(t){var e={};for(var r in t)t.hasOwnProperty(r)&&(e[r]=t[r]);return e}var i=r(14),s=r(5),a=(r(3)("engine.io-client:socket"),r(34)),c=r(20),h=r(2),p=r(35),u=r(28);t.exports=n,n.priorWebsocketSuccess=!1,s(n.prototype),n.protocol=c.protocol,n.Socket=n,n.Transport=r(19),n.transports=r(14),n.parser=r(20),n.prototype.createTransport=function(t){var e=o(this.query);e.EIO=c.protocol,e.transport=t;var r=this.transportOptions[t]||{};this.id&&(e.sid=this.id);var n=new i[t]({query:e,socket:this,agent:r.agent||this.agent,hostname:r.hostname||this.hostname,port:r.port||this.port,secure:r.secure||this.secure,path:r.path||this.path,forceJSONP:r.forceJSONP||this.forceJSONP,jsonp:r.jsonp||this.jsonp,forceBase64:r.forceBase64||this.forceBase64,enablesXDR:r.enablesXDR||this.enablesXDR,timestampRequests:r.timestampRequests||this.timestampRequests,timestampParam:r.timestampParam||this.timestampParam,policyPort:r.policyPort||this.policyPort,pfx:r.pfx||this.pfx,key:r.key||this.key,passphrase:r.passphrase||this.passphrase,cert:r.cert||this.cert,ca:r.ca||this.ca,ciphers:r.ciphers||this.ciphers,rejectUnauthorized:r.rejectUnauthorized||this.rejectUnauthorized,perMessageDeflate:r.perMessageDeflate||this.perMessageDeflate,extraHeaders:r.extraHeaders||this.extraHeaders,forceNode:r.forceNode||this.forceNode,localAddress:r.localAddress||this.localAddress,requestTimeout:r.requestTimeout||this.requestTimeout,protocols:r.protocols||void 0});return n},n.prototype.open=function(){var t;if(this.rememberUpgrade&&n.priorWebsocketSuccess&&this.transports.indexOf("websocket")!==-1)t="websocket";else{if(0===this.transports.length){var e=this;return void setTimeout(function(){e.emit("error","No transports available")},0)}t=this.transports[0]}this.readyState="opening";try{t=this.createTransport(t)}catch(t){return this.transports.shift(),void this.open()}t.open(),this.setTransport(t)},n.prototype.setTransport=function(t){var e=this;this.transport&&this.transport.removeAllListeners(),this.transport=t,t.on("drain",function(){e.onDrain()}).on("packet",function(t){e.onPacket(t)}).on("error",function(t){e.onError(t)}).on("close",function(){e.onClose("transport close")})},n.prototype.probe=function(t){function e(){if(u.onlyBinaryUpgrades){var t=!this.supportsBinary&&u.transport.supportsBinary;p=p||t}p||(h.send([{type:"ping",data:"probe"}]),h.once("packet",function(t){if(!p)if("pong"===t.type&&"probe"===t.data){if(u.upgrading=!0,u.emit("upgrading",h),!h)return;n.priorWebsocketSuccess="websocket"===h.name,u.transport.pause(function(){p||"closed"!==u.readyState&&(c(),u.setTransport(h),h.send([{type:"upgrade"}]),u.emit("upgrade",h),h=null,u.upgrading=!1,u.flush())})}else{var e=new Error("probe error");e.transport=h.name,u.emit("upgradeError",e)}}))}function r(){p||(p=!0,c(),h.close(),h=null)}function o(t){var e=new Error("probe error: "+t);e.transport=h.name,r(),u.emit("upgradeError",e)}function i(){o("transport closed")}function s(){o("socket closed")}function a(t){h&&t.name!==h.name&&r()}function c(){h.removeListener("open",e),h.removeListener("error",o),h.removeListener("close",i),u.removeListener("close",s),u.removeListener("upgrading",a)}var h=this.createTransport(t,{probe:1}),p=!1,u=this;n.priorWebsocketSuccess=!1,h.once("open",e),h.once("error",o),h.once("close",i),this.once("close",s),this.once("upgrading",a),h.open()},n.prototype.onOpen=function(){if(this.readyState="open",n.priorWebsocketSuccess="websocket"===this.transport.name,this.emit("open"),this.flush(),"open"===this.readyState&&this.upgrade&&this.transport.pause)for(var t=0,e=this.upgrades.length;t<e;t++)this.probe(this.upgrades[t])},n.prototype.onPacket=function(t){if("opening"===this.readyState||"open"===this.readyState||"closing"===this.readyState)switch(this.emit("packet",t),this.emit("heartbeat"),t.type){case"open":this.onHandshake(p(t.data));break;case"pong":this.setPing(),this.emit("pong");break;case"error":var e=new Error("server error");e.code=t.data,this.onError(e);break;case"message":this.emit("data",t.data),this.emit("message",t.data)}},n.prototype.onHandshake=function(t){this.emit("handshake",t),this.id=t.sid,this.transport.query.sid=t.sid,this.upgrades=this.filterUpgrades(t.upgrades),this.pingInterval=t.pingInterval,this.pingTimeout=t.pingTimeout,this.onOpen(),"closed"!==this.readyState&&(this.setPing(),this.removeListener("heartbeat",this.onHeartbeat),this.on("heartbeat",this.onHeartbeat))},n.prototype.onHeartbeat=function(t){clearTimeout(this.pingTimeoutTimer);var e=this;e.pingTimeoutTimer=setTimeout(function(){"closed"!==e.readyState&&e.onClose("ping timeout")},t||e.pingInterval+e.pingTimeout)},n.prototype.setPing=function(){var t=this;clearTimeout(t.pingIntervalTimer),t.pingIntervalTimer=setTimeout(function(){t.ping(),t.onHeartbeat(t.pingTimeout)},t.pingInterval)},n.prototype.ping=function(){var t=this;this.sendPacket("ping",function(){t.emit("ping")})},n.prototype.onDrain=function(){this.writeBuffer.splice(0,this.prevBufferLen),this.prevBufferLen=0,0===this.writeBuffer.length?this.emit("drain"):this.flush()},n.prototype.flush=function(){"closed"!==this.readyState&&this.transport.writable&&!this.upgrading&&this.writeBuffer.length&&(this.transport.send(this.writeBuffer),this.prevBufferLen=this.writeBuffer.length,this.emit("flush"))},n.prototype.write=n.prototype.send=function(t,e,r){return this.sendPacket("message",t,e,r),this},n.prototype.sendPacket=function(t,e,r,n){if("function"==typeof e&&(n=e,e=void 0),"function"==typeof r&&(n=r,r=null),"closing"!==this.readyState&&"closed"!==this.readyState){r=r||{},r.compress=!1!==r.compress;var o={type:t,data:e,options:r};this.emit("packetCreate",o),this.writeBuffer.push(o),n&&this.once("flush",n),this.flush()}},n.prototype.close=function(){function t(){n.onClose("forced close"),n.transport.close()}function e(){n.removeListener("upgrade",e),n.removeListener("upgradeError",e),t()}function r(){n.once("upgrade",e),n.once("upgradeError",e)}if("opening"===this.readyState||"open"===this.readyState){this.readyState="closing";var n=this;this.writeBuffer.length?this.once("drain",function(){this.upgrading?r():t()}):this.upgrading?r():t()}return this},n.prototype.onError=function(t){n.priorWebsocketSuccess=!1,this.emit("error",t),this.onClose("transport error",t)},n.prototype.onClose=function(t,e){if("opening"===this.readyState||"open"===this.readyState||"closing"===this.readyState){var r=this;clearTimeout(this.pingIntervalTimer),clearTimeout(this.pingTimeoutTimer),this.transport.removeAllListeners("close"),this.transport.close(),this.transport.removeAllListeners(),this.readyState="closed",this.id=null,this.emit("close",t,e),r.writeBuffer=[],r.prevBufferLen=0}},n.prototype.filterUpgrades=function(t){for(var e=[],r=0,n=t.length;r<n;r++)~a(this.transports,t[r])&&e.push(t[r]);return e}}).call(e,function(){return this}())},function(t,e,r){(function(t){function n(e){var r,n=!1,a=!1,c=!1!==e.jsonp;if(t.location){var h="https:"===location.protocol,p=location.port;p||(p=h?443:80),n=e.hostname!==location.hostname||p!==e.port,a=e.secure!==h}if(e.xdomain=n,e.xscheme=a,r=new o(e),"open"in r&&!e.forceJSONP)return new i(e);if(!c)throw new Error("JSONP disabled");return new s(e)}var o=r(15),i=r(17),s=r(31),a=r(32);e.polling=n,e.websocket=a}).call(e,function(){return this}())},function(t,e,r){(function(e){var n=r(16);t.exports=function(t){var r=t.xdomain,o=t.xscheme,i=t.enablesXDR;try{if("undefined"!=typeof XMLHttpRequest&&(!r||n))return new XMLHttpRequest}catch(t){}try{if("undefined"!=typeof XDomainRequest&&!o&&i)return new XDomainRequest}catch(t){}if(!r)try{return new(e[["Active"].concat("Object").join("X")])("Microsoft.XMLHTTP")}catch(t){}}}).call(e,function(){return this}())},function(t,e){try{t.exports="undefined"!=typeof XMLHttpRequest&&"withCredentials"in new XMLHttpRequest}catch(e){t.exports=!1}},function(t,e,r){(function(e){function n(){}function o(t){if(c.call(this,t),this.requestTimeout=t.requestTimeout,this.extraHeaders=t.extraHeaders,e.location){var r="https:"===location.protocol,n=location.port;n||(n=r?443:80),this.xd=t.hostname!==e.location.hostname||n!==t.port,this.xs=t.secure!==r}}function i(t){this.method=t.method||"GET",this.uri=t.uri,this.xd=!!t.xd,this.xs=!!t.xs,this.async=!1!==t.async,this.data=void 0!==t.data?t.data:null,this.agent=t.agent,this.isBinary=t.isBinary,this.supportsBinary=t.supportsBinary,this.enablesXDR=t.enablesXDR,this.requestTimeout=t.requestTimeout,this.pfx=t.pfx,this.key=t.key,this.passphrase=t.passphrase,this.cert=t.cert,this.ca=t.ca,this.ciphers=t.ciphers,this.rejectUnauthorized=t.rejectUnauthorized,this.extraHeaders=t.extraHeaders,this.create()}function s(){for(var t in i.requests)i.requests.hasOwnProperty(t)&&i.requests[t].abort()}var a=r(15),c=r(18),h=r(5),p=r(29);r(3)("engine.io-client:polling-xhr");t.exports=o,t.exports.Request=i,p(o,c),o.prototype.supportsBinary=!0,o.prototype.request=function(t){return t=t||{},t.uri=this.uri(),t.xd=this.xd,t.xs=this.xs,t.agent=this.agent||!1,t.supportsBinary=this.supportsBinary,t.enablesXDR=this.enablesXDR,t.pfx=this.pfx,t.key=this.key,t.passphrase=this.passphrase,t.cert=this.cert,t.ca=this.ca,t.ciphers=this.ciphers,t.rejectUnauthorized=this.rejectUnauthorized,t.requestTimeout=this.requestTimeout,t.extraHeaders=this.extraHeaders,new i(t)},o.prototype.doWrite=function(t,e){var r="string"!=typeof t&&void 0!==t,n=this.request({method:"POST",data:t,isBinary:r}),o=this;n.on("success",e),n.on("error",function(t){o.onError("xhr post error",t)}),this.sendXhr=n},o.prototype.doPoll=function(){var t=this.request(),e=this;t.on("data",function(t){e.onData(t)}),t.on("error",function(t){e.onError("xhr poll error",t)}),this.pollXhr=t},h(i.prototype),i.prototype.create=function(){var t={agent:this.agent,xdomain:this.xd,xscheme:this.xs,enablesXDR:this.enablesXDR};t.pfx=this.pfx,t.key=this.key,t.passphrase=this.passphrase,t.cert=this.cert,t.ca=this.ca,t.ciphers=this.ciphers,t.rejectUnauthorized=this.rejectUnauthorized;var r=this.xhr=new a(t),n=this;try{r.open(this.method,this.uri,this.async);try{if(this.extraHeaders){r.setDisableHeaderCheck&&r.setDisableHeaderCheck(!0);for(var o in this.extraHeaders)this.extraHeaders.hasOwnProperty(o)&&r.setRequestHeader(o,this.extraHeaders[o])}}catch(t){}if("POST"===this.method)try{this.isBinary?r.setRequestHeader("Content-type","application/octet-stream"):r.setRequestHeader("Content-type","text/plain;charset=UTF-8")}catch(t){}try{r.setRequestHeader("Accept","*/*")}catch(t){}"withCredentials"in r&&(r.withCredentials=!0),this.requestTimeout&&(r.timeout=this.requestTimeout),this.hasXDR()?(r.onload=function(){n.onLoad()},r.onerror=function(){n.onError(r.responseText)}):r.onreadystatechange=function(){if(2===r.readyState){var t;try{t=r.getResponseHeader("Content-Type")}catch(t){}"application/octet-stream"===t&&(r.responseType="arraybuffer")}4===r.readyState&&(200===r.status||1223===r.status?n.onLoad():setTimeout(function(){n.onError(r.status)},0))},r.send(this.data)}catch(t){return void setTimeout(function(){n.onError(t)},0)}e.document&&(this.index=i.requestsCount++,i.requests[this.index]=this)},i.prototype.onSuccess=function(){this.emit("success"),this.cleanup()},i.prototype.onData=function(t){this.emit("data",t),this.onSuccess()},i.prototype.onError=function(t){this.emit("error",t),this.cleanup(!0)},i.prototype.cleanup=function(t){if("undefined"!=typeof this.xhr&&null!==this.xhr){if(this.hasXDR()?this.xhr.onload=this.xhr.onerror=n:this.xhr.onreadystatechange=n,t)try{this.xhr.abort()}catch(t){}e.document&&delete i.requests[this.index],this.xhr=null}},i.prototype.onLoad=function(){var t;try{var e;try{e=this.xhr.getResponseHeader("Content-Type")}catch(t){}t="application/octet-stream"===e?this.xhr.response||this.xhr.responseText:this.xhr.responseText}catch(t){this.onError(t)}null!=t&&this.onData(t)},i.prototype.hasXDR=function(){return"undefined"!=typeof e.XDomainRequest&&!this.xs&&this.enablesXDR},i.prototype.abort=function(){this.cleanup()},i.requestsCount=0,i.requests={},e.document&&(e.attachEvent?e.attachEvent("onunload",s):e.addEventListener&&e.addEventListener("beforeunload",s,!1))}).call(e,function(){return this}())},function(t,e,r){function n(t){var e=t&&t.forceBase64;h&&!e||(this.supportsBinary=!1),o.call(this,t)}var o=r(19),i=r(28),s=r(20),a=r(29),c=r(30);r(3)("engine.io-client:polling");t.exports=n;var h=function(){var t=r(15),e=new t({xdomain:!1});return null!=e.responseType}();a(n,o),n.prototype.name="polling",n.prototype.doOpen=function(){this.poll()},n.prototype.pause=function(t){function e(){r.readyState="paused",t()}var r=this;if(this.readyState="pausing",this.polling||!this.writable){var n=0;this.polling&&(n++,this.once("pollComplete",function(){--n||e()})),this.writable||(n++,this.once("drain",function(){--n||e()}))}else e()},n.prototype.poll=function(){this.polling=!0,this.doPoll(),this.emit("poll")},n.prototype.onData=function(t){var e=this,r=function(t,r,n){return"opening"===e.readyState&&e.onOpen(),"close"===t.type?(e.onClose(),!1):void e.onPacket(t)};s.decodePayload(t,this.socket.binaryType,r),"closed"!==this.readyState&&(this.polling=!1,this.emit("pollComplete"),"open"===this.readyState&&this.poll())},n.prototype.doClose=function(){function t(){e.write([{type:"close"}])}var e=this;"open"===this.readyState?t():this.once("open",t)},n.prototype.write=function(t){var e=this;this.writable=!1;var r=function(){e.writable=!0,e.emit("drain")};s.encodePayload(t,this.supportsBinary,function(t){e.doWrite(t,r)})},n.prototype.uri=function(){var t=this.query||{},e=this.secure?"https":"http",r="";!1!==this.timestampRequests&&(t[this.timestampParam]=c()),this.supportsBinary||t.sid||(t.b64=1),t=i.encode(t),this.port&&("https"===e&&443!==Number(this.port)||"http"===e&&80!==Number(this.port))&&(r=":"+this.port),t.length&&(t="?"+t);var n=this.hostname.indexOf(":")!==-1;return e+"://"+(n?"["+this.hostname+"]":this.hostname)+r+this.path+t}},function(t,e,r){function n(t){this.path=t.path,this.hostname=t.hostname,this.port=t.port,this.secure=t.secure,this.query=t.query,this.timestampParam=t.timestampParam,this.timestampRequests=t.timestampRequests,this.readyState="",this.agent=t.agent||!1,this.socket=t.socket,this.enablesXDR=t.enablesXDR,this.pfx=t.pfx,this.key=t.key,this.passphrase=t.passphrase,this.cert=t.cert,this.ca=t.ca,this.ciphers=t.ciphers,this.rejectUnauthorized=t.rejectUnauthorized,this.forceNode=t.forceNode,this.extraHeaders=t.extraHeaders,this.localAddress=t.localAddress}var o=r(20),i=r(5);t.exports=n,i(n.prototype),n.prototype.onError=function(t,e){var r=new Error(t);return r.type="TransportError",r.description=e,this.emit("error",r),this},n.prototype.open=function(){return"closed"!==this.readyState&&""!==this.readyState||(this.readyState="opening",this.doOpen()),this},n.prototype.close=function(){return"opening"!==this.readyState&&"open"!==this.readyState||(this.doClose(),this.onClose()),this},n.prototype.send=function(t){if("open"!==this.readyState)throw new Error("Transport not open");this.write(t)},n.prototype.onOpen=function(){this.readyState="open",
this.writable=!0,this.emit("open")},n.prototype.onData=function(t){var e=o.decodePacket(t,this.socket.binaryType);this.onPacket(e)},n.prototype.onPacket=function(t){this.emit("packet",t)},n.prototype.onClose=function(){this.readyState="closed",this.emit("close")}},function(t,e,r){(function(t){function n(t,r){var n="b"+e.packets[t.type]+t.data.data;return r(n)}function o(t,r,n){if(!r)return e.encodeBase64Packet(t,n);var o=t.data,i=new Uint8Array(o),s=new Uint8Array(1+o.byteLength);s[0]=v[t.type];for(var a=0;a<i.length;a++)s[a+1]=i[a];return n(s.buffer)}function i(t,r,n){if(!r)return e.encodeBase64Packet(t,n);var o=new FileReader;return o.onload=function(){t.data=o.result,e.encodePacket(t,r,!0,n)},o.readAsArrayBuffer(t.data)}function s(t,r,n){if(!r)return e.encodeBase64Packet(t,n);if(g)return i(t,r,n);var o=new Uint8Array(1);o[0]=v[t.type];var s=new w([o.buffer,t.data]);return n(s)}function a(t){try{t=d.decode(t,{strict:!1})}catch(t){return!1}return t}function c(t,e,r){for(var n=new Array(t.length),o=l(t.length,r),i=function(t,r,o){e(r,function(e,r){n[t]=r,o(e,n)})},s=0;s<t.length;s++)i(s,t[s],o)}var h,p=r(21),u=r(6),f=r(22),l=r(23),d=r(24);t&&t.ArrayBuffer&&(h=r(26));var y="undefined"!=typeof navigator&&/Android/i.test(navigator.userAgent),m="undefined"!=typeof navigator&&/PhantomJS/i.test(navigator.userAgent),g=y||m;e.protocol=3;var v=e.packets={open:0,close:1,ping:2,pong:3,message:4,upgrade:5,noop:6},b=p(v),k={type:"error",data:"parser error"},w=r(27);e.encodePacket=function(e,r,i,a){"function"==typeof r&&(a=r,r=!1),"function"==typeof i&&(a=i,i=null);var c=void 0===e.data?void 0:e.data.buffer||e.data;if(t.ArrayBuffer&&c instanceof ArrayBuffer)return o(e,r,a);if(w&&c instanceof t.Blob)return s(e,r,a);if(c&&c.base64)return n(e,a);var h=v[e.type];return void 0!==e.data&&(h+=i?d.encode(String(e.data),{strict:!1}):String(e.data)),a(""+h)},e.encodeBase64Packet=function(r,n){var o="b"+e.packets[r.type];if(w&&r.data instanceof t.Blob){var i=new FileReader;return i.onload=function(){var t=i.result.split(",")[1];n(o+t)},i.readAsDataURL(r.data)}var s;try{s=String.fromCharCode.apply(null,new Uint8Array(r.data))}catch(t){for(var a=new Uint8Array(r.data),c=new Array(a.length),h=0;h<a.length;h++)c[h]=a[h];s=String.fromCharCode.apply(null,c)}return o+=t.btoa(s),n(o)},e.decodePacket=function(t,r,n){if(void 0===t)return k;if("string"==typeof t){if("b"===t.charAt(0))return e.decodeBase64Packet(t.substr(1),r);if(n&&(t=a(t),t===!1))return k;var o=t.charAt(0);return Number(o)==o&&b[o]?t.length>1?{type:b[o],data:t.substring(1)}:{type:b[o]}:k}var i=new Uint8Array(t),o=i[0],s=f(t,1);return w&&"blob"===r&&(s=new w([s])),{type:b[o],data:s}},e.decodeBase64Packet=function(t,e){var r=b[t.charAt(0)];if(!h)return{type:r,data:{base64:!0,data:t.substr(1)}};var n=h.decode(t.substr(1));return"blob"===e&&w&&(n=new w([n])),{type:r,data:n}},e.encodePayload=function(t,r,n){function o(t){return t.length+":"+t}function i(t,n){e.encodePacket(t,!!s&&r,!1,function(t){n(null,o(t))})}"function"==typeof r&&(n=r,r=null);var s=u(t);return r&&s?w&&!g?e.encodePayloadAsBlob(t,n):e.encodePayloadAsArrayBuffer(t,n):t.length?void c(t,i,function(t,e){return n(e.join(""))}):n("0:")},e.decodePayload=function(t,r,n){if("string"!=typeof t)return e.decodePayloadAsBinary(t,r,n);"function"==typeof r&&(n=r,r=null);var o;if(""===t)return n(k,0,1);for(var i,s,a="",c=0,h=t.length;c<h;c++){var p=t.charAt(c);if(":"===p){if(""===a||a!=(i=Number(a)))return n(k,0,1);if(s=t.substr(c+1,i),a!=s.length)return n(k,0,1);if(s.length){if(o=e.decodePacket(s,r,!1),k.type===o.type&&k.data===o.data)return n(k,0,1);var u=n(o,c+i,h);if(!1===u)return}c+=i,a=""}else a+=p}return""!==a?n(k,0,1):void 0},e.encodePayloadAsArrayBuffer=function(t,r){function n(t,r){e.encodePacket(t,!0,!0,function(t){return r(null,t)})}return t.length?void c(t,n,function(t,e){var n=e.reduce(function(t,e){var r;return r="string"==typeof e?e.length:e.byteLength,t+r.toString().length+r+2},0),o=new Uint8Array(n),i=0;return e.forEach(function(t){var e="string"==typeof t,r=t;if(e){for(var n=new Uint8Array(t.length),s=0;s<t.length;s++)n[s]=t.charCodeAt(s);r=n.buffer}e?o[i++]=0:o[i++]=1;for(var a=r.byteLength.toString(),s=0;s<a.length;s++)o[i++]=parseInt(a[s]);o[i++]=255;for(var n=new Uint8Array(r),s=0;s<n.length;s++)o[i++]=n[s]}),r(o.buffer)}):r(new ArrayBuffer(0))},e.encodePayloadAsBlob=function(t,r){function n(t,r){e.encodePacket(t,!0,!0,function(t){var e=new Uint8Array(1);if(e[0]=1,"string"==typeof t){for(var n=new Uint8Array(t.length),o=0;o<t.length;o++)n[o]=t.charCodeAt(o);t=n.buffer,e[0]=0}for(var i=t instanceof ArrayBuffer?t.byteLength:t.size,s=i.toString(),a=new Uint8Array(s.length+1),o=0;o<s.length;o++)a[o]=parseInt(s[o]);if(a[s.length]=255,w){var c=new w([e.buffer,a.buffer,t]);r(null,c)}})}c(t,n,function(t,e){return r(new w(e))})},e.decodePayloadAsBinary=function(t,r,n){"function"==typeof r&&(n=r,r=null);for(var o=t,i=[];o.byteLength>0;){for(var s=new Uint8Array(o),a=0===s[0],c="",h=1;255!==s[h];h++){if(c.length>310)return n(k,0,1);c+=s[h]}o=f(o,2+c.length),c=parseInt(c);var p=f(o,0,c);if(a)try{p=String.fromCharCode.apply(null,new Uint8Array(p))}catch(t){var u=new Uint8Array(p);p="";for(var h=0;h<u.length;h++)p+=String.fromCharCode(u[h])}i.push(p),o=f(o,c)}var l=i.length;i.forEach(function(t,o){n(e.decodePacket(t,r,!0),o,l)})}}).call(e,function(){return this}())},function(t,e){t.exports=Object.keys||function(t){var e=[],r=Object.prototype.hasOwnProperty;for(var n in t)r.call(t,n)&&e.push(n);return e}},function(t,e){t.exports=function(t,e,r){var n=t.byteLength;if(e=e||0,r=r||n,t.slice)return t.slice(e,r);if(e<0&&(e+=n),r<0&&(r+=n),r>n&&(r=n),e>=n||e>=r||0===n)return new ArrayBuffer(0);for(var o=new Uint8Array(t),i=new Uint8Array(r-e),s=e,a=0;s<r;s++,a++)i[a]=o[s];return i.buffer}},function(t,e){function r(t,e,r){function o(t,n){if(o.count<=0)throw new Error("after called too many times");--o.count,t?(i=!0,e(t),e=r):0!==o.count||i||e(null,n)}var i=!1;return r=r||n,o.count=t,0===t?e():o}function n(){}t.exports=r},function(t,e,r){var n;(function(t,o){!function(i){function s(t){for(var e,r,n=[],o=0,i=t.length;o<i;)e=t.charCodeAt(o++),e>=55296&&e<=56319&&o<i?(r=t.charCodeAt(o++),56320==(64512&r)?n.push(((1023&e)<<10)+(1023&r)+65536):(n.push(e),o--)):n.push(e);return n}function a(t){for(var e,r=t.length,n=-1,o="";++n<r;)e=t[n],e>65535&&(e-=65536,o+=k(e>>>10&1023|55296),e=56320|1023&e),o+=k(e);return o}function c(t,e){if(t>=55296&&t<=57343){if(e)throw Error("Lone surrogate U+"+t.toString(16).toUpperCase()+" is not a scalar value");return!1}return!0}function h(t,e){return k(t>>e&63|128)}function p(t,e){if(0==(4294967168&t))return k(t);var r="";return 0==(4294965248&t)?r=k(t>>6&31|192):0==(4294901760&t)?(c(t,e)||(t=65533),r=k(t>>12&15|224),r+=h(t,6)):0==(4292870144&t)&&(r=k(t>>18&7|240),r+=h(t,12),r+=h(t,6)),r+=k(63&t|128)}function u(t,e){e=e||{};for(var r,n=!1!==e.strict,o=s(t),i=o.length,a=-1,c="";++a<i;)r=o[a],c+=p(r,n);return c}function f(){if(b>=v)throw Error("Invalid byte index");var t=255&g[b];if(b++,128==(192&t))return 63&t;throw Error("Invalid continuation byte")}function l(t){var e,r,n,o,i;if(b>v)throw Error("Invalid byte index");if(b==v)return!1;if(e=255&g[b],b++,0==(128&e))return e;if(192==(224&e)){if(r=f(),i=(31&e)<<6|r,i>=128)return i;throw Error("Invalid continuation byte")}if(224==(240&e)){if(r=f(),n=f(),i=(15&e)<<12|r<<6|n,i>=2048)return c(i,t)?i:65533;throw Error("Invalid continuation byte")}if(240==(248&e)&&(r=f(),n=f(),o=f(),i=(7&e)<<18|r<<12|n<<6|o,i>=65536&&i<=1114111))return i;throw Error("Invalid UTF-8 detected")}function d(t,e){e=e||{};var r=!1!==e.strict;g=s(t),v=g.length,b=0;for(var n,o=[];(n=l(r))!==!1;)o.push(n);return a(o)}var y="object"==typeof e&&e,m=("object"==typeof t&&t&&t.exports==y&&t,"object"==typeof o&&o);m.global!==m&&m.window!==m||(i=m);var g,v,b,k=String.fromCharCode,w={version:"2.1.2",encode:u,decode:d};n=function(){return w}.call(e,r,e,t),!(void 0!==n&&(t.exports=n))}(this)}).call(e,r(25)(t),function(){return this}())},function(t,e){t.exports=function(t){return t.webpackPolyfill||(t.deprecate=function(){},t.paths=[],t.children=[],t.webpackPolyfill=1),t}},function(t,e){!function(){"use strict";for(var t="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/",r=new Uint8Array(256),n=0;n<t.length;n++)r[t.charCodeAt(n)]=n;e.encode=function(e){var r,n=new Uint8Array(e),o=n.length,i="";for(r=0;r<o;r+=3)i+=t[n[r]>>2],i+=t[(3&n[r])<<4|n[r+1]>>4],i+=t[(15&n[r+1])<<2|n[r+2]>>6],i+=t[63&n[r+2]];return o%3===2?i=i.substring(0,i.length-1)+"=":o%3===1&&(i=i.substring(0,i.length-2)+"=="),i},e.decode=function(t){var e,n,o,i,s,a=.75*t.length,c=t.length,h=0;"="===t[t.length-1]&&(a--,"="===t[t.length-2]&&a--);var p=new ArrayBuffer(a),u=new Uint8Array(p);for(e=0;e<c;e+=4)n=r[t.charCodeAt(e)],o=r[t.charCodeAt(e+1)],i=r[t.charCodeAt(e+2)],s=r[t.charCodeAt(e+3)],u[h++]=n<<2|o>>4,u[h++]=(15&o)<<4|i>>2,u[h++]=(3&i)<<6|63&s;return p}}()},function(t,e){(function(e){function r(t){for(var e=0;e<t.length;e++){var r=t[e];if(r.buffer instanceof ArrayBuffer){var n=r.buffer;if(r.byteLength!==n.byteLength){var o=new Uint8Array(r.byteLength);o.set(new Uint8Array(n,r.byteOffset,r.byteLength)),n=o.buffer}t[e]=n}}}function n(t,e){e=e||{};var n=new i;r(t);for(var o=0;o<t.length;o++)n.append(t[o]);return e.type?n.getBlob(e.type):n.getBlob()}function o(t,e){return r(t),new Blob(t,e||{})}var i=e.BlobBuilder||e.WebKitBlobBuilder||e.MSBlobBuilder||e.MozBlobBuilder,s=function(){try{var t=new Blob(["hi"]);return 2===t.size}catch(t){return!1}}(),a=s&&function(){try{var t=new Blob([new Uint8Array([1,2])]);return 2===t.size}catch(t){return!1}}(),c=i&&i.prototype.append&&i.prototype.getBlob;t.exports=function(){return s?a?e.Blob:o:c?n:void 0}()}).call(e,function(){return this}())},function(t,e){e.encode=function(t){var e="";for(var r in t)t.hasOwnProperty(r)&&(e.length&&(e+="&"),e+=encodeURIComponent(r)+"="+encodeURIComponent(t[r]));return e},e.decode=function(t){for(var e={},r=t.split("&"),n=0,o=r.length;n<o;n++){var i=r[n].split("=");e[decodeURIComponent(i[0])]=decodeURIComponent(i[1])}return e}},function(t,e){t.exports=function(t,e){var r=function(){};r.prototype=e.prototype,t.prototype=new r,t.prototype.constructor=t}},function(t,e){"use strict";function r(t){var e="";do e=s[t%a]+e,t=Math.floor(t/a);while(t>0);return e}function n(t){var e=0;for(p=0;p<t.length;p++)e=e*a+c[t.charAt(p)];return e}function o(){var t=r(+new Date);return t!==i?(h=0,i=t):t+"."+r(h++)}for(var i,s="0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz-_".split(""),a=64,c={},h=0,p=0;p<a;p++)c[s[p]]=p;o.encode=r,o.decode=n,t.exports=o},function(t,e,r){(function(e){function n(){}function o(t){i.call(this,t),this.query=this.query||{},a||(e.___eio||(e.___eio=[]),a=e.___eio),this.index=a.length;var r=this;a.push(function(t){r.onData(t)}),this.query.j=this.index,e.document&&e.addEventListener&&e.addEventListener("beforeunload",function(){r.script&&(r.script.onerror=n)},!1)}var i=r(18),s=r(29);t.exports=o;var a,c=/\n/g,h=/\\n/g;s(o,i),o.prototype.supportsBinary=!1,o.prototype.doClose=function(){this.script&&(this.script.parentNode.removeChild(this.script),this.script=null),this.form&&(this.form.parentNode.removeChild(this.form),this.form=null,this.iframe=null),i.prototype.doClose.call(this)},o.prototype.doPoll=function(){var t=this,e=document.createElement("script");this.script&&(this.script.parentNode.removeChild(this.script),this.script=null),e.async=!0,e.src=this.uri(),e.onerror=function(e){t.onError("jsonp poll error",e)};var r=document.getElementsByTagName("script")[0];r?r.parentNode.insertBefore(e,r):(document.head||document.body).appendChild(e),this.script=e;var n="undefined"!=typeof navigator&&/gecko/i.test(navigator.userAgent);n&&setTimeout(function(){var t=document.createElement("iframe");document.body.appendChild(t),document.body.removeChild(t)},100)},o.prototype.doWrite=function(t,e){function r(){n(),e()}function n(){if(o.iframe)try{o.form.removeChild(o.iframe)}catch(t){o.onError("jsonp polling iframe removal error",t)}try{var t='<iframe src="javascript:0" name="'+o.iframeId+'">';i=document.createElement(t)}catch(t){i=document.createElement("iframe"),i.name=o.iframeId,i.src="javascript:0"}i.id=o.iframeId,o.form.appendChild(i),o.iframe=i}var o=this;if(!this.form){var i,s=document.createElement("form"),a=document.createElement("textarea"),p=this.iframeId="eio_iframe_"+this.index;s.className="socketio",s.style.position="absolute",s.style.top="-1000px",s.style.left="-1000px",s.target=p,s.method="POST",s.setAttribute("accept-charset","utf-8"),a.name="d",s.appendChild(a),document.body.appendChild(s),this.form=s,this.area=a}this.form.action=this.uri(),n(),t=t.replace(h,"\\\n"),this.area.value=t.replace(c,"\\n");try{this.form.submit()}catch(t){}this.iframe.attachEvent?this.iframe.onreadystatechange=function(){"complete"===o.iframe.readyState&&r()}:this.iframe.onload=r}}).call(e,function(){return this}())},function(t,e,r){(function(e){function n(t){var e=t&&t.forceBase64;e&&(this.supportsBinary=!1),this.perMessageDeflate=t.perMessageDeflate,this.usingBrowserWebSocket=p&&!t.forceNode,this.protocols=t.protocols,this.usingBrowserWebSocket||(u=o),i.call(this,t)}var o,i=r(19),s=r(20),a=r(28),c=r(29),h=r(30),p=(r(3)("engine.io-client:websocket"),e.WebSocket||e.MozWebSocket);if("undefined"==typeof window)try{o=r(33)}catch(t){}var u=p;u||"undefined"!=typeof window||(u=o),t.exports=n,c(n,i),n.prototype.name="websocket",n.prototype.supportsBinary=!0,n.prototype.doOpen=function(){if(this.check()){var t=this.uri(),e=this.protocols,r={agent:this.agent,perMessageDeflate:this.perMessageDeflate};r.pfx=this.pfx,r.key=this.key,r.passphrase=this.passphrase,r.cert=this.cert,r.ca=this.ca,r.ciphers=this.ciphers,r.rejectUnauthorized=this.rejectUnauthorized,this.extraHeaders&&(r.headers=this.extraHeaders),this.localAddress&&(r.localAddress=this.localAddress);try{this.ws=this.usingBrowserWebSocket?e?new u(t,e):new u(t):new u(t,e,r)}catch(t){return this.emit("error",t)}void 0===this.ws.binaryType&&(this.supportsBinary=!1),this.ws.supports&&this.ws.supports.binary?(this.supportsBinary=!0,this.ws.binaryType="nodebuffer"):this.ws.binaryType="arraybuffer",this.addEventListeners()}},n.prototype.addEventListeners=function(){var t=this;this.ws.onopen=function(){t.onOpen()},this.ws.onclose=function(){t.onClose()},this.ws.onmessage=function(e){t.onData(e.data)},this.ws.onerror=function(e){t.onError("websocket error",e)}},n.prototype.write=function(t){function r(){n.emit("flush"),setTimeout(function(){n.writable=!0,n.emit("drain")},0)}var n=this;this.writable=!1;for(var o=t.length,i=0,a=o;i<a;i++)!function(t){s.encodePacket(t,n.supportsBinary,function(i){if(!n.usingBrowserWebSocket){var s={};if(t.options&&(s.compress=t.options.compress),n.perMessageDeflate){var a="string"==typeof i?e.Buffer.byteLength(i):i.length;a<n.perMessageDeflate.threshold&&(s.compress=!1)}}try{n.usingBrowserWebSocket?n.ws.send(i):n.ws.send(i,s)}catch(t){}--o||r()})}(t[i])},n.prototype.onClose=function(){i.prototype.onClose.call(this)},n.prototype.doClose=function(){"undefined"!=typeof this.ws&&this.ws.close()},n.prototype.uri=function(){var t=this.query||{},e=this.secure?"wss":"ws",r="";this.port&&("wss"===e&&443!==Number(this.port)||"ws"===e&&80!==Number(this.port))&&(r=":"+this.port),this.timestampRequests&&(t[this.timestampParam]=h()),this.supportsBinary||(t.b64=1),t=a.encode(t),t.length&&(t="?"+t);var n=this.hostname.indexOf(":")!==-1;return e+"://"+(n?"["+this.hostname+"]":this.hostname)+r+this.path+t},n.prototype.check=function(){return!(!u||"__initialize"in u&&this.name===n.prototype.name)}}).call(e,function(){return this}())},function(t,e){},function(t,e){var r=[].indexOf;t.exports=function(t,e){if(r)return t.indexOf(e);for(var n=0;n<t.length;++n)if(t[n]===e)return n;return-1}},function(t,e){(function(e){var r=/^[\],:{}\s]*$/,n=/\\(?:["\\\/bfnrt]|u[0-9a-fA-F]{4})/g,o=/"[^"\\\n\r]*"|true|false|null|-?\d+(?:\.\d*)?(?:[eE][+\-]?\d+)?/g,i=/(?:^|:|,)(?:\s*\[)+/g,s=/^\s+/,a=/\s+$/;t.exports=function(t){return"string"==typeof t&&t?(t=t.replace(s,"").replace(a,""),e.JSON&&JSON.parse?JSON.parse(t):r.test(t.replace(n,"@").replace(o,"]").replace(i,""))?new Function("return "+t)():void 0):null}}).call(e,function(){return this}())},function(t,e,r){"use strict";function n(t,e,r){this.io=t,this.nsp=e,this.json=this,this.ids=0,this.acks={},this.receiveBuffer=[],this.sendBuffer=[],this.connected=!1,this.disconnected=!0,r&&r.query&&(this.query=r.query),this.io.autoConnect&&this.open()}var o="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(t){return typeof t}:function(t){return t&&"function"==typeof Symbol&&t.constructor===Symbol&&t!==Symbol.prototype?"symbol":typeof t},i=r(4),s=r(5),a=r(37),c=r(38),h=r(39),p=(r(3)("socket.io-client:socket"),r(28));t.exports=e=n;var u={connect:1,connect_error:1,connect_timeout:1,connecting:1,disconnect:1,error:1,reconnect:1,reconnect_attempt:1,reconnect_failed:1,reconnect_error:1,reconnecting:1,ping:1,pong:1},f=s.prototype.emit;s(n.prototype),n.prototype.subEvents=function(){if(!this.subs){var t=this.io;this.subs=[c(t,"open",h(this,"onopen")),c(t,"packet",h(this,"onpacket")),c(t,"close",h(this,"onclose"))]}},n.prototype.open=n.prototype.connect=function(){return this.connected?this:(this.subEvents(),this.io.open(),"open"===this.io.readyState&&this.onopen(),this.emit("connecting"),this)},n.prototype.send=function(){var t=a(arguments);return t.unshift("message"),this.emit.apply(this,t),this},n.prototype.emit=function(t){if(u.hasOwnProperty(t))return f.apply(this,arguments),this;var e=a(arguments),r={type:i.EVENT,data:e};return r.options={},r.options.compress=!this.flags||!1!==this.flags.compress,"function"==typeof e[e.length-1]&&(this.acks[this.ids]=e.pop(),r.id=this.ids++),this.connected?this.packet(r):this.sendBuffer.push(r),delete this.flags,this},n.prototype.packet=function(t){t.nsp=this.nsp,this.io.packet(t)},n.prototype.onopen=function(){if("/"!==this.nsp)if(this.query){var t="object"===o(this.query)?p.encode(this.query):this.query;this.packet({type:i.CONNECT,query:t})}else this.packet({type:i.CONNECT})},n.prototype.onclose=function(t){this.connected=!1,this.disconnected=!0,delete this.id,this.emit("disconnect",t)},n.prototype.onpacket=function(t){if(t.nsp===this.nsp)switch(t.type){case i.CONNECT:this.onconnect();break;case i.EVENT:this.onevent(t);break;case i.BINARY_EVENT:this.onevent(t);break;case i.ACK:this.onack(t);break;case i.BINARY_ACK:this.onack(t);break;case i.DISCONNECT:this.ondisconnect();break;case i.ERROR:this.emit("error",t.data)}},n.prototype.onevent=function(t){var e=t.data||[];null!=t.id&&e.push(this.ack(t.id)),this.connected?f.apply(this,e):this.receiveBuffer.push(e)},n.prototype.ack=function(t){var e=this,r=!1;return function(){if(!r){r=!0;var n=a(arguments);e.packet({type:i.ACK,id:t,data:n})}}},n.prototype.onack=function(t){var e=this.acks[t.id];"function"==typeof e&&(e.apply(this,t.data),delete this.acks[t.id])},n.prototype.onconnect=function(){this.connected=!0,this.disconnected=!1,this.emit("connect"),this.emitBuffered()},n.prototype.emitBuffered=function(){var t;for(t=0;t<this.receiveBuffer.length;t++)f.apply(this,this.receiveBuffer[t]);for(this.receiveBuffer=[],t=0;t<this.sendBuffer.length;t++)this.packet(this.sendBuffer[t]);this.sendBuffer=[]},n.prototype.ondisconnect=function(){this.destroy(),this.onclose("io server disconnect")},n.prototype.destroy=function(){if(this.subs){for(var t=0;t<this.subs.length;t++)this.subs[t].destroy();this.subs=null}this.io.destroy(this)},n.prototype.close=n.prototype.disconnect=function(){return this.connected&&this.packet({type:i.DISCONNECT}),this.destroy(),this.connected&&this.onclose("io client disconnect"),this},n.prototype.compress=function(t){return this.flags=this.flags||{},this.flags.compress=t,this}},function(t,e){function r(t,e){var r=[];e=e||0;for(var n=e||0;n<t.length;n++)r[n-e]=t[n];return r}t.exports=r},function(t,e){"use strict";function r(t,e,r){return t.on(e,r),{destroy:function(){t.removeListener(e,r)}}}t.exports=r},function(t,e){var r=[].slice;t.exports=function(t,e){if("string"==typeof e&&(e=t[e]),"function"!=typeof e)throw new Error("bind() requires a function");var n=r.call(arguments,2);return function(){return e.apply(t,n.concat(r.call(arguments)))}}},function(t,e){function r(t){t=t||{},this.ms=t.min||100,this.max=t.max||1e4,this.factor=t.factor||2,this.jitter=t.jitter>0&&t.jitter<=1?t.jitter:0,this.attempts=0}t.exports=r,r.prototype.duration=function(){var t=this.ms*Math.pow(this.factor,this.attempts++);if(this.jitter){var e=Math.random(),r=Math.floor(e*this.jitter*t);t=0==(1&Math.floor(10*e))?t-r:t+r}return 0|Math.min(t,this.max)},r.prototype.reset=function(){this.attempts=0},r.prototype.setMin=function(t){this.ms=t},r.prototype.setMax=function(t){this.max=t},r.prototype.setJitter=function(t){this.jitter=t}}])});

(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory();
	else if(typeof define === 'function' && define.amd)
		define([], factory);
	else {
		var a = factory();
		for(var i in a) (typeof exports === 'object' ? exports : root)[i] = a[i];
	}
})(this, function() {
return /******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// identity function for calling harmony imports with the correct context
/******/ 	__webpack_require__.i = function(value) { return value; };
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, {
/******/ 				configurable: false,
/******/ 				enumerable: true,
/******/ 				get: getter
/******/ 			});
/******/ 		}
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 33);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.string = exports.object = exports.Disposable = exports.async = exports.array = undefined;

var _core = __webpack_require__(17);

Object.keys(_core).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function get() {
      return _core[key];
    }
  });
});

var _core2 = _interopRequireDefault(_core);

var _array = __webpack_require__(48);

var _array2 = _interopRequireDefault(_array);

var _async = __webpack_require__(49);

var _async2 = _interopRequireDefault(_async);

var _Disposable = __webpack_require__(51);

var _Disposable2 = _interopRequireDefault(_Disposable);

var _object = __webpack_require__(52);

var _object2 = _interopRequireDefault(_object);

var _string = __webpack_require__(53);

var _string2 = _interopRequireDefault(_string);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.array = _array2.default;
exports.async = _async2.default;
exports.Disposable = _Disposable2.default;
exports.object = _object2.default;
exports.string = _string2.default;
exports.default = _core2.default;

/***/ }),
/* 1 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * Class responsible for storing an object that will be printed as JSON
 * when the `toString` method is called.
 */

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var Embodied = function () {
  /**
  * Constructs a Embodied instance.
  * @constructor
  */
  function Embodied() {
    _classCallCheck(this, Embodied);

    this.body_ = {};
  }

  /**
  * Gets the json object that represents this instance.
  * @return {!Object}
  */


  _createClass(Embodied, [{
    key: 'body',
    value: function body() {
      return this.body_;
    }

    /**
    * If the given object is an instance of Embodied, this will
    * return its body content. Otherwise this will return the
    * original object.
    * @param {*} obj
    * @return {*}
    * @static
    */

  }, {
    key: 'toString',


    /**
    * Gets the json string that represents this instance.
    * @return {string}
    */
    value: function toString() {
      return JSON.stringify(this.body());
    }
  }], [{
    key: 'toBody',
    value: function toBody(obj) {
      return obj instanceof Embodied ? obj.body() : obj;
    }
  }]);

  return Embodied;
}();

exports.default = Embodied;

/***/ }),
/* 2 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.TreeNode = exports.MultiMap = undefined;

var _MultiMap = __webpack_require__(43);

var _MultiMap2 = _interopRequireDefault(_MultiMap);

var _TreeNode = __webpack_require__(44);

var _TreeNode2 = _interopRequireDefault(_TreeNode);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.MultiMap = _MultiMap2.default;
exports.TreeNode = _TreeNode2.default;

/***/ }),
/* 3 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.assertUriWithNoPath = exports.assertUserSignedIn = exports.assertResponseSucceeded = exports.assertObject = exports.assertFunction = exports.assertNotNull = exports.assertDefAndNotNull = exports.assertBrowserEnvironment = undefined;

var _metal = __webpack_require__(0);

var _globals = __webpack_require__(5);

var _globals2 = _interopRequireDefault(_globals);

var _metalUri = __webpack_require__(6);

var _metalUri2 = _interopRequireDefault(_metalUri);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Throws an exception if the current environment is not a browser.
 */
function assertBrowserEnvironment() {
  if (!_globals2.default.window) {
    throw new Error('Sign-in type not supported in this environment');
  }
}

/**
 * Throws an exception if given value is undefined or null.
 * @param {!*} value The value to be checked.
 * @param {!string} errorMessage The message to be provided to the exception.
 */
function assertDefAndNotNull(value, errorMessage) {
  if (!_metal.core.isDefAndNotNull(value)) {
    throw new Error(errorMessage);
  }
}

/**
 * Throws an exception if given value is null.
 * @param {!*} value The value to be checked.
 * @param {!string} errorMessage The message to be provided to the exception.
 */
function assertNotNull(value, errorMessage) {
  if (_metal.core.isNull(value)) {
    throw new Error(errorMessage);
  }
}

/**
 * Throws an exception if given value is not a function.
 * @param {!*} value The value to be checked.
 * @param {!string} errorMessage The message to be provided to the exception.
 */
function assertFunction(value, errorMessage) {
  if (!_metal.core.isFunction(value)) {
    throw new Error(errorMessage);
  }
}

/**
 * Throws an exception if given value is not an object.
 * @param {!*} value The value to be checked.
 * @param {!string} errorMessage The message to be provided to the exception.
 */
function assertObject(value, errorMessage) {
  if (!_metal.core.isObject(value)) {
    throw new Error(errorMessage);
  }
}

/**
 * Checks if a response has succeeded. The function checks if the `succeeded`
 * method of response object returns true. Throws an exception if the returned
 * value is false.
 * @param {!Object} response The response to be checked.
 * @return {Object} The response itself if valid. Otherwise throws an exception.
 */
function assertResponseSucceeded(response) {
  if (!response.succeeded()) {
    throw response.body();
  }
  return response;
}

/**
 * Checks if a valid user is provided to the function. Throws an exception
 * in case of an invalid user.
 * @param {!Object} user The user to be checked.
 */
function assertUserSignedIn(user) {
  if (!_metal.core.isDefAndNotNull(user)) {
    throw new Error('You must be signed-in to perform this operation');
  }
}

/**
 * Checks if an URL with a valid path is provided. Throws an exception
 * if the provided URL doesn't have a valid path.
 * @param {!string} url The URL to be checked.
 * @param {!string} errorMessage The message to be provided to the exception.
 */
function assertUriWithNoPath(url, errorMessage) {
  var uri = new _metalUri2.default(url);
  if (uri.getPathname().length > 1) {
    throw new Error(errorMessage);
  }
}

exports.assertBrowserEnvironment = assertBrowserEnvironment;
exports.assertDefAndNotNull = assertDefAndNotNull;
exports.assertNotNull = assertNotNull;
exports.assertFunction = assertFunction;
exports.assertObject = assertObject;
exports.assertResponseSucceeded = assertResponseSucceeded;
exports.assertUserSignedIn = assertUserSignedIn;
exports.assertUriWithNoPath = assertUriWithNoPath;

/***/ }),
/* 4 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
		value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _metal = __webpack_require__(0);

var _Embodied2 = __webpack_require__(1);

var _Embodied3 = _interopRequireDefault(_Embodied2);

var _FilterBody = __webpack_require__(20);

var _FilterBody2 = _interopRequireDefault(_FilterBody);

var _Geo = __webpack_require__(15);

var _Geo2 = _interopRequireDefault(_Geo);

var _Range = __webpack_require__(8);

var _Range2 = _interopRequireDefault(_Range);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * Class responsible for building filters.
 * @extends {Embodied}
 */
var Filter = function (_Embodied) {
		_inherits(Filter, _Embodied);

		/**
  * Constructs a {@link Filter} instance.
  * @param {string} field The name of the field to filter by.
  * @param {*} operatorOrValue If a third param is given, this should
  *   be the filter's operator (like ">="). Otherwise, this will be
  *   used as the filter's value, and the filter's operator will be "=".
  * @param {*=} opt_value The filter's value.
  * @constructor
  */
		function Filter(field, operatorOrValue, opt_value) {
				_classCallCheck(this, Filter);

				var _this = _possibleConstructorReturn(this, (Filter.__proto__ || Object.getPrototypeOf(Filter)).call(this));

				_this.body_ = new _FilterBody2.default(field, operatorOrValue, opt_value);
				return _this;
		}

		/**
  * Adds a filter to be composed with this filter using the given operator.
  * @param {string} operator
  * @param {!Filter|string} fieldOrFilter Either a {@link Filter} instance or
  *   the name of the field to filter by.
  * @param {*=} opt_operatorOrValue Either the field's operator or its value.
  * @param {*=} opt_value The filter's value.
  * @return {Filter} Returns the {@link Filter} object itself, so calls can be
  *   chained.
  * @chainable
  */


		_createClass(Filter, [{
				key: 'add',
				value: function add(operator, fieldOrFilter, opt_operatorOrValue, opt_value) {
						var filter = fieldOrFilter ? Filter.toFilter(fieldOrFilter, opt_operatorOrValue, opt_value) : null;
						this.body_.add(operator, filter);
						return this;
				}

				/**
    * Adds filters to be composed with this filter using the given operator.
    * @param {string} operator
    * @param {...*} filters A variable amount of filters to be composed.
    * @return {Filter} Returns the {@link Filter} object itself, so calls can be
    *   chained.
    * @chainable
    */

		}, {
				key: 'addMany',
				value: function addMany(operator) {
						var _body_;

						for (var _len = arguments.length, filters = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
								filters[_key - 1] = arguments[_key];
						}

						(_body_ = this.body_).addMany.apply(_body_, [operator].concat(filters));
						return this;
				}

				/**
    * Adds a filter to be composed with this filter using the "and" operator.
    * @param {!Filter|string} fieldOrFilter Either a {@link Filter} instance or
    *   the name of the field to filter by.
    * @param {*=} opt_operatorOrValue Either the field's operator or its value.
    * @param {*=} opt_value The filter's value.
    * @return {Filter} Returns the {@link Filter} object itself, so calls can be
    *   chained.
    * @chainable
    */

		}, {
				key: 'and',
				value: function and(fieldOrFilter, opt_operatorOrValue, opt_value) {
						return this.add('and', fieldOrFilter, opt_operatorOrValue, opt_value);
				}

				/**
    * Returns a {@link Filter} instance that uses the "any" operator.
    * @param {string} field The name of the field to filter by.
    * @param {Array|*} values A variable amount of values to be used with
    *   the "any" operator. Can be passed either as a single array or as
    *   separate params.
    * @return {!Filter}
    * @static
    */

		}, {
				key: 'body',


				/**
    * Gets the json object that represents this filter.
    * @return {!Object}
    */
				value: function body() {
						return this.body_.getObject();
				}

				/**
    * Returns a {@link Filter} instance that uses the "gd" operator.
    * @param {string} field The field's name.
    * @param {*} locationOrCircle Either a `Geo.Circle` instance or a coordinate.
    * @param {Range|string=} opt_rangeOrDistance Either a `Range` instance or
    *   the distance value.
    * @return {!Filter}
    * @static
    */

		}, {
				key: 'or',


				/**
    * Adds a filter to be composed with this filter using the "or" operator.
    * @param {!Filter|string} fieldOrFilter Either a {@link Filter} instance or
    * the name of the field to filter by.
    * @param {*=} opt_operatorOrValue Either the field's operator or its value.
    * @param {*=} opt_value The filter's value.
    * @return {Filter} Returns the {@link Filter} object itself, so calls can be
    *   chained.
    * @chainable
    */
				value: function or(fieldOrFilter, opt_operatorOrValue, opt_value) {
						return this.add('or', fieldOrFilter, opt_operatorOrValue, opt_value);
				}

				/**
    * Converts the given arguments into a {@link Filter} instance.
    * @param {!Filter|string} fieldOrFilter Either a {@link Filter} instance or
    * the name of the field to filter by.
    * @param {*=} opt_operatorOrValue Either the field's operator or its value.
    * @param {*=} opt_value The filter's value.
    * @return {!Filter}
    */

		}], [{
				key: 'any',
				value: function any(field) {
						for (var _len2 = arguments.length, values = Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
								values[_key2 - 1] = arguments[_key2];
						}

						if (values.length === 1 && Array.isArray(values[0])) {
								values = values[0];
						}
						return new Filter(field, 'any', values);
				}

				/**
    * Returns a {@link Filter} instance that uses the "gp" operator.
    * This is a special use case of `Filter.polygon` for bounding
    * boxes.
    * @param {string} field The field's name.
    * @param {*} boxOrUpperLeft Either a `Geo.BoundingBox` instance, or
    *   a bounding box's upper left coordinate.
    * @param {*=} opt_lowerRight A bounding box's lower right coordinate.
    * @return {!Filter}
    * @static
    */

		}, {
				key: 'boundingBox',
				value: function boundingBox(field, boxOrUpperLeft, opt_lowerRight) {
						if (boxOrUpperLeft instanceof _Geo2.default.BoundingBox) {
								return Filter.polygon.apply(Filter, [field].concat(_toConsumableArray(boxOrUpperLeft.getPoints())));
						} else {
								return Filter.polygon(field, boxOrUpperLeft, opt_lowerRight);
						}
				}
		}, {
				key: 'distance',
				value: function distance(field, locationOrCircle, opt_rangeOrDistance) {
						var location = locationOrCircle;
						var range = opt_rangeOrDistance;
						if (locationOrCircle instanceof _Geo2.default.Circle) {
								location = locationOrCircle.getCenter();
								range = _Range2.default.to(locationOrCircle.getRadius());
						} else if (!(opt_rangeOrDistance instanceof _Range2.default)) {
								range = _Range2.default.to(opt_rangeOrDistance);
						}
						return Filter.distanceInternal_(field, location, range);
				}

				/**
    * Returns a {@link Filter} instance that uses the "gd" operator. This
    * is just an internal helper used by `Filter.distance`.
    * @param {string} field The field's name.
    * @param {*} location A location coordinate.
    * @param {Range} range A `Range` instance.
    * @return {!Filter}
    * @protected
    * @static
    */

		}, {
				key: 'distanceInternal_',
				value: function distanceInternal_(field, location, range) {
						var value = {
								location: _Embodied3.default.toBody(location)
						};
						range = range.body();
						if (range.from) {
								value.min = range.from;
						}
						if (range.to) {
								value.max = range.to;
						}
						return Filter.field(field, 'gd', value);
				}

				/**
    * Returns a {@link Filter} instance that uses the "=" operator.
    * @param {string} field The name of the field to filter by.
    * @param {*} value The filter's value.
    * @return {!Filter}
    * @static
    */

		}, {
				key: 'equal',
				value: function equal(field, value) {
						return new Filter(field, '=', value);
				}

				/**
    * Returns a {@link Filter} instance that uses the "exists" operator.
    * @param {string} field The field's name.
    * @return {!Filter}
    * @static
    */

		}, {
				key: 'exists',
				value: function exists(field) {
						return Filter.field(field, 'exists', null);
				}

				/**
    * Returns a {@link Filter} instance that uses the "fuzzy" operator.
    * @param {string} fieldOrQuery If no second string argument is given, this
    *   should be the query string, in which case all fields will be matched.
    *   Otherwise, this should be the name of the field to match.
    * @param {string|number=} opt_queryOrFuzziness If this is a string, it should
    *   be the query, otherwise it should be the fuzziness value.
    * @param {number=} opt_fuzziness The fuzziness value.
    * @return {!Filter}
    * @static
    */

		}, {
				key: 'fuzzy',
				value: function fuzzy(fieldOrQuery, opt_queryOrFuzziness, opt_fuzziness) {
						return Filter.fuzzyInternal_('fuzzy', fieldOrQuery, opt_queryOrFuzziness, opt_fuzziness);
				}

				/**
    * Returns a {@link Filter} instance that uses the given fuzzy operator. This
    * is an internal implementation used by the `Filter.fuzzy` method.
    * @param {string} operator The fuzzy operator.
    * @param {string} fieldOrQuery If no second string argument is given, this
    *   should be the query string, in which case all fields will be matched.
    *   Otherwise, this should be the name of the field to match.
    * @param {string|number=} opt_queryOrFuzziness If this is a string, it should
    *   be the query, otherwise it should be the fuzziness value.
    * @param {number=} opt_fuzziness The fuzziness value.
    * @return {!Filter}
    * @protected
    * @static
    */

		}, {
				key: 'fuzzyInternal_',
				value: function fuzzyInternal_(operator, fieldOrQuery, opt_queryOrFuzziness, opt_fuzziness) {
						var arg2IsString = _metal.core.isString(opt_queryOrFuzziness);

						var value = {
								query: arg2IsString ? opt_queryOrFuzziness : fieldOrQuery
						};
						var fuzziness = arg2IsString ? opt_fuzziness : opt_queryOrFuzziness;
						if (fuzziness) {
								value.fuzziness = fuzziness;
						}

						var field = arg2IsString ? fieldOrQuery : Filter.ALL;
						return Filter.field(field, operator, value);
				}

				/**
    * Returns a {@link Filter} instance that uses the ">" operator.
    * @param {string} field The name of the field to filter by.
    * @param {*} value The filter's value.
    * @return {!Filter}
    * @static
    */

		}, {
				key: 'gt',
				value: function gt(field, value) {
						return new Filter(field, '>', value);
				}

				/**
    * Returns a {@link Filter} instance that uses the ">=" operator.
    * @param {string} field The name of the field to filter by.
    * @param {*} value The filter's value.
    * @return {!Filter}
    * @static
    */

		}, {
				key: 'gte',
				value: function gte(field, value) {
						return new Filter(field, '>=', value);
				}

				/**
    * Returns a {@link Filter} instance that uses the "match" operator.
    * @param {string} fieldOrQuery If no second string argument is given, this
    *   should be the query string, in which case all fields will be matched.
    *   Otherwise, this should be the name of the field to match.
    * @param {string=} opt_query The query string.
    * @return {!Filter}
    * @static
    */

		}, {
				key: 'match',
				value: function match(fieldOrQuery, opt_query) {
						var field = _metal.core.isString(opt_query) ? fieldOrQuery : Filter.ALL;
						var query = _metal.core.isString(opt_query) ? opt_query : fieldOrQuery;
						return Filter.field(field, 'match', query);
				}

				/**
    * Returns a {@link Filter} instance that uses the "missing" operator.
    * @param {string} field The field's name.
    * @return {!Filter}
    * @static
    */

		}, {
				key: 'missing',
				value: function missing(field) {
						return Filter.field(field, 'missing', null);
				}

				/**
    * Returns a {@link Filter} instance that uses the "phrase" operator.
    * @param {string} fieldOrQuery If no second string argument is given, this
    *   should be the query string, in which case all fields will be matched.
    *   Otherwise, this should be the name of the field to match.
    * @param {string=} opt_query The query string.
    * @return {!Filter}
    * @static
    */

		}, {
				key: 'phrase',
				value: function phrase(fieldOrQuery, opt_query) {
						var field = _metal.core.isString(opt_query) ? fieldOrQuery : Filter.ALL;
						var query = _metal.core.isString(opt_query) ? opt_query : fieldOrQuery;
						return Filter.field(field, 'phrase', query);
				}

				/**
    * Returns a {@link Filter} instance that uses the "gp" operator.
    * @param {string} field The name of the field.
    * @param {...!Object} points Objects representing points in the polygon.
    * @return {!Filter}
    * @static
    */

		}, {
				key: 'polygon',
				value: function polygon(field) {
						for (var _len3 = arguments.length, points = Array(_len3 > 1 ? _len3 - 1 : 0), _key3 = 1; _key3 < _len3; _key3++) {
								points[_key3 - 1] = arguments[_key3];
						}

						points = points.map(function (point) {
								return _Embodied3.default.toBody(point);
						});
						return Filter.field(field, 'gp', points);
				}

				/**
    * Returns a {@link Filter} instance that uses the "prefix" operator.
    * @param {string} fieldOrQuery If no second argument is given, this should
    *   be the query string, in which case all fields will be matched. Otherwise,
    *   this should be the name of the field to match.
    * @param {string=} opt_query The query string.
    * @return {!Filter}
    * @static
    */

		}, {
				key: 'prefix',
				value: function prefix(fieldOrQuery, opt_query) {
						var field = _metal.core.isDefAndNotNull(opt_query) ? fieldOrQuery : Filter.ALL;
						var query = _metal.core.isDefAndNotNull(opt_query) ? opt_query : fieldOrQuery;
						return Filter.field(field, 'prefix', query);
				}

				/**
    * Returns a {@link Filter} instance that uses the "range" operator.
    * @param {string} field The field's name.
    * @param {*} rangeOrMin Either a `Range` instance or a the range's min value.
    * @param {*=} opt_max The range's max value.
    * @return {!Filter}
    * @static
    */

		}, {
				key: 'range',
				value: function range(field, rangeOrMin, opt_max) {
						var range = rangeOrMin;
						if (!(range instanceof _Range2.default)) {
								range = _Range2.default.range(rangeOrMin, opt_max);
						}
						return Filter.field(field, 'range', range);
				}

				/**
    * Returns a {@link Filter} instance that uses the "~" operator.
    * @param {string} field The name of the field to filter by.
    * @param {*} value The filter's value.
    * @return {!Filter}
    * @static
    */

		}, {
				key: 'regex',
				value: function regex(field, value) {
						return new Filter(field, '~', value);
				}

				/**
    * Returns a {@link Filter} instance that uses the "gs" operator.
    * @param {string} field The field's name.
    * @param {...!Object} shapes Objects representing shapes.
    * @return {!Filter}
    * @static
    */

		}, {
				key: 'shape',
				value: function shape(field) {
						for (var _len4 = arguments.length, shapes = Array(_len4 > 1 ? _len4 - 1 : 0), _key4 = 1; _key4 < _len4; _key4++) {
								shapes[_key4 - 1] = arguments[_key4];
						}

						shapes = shapes.map(function (shape) {
								return _Embodied3.default.toBody(shape);
						});
						var value = {
								type: 'geometrycollection',
								geometries: shapes
						};
						return Filter.field(field, 'gs', value);
				}

				/**
    * Returns a {@link Filter} instance that uses the "similar" operator.
    * @param {string} fieldOrQuery If no second string argument is given, this
    *   should be the query string, in which case all fields will be matched.
    *   Otherwise, this should be the name of the field to match.
    * @param {?string} query The query string.
    * @return {!Filter}
    * @static
    */

		}, {
				key: 'similar',
				value: function similar(fieldOrQuery, query) {
						var field = _metal.core.isString(query) ? fieldOrQuery : Filter.ALL;
						var value = {
								query: _metal.core.isString(query) ? query : fieldOrQuery
						};
						return Filter.field(field, 'similar', value);
				}

				/**
    * Returns a {@link Filter} instance that uses the "<" operator.
    * @param {string} field The name of the field to filter by.
    * @param {*} value The filter's value.
    * @return {!Filter}
    * @static
    */

		}, {
				key: 'lt',
				value: function lt(field, value) {
						return new Filter(field, '<', value);
				}

				/**
    * Returns a {@link Filter} instance that uses the "<=" operator.
    * @param {string} field The name of the field to filter by.
    * @param {*} value The filter's value.
    * @return {!Filter}
    * @static
    */

		}, {
				key: 'lte',
				value: function lte(field, value) {
						return new Filter(field, '<=', value);
				}

				/**
    * Returns a {@link Filter} instance that uses the "none" operator.
    * @param {string} field The name of the field to filter by.
    * @param {!(Array|*)} value A variable amount of values to be used with
    * the "none" operator. Can be passed either as a single array or as
    * separate params.
    * @return {!Filter}
    * @static
    */

		}, {
				key: 'none',
				value: function none(field) {
						for (var _len5 = arguments.length, values = Array(_len5 > 1 ? _len5 - 1 : 0), _key5 = 1; _key5 < _len5; _key5++) {
								values[_key5 - 1] = arguments[_key5];
						}

						if (values.length === 1 && Array.isArray(values[0])) {
								values = values[0];
						}
						return new Filter(field, 'none', values);
				}

				/**
    * Returns a {@link Filter} instance that uses the "!=" operator.
    * @param {string} field The name of the field to filter by.
    * @param {*} value The filter's value.
    * @return {!Filter}
    * @static
    */

		}, {
				key: 'notEqual',
				value: function notEqual(field, value) {
						return new Filter(field, '!=', value);
				}

				/**
    * Returns a {@link Filter} instance that uses the "not" operator.
    * @param {!Filter|string} fieldOrFilter Either a {@link Filter} instance or
    * the name of the field to filter by.
    * @param {*=} opt_operatorOrValue Either the field's operator or its value.
    * @param {*=} opt_value The filter's value.
    * @return {!Filter}
    * @static
    */

		}, {
				key: 'not',
				value: function not(fieldOrFilter, opt_operatorOrValue, opt_value) {
						return Filter.toFilter(fieldOrFilter, opt_operatorOrValue, opt_value).add('not');
				}

				/**
    * Returns a {@link Filter} instance.
    * @param {string} field The name of the field to filter by.
    * @param {*} operatorOrValue If a third param is given, this should be the
    * filter's operator (like ">="). Otherwise, this will be used as the
    * filter's value, and the filter's operator will be "=".
    * @param {*=} opt_value The filter's value.
    * @return {!Filter}
    * @static
    */

		}, {
				key: 'field',
				value: function field(_field, operatorOrValue, opt_value) {
						return new Filter(_field, operatorOrValue, opt_value);
				}
		}, {
				key: 'toFilter',
				value: function toFilter(fieldOrFilter, opt_operatorOrValue, opt_value) {
						var filter = fieldOrFilter;
						if (!(filter instanceof Filter)) {
								filter = Filter.field(fieldOrFilter, opt_operatorOrValue, opt_value);
						}
						return filter;
				}
		}]);

		return Filter;
}(_Embodied3.default);

/**
 * String constant that represents all fields.
 * @type {string}
 * @static
 */


Filter.ALL = '*';

exports.default = Filter;

/***/ }),
/* 5 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
var globals = {};

if (typeof window !== 'undefined') {
  globals.window = window;
}

if (typeof document !== 'undefined') {
  globals.document = document;
}

exports.default = globals;

/***/ }),
/* 6 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var Uri = __webpack_require__(45).default;

if (typeof URL === 'undefined' && "function" !== 'undefined') {
	// If there is no "document", then this should be running in NodeJS or in ReactNative env and
	// in this case we should use the "url" NPM module as the parse function.
	// In ReactNative env "path" will be replaced with "path-browserify".

	var path = __webpack_require__(54);
	var url = __webpack_require__(61);

	Uri.setParseFn(function(urlStr) {
		var parsed = url.parse(urlStr);
		parsed.pathname = path.normalize(parsed.pathname);
		return parsed;
	});
}

module.exports = Uri;


/***/ }),
/* 7 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
		value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _metal = __webpack_require__(0);

var _Embodied2 = __webpack_require__(1);

var _Embodied3 = _interopRequireDefault(_Embodied2);

var _Filter = __webpack_require__(4);

var _Filter2 = _interopRequireDefault(_Filter);

var _Aggregation = __webpack_require__(19);

var _Aggregation2 = _interopRequireDefault(_Aggregation);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * Class responsible for building queries.
 * @extends {Embodied}
 */
var Query = function (_Embodied) {
		_inherits(Query, _Embodied);

		function Query() {
				_classCallCheck(this, Query);

				return _possibleConstructorReturn(this, (Query.__proto__ || Object.getPrototypeOf(Query)).apply(this, arguments));
		}

		_createClass(Query, [{
				key: 'aggregate',


				/**
    * Adds an aggregation to this {@link Query} instance.
    * @param {string} name The aggregation name.
    * @param {!Aggregation|string} aggregationOrField Either an
    *   {@link Aggregation} instance or the name of the aggregation field.
    * @param {string=} opt_operator The aggregation operator.
    * @return {Query} Returns the {@link Query} object itself, so calls can be
    *   chained.
    * @chainnable
    */
				value: function aggregate(name, aggregationOrField, opt_operator) {
						var aggregation = aggregationOrField;
						if (!(aggregation instanceof _Aggregation2.default)) {
								aggregation = _Aggregation2.default.field(aggregationOrField, opt_operator);
						}

						var field = aggregation.getField();
						var value = {};
						value[field] = {
								name: name,
								operator: aggregation.getOperator()
						};
						if (_metal.core.isDefAndNotNull(aggregation.getValue())) {
								value[field].value = aggregation.getValue();
						}

						if (!this.body_.aggregation) {
								this.body_.aggregation = [];
						}
						this.body_.aggregation.push(value);
						return this;
				}

				/**
    * Sets this query's type to "count".
    * @return {Query} Returns the {@link Query} object itself, so calls can be
    *   chained.
    * @chainnable
    */

		}, {
				key: 'count',
				value: function count() {
						return this.type('count');
				}

				/**
    * Sets this query's type to "fetch".
    * @return {Query} Returns the {@link Query} object itself, so calls can be
    *   chained.
    * @chainnable
    */

		}, {
				key: 'fetch',
				value: function fetch() {
						return this.type('fetch');
				}

				/**
    * Adds a filter to this Query.
    * @param {!Filter|string} fieldOrFilter Either a {@link Filter} or the
    *   name of the field to filter by.
    * @param {*=} opt_operatorOrValue Either the field's operator or its value.
    * @param {*=} opt_value The filter's value.
    * @return {Query} Returns the {@link Query} object itself, so calls can be
    *   chained.
    * @chainnable
    */

		}, {
				key: 'filter',
				value: function filter(fieldOrFilter, opt_operatorOrValue, opt_value) {
						var filter = _Filter2.default.toFilter(fieldOrFilter, opt_operatorOrValue, opt_value);
						if (!this.body_.filter) {
								this.body_.filter = [];
						}
						this.body_.filter.push(filter.body());
						return this;
				}

				/**
    * Sets the query offset.
    * @param {number} offset The index of the first entry that should be returned
    *   by this query.
    * @return {Query} Returns the {@link Query} object itself, so calls can be
    *   chained.
    * @chainnable
    */

		}, {
				key: 'offset',
				value: function offset(_offset2) {
						this.body_.offset = _offset2;
						return this;
				}

				/**
    * Adds a highlight entry to this {@link Query} instance.
    * @param {string} field The field's name.
    * @return {Query} Returns the {@link Query} object itself, so calls can be
    *   chained.
    * @chainnable
    */

		}, {
				key: 'highlight',
				value: function highlight(field) {
						if (!this.body_.highlight) {
								this.body_.highlight = [];
						}

						this.body_.highlight.push(field);
						return this;
				}

				/**
    * Sets the query limit.
    * @param {number} limit The max amount of entries that this query should
    *   return.
    * @return {Query} Returns the {@link Query} object itself, so calls can be
    *   chained.
    * @chainnable
    */

		}, {
				key: 'limit',
				value: function limit(_limit2) {
						this.body_.limit = _limit2;
						return this;
				}

				/**
    * Adds a search to this {@link Query} instance.
    * @param {!Filter|string=} filterOrTextOrField If no other arguments
    *   are passed to this function, this should be either a {@link Filter}
    *   instance or a text to be used in a match filter. In both cases
    *   the filter will be applied to all fields. Another option is to
    *   pass this as a field name instead, together with other arguments
    *   so the filter can be created. If the value of this parameter is
    *   undefined or null, no filter will be provided to the search query.
    * @param {string=} opt_textOrOperator Either a text to be used in a
    *   match filter, or the operator that should be used.
    * @param {*=} opt_value The value to be used by the filter. Should
    *   only be passed if an operator was passed as the second argument.
    * @return {Query} Returns the {@link Query} object itself, so calls can be
    *   chained.
    * @chainnable
    */

		}, {
				key: 'search',
				value: function search(filterOrTextOrField, opt_textOrOperator, opt_value) {
						var filter = filterOrTextOrField;

						if (opt_value) {
								filter = _Filter2.default.field(filterOrTextOrField, opt_textOrOperator, opt_value);
						} else if (opt_textOrOperator) {
								filter = _Filter2.default.match(filterOrTextOrField, opt_textOrOperator);
						} else if (filter && !(filter instanceof _Filter2.default)) {
								filter = _Filter2.default.match(filterOrTextOrField);
						}

						this.type('search');

						if (filter) {
								this.filter(filter);
						}

						return this;
				}

				/**
    * Adds a sort entry to this query, specifying the field this query should be
    * sorted by and, optionally, the sort direction.
    * @param {string} field The field that the query should be sorted by.
    * @param {string=} opt_direction The direction the sort operation should use.
    *   If none is given, "asc" is used by default.
    * @return {Query} Returns the {@link Query} object itself, so calls can be
    *   chained.
    * @chainnable
    */

		}, {
				key: 'sort',
				value: function sort(field, opt_direction) {
						if (!this.body_.sort) {
								this.body_.sort = [];
						}
						var sortEntry = {};
						sortEntry[field] = opt_direction || 'asc';
						this.body_.sort.push(sortEntry);
						return this;
				}

				/**
    * Sets the query type.
    * @param {string} type The query's type. For example: "count", "fetch".
    * @return {Query} Returns the {@link Query} object itself, so calls can be
    *   chained.
    * @chainnable
    */

		}, {
				key: 'type',
				value: function type(_type2) {
						this.body_.type = _type2;
						return this;
				}
		}], [{
				key: 'aggregate',

				/**
    * Adds an aggregation to this {@link Query} instance.
    * @param {string} name The aggregation name.
    * @param {!Aggregation|string} aggregationOrField Either an
    *   {@link Aggregation} instance or the name of the aggregation field.
    * @param {string=} opt_operator The aggregation operator.
    * @return {!Query}
    * @static
    */
				value: function aggregate(name, aggregationOrField, opt_operator) {
						return new Query().aggregate(name, aggregationOrField, opt_operator);
				}

				/**
    * Sets this query's type to "count".
    * @return {!Query}
    * @static
    */

		}, {
				key: 'count',
				value: function count() {
						return new Query().type('count');
				}

				/**
    * Sets this query's type to "fetch".
    * @return {!Query}
    * @static
    */

		}, {
				key: 'fetch',
				value: function fetch() {
						return new Query().type('fetch');
				}

				/**
    * Adds a filter to this Query.
    * @param {!Filter|string} fieldOrFilter Either a {@link Filter} or the
    *   name of the field to filter by.
    * @param {*=} opt_operatorOrValue Either the field's operator or its value.
    * @param {*=} opt_value The filter's value.
    * @return {!Query}
    * @static
    */

		}, {
				key: 'filter',
				value: function filter(fieldOrFilter, opt_operatorOrValue, opt_value) {
						return new Query().filter(fieldOrFilter, opt_operatorOrValue, opt_value);
				}

				/**
    * Sets the query offset.
    * @param {number} offset The index of the first entry that should be returned
    *   by this query.
    * @return {!Query}
    * @static
    */

		}, {
				key: 'offset',
				value: function offset(_offset) {
						return new Query().offset(_offset);
				}

				/**
    * Adds a highlight entry to this {@link Query} instance.
    * @param {string} field The field's name.
    * @return {!Query}
    * @static
    */

		}, {
				key: 'highlight',
				value: function highlight(field) {
						return new Query().highlight(field);
				}

				/**
    * Sets the query limit.
    * @param {number} limit The max amount of entries that this query should
    *   return.
    * @return {!Query}
    * @static
    */

		}, {
				key: 'limit',
				value: function limit(_limit) {
						return new Query().limit(_limit);
				}

				/**
    * Adds a search to this {@link Query} instance.
    * @param {!Filter|string} filterOrTextOrField If no other arguments
    *   are passed to this function, this should be either a {@link Filter}
    *   instance or a text to be used in a match filter. In both cases
    *   the filter will be applied to all fields. Another option is to
    *   pass this as a field name instead, together with other arguments
    *   so the filter can be created.
    * @param {string=} opt_textOrOperator Either a text to be used in a
    *   match filter, or the operator that should be used.
    * @param {*=} opt_value The value to be used by the filter. Should
    *   only be passed if an operator was passed as the second argument.
    * @return {!Query}
    * @static
    */

		}, {
				key: 'search',
				value: function search(filterOrTextOrField, opt_textOrOperator, opt_value) {
						return new Query().search(filterOrTextOrField, opt_textOrOperator, opt_value);
				}

				/**
    * Adds a sort entry to this query, specifying the field this query should be
    * sorted by and, optionally, the sort direction.
    * @param {string} field The field that the query should be sorted by.
    * @param {string=} opt_direction The direction the sort operation should use.
    *   If none is given, "asc" is used by default.
    * @return {!Query}
    * @static
    */

		}, {
				key: 'sort',
				value: function sort(field, opt_direction) {
						return new Query().sort(field, opt_direction);
				}

				/**
    * Sets the query type.
    * @param {string} type The query's type. For example: "count", "fetch".
    * @return {!Query}
    * @static
    */

		}, {
				key: 'type',
				value: function type(_type) {
						return new Query().type(_type);
				}
		}]);

		return Query;
}(_Embodied3.default);

exports.default = Query;

/***/ }),
/* 8 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _metal = __webpack_require__(0);

var _Embodied2 = __webpack_require__(1);

var _Embodied3 = _interopRequireDefault(_Embodied2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * Class responsible for building range objects to be used by `Filter`.
 * @extends {Embodied}
 */
var Range = function (_Embodied) {
  _inherits(Range, _Embodied);

  /**
  * Constructs a {@link Range} instance.
  * @param {*} from
  * @param {*} opt_to
  * @constructor
  */
  function Range(from, opt_to) {
    _classCallCheck(this, Range);

    var _this = _possibleConstructorReturn(this, (Range.__proto__ || Object.getPrototypeOf(Range)).call(this));

    if (_metal.core.isDefAndNotNull(from)) {
      _this.body_.from = from;
    }
    if (_metal.core.isDefAndNotNull(opt_to)) {
      _this.body_.to = opt_to;
    }
    return _this;
  }

  /**
  * Constructs a {@link Range} instance.
  * @param {*} from
  * @return {!Range}
  * @static
  */


  _createClass(Range, null, [{
    key: 'from',
    value: function from(_from) {
      return new Range(_from);
    }

    /**
    * Constructs a {@link Range} instance.
    * @param {*} from
    * @param {*} to
    * @return {!Range}
    * @static
    */

  }, {
    key: 'range',
    value: function range(from, to) {
      return new Range(from, to);
    }

    /**
    * Constructs a {@link Range} instance.
    * @param {*} to
    * @return {!Range}
    * @static
    */

  }, {
    key: 'to',
    value: function to(_to) {
      return new Range(null, _to);
    }
  }]);

  return Range;
}(_Embodied3.default);

exports.default = Range;

/***/ }),
/* 9 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _assertions = __webpack_require__(3);

var _metalStructs = __webpack_require__(2);

var _Auth = __webpack_require__(10);

var _Auth2 = _interopRequireDefault(_Auth);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * Class responsible for encapsulating API calls.
 */
var ApiHelper = function () {
  /**
  * Constructs an {@link ApiHelper} instance.
  * @param {!WeDeploy} wedeployClient {@link WeDeploy} client reference.
  * @constructor
  */
  function ApiHelper(wedeployClient) {
    _classCallCheck(this, ApiHelper);

    (0, _assertions.assertDefAndNotNull)(wedeployClient, 'WeDeploy client reference must be specified');
    this.wedeployClient = wedeployClient;
    this.headers_ = new _metalStructs.MultiMap();
  }

  /**
  * Adds a header. If a header with the same name already exists, it will not
  * be overwritten, but the new value will be stored as well. The order is
  * preserved.
  * @param {string} name
  * @param {string} value
  * @return {!ClientMessage} Returns the {@link ClientMessage}
  *   object itself, so calls can be chained.
  * @chainable
  */


  _createClass(ApiHelper, [{
    key: 'header',
    value: function header(name, value) {
      if (arguments.length !== 2) {
        throw new Error('Invalid arguments');
      }
      this.headers_.set(name, value);
      return this;
    }

    /**
    * Adds authorization information to this request.
    * @param {!Auth|string} authOrTokenOrEmail Either an {@link Auth} instance,
    * an authorization token, or the email.
    * @param {string=} opt_password If a email is given as the first param,
    * this should be the password.
    * @return {ApiHelper}
    * @chainable
    */

  }, {
    key: 'auth',
    value: function auth(authOrTokenOrEmail, opt_password) {
      this.helperAuthScope = _Auth2.default.create(authOrTokenOrEmail, opt_password);
      this.helperAuthScope.wedeployClient = this.wedeployClient;
      return this;
    }
  }]);

  return ApiHelper;
}();

exports.default = ApiHelper;

/***/ }),
/* 10 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _metal = __webpack_require__(0);

var _metalStructs = __webpack_require__(2);

var _assertions = __webpack_require__(3);

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * Class responsible for storing authorization information.
 */
var Auth = function () {
  /**
  * Constructs an {@link Auth} instance.
  * @param {string} tokenOrEmail Either the authorization token, or
  *   the username.
  * @param {string=} opt_password If a username is given as the first param,
  *   this should be the password.
  * @constructor
  */
  function Auth(tokenOrEmail) {
    var opt_password = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;

    _classCallCheck(this, Auth);

    this.token = _metal.core.isString(opt_password) ? null : tokenOrEmail;
    this.email = _metal.core.isString(opt_password) ? tokenOrEmail : null;
    this.password = opt_password;

    this.createdAt = null;
    this.id = null;
    this.name = null;
    this.photoUrl = null;
    this.supportedScopes = [];
    this.wedeployClient = null;
    this.headers_ = new _metalStructs.MultiMap();
  }

  /**
  * Constructs an {@link Auth} instance.
  * @param {string} authOrTokenOrEmail Either an auth instance, the
  *   authorization token, or the username.
  * @param {string=} opt_password If a username is given as the first param,
  *   this should be the password.
  * @return {!Auth}
  */


  _createClass(Auth, [{
    key: 'getCreatedAt',


    /**
    * Gets the created at date.
    * @return {string}
    */
    value: function getCreatedAt() {
      return this.createdAt;
    }

    /**
    * Gets the email.
    * @return {string}
    */

  }, {
    key: 'getEmail',
    value: function getEmail() {
      return this.email;
    }

    /**
    * Gets the id.
    * @return {string}
    */

  }, {
    key: 'getId',
    value: function getId() {
      return this.id;
    }

    /**
    * Gets the name.
    * @return {string}
    */

  }, {
    key: 'getName',
    value: function getName() {
      return this.name;
    }

    /**
    * Gets the password.
    * @return {string}
    */

  }, {
    key: 'getPassword',
    value: function getPassword() {
      return this.password;
    }

    /**
    * Gets the photo url.
    * @return {string}
    */

  }, {
    key: 'getPhotoUrl',
    value: function getPhotoUrl() {
      return this.photoUrl;
    }

    /**
    * Gets the supported scopes.
    * @return {array.<string>}
    */

  }, {
    key: 'getSupportedScopes',
    value: function getSupportedScopes() {
      return this.supportedScopes;
    }

    /**
    * Gets the token.
    * @return {string}
    */

  }, {
    key: 'getToken',
    value: function getToken() {
      return this.token;
    }

    /**
    * Checks if created at is set.
    * @return {boolean}
    */

  }, {
    key: 'hasCreatedAt',
    value: function hasCreatedAt() {
      return _metal.core.isDefAndNotNull(this.createdAt);
    }

    /**
    * Checks if the email is set.
    * @return {boolean}
    */

  }, {
    key: 'hasEmail',
    value: function hasEmail() {
      return _metal.core.isDefAndNotNull(this.email);
    }

    /**
    * Checks if the id is set.
    * @return {boolean}
    */

  }, {
    key: 'hasId',
    value: function hasId() {
      return _metal.core.isDefAndNotNull(this.id);
    }

    /**
    * Checks if the name is set.
    * @return {boolean}
    */

  }, {
    key: 'hasName',
    value: function hasName() {
      return _metal.core.isDefAndNotNull(this.name);
    }

    /**
    * Checks if the password is set.
    * @return {boolean}
    */

  }, {
    key: 'hasPassword',
    value: function hasPassword() {
      return _metal.core.isDefAndNotNull(this.password);
    }

    /**
    * Checks if the photo url is set.
    * @return {boolean}
    */

  }, {
    key: 'hasPhotoUrl',
    value: function hasPhotoUrl() {
      return _metal.core.isDefAndNotNull(this.photoUrl);
    }

    /**
    * Checks if the user has scopes.
    * @param {string|array.<string>} scopes Scope or array of scopes to check.
    * @return {boolean}
    */

  }, {
    key: 'hasSupportedScopes',
    value: function hasSupportedScopes(scopes) {
      var _this = this;

      if (Array.isArray(scopes)) {
        return scopes.every(function (val) {
          return _this.supportedScopes.indexOf(val) > -1;
        });
      } else {
        return this.supportedScopes.indexOf(scopes) > -1;
      }
    }

    /**
    * Checks if the token is set.
    * @return {boolean}
    */

  }, {
    key: 'hasToken',
    value: function hasToken() {
      return _metal.core.isDefAndNotNull(this.token);
    }

    /**
    * Sets created at.
    * @param {string} createdAt
    */

  }, {
    key: 'setCreatedAt',
    value: function setCreatedAt(createdAt) {
      this.createdAt = createdAt;
    }

    /**
    * Sets the email.
    * @param {string} email
    */

  }, {
    key: 'setEmail',
    value: function setEmail(email) {
      this.email = email;
    }

    /**
    * Sets the headers.
    * @param {!MultiMap|Object} headers The headers to be set
    */

  }, {
    key: 'setHeaders',
    value: function setHeaders(headers) {
      var _this2 = this;

      if (!(headers instanceof _metalStructs.MultiMap)) {
        headers = _metalStructs.MultiMap.fromObject(headers);
      }

      headers.names().forEach(function (name) {
        var values = headers.getAll(name);

        values.forEach(function (value) {
          _this2.headers_.set(name, value);
        });
      });
    }

    /**
    * Sets the id.
    * @param {string} id
    */

  }, {
    key: 'setId',
    value: function setId(id) {
      this.id = id;
    }

    /**
    * Sets the name.
    * @param {string} name
    */

  }, {
    key: 'setName',
    value: function setName(name) {
      this.name = name;
    }

    /**
    * Sets the password.
    * @param {string} password
    */

  }, {
    key: 'setPassword',
    value: function setPassword(password) {
      this.password = password;
    }

    /**
    * Sets the photo url.
    * @param {string} photoUrl
    */

  }, {
    key: 'setPhotoUrl',
    value: function setPhotoUrl(photoUrl) {
      this.photoUrl = photoUrl;
    }

    /**
    * Sets supported scopes.
    * @param {array.<string>} supportedScopes
    */

  }, {
    key: 'setSupportedScopes',
    value: function setSupportedScopes(supportedScopes) {
      this.supportedScopes = supportedScopes;
    }

    /**
    * Sets the token.
    * @param {string} token
    */

  }, {
    key: 'setToken',
    value: function setToken(token) {
      this.token = token;
    }

    /**
    * Sets the WeDeploy client.
    * @param {Object} wedeployClient
    */

  }, {
    key: 'setWedeployClient',
    value: function setWedeployClient(wedeployClient) {
      this.wedeployClient = wedeployClient;
    }

    /**
    * Updates the user.
    * @param {!Object} data
    * @return {CompletableFuture}
    */

  }, {
    key: 'updateUser',
    value: function updateUser(data) {
      (0, _assertions.assertObject)(data, 'User data must be specified as object');
      return this.buildUrl_().path('/users', this.getId().toString()).auth(this).patch(data).then(function (response) {
        return (0, _assertions.assertResponseSucceeded)(response);
      });
    }

    /**
    * Deletes the current user.
    * @return {CompletableFuture}
    */

  }, {
    key: 'deleteUser',
    value: function deleteUser() {
      (0, _assertions.assertDefAndNotNull)(this.getId(), 'Cannot delete user without id');
      return this.buildUrl_().path('/users', this.getId().toString()).auth(this).delete().then(function (response) {
        return (0, _assertions.assertResponseSucceeded)(response);
      });
    }

    /**
    * Builds URL by joining the headers.
    * @return {WeDeploy} Returns the {@link WeDeploy} object itself, so calls can
    *   be chained.
    * @chainable
    */

  }, {
    key: 'buildUrl_',
    value: function buildUrl_() {
      return this.wedeployClient.url(this.wedeployClient.authUrl_).headers(this.headers_);
    }
  }], [{
    key: 'create',
    value: function create(authOrTokenOrEmail, opt_password) {
      if (authOrTokenOrEmail instanceof Auth) {
        return authOrTokenOrEmail;
      } else if ((0, _metal.isString)(authOrTokenOrEmail) && (0, _metal.isString)(opt_password)) {
        return new Auth(authOrTokenOrEmail, opt_password);
      } else if ((0, _metal.isString)(authOrTokenOrEmail) && !(0, _metal.isDef)(opt_password)) {
        return new Auth(authOrTokenOrEmail);
      } else if ((0, _metal.isDefAndNotNull)(authOrTokenOrEmail) && (0, _metal.isObject)(authOrTokenOrEmail)) {
        return Auth.createFromData(authOrTokenOrEmail);
      } else {
        return new Auth();
      }
    }

    /**
    * Makes user Auth from data object.
    * @param {Object} data
    * @return {Auth}
    * @protected
    */

  }, {
    key: 'createFromData',
    value: function createFromData(data) {
      var auth = new Auth();
      if ((0, _metal.isObject)(data)) {
        var properties = {};
        Object.keys(data).forEach(function (key) {
          properties[key] = {
            enumerable: true,
            value: data[key],
            writable: true
          };
        });
        Object.defineProperties(auth, properties);
      }
      auth.setWedeployClient(this.wedeployClient);
      return auth;
    }
  }]);

  return Auth;
}();

exports.default = Auth;

/***/ }),
/* 11 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _metalUri = __webpack_require__(6);

var _metalUri2 = _interopRequireDefault(_metalUri);

var _metal = __webpack_require__(0);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * Class responsible for encapsulate provider information.
 */
var AuthProvider = function () {
  /**
  * Constructs an {@link AuthProvider} instance.
  * @constructor
  */
  function AuthProvider() {
    _classCallCheck(this, AuthProvider);

    this.provider = null;
    this.providerScope = null;
    this.redirectUri = null;
    this.scope = null;
  }

  /**
  * Checks if provider is defined and not null.
  * @return {boolean}
  */


  _createClass(AuthProvider, [{
    key: 'hasProvider',
    value: function hasProvider() {
      return _metal.core.isDefAndNotNull(this.provider);
    }

    /**
    * Checks if scope is defined and not null.
    * @return {boolean}
    */

  }, {
    key: 'hasProviderScope',
    value: function hasProviderScope() {
      return _metal.core.isDefAndNotNull(this.providerScope);
    }

    /**
    * Checks if redirect uri is defined and not null.
    * @return {boolean}
    */

  }, {
    key: 'hasRedirectUri',
    value: function hasRedirectUri() {
      return _metal.core.isDefAndNotNull(this.redirectUri);
    }

    /**
    * Checks if scope is defined and not null.
    * @return {boolean}
    */

  }, {
    key: 'hasScope',
    value: function hasScope() {
      return _metal.core.isDefAndNotNull(this.scope);
    }

    /**
    * Makes authorization url. An optional authorization URL might be provided.
    * @param {string} opt_authUrl Optional authorization URL.
    * @return {string} Normalized authorization URL.
    */

  }, {
    key: 'makeAuthorizationUrl',
    value: function makeAuthorizationUrl(opt_authUrl) {
      var uri = new _metalUri2.default(opt_authUrl);

      uri.setPathname('/oauth/authorize');

      if (this.hasProvider()) {
        uri.setParameterValue('provider', this.getProvider());
      }
      if (this.hasProviderScope()) {
        uri.setParameterValue('provider_scope', this.getProviderScope());
      }
      if (this.hasRedirectUri()) {
        uri.setParameterValue('redirect_uri', this.getRedirectUri());
      }
      if (this.hasScope()) {
        uri.setParameterValue('scope', this.getScope());
      }

      return uri.toString();
    }

    /**
    * Gets provider name.
    * @return {string} Provider name.
    */

  }, {
    key: 'getProvider',
    value: function getProvider() {
      return this.provider;
    }

    /**
    * Gets provider scope.
    * @return {string} String with scopes.
    */

  }, {
    key: 'getProviderScope',
    value: function getProviderScope() {
      return this.providerScope;
    }

    /**
    * Gets redirect uri.
    * @return {string}.
    */

  }, {
    key: 'getRedirectUri',
    value: function getRedirectUri() {
      return this.redirectUri;
    }

    /**
    * Gets scope.
    * @return {string} String with scopes.
    */

  }, {
    key: 'getScope',
    value: function getScope() {
      return this.scope;
    }

    /**
    * Sets provider scope.
    * @param {string=} providerScope Scope string. Separate by space for multiple
    *   scopes, e.g. "scope1 scope2".
    */

  }, {
    key: 'setProviderScope',
    value: function setProviderScope(providerScope) {
      assertStringIfDefAndNotNull(providerScope, 'Provider scope must be a string');
      this.providerScope = providerScope;
    }

    /**
    * Sets redirect uri.
    * @param {string} redirectUri The redirect URI to be set to the current
    *   instance.
    */

  }, {
    key: 'setRedirectUri',
    value: function setRedirectUri(redirectUri) {
      assertStringIfDefAndNotNull(redirectUri, 'Redirect uri must be a string');
      this.redirectUri = redirectUri;
    }

    /**
    * Sets scope.
    * @param {string=} scope Scope string. Separate by space for multiple
    *   scopes, e.g. "scope1 scope2".
    */

  }, {
    key: 'setScope',
    value: function setScope(scope) {
      assertStringIfDefAndNotNull(scope, 'Scope must be a string');
      this.scope = scope;
    }
  }]);

  return AuthProvider;
}();

/**
 * Throws an exception if the provided value is defined and not null, but not a
 *   string.
 * @param {!*} value The value to be checked.
 * @param {!string} errorMessage The message to be provided to the exception.
 */


function assertStringIfDefAndNotNull(value, errorMessage) {
  if (_metal.core.isDefAndNotNull(value) && !_metal.core.isString(value)) {
    throw new Error(errorMessage);
  }
}

exports.default = AuthProvider;

/***/ }),
/* 12 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/* jshint ignore:start */

/**
 * Abstract interface for storing and retrieving data using some persistence
 * mechanism.
 * @constructor
 */

Object.defineProperty(exports, "__esModule", {
	value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var StorageMechanism = function () {
	function StorageMechanism() {
		_classCallCheck(this, StorageMechanism);
	}

	_createClass(StorageMechanism, [{
		key: 'clear',

		/**
   * Clear all items from the data storage.
   */
		value: function clear() {
			throw Error('Unimplemented abstract method');
		}

		/**
   * Sets an item in the data storage.
   * @param {string} key The key to set.
   * @param {*} value The value to serialize to a string and save.
   */

	}, {
		key: 'set',
		value: function set(key, value) {
			throw Error('Unimplemented abstract method');
		}

		/**
   * Gets an item from the data storage.
   * @param {string} key The key to get.
   * @return {*} Deserialized value or undefined if not found.
   */

	}, {
		key: 'get',
		value: function get(key) {
			throw Error('Unimplemented abstract method');
		}

		/**
   * Checks if this mechanism is supported in the current environment.
   * Subclasses should override this when necessary.
   */

	}, {
		key: 'keys',


		/**
   * Returns the list of keys stored in the Storage object.
   * @param {!Array<string>} keys
   */
		value: function keys() {
			throw Error('Unimplemented abstract method');
		}

		/**
   * Removes an item from the data storage.
   * @param {string} key The key to remove.
   */

	}, {
		key: 'remove',
		value: function remove(key) {
			throw Error('Unimplemented abstract method');
		}

		/**
   * Returns the number of data items stored in the Storage object.
   * @return {number}
   */

	}, {
		key: 'size',
		value: function size() {
			throw Error('Unimplemented abstract method');
		}
	}], [{
		key: 'isSupported',
		value: function isSupported() {
			return true;
		}
	}]);

	return StorageMechanism;
}();

exports.default = StorageMechanism;

/* jshint ignore:end */

/***/ }),
/* 13 */
/***/ (function(module, exports) {

// shim for using process in browser
var process = module.exports = {};

// cached from whatever global is present so that test runners that stub it
// don't break things.  But we need to wrap it in a try catch in case it is
// wrapped in strict mode code which doesn't define any globals.  It's inside a
// function because try/catches deoptimize in certain engines.

var cachedSetTimeout;
var cachedClearTimeout;

function defaultSetTimout() {
    throw new Error('setTimeout has not been defined');
}
function defaultClearTimeout () {
    throw new Error('clearTimeout has not been defined');
}
(function () {
    try {
        if (typeof setTimeout === 'function') {
            cachedSetTimeout = setTimeout;
        } else {
            cachedSetTimeout = defaultSetTimout;
        }
    } catch (e) {
        cachedSetTimeout = defaultSetTimout;
    }
    try {
        if (typeof clearTimeout === 'function') {
            cachedClearTimeout = clearTimeout;
        } else {
            cachedClearTimeout = defaultClearTimeout;
        }
    } catch (e) {
        cachedClearTimeout = defaultClearTimeout;
    }
} ())
function runTimeout(fun) {
    if (cachedSetTimeout === setTimeout) {
        //normal enviroments in sane situations
        return setTimeout(fun, 0);
    }
    // if setTimeout wasn't available but was latter defined
    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
        cachedSetTimeout = setTimeout;
        return setTimeout(fun, 0);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedSetTimeout(fun, 0);
    } catch(e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
            return cachedSetTimeout.call(null, fun, 0);
        } catch(e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
            return cachedSetTimeout.call(this, fun, 0);
        }
    }


}
function runClearTimeout(marker) {
    if (cachedClearTimeout === clearTimeout) {
        //normal enviroments in sane situations
        return clearTimeout(marker);
    }
    // if clearTimeout wasn't available but was latter defined
    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
        cachedClearTimeout = clearTimeout;
        return clearTimeout(marker);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedClearTimeout(marker);
    } catch (e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
            return cachedClearTimeout.call(null, marker);
        } catch (e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
            // Some versions of I.E. have different rules for clearTimeout vs setTimeout
            return cachedClearTimeout.call(this, marker);
        }
    }



}
var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;

function cleanUpNextTick() {
    if (!draining || !currentQueue) {
        return;
    }
    draining = false;
    if (currentQueue.length) {
        queue = currentQueue.concat(queue);
    } else {
        queueIndex = -1;
    }
    if (queue.length) {
        drainQueue();
    }
}

function drainQueue() {
    if (draining) {
        return;
    }
    var timeout = runTimeout(cleanUpNextTick);
    draining = true;

    var len = queue.length;
    while(len) {
        currentQueue = queue;
        queue = [];
        while (++queueIndex < len) {
            if (currentQueue) {
                currentQueue[queueIndex].run();
            }
        }
        queueIndex = -1;
        len = queue.length;
    }
    currentQueue = null;
    draining = false;
    runClearTimeout(timeout);
}

process.nextTick = function (fun) {
    var args = new Array(arguments.length - 1);
    if (arguments.length > 1) {
        for (var i = 1; i < arguments.length; i++) {
            args[i - 1] = arguments[i];
        }
    }
    queue.push(new Item(fun, args));
    if (queue.length === 1 && !draining) {
        runTimeout(drainQueue);
    }
};

// v8 likes predictible objects
function Item(fun, array) {
    this.fun = fun;
    this.array = array;
}
Item.prototype.run = function () {
    this.fun.apply(null, this.array);
};
process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];
process.version = ''; // empty string to avoid regexp issues
process.versions = {};

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;
process.prependListener = noop;
process.prependOnceListener = noop;

process.listeners = function (name) { return [] }

process.binding = function (name) {
    throw new Error('process.binding is not supported');
};

process.cwd = function () { return '/' };
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};
process.umask = function() { return 0; };


/***/ }),
/* 14 */
/***/ (function(module, exports) {

var g;

// This works in non-strict mode
g = (function() {
	return this;
})();

try {
	// This works if eval is allowed (see CSP)
	g = g || Function("return this")() || (1,eval)("this");
} catch(e) {
	// This works if the window reference is available
	if(typeof window === "object")
		g = window;
}

// g can still be undefined, but nothing to do about it...
// We return undefined, instead of nothing here, so it's
// easier to handle this case. if(!global) { ...}

module.exports = g;


/***/ }),
/* 15 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _Embodied6 = __webpack_require__(1);

var _Embodied7 = _interopRequireDefault(_Embodied6);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * Class responsible for building different types of geometric
 * shapes.
 */
var Geo = function () {
  function Geo() {
    _classCallCheck(this, Geo);
  }

  _createClass(Geo, null, [{
    key: 'boundingBox',

    /**
    * Creates a new {@link BoundingBox} instance.
    * @param {*} upperLeft The upper left point.
    * @param {*} lowerRight The lower right point.
    * @return {!BoundingBox}
    * @static
    */
    value: function boundingBox(upperLeft, lowerRight) {
      return new Geo.BoundingBox(upperLeft, lowerRight);
    }

    /**
    * Creates a new {@link Circle} instance.
    * @param {*} center The circle's center coordinate.
    * @param {string} radius The circle's radius.
    * @return {!Circle}
    * @static
    */

  }, {
    key: 'circle',
    value: function circle(center, radius) {
      return new Geo.Circle(center, radius);
    }

    /**
    * Creates a new {@link Line} instance.
    * @param {...*} points This line's points.
    * @return {!Line}
    * @static
    */

  }, {
    key: 'line',
    value: function line() {
      for (var _len = arguments.length, points = Array(_len), _key = 0; _key < _len; _key++) {
        points[_key] = arguments[_key];
      }

      return new (Function.prototype.bind.apply(Geo.Line, [null].concat(points)))();
    }

    /**
    * Creates a new {@link Point} instance.
    * @param {number} lat The latitude coordinate
    * @param {number} lon The longitude coordinate
    * @return {!Point}
    * @static
    */

  }, {
    key: 'point',
    value: function point(lat, lon) {
      return new Geo.Point(lat, lon);
    }

    /**
    * Creates a new {@link Polygon} instance.
    * @param {...*} points This polygon's points.
    * @return {!Polygon}
    * @static
    */

  }, {
    key: 'polygon',
    value: function polygon() {
      for (var _len2 = arguments.length, points = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
        points[_key2] = arguments[_key2];
      }

      return new (Function.prototype.bind.apply(Geo.Polygon, [null].concat(points)))();
    }
  }]);

  return Geo;
}();

/**
 * Class that represents a point coordinate.
 * @extends {Embodied}
 */


var Point = function (_Embodied) {
  _inherits(Point, _Embodied);

  /**
  * Constructs a {@link Point} instance.
  * @param {number} lat The latitude coordinate
  * @param {number} lon The longitude coordinate
  * @constructor
  */
  function Point(lat, lon) {
    _classCallCheck(this, Point);

    var _this = _possibleConstructorReturn(this, (Point.__proto__ || Object.getPrototypeOf(Point)).call(this));

    _this.body_ = [lat, lon];
    return _this;
  }

  return Point;
}(_Embodied7.default);

Geo.Point = Point;

/**
 * Class that represents a line.
 * @extends {Embodied}
 */

var Line = function (_Embodied2) {
  _inherits(Line, _Embodied2);

  /**
  * Constructs a {@link Line} instance.
  * @param {...*} points This line's points.
  * @constructor
  */
  function Line() {
    _classCallCheck(this, Line);

    var _this2 = _possibleConstructorReturn(this, (Line.__proto__ || Object.getPrototypeOf(Line)).call(this));

    for (var _len3 = arguments.length, points = Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
      points[_key3] = arguments[_key3];
    }

    _this2.body_ = {
      type: 'linestring',
      coordinates: points.map(function (point) {
        return _Embodied7.default.toBody(point);
      })
    };
    return _this2;
  }

  return Line;
}(_Embodied7.default);

Geo.Line = Line;

/**
 * Class that represents a bounding box.
 * @extends {Embodied}
 */

var BoundingBox = function (_Embodied3) {
  _inherits(BoundingBox, _Embodied3);

  /**
  * Constructs a {@link BoundingBox} instance.
  * @param {*} upperLeft The upper left point.
  * @param {*} lowerRight The lower right point.
  * @constructor
  */
  function BoundingBox(upperLeft, lowerRight) {
    _classCallCheck(this, BoundingBox);

    var _this3 = _possibleConstructorReturn(this, (BoundingBox.__proto__ || Object.getPrototypeOf(BoundingBox)).call(this));

    _this3.body_ = {
      type: 'envelope',
      coordinates: [_Embodied7.default.toBody(upperLeft), _Embodied7.default.toBody(lowerRight)]
    };
    return _this3;
  }

  /**
  * Gets this bounding box's points.
  * @return {!Array}
  */


  _createClass(BoundingBox, [{
    key: 'getPoints',
    value: function getPoints() {
      return this.body_.coordinates;
    }
  }]);

  return BoundingBox;
}(_Embodied7.default);

Geo.BoundingBox = BoundingBox;

/**
 * Class that represents a circle.
 * @extends {Embodied}
 */

var Circle = function (_Embodied4) {
  _inherits(Circle, _Embodied4);

  /**
  * Constructs a {@link Circle} instance.
  * @param {*} center The circle's center coordinate.
  * @param {string} radius The circle's radius.
  * @constructor
  */
  function Circle(center, radius) {
    _classCallCheck(this, Circle);

    var _this4 = _possibleConstructorReturn(this, (Circle.__proto__ || Object.getPrototypeOf(Circle)).call(this));

    _this4.body_ = {
      type: 'circle',
      coordinates: _Embodied7.default.toBody(center),
      radius: radius
    };
    return _this4;
  }

  /**
  * Gets this circle's center coordinate.
  * @return {*}
  */


  _createClass(Circle, [{
    key: 'getCenter',
    value: function getCenter() {
      return this.body_.coordinates;
    }

    /**
    * Gets this circle's radius.
    * @return {string}
    */

  }, {
    key: 'getRadius',
    value: function getRadius() {
      return this.body_.radius;
    }
  }]);

  return Circle;
}(_Embodied7.default);

Geo.Circle = Circle;

/**
 * Class that represents a polygon.
 * @extends {Embodied}
 */

var Polygon = function (_Embodied5) {
  _inherits(Polygon, _Embodied5);

  /**
  * Constructs a {@link Polygon} instance.
  * @param {...*} points This polygon's points.
  * @constructor
  */
  function Polygon() {
    _classCallCheck(this, Polygon);

    var _this5 = _possibleConstructorReturn(this, (Polygon.__proto__ || Object.getPrototypeOf(Polygon)).call(this));

    _this5.body_ = {
      type: 'polygon',
      coordinates: []
    };
    _this5.addCoordinates_.apply(_this5, arguments);
    return _this5;
  }

  /**
  * Adds the given points as coordinates for this polygon.
  * @param {...*} points
  * @protected
  */


  _createClass(Polygon, [{
    key: 'addCoordinates_',
    value: function addCoordinates_() {
      for (var _len4 = arguments.length, points = Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {
        points[_key4] = arguments[_key4];
      }

      this.body_.coordinates.push(points.map(function (point) {
        return _Embodied7.default.toBody(point);
      }));
    }

    /**
    * Adds the given points as a hole inside this polygon.
    * @param {...*} points
    * @return {Polygon} Returns the {@link Polygon} object itself, so calls can
    *   be chained.
    * @chainable
    */

  }, {
    key: 'hole',
    value: function hole() {
      this.addCoordinates_.apply(this, arguments);
      return this;
    }
  }]);

  return Polygon;
}(_Embodied7.default);

Geo.Polygon = Polygon;

exports.default = Geo;

/***/ }),
/* 16 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _metal = __webpack_require__(0);

var _metalStructs = __webpack_require__(2);

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * Represents a client message (e.g. a request or a response).
 */
var ClientMessage = function () {
  /**
  * Constructs an {@link ClientMessage} instance.
  * @constructor
  */
  function ClientMessage() {
    _classCallCheck(this, ClientMessage);

    this.headers_ = new _metalStructs.MultiMap();
  }

  /**
  * Fluent getter and setter for request body.
  * @param {*=} opt_body Request body to be set. If none is given,
  *   the current value of the body will be returned.
  * @return {*} Returns request body if no body value was given. Otherwise
  *   returns the {@link ClientMessage} object itself, so calls can be chained.
  * @chainable Chainable when used as setter.
  */


  _createClass(ClientMessage, [{
    key: 'body',
    value: function body(opt_body) {
      if (_metal.core.isDef(opt_body)) {
        this.body_ = opt_body;
        return this;
      }
      return this.body_;
    }

    /**
    * Adds a header. If a header with the same name already exists, it will not
    * be overwritten, but the new value will be stored as well. The order is
    * preserved.
    * @param {string} name
    * @param {string} value
    * @return {!ClientMessage} Returns the {@link ClientMessage}
    *   object itself, so calls can be chained.
    * @chainable
    */

  }, {
    key: 'header',
    value: function header(name, value) {
      if (arguments.length !== 2) {
        throw new Error('Invalid arguments');
      }
      this.headers_.set(name, value);
      return this;
    }

    /**
    * Fluent getter and setter for request headers.
    * @param {MultiMap|Object=} opt_headers Request headers list to
    *   be set. If none is given the current value of the headers will
    *   be returned.
    * @return {!MultiMap|ClientMessage} Returns map of request headers
    *   if no new value was given. Otherwise returns the {@link ClientMessage}
    *   object itself, so calls can be chained.
    * @chainable Chainable when used as setter.
    */

  }, {
    key: 'headers',
    value: function headers(opt_headers) {
      if (_metal.core.isDef(opt_headers)) {
        if (opt_headers instanceof _metalStructs.MultiMap) {
          this.headers_ = opt_headers;
        } else {
          this.headers_.values = opt_headers;
        }
        return opt_headers;
      }
      return this.headers_;
    }

    /**
    * Removes the body.
    */

  }, {
    key: 'removeBody',
    value: function removeBody() {
      this.body_ = undefined;
    }
  }]);

  return ClientMessage;
}();

exports.default = ClientMessage;

/***/ }),
/* 17 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


// This file exists just for backwards compatibility, making sure that old
// default imports for this file still work. It's best to use the named exports
// for each function instead though, since that allows bundlers like Rollup to
// reduce the bundle size by removing unused code.

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.core = undefined;

var _coreNamed = __webpack_require__(50);

Object.keys(_coreNamed).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function get() {
      return _coreNamed[key];
    }
  });
});

var core = _interopRequireWildcard(_coreNamed);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

exports.default = core;
exports.core = core;

/***/ }),
/* 18 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _globals = __webpack_require__(5);

var _globals2 = _interopRequireDefault(_globals);

var _metal = __webpack_require__(0);

var _Auth = __webpack_require__(10);

var _Auth2 = _interopRequireDefault(_Auth);

var _AuthApiHelper = __webpack_require__(25);

var _AuthApiHelper2 = _interopRequireDefault(_AuthApiHelper);

var _DataApiHelper = __webpack_require__(30);

var _DataApiHelper2 = _interopRequireDefault(_DataApiHelper);

var _EmailApiHelper = __webpack_require__(31);

var _EmailApiHelper2 = _interopRequireDefault(_EmailApiHelper);

var _Base = __webpack_require__(32);

var _Base2 = _interopRequireDefault(_Base);

var _Embodied = __webpack_require__(1);

var _Embodied2 = _interopRequireDefault(_Embodied);

var _Query = __webpack_require__(7);

var _Query2 = _interopRequireDefault(_Query);

var _Filter = __webpack_require__(4);

var _Filter2 = _interopRequireDefault(_Filter);

var _TransportFactory = __webpack_require__(24);

var _TransportFactory2 = _interopRequireDefault(_TransportFactory);

var _ClientRequest = __webpack_require__(21);

var _ClientRequest2 = _interopRequireDefault(_ClientRequest);

var _metalStructs = __webpack_require__(2);

var _metalUri = __webpack_require__(6);

var _metalUri2 = _interopRequireDefault(_metalUri);

var _assertions = __webpack_require__(3);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var io = void 0;
var FormDataImpl = void 0;

// Optimistic initialization of `io` reference from global `globals.window.io`.
if (typeof _globals2.default.window !== 'undefined') {
  io = _globals2.default.window.io;
}

// Optimistic initialization of `FormData` reference from global
// `globals.window.FormData`.
if (typeof _globals2.default.window !== 'undefined') {
  FormDataImpl = _globals2.default.window.FormData;
}

/**
 * The main class for making api requests. Sending requests returns a promise
 * that is resolved when the response arrives. Usage example:
 * ```javascript
 * WeDeploy
 *   .url('/data/tasks')
 *   .post({desc: 'Buy milk'})
 *   .then(function(response) {
 *     // Handle response here.
 *     console.log(response.body())
 *   });
 * ```
 */

var WeDeploy = function () {
  /**
  * WeDeploy constructor function.
  * @param {string} url The base url.
  * @param {...string} paths Any amount of paths to be appended to the base
  * url.
  * @constructor
  */
  function WeDeploy(url) {
    for (var _len = arguments.length, paths = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
      paths[_key - 1] = arguments[_key];
    }

    _classCallCheck(this, WeDeploy);

    if (arguments.length === 0) {
      throw new Error('Invalid arguments, try `new WeDeploy(baseUrl, url)`');
    }

    this.auth_ = null;
    this.data_ = null;
    this.body_ = null;
    this.url_ = _metalUri2.default.joinPaths.apply(_metalUri2.default, [url || ''].concat(paths));
    this.headers_ = new _metalStructs.MultiMap();
    this.params_ = new _metalStructs.MultiMap();
    this.withCredentials_ = true;

    this.header('Content-Type', 'application/json');
    this.header('X-Requested-With', 'XMLHttpRequest');
  }

  /**
  * Static factory for creating WeDeploy data for the given url.
  * @param {string=} opt_dataUrl The url that points to the data services.
  * @return {data} WeDeploy data instance.
  */


  _createClass(WeDeploy, [{
    key: 'auth',


    /**
    * Adds authorization information to this request.
    * @param {!Auth|string} authOrTokenOrEmail Either an {@link Auth} instance,
    * an authorization token, or the email.
    * @param {string=} opt_password If a email is given as the first param,
    * this should be the password.
    * @return {WeDeploy} Returns the {@link WeDeploy} object itself, so calls can
    *   be chained.
    * @chainable
    */
    value: function auth(authOrTokenOrEmail, opt_password) {
      this.auth_ = _Auth2.default.create(authOrTokenOrEmail, opt_password);
      this.auth_.setWedeployClient(WeDeploy);
      return this;
    }

    /**
    * Static factory for creating WeDeploy auth for the given url.
    * @param {string=} opt_authUrl The url that points to the auth service.
    * @return {!Auth} Returns an {@link Auth} instance.
    */

  }, {
    key: 'body',


    /**
    * Sets the body that will be sent with this request.
    * @param {*} body
    * @return {WeDeploy} Returns the {@link WeDeploy} object itself, so calls can
    *   be chained.
    * @chainable
    */
    value: function body(_body) {
      this.body_ = _body;
      return this;
    }

    /**
    * Converts the given body object to query params.
    * @param {!ClientRequest} clientRequest Client request.
    * @param {*} body
    * @protected
    */

  }, {
    key: 'convertBodyToParams_',
    value: function convertBodyToParams_(clientRequest, body) {
      if (_metal.core.isString(body)) {
        body = {
          body: body
        };
      } else if (body instanceof _Embodied2.default) {
        body = body.body();
      }
      Object.keys(body || {}).forEach(function (name) {
        return clientRequest.param(name, body[name]);
      });
    }

    /**
    * Creates client request and encode.
    * @param {string} method
    * @param {*} body
    * @return {!ClientRequest} Client request.
    * @protected
    */

  }, {
    key: 'createClientRequest_',
    value: function createClientRequest_(method, body) {
      var clientRequest = new _ClientRequest2.default();

      clientRequest.body(body || this.body_);

      if (!_metal.core.isDefAndNotNull(clientRequest.body())) {
        if (this.formData_) {
          clientRequest.body(this.formData_);
        }
      }

      clientRequest.method(method);
      clientRequest.headers(this.headers());
      clientRequest.params(this.params());
      clientRequest.url(this.url());
      clientRequest.withCredentials(this.withCredentials_);

      this.encode(clientRequest);

      return clientRequest;
    }

    /**
    * Decodes clientResponse body, parsing the body for example.
    * @param {!ClientResponse} clientResponse The response object to be
    * decoded.
    * @return {!ClientResponse} The decoded response.
    */

  }, {
    key: 'decode',
    value: function decode(clientResponse) {
      if (WeDeploy.isContentTypeJson(clientResponse)) {
        try {
          clientResponse.body(JSON.parse(clientResponse.body()));
        } catch (err) {}
      }
      return clientResponse;
    }

    /**
    * Sends message with the DELETE http verb.
    * @param {string=} opt_body Content to be sent as the request's body.
    * @return {!CancellablePromise}
    */

  }, {
    key: 'delete',
    value: function _delete(opt_body) {
      return this.sendAsync('DELETE', opt_body);
    }

    /**
    * Encodes the given {@link ClientRequest}, converting its body to an
    * appropriate format for example.
    * @param {!ClientRequest} clientRequest The request object to encode.
    * @return {!ClientRequest} The encoded request.
    */

  }, {
    key: 'encode',
    value: function encode(clientRequest) {
      var body = clientRequest.body();

      if (_metal.core.isElement(body)) {
        body = new FormDataImpl(body);
        clientRequest.body(body);
      }

      body = this.maybeWrapWithQuery_(body);
      if (clientRequest.method() === 'GET') {
        this.convertBodyToParams_(clientRequest, body);
        clientRequest.removeBody();
        body = null;
      }

      if (typeof FormDataImpl !== 'undefined' && body instanceof FormDataImpl) {
        clientRequest.headers().remove('content-type');
      } else if (body instanceof _Embodied2.default) {
        clientRequest.body(body.toString());
      } else if (WeDeploy.isContentTypeJson(clientRequest)) {
        var _body2 = clientRequest.body();
        if (_metal.core.isDefAndNotNull(_body2)) {
          _body2 = JSON.stringify(_body2);
          clientRequest.body(_body2);
        }
      }

      this.encodeParams_(clientRequest);
      this.resolveAuthentication_(clientRequest);

      return clientRequest;
    }

    /**
    * Encodes the params for the given request, according to their types.
    * @param {!ClientRequest} clientRequest
    * @protected
    */

  }, {
    key: 'encodeParams_',
    value: function encodeParams_(clientRequest) {
      var params = clientRequest.params();
      params.names().forEach(function (name) {
        var values = params.getAll(name);
        values.forEach(function (value, index) {
          if (value instanceof _Embodied2.default) {
            value = value.toString();
          } else if (_metal.core.isObject(value) || value instanceof Array) {
            value = JSON.stringify(value);
          }
          values[index] = value;
        });
      });
    }

    /**
    * Adds a key/value pair to be sent via the body in a `multipart/form-data`
    * format.
    * If the body is set by other means (for example, through the `body` method),
    * this will be ignored.
    * @param {string} name
    * @param {*} value
    * @return {WeDeploy} Returns the {@link WeDeploy} object itself, so calls can
    *   be chained.
    * @chainable
    */

  }, {
    key: 'form',
    value: function form(name, value) {
      if (typeof FormDataImpl === 'undefined') {
        throw new Error('form() is only available when FormData API is available.');
      }

      if (!this.formData_) {
        this.formData_ = new FormDataImpl();
      }
      this.formData_.append(name, value);
      return this;
    }

    /**
    * Sends message with the GET http verb.
    * @param {*=} opt_params Params to be added to the request url.
    * @return {!CancellablePromise}
    */

  }, {
    key: 'get',
    value: function get(opt_params) {
      return this.sendAsync('GET', opt_params);
    }

    /**
    * Adds a header. If the header with the same name already exists, it will
    * not be overwritten, but new value will be stored. The order is preserved.
    * @param {string} name Header key.
    * @param {*} value Header value.
    * @return {WeDeploy} Returns the {@link WeDeploy} object itself, so calls can
    *   be chained.
    * @chainable
    */

  }, {
    key: 'header',
    value: function header(name, value) {
      if (arguments.length !== 2) {
        throw new Error('Invalid arguments');
      }
      this.headers_.set(name, value);
      return this;
    }

    /**
    * Gets or sets the headers. If headers are passed to the function as
     * parameter, they will be set as internal headers, overwriting the existing
     * ones. Otherwise, the currently set headers will be returned.
     * @param {MultiMap|Object=} opt_headers Headers to be set
    * @return {WeDeploy|MultiMap} If headers were passed to te function,
     *   the returned result will be the {@link WeDeploy} object itself, so calls
     *   can be chained. If headers were not passed to the function, the returned
     *   result will be the current headers.
     * @chainable Chainable when used as setter.
     */

  }, {
    key: 'headers',
    value: function headers(opt_headers) {
      var _this = this;

      if (_metal.core.isDefAndNotNull(opt_headers)) {
        if (!(opt_headers instanceof _metalStructs.MultiMap)) {
          opt_headers = _metalStructs.MultiMap.fromObject(opt_headers);
        }

        opt_headers.names().forEach(function (name) {
          var values = opt_headers.getAll(name);

          values.forEach(function (value) {
            _this.headers_.set(name, value);
          });
        });

        return this;
      } else {
        return this.headers_;
      }
    }

    /**
    * Check if clientMessage content type is application/json.
    * @param {ClientMessage} clientMessage Client message.
    * @return {boolean}
    */

  }, {
    key: 'maybeWrapWithQuery_',


    /**
    * Wraps the given `Embodied` instance with a {@link Query} instance if
    * needed.
    * @param {Embodied} embodied
    * @return {Embodied}
    * @protected
    */
    value: function maybeWrapWithQuery_(embodied) {
      if (embodied instanceof _Filter2.default) {
        embodied = _Query2.default.filter(embodied);
      }
      return embodied;
    }

    /**
    * Adds a query. If the query with the same name already exists, it will not
    * be overwritten, but new value will be stored. The order is preserved.
    * @param {string} name Param key.
    * @param {*} value Param value.
    * @return {WeDeploy} Returns the {@link WeDeploy} object itself, so calls can
    *   be chained.
    * @chainable
    */

  }, {
    key: 'param',
    value: function param(name, value) {
      if (arguments.length !== 2) {
        throw new Error('Invalid arguments');
      }
      this.params_.set(name, value);
      return this;
    }

    /**
    * Gets the query strings map.
    * @return {!MultiMap}
    */

  }, {
    key: 'params',
    value: function params() {
      return this.params_;
    }

    /**
    * Sends message with the PATCH http verb.
    * @param {string=} opt_body Content to be sent as the request's body.
    * @return {!CancellablePromise}
    */

  }, {
    key: 'patch',
    value: function patch(opt_body) {
      return this.sendAsync('PATCH', opt_body);
    }

    /**
    * Creates a new {@link WeDeploy} instance for handling the url resulting in
    * the union of the current url with the given paths.
    * @param {...string} paths Any number of paths.
    * @return {!WeDeploy} A new {@link WeDeploy} instance for handling the given
    *   paths.
    */

  }, {
    key: 'path',
    value: function path() {
      for (var _len2 = arguments.length, paths = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
        paths[_key2] = arguments[_key2];
      }

      var wedeployClient = new (Function.prototype.bind.apply(WeDeploy, [null].concat([this.url()], paths)))();

      if (_metal.core.isDefAndNotNull(this.auth_)) {
        wedeployClient.auth(this.auth_);
      }

      wedeployClient.headers(this.headers_);

      return wedeployClient.use(this.customTransport_);
    }

    /**
    * Sends message with the POST http verb.
    * @param {string=} opt_body Content to be sent as the request's body.
    * @return {!CancellablePromise}
    */

  }, {
    key: 'post',
    value: function post(opt_body) {
      return this.sendAsync('POST', opt_body);
    }

    /**
    * Sends message with the PUT http verb.
    * @param {string=} opt_body Content to be sent as the request's body.
    * @return {!CancellablePromise}
    */

  }, {
    key: 'put',
    value: function put(opt_body) {
      return this.sendAsync('PUT', opt_body);
    }

    /**
    * Adds the authentication information to the request.
    * @param {!ClientRequest} clientRequest
    * @protected
    */

  }, {
    key: 'resolveAuthentication_',
    value: function resolveAuthentication_(clientRequest) {
      if (!this.auth_) {
        return;
      }
      if (this.auth_.hasToken()) {
        clientRequest.header('Authorization', 'Bearer ' + this.auth_.token);
      } else if (this.auth_.hasEmail() && this.auth_.hasPassword()) {
        var credentials = this.auth_.email + ':' + this.auth_.password;
        clientRequest.header('Authorization', 'Basic ' + _Base2.default.encodeString(credentials));
      }
    }

    /**
    * Uses transport to send request with given method name and body
    * asynchronously.
    * @param {string} method The HTTP method to be used when sending data.
    * @param {string} body Content to be sent as the request's body.
    * @return {!CancellablePromise} Deferred request.
    */

  }, {
    key: 'sendAsync',
    value: function sendAsync(method, body) {
      var transport = this.customTransport_ || _TransportFactory2.default.instance().getDefault();

      var clientRequest = this.createClientRequest_(method, body);

      return transport.send(clientRequest).then(this.decode);
    }

    /**
    * Sets the socket transport
    * @param {Object} socket implementation object.
    */

  }, {
    key: 'url',


    /**
    * Returns the URL used by this client.
    * @return {!string}
    */
    value: function url() {
      return this.url_;
    }

    /**
    * Specifies {@link Transport} implementation.
    * @param {!Transport} transport The transport implementation that should be
    * used.
    * @return {WeDeploy} Returns the {@link WeDeploy} object itself, so calls can
    *   be chained.
    */

  }, {
    key: 'use',
    value: function use(transport) {
      this.customTransport_ = transport;
      return this;
    }

    /**
    * Creates new socket.io instance. The parameters passed to socket.io
    * constructor will be provided:
    *
    * ```javascript
    * WeDeploy.url('http://domain:8080/path/a').watch({id: 'myId'}, {foo: true});
    * // Equals:
    * io('domain:8080/?url=path%2Fa%3Fid%3DmyId', {foo: true});
    * ```
    *
    * @param {Object=} opt_params Params to be sent with the Socket IO request.
    * @param {Object=} opt_options Object with Socket IO options.
    * @return {!io} Socket IO reference. Server events can be listened on it.
    */

  }, {
    key: 'watch',
    value: function watch(opt_params, opt_options) {
      if (typeof io === 'undefined') {
        throw new Error('Socket.io client not loaded');
      }

      var clientRequest = this.createClientRequest_('GET', opt_params);
      var uri = new _metalUri2.default(clientRequest.url());
      uri.addParametersFromMultiMap(clientRequest.params());

      var jsonp = typeof navigator === 'undefined' || navigator.product !== 'ReactNative';

      opt_options = opt_options || {
        forceNew: true,
        jsonp: jsonp
      };
      opt_options.query = 'url=' + encodeURIComponent(uri.getPathname() + uri.getSearch());
      opt_options.path = opt_options.path || uri.getPathname();
      opt_options = this.resolveTransportOptions_(opt_options);

      return io(uri.getProtocol() + '//' + uri.getHost(), opt_options);
    }

    /**
     * Resolves the polling options object by adding Authorization header if the
     *   current auth object has token, or it has both email and password.
     * @param {!Object} options The object where transport options should be added
     * @return {Object} Returns the modified options object
     */

  }, {
    key: 'resolveTransportOptions_',
    value: function resolveTransportOptions_(options) {
      if (!this.auth_) {
        return options;
      }

      if (this.auth_.hasToken()) {
        options.transportOptions = {
          polling: {
            extraHeaders: {
              Authorization: 'Bearer ' + this.auth_.getToken()
            }
          }
        };
      } else if (this.auth_.hasEmail() && this.auth_.hasPassword()) {
        var credentials = this.auth_.getEmail() + ':' + this.auth_.getPassword();
        options.transportOptions = {
          polling: {
            extraHeaders: {
              Authorization: 'Basic ' + _Base2.default.encodeString(credentials)
            }
          }
        };
      }

      return options;
    }

    /**
    * Assigns the passed value to the internal with credentials option.
    * @param {boolean} withCredentials
    * @return {WeDeploy} Returns the {@link WeDeploy} object itself, so calls can
    *   be chained.
    */

  }, {
    key: 'withCredentials',
    value: function withCredentials(_withCredentials) {
      this.withCredentials_ = !!_withCredentials;
      return this;
    }
  }], [{
    key: 'data',
    value: function data(opt_dataUrl) {
      (0, _assertions.assertUriWithNoPath)(opt_dataUrl, 'The data url should not have a path');

      if (_metal.core.isString(opt_dataUrl)) {
        WeDeploy.dataUrl_ = opt_dataUrl;
      }
      if (!WeDeploy.data_) {
        WeDeploy.data_ = new _DataApiHelper2.default(WeDeploy);
      }
      WeDeploy.data_.auth(WeDeploy.auth().currentUser);
      return WeDeploy.data_;
    }

    /**
    * Static factory for creating WeDeploy email for the given url.
    * @param {string=} opt_emailUrl The url that points to the email services.
    * @return {data} WeDeploy email instance.
    */

  }, {
    key: 'email',
    value: function email(opt_emailUrl) {
      (0, _assertions.assertUriWithNoPath)(opt_emailUrl, 'The email url should not have a path');

      if (_metal.core.isString(opt_emailUrl)) {
        WeDeploy.emailUrl_ = opt_emailUrl;
      }
      if (!WeDeploy.email_) {
        WeDeploy.email_ = new _EmailApiHelper2.default(WeDeploy);
      }
      WeDeploy.email_.auth(WeDeploy.auth().currentUser);
      return WeDeploy.email_;
    }
  }, {
    key: 'auth',
    value: function auth(opt_authUrl) {
      if (_metal.core.isString(opt_authUrl)) {
        WeDeploy.authUrl_ = opt_authUrl;
      }
      if (!WeDeploy.auth_) {
        WeDeploy.auth_ = new _AuthApiHelper2.default(WeDeploy);
      }
      return WeDeploy.auth_;
    }
  }, {
    key: 'isContentTypeJson',
    value: function isContentTypeJson(clientMessage) {
      var contentType = clientMessage.headers().get('content-type') || '';
      return contentType.indexOf('application/json') === 0;
    }
  }, {
    key: 'socket',
    value: function socket(_socket) {
      io = _socket;
    }

    /**
    * Sets the FormData
    * @param {Object} formData implementation object.
    */

  }, {
    key: 'formData',
    value: function formData(_formData) {
      FormDataImpl = _formData;
    }

    /**
    * Static factory for creating WeDeploy client for the given url.
    * @param {string} url The url that the client should use for sending
    *   requests.
    * @return {WeDeploy} Returns the {@link WeDeploy} object itself, so calls can
    *   be chained.
    */

  }, {
    key: 'url',
    value: function url(_url) {
      return new WeDeploy(_url).use(this.customTransport_);
    }
  }]);

  return WeDeploy;
}();

WeDeploy.auth_ = null;
WeDeploy.data_ = null;
WeDeploy.email_ = null;
WeDeploy.authUrl_ = '';
WeDeploy.dataUrl_ = '';
WeDeploy.emailUrl_ = '';

exports.default = WeDeploy;

/***/ }),
/* 19 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
		value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _Embodied = __webpack_require__(1);

var _Embodied2 = _interopRequireDefault(_Embodied);

var _Range = __webpack_require__(8);

var _Range2 = _interopRequireDefault(_Range);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * Class that represents a search aggregation.
 */
var Aggregation = function () {
		/**
  * Constructs an {@link Aggregation} instance.
  * @param {string} field The aggregation field.
  * @param {string} operator The aggregation operator.
  * @param {*=} opt_value The aggregation value.
  * @constructor
  */
		function Aggregation(field, operator, opt_value) {
				_classCallCheck(this, Aggregation);

				this.field_ = field;
				this.operator_ = operator;
				this.value_ = opt_value;
		}

		/**
  * Creates an {@link Aggregation} instance with the "avg" operator.
  * @param {string} field The aggregation field.
  * @return {!Aggregation}
  * @static
  */


		_createClass(Aggregation, [{
				key: 'getField',


				/**
    * Gets this aggregation's field.
    * @return {string}
    */
				value: function getField() {
						return this.field_;
				}

				/**
    * Gets this aggregation's operator.
    * @return {string}
    */

		}, {
				key: 'getOperator',
				value: function getOperator() {
						return this.operator_;
				}

				/**
    * Gets this aggregation's value.
    * @return {*}
    */

		}, {
				key: 'getValue',
				value: function getValue() {
						return this.value_;
				}

				/**
    * Creates an {@link Aggregation} instance with the "histogram" operator.
    * @param {string} field The aggregation field.
    * @param {number} interval The histogram's interval.
    * @return {!Aggregation}
    * @static
    */

		}], [{
				key: 'avg',
				value: function avg(field) {
						return Aggregation.field(field, 'avg');
				}

				/**
    * Creates an {@link Aggregation} instance with the "count" operator.
    * @param {string} field The aggregation field.
    * @return {!Aggregation}
    * @static
    */

		}, {
				key: 'count',
				value: function count(field) {
						return Aggregation.field(field, 'count');
				}

				/**
    * Creates an {@link DistanceAggregation} instance with the "geoDistance"
    * operator.
    * @param {string} field The aggregation field.
    * @param {*} location The aggregation location.
    * @param {...!Range} ranges The aggregation ranges.
    * @return {!DistanceAggregation}
    * @static
    */

		}, {
				key: 'distance',
				value: function distance(field, location) {
						for (var _len = arguments.length, ranges = Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {
								ranges[_key - 2] = arguments[_key];
						}

						return new (Function.prototype.bind.apply(Aggregation.DistanceAggregation, [null].concat([field, location], ranges)))();
				}

				/**
    * Creates an {@link Aggregation} instance with the "extendedStats" operator.
    * @param {string} field The aggregation field.
    * @return {!Aggregation}
    * @static
    */

		}, {
				key: 'extendedStats',
				value: function extendedStats(field) {
						return Aggregation.field(field, 'extendedStats');
				}
		}, {
				key: 'histogram',
				value: function histogram(field, interval) {
						return new Aggregation(field, 'histogram', interval);
				}

				/**
    * Creates an {@link Aggregation} instance with the "max" operator.
    * @param {string} field The aggregation field.
    * @return {!Aggregation}
    * @static
    */

		}, {
				key: 'max',
				value: function max(field) {
						return Aggregation.field(field, 'max');
				}

				/**
    * Creates an {@link Aggregation} instance with the "min" operator.
    * @param {string} field The aggregation field.
    * @return {!Aggregation}
    * @static
    */

		}, {
				key: 'min',
				value: function min(field) {
						return Aggregation.field(field, 'min');
				}

				/**
    * Creates an {@link Aggregation} instance with the "missing" operator.
    * @param {string} field The aggregation field.
    * @return {!Aggregation}
    * @static
    */

		}, {
				key: 'missing',
				value: function missing(field) {
						return Aggregation.field(field, 'missing');
				}

				/**
    * Creates a new {@link Aggregation} instance.
    * @param {string} field The aggregation field.
    * @param {string} operator The aggregation operator.
    * @return {!Aggregation}
    * @static
    */

		}, {
				key: 'field',
				value: function field(_field, operator) {
						return new Aggregation(_field, operator);
				}

				/**
    * Creates an {@link RangeAggregation} instance with the "range" operator.
    * @param {string} field The aggregation field.
    * @param {...!Range} ranges The aggregation ranges.
    * @return {!RangeAggregation}
    * @static
    */

		}, {
				key: 'range',
				value: function range(field) {
						for (var _len2 = arguments.length, ranges = Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
								ranges[_key2 - 1] = arguments[_key2];
						}

						return new (Function.prototype.bind.apply(Aggregation.RangeAggregation, [null].concat([field], ranges)))();
				}

				/**
    * Creates an {@link Aggregation} instance with the "stats" operator.
    * @param {string} field The aggregation field.
    * @return {!Aggregation}
    * @static
    */

		}, {
				key: 'stats',
				value: function stats(field) {
						return Aggregation.field(field, 'stats');
				}

				/**
    * Creates an {@link Aggregation} instance with the "sum" operator.
    * @param {string} field The aggregation field.
    * @return {!Aggregation}
    * @static
    */

		}, {
				key: 'sum',
				value: function sum(field) {
						return Aggregation.field(field, 'sum');
				}

				/**
    * Creates an {@link Aggregation} instance with the "terms" operator.
    * @param {string} field The aggregation field.
    * @return {!Aggregation}
    * @static
    */

		}, {
				key: 'terms',
				value: function terms(field) {
						return Aggregation.field(field, 'terms');
				}
		}]);

		return Aggregation;
}();

/**
 * Class that represents a distance aggregation.
 * @extends {Aggregation}
 */


var DistanceAggregation = function (_Aggregation) {
		_inherits(DistanceAggregation, _Aggregation);

		/**
  * Constructs an {@link DistanceAggregation} instance.
  * @param {string} field The aggregation field.
  * @param {*} location The aggregation location.
  * @param {...!Range} ranges The aggregation ranges.
  * @constructor
  */
		function DistanceAggregation(field, location) {
				_classCallCheck(this, DistanceAggregation);

				var _this = _possibleConstructorReturn(this, (DistanceAggregation.__proto__ || Object.getPrototypeOf(DistanceAggregation)).call(this, field, 'geoDistance', {}));

				_this.value_.location = _Embodied2.default.toBody(location);

				for (var _len3 = arguments.length, ranges = Array(_len3 > 2 ? _len3 - 2 : 0), _key3 = 2; _key3 < _len3; _key3++) {
						ranges[_key3 - 2] = arguments[_key3];
				}

				_this.value_.ranges = ranges.map(function (range) {
						return range.body();
				});
				return _this;
		}

		/**
  * Adds a range to this aggregation.
  * @param {*} rangeOrFrom
  * @param {*=} opt_to
  * @return {Aggregation} Returns the {@link Aggregation} object itself, so
  *   calls can be chained.
  * @chainable
  */


		_createClass(DistanceAggregation, [{
				key: 'range',
				value: function range(rangeOrFrom, opt_to) {
						var range = rangeOrFrom;
						if (!(range instanceof _Range2.default)) {
								range = _Range2.default.range(rangeOrFrom, opt_to);
						}
						this.value_.ranges.push(range.body());
						return this;
				}

				/**
    * Sets this aggregation's unit.
    * @param {string} unit
    * @return {Aggregation} Returns the {@link Aggregation} object itself, so
    *   calls can be chained.
    * @chainable
    */

		}, {
				key: 'unit',
				value: function unit(_unit) {
						this.value_.unit = _unit;
						return this;
				}
		}]);

		return DistanceAggregation;
}(Aggregation);

Aggregation.DistanceAggregation = DistanceAggregation;

/**
 * Class that represents a range aggregation.
 * @extends {Aggregation}
 */

var RangeAggregation = function (_Aggregation2) {
		_inherits(RangeAggregation, _Aggregation2);

		/**
  * Constructs an {@link RangeAggregation} instance.
  * @param {string} field The aggregation field.
  * @param {...!Range} ranges The aggregation ranges.
  * @constructor
  */
		function RangeAggregation(field) {
				_classCallCheck(this, RangeAggregation);

				var _this2 = _possibleConstructorReturn(this, (RangeAggregation.__proto__ || Object.getPrototypeOf(RangeAggregation)).call(this, field, 'range'));

				for (var _len4 = arguments.length, ranges = Array(_len4 > 1 ? _len4 - 1 : 0), _key4 = 1; _key4 < _len4; _key4++) {
						ranges[_key4 - 1] = arguments[_key4];
				}

				_this2.value_ = ranges.map(function (range) {
						return range.body();
				});
				return _this2;
		}

		/**
  * Adds a range to this aggregation.
  * @param {*} rangeOrFrom
  * @param {*=} opt_to
  * @return {Aggregation} Returns the {@link Aggregation} object itself, so
  *   calls can be chained.
  * @chainable
  */


		_createClass(RangeAggregation, [{
				key: 'range',
				value: function range(rangeOrFrom, opt_to) {
						var range = rangeOrFrom;
						if (!(range instanceof _Range2.default)) {
								range = _Range2.default.range(rangeOrFrom, opt_to);
						}
						this.value_.push(range.body());
						return this;
				}
		}]);

		return RangeAggregation;
}(Aggregation);

Aggregation.RangeAggregation = RangeAggregation;

exports.default = Aggregation;

/***/ }),
/* 20 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _metal = __webpack_require__(0);

var _Embodied = __webpack_require__(1);

var _Embodied2 = _interopRequireDefault(_Embodied);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * Class responsible for storing and handling the body contents
 * of a Filter instance.
 */
var FilterBody = function () {
  /**
  * Constructs a {@link FilterBody} instance.
  * @param {string} field The name of the field to filter by.
  * @param {*} operatorOrValue If a third param is given, this should
  *   be the filter's operator (like ">="). Otherwise, this will be
  *   used as the filter's value, and the filter's operator will be "=".
  * @param {*=} opt_value The filter's value.
  * @constructor
  */
  function FilterBody(field, operatorOrValue, opt_value) {
    _classCallCheck(this, FilterBody);

    var obj = {
      operator: _metal.core.isDef(opt_value) ? operatorOrValue : '='
    };

    var value = _metal.core.isDef(opt_value) ? opt_value : operatorOrValue;

    if (_metal.core.isDefAndNotNull(value)) {
      if (value instanceof _Embodied2.default) {
        value = value.body();
      }
      obj.value = value;
    }

    if (_metal.core.isDefAndNotNull(field)) {
      this.createBody_(field, obj);
    } else {
      this.createBody_('and', []);
    }
  }

  /**
  * Composes the current filter with the given operator.
  * @param {string} operator
  * @param {Filter=} opt_filter Another filter to compose this filter with,
  *   if the operator is not unary.
  */


  _createClass(FilterBody, [{
    key: 'add',
    value: function add(operator, opt_filter) {
      if (opt_filter) {
        this.addArrayOperator_(operator, opt_filter);
      } else {
        this.createBody_(operator, this.body_);
      }
    }

    /**
    * Composes the current filter with an operator that stores its values in an
    * array.
    * @param {string} operator
    * @param {!Filter} filter
    * @protected
    */

  }, {
    key: 'addArrayOperator_',
    value: function addArrayOperator_(operator, filter) {
      if (!(this.body_[operator] instanceof Array)) {
        this.createBody_(operator, [this.body_]);
      }
      this.body_[operator].push(filter.body());
    }

    /**
    * Adds filters to be composed with this filter body using the given operator.
    * @param {string} operator
    * @param {...*} filters A variable amount of filters to be composed.
    */

  }, {
    key: 'addMany',
    value: function addMany(operator) {
      for (var _len = arguments.length, filters = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
        filters[_key - 1] = arguments[_key];
      }

      for (var i = 0; i < filters.length; i++) {
        this.add(operator, filters[i]);
      }
    }

    /**
    * Creates a new body object, setting the requested key to the given value.
    * @param {string} key The key to set in the new body object
    * @param {*} value The value the requested key should have in the new body
    *   object.
    * @protected
    */

  }, {
    key: 'createBody_',
    value: function createBody_(key, value) {
      this.body_ = {};
      this.body_[key] = value;
    }

    /**
    * Gets the json object that represents this filter's body.
    * @return {!Object}
    */

  }, {
    key: 'getObject',
    value: function getObject() {
      return this.body_;
    }
  }]);

  return FilterBody;
}();

exports.default = FilterBody;

/***/ }),
/* 21 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _metal = __webpack_require__(0);

var _ClientMessage2 = __webpack_require__(16);

var _ClientMessage3 = _interopRequireDefault(_ClientMessage2);

var _metalStructs = __webpack_require__(2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * Represents a client request object.
 * @extends {ClientMessage}
 */
var ClientRequest = function (_ClientMessage) {
  _inherits(ClientRequest, _ClientMessage);

  /**
  * Constructs an {@link ClientRequest} instance.
  * @constructor
  */
  function ClientRequest() {
    _classCallCheck(this, ClientRequest);

    var _this = _possibleConstructorReturn(this, (ClientRequest.__proto__ || Object.getPrototypeOf(ClientRequest)).call(this));

    _this.params_ = new _metalStructs.MultiMap();
    _this.withCredentials_ = true;
    return _this;
  }

  /**
  * Fluent getter and setter for with credentials option.
  * @param {boolean=} opt_withCredentials
  * @return {!ClientRequest|boolean} Returns the {@link ClientMessage} object
  *   itself when used as setter, otherwise returns the current value of with
  *   credentials option.
  * @chainable Chainable when used as setter.
  */


  _createClass(ClientRequest, [{
    key: 'withCredentials',
    value: function withCredentials(opt_withCredentials) {
      if (_metal.core.isDef(opt_withCredentials)) {
        this.withCredentials_ = !!opt_withCredentials;
        return this;
      }
      return this.withCredentials_;
    }

    /**
    * Fluent getter and setter for request method.
    * @param {string=} opt_method Request method to be set. If none is given,
    *   the current method value will be returned.
    * @return {!ClientMessage|string} Returns request method if no new value was
    *   given. Otherwise returns the {@link ClientMessage} object itself, so
    *   calls can be chained.
    * @chainable Chainable when used as setter.
    */

  }, {
    key: 'method',
    value: function method(opt_method) {
      if (_metal.core.isDef(opt_method)) {
        this.method_ = opt_method;
        return this;
      }
      return this.method_ || ClientRequest.DEFAULT_METHOD;
    }

    /**
    * Adds a query. If a query with the same name already exists, it will not
    * be overwritten, but new value will be stored as well. The order is
    * preserved.
    * @param {string} name
    * @param {string} value
    * @return {!ClientMessage} Returns the {@link ClientMessage} object itself,
    *   so calls can be chained.
    * @chainable
    */

  }, {
    key: 'param',
    value: function param(name, value) {
      if (arguments.length !== 2) {
        throw new Error('Invalid arguments');
      }
      this.params_.set(name, value);
      return this;
    }

    /**
    * Fluent getter and setter for request querystring.
    * @param {MultiMap|Object=} opt_params Request querystring map to be set.
    *   If none is given the current value of the params will be returned.
    * @return {!MultiMap|ClientMessage} Returns map of request querystring if
    *   no new value was given. Otherwise returns the {@link ClientMessage}
    *   object itself, so calls can be chained.
    */

  }, {
    key: 'params',
    value: function params(opt_params) {
      if (_metal.core.isDef(opt_params)) {
        if (opt_params instanceof _metalStructs.MultiMap) {
          this.params_ = opt_params;
        } else {
          this.params_.values = opt_params;
        }
        return opt_params;
      }
      return this.params_;
    }

    /**
    * Fluent getter and setter for request url.
    * @param {string=} opt_url Request url to be set. If none is given,
    *   the current value of the url will be returned.
    * @return {!ClientMessage|string} Returns request url if no new value was
    *  given.
    *  Otherwise returns the {@link ClientMessage} object itself, so calls can be
    *  chained.
    * @chainable Chainable when used as setter.
    */

  }, {
    key: 'url',
    value: function url(opt_url) {
      if (_metal.core.isDef(opt_url)) {
        this.url_ = opt_url;
        return this;
      }
      return this.url_;
    }
  }]);

  return ClientRequest;
}(_ClientMessage3.default);

ClientRequest.DEFAULT_METHOD = 'GET';

exports.default = ClientRequest;

/***/ }),
/* 22 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _metal = __webpack_require__(0);

var _ClientMessage2 = __webpack_require__(16);

var _ClientMessage3 = _interopRequireDefault(_ClientMessage2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * Represents a client response object.
 * @extends {ClientMessage}
 */
var ClientResponse = function (_ClientMessage) {
  _inherits(ClientResponse, _ClientMessage);

  /**
  * Constructs an {@link ClientResponse} instance.
  * @param {!ClientRequest} clientRequest Instance of {@link ClientRequest}
  *   object.
  * @constructor
  */
  function ClientResponse(clientRequest) {
    _classCallCheck(this, ClientResponse);

    var _this = _possibleConstructorReturn(this, (ClientResponse.__proto__ || Object.getPrototypeOf(ClientResponse)).call(this));

    if (!clientRequest) {
      throw new Error('Can not create response without request');
    }
    _this.clientRequest_ = clientRequest;
    return _this;
  }

  /**
  * Returns request that created this response.
  * @return {!ClientRequest}
  */


  _createClass(ClientResponse, [{
    key: 'request',
    value: function request() {
      return this.clientRequest_;
    }

    /**
    * Fluent getter and setter for response status code.
    * @param {number=} opt_statusCode Request status code to be set. If none is
    *  given, the current status code value will be returned.
    * @return {!ClientMessage|number} Returns response status code if no new
    *   value was given. Otherwise returns the {@link ClientMessage} object
    *   itself, so calls can be chained.
    * @chainable Chainable when used as setter.
    */

  }, {
    key: 'statusCode',
    value: function statusCode(opt_statusCode) {
      if (_metal.core.isDef(opt_statusCode)) {
        this.statusCode_ = opt_statusCode;
        return this;
      }
      return this.statusCode_;
    }

    /**
    * Fluent getter and setter for response status text.
    * @param {string=} opt_statusText Request status text to be set. If none is
    *   given, the current status text value will be returned.
    * @return {!ClientMessage|number} Returns response status text if no new
    *   value was given. Otherwise returns the {@link ClientMessage} object
    *   itself, so calls can be chained.
    * @chainable Chainable when used as setter.
    */

  }, {
    key: 'statusText',
    value: function statusText(opt_statusText) {
      if (_metal.core.isDef(opt_statusText)) {
        this.statusText_ = opt_statusText;
        return this;
      }
      return this.statusText_;
    }

    /**
    * Checks if response succeeded. Any status code 2xx or 3xx is considered
    * valid.
    * @return {boolean}
    */

  }, {
    key: 'succeeded',
    value: function succeeded() {
      return this.statusCode() >= 200 && this.statusCode() <= 399;
    }
  }]);

  return ClientResponse;
}(_ClientMessage3.default);

exports.default = ClientResponse;

/***/ }),
/* 23 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * Provides a convenient interface for data transport.
 * @interface
 */

Object.defineProperty(exports, "__esModule", {
	value: true
});

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var Transport = function Transport() {
	_classCallCheck(this, Transport);
};

exports.default = Transport;

/***/ }),
/* 24 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _AjaxTransport = __webpack_require__(29);

var _AjaxTransport2 = _interopRequireDefault(_AjaxTransport);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * Provides a factory for data transport.
 */
var TransportFactory = function () {
  /**
  * Constructs an {@link TransportFactory} instance.
  * @constructor
  */
  function TransportFactory() {
    _classCallCheck(this, TransportFactory);

    this.transports = {};
    this.transports[TransportFactory.DEFAULT_TRANSPORT_NAME] = TransportFactory[TransportFactory.DEFAULT_TRANSPORT_NAME];
  }

  /**
  * Returns {@link TransportFactory} instance.
  * @return {!TransportFactory} Instance of TransportFactory
  */


  _createClass(TransportFactory, [{
    key: 'get',


    /**
    * Gets an instance of the transport implementation with the given name.
    * @param {string} implementationName
    * @return {!Transport}
    */
    value: function get(implementationName) {
      var TransportClass = this.transports[implementationName];

      if (!TransportClass) {
        throw new Error('Invalid transport name: ' + implementationName);
      }

      try {
        return new TransportClass();
      } catch (err) {
        throw new Error('Can not create transport', err);
      }
    }

    /**
    * Returns the default transport implementation.
    * @return {!Transport}
    */

  }, {
    key: 'getDefault',
    value: function getDefault() {
      return this.get(TransportFactory.DEFAULT_TRANSPORT_NAME);
    }
  }], [{
    key: 'instance',
    value: function instance() {
      if (!TransportFactory.instance_) {
        TransportFactory.instance_ = new TransportFactory();
      }
      return TransportFactory.instance_;
    }
  }]);

  return TransportFactory;
}();

TransportFactory.DEFAULT_TRANSPORT_NAME = 'default';

TransportFactory[TransportFactory.DEFAULT_TRANSPORT_NAME] = _AjaxTransport2.default;

exports.default = TransportFactory;

/***/ }),
/* 25 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _Auth = __webpack_require__(10);

var _Auth2 = _interopRequireDefault(_Auth);

var _ApiHelper2 = __webpack_require__(9);

var _ApiHelper3 = _interopRequireDefault(_ApiHelper2);

var _FacebookAuthProvider = __webpack_require__(26);

var _FacebookAuthProvider2 = _interopRequireDefault(_FacebookAuthProvider);

var _GithubAuthProvider = __webpack_require__(27);

var _GithubAuthProvider2 = _interopRequireDefault(_GithubAuthProvider);

var _globals = __webpack_require__(5);

var _globals2 = _interopRequireDefault(_globals);

var _GoogleAuthProvider = __webpack_require__(28);

var _GoogleAuthProvider2 = _interopRequireDefault(_GoogleAuthProvider);

var _metalStorage = __webpack_require__(41);

var _assertions = __webpack_require__(3);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * Class responsible for encapsulating auth API calls.
 */
var AuthApiHelper = function (_ApiHelper) {
  _inherits(AuthApiHelper, _ApiHelper);

  /**
  * Constructs an {@link AuthApiHelper} instance.
  * @param {!string} wedeployClient
  * @constructor
  */
  function AuthApiHelper(wedeployClient) {
    _classCallCheck(this, AuthApiHelper);

    var _this = _possibleConstructorReturn(this, (AuthApiHelper.__proto__ || Object.getPrototypeOf(AuthApiHelper)).call(this, wedeployClient));

    _this.currentUser = null;
    _this.onSignInCallback = null;
    _this.onSignOutCallback = null;

    if (_metalStorage.LocalStorageMechanism.isSupported()) {
      _this.storage = new _metalStorage.Storage(new _metalStorage.LocalStorageMechanism());
    }

    _this.processSignIn_();

    _this.provider = {
      Facebook: _FacebookAuthProvider2.default,
      Google: _GoogleAuthProvider2.default,
      Github: _GithubAuthProvider2.default
    };
    return _this;
  }

  /**
  * Creates access token cookie.
  * @param {string} accessToken
  */


  _createClass(AuthApiHelper, [{
    key: 'createAccessTokenCookie',
    value: function createAccessTokenCookie(accessToken) {
      if (_globals2.default.document && _globals2.default.window) {
        _globals2.default.document.cookie = 'access_token=' + accessToken + '; Domain=' + _globals2.default.window.location.hostname + ';';
      }
    }

    /**
     * @param {Object} data
     * @return {Auth}
     */

  }, {
    key: 'createAuthFromData',
    value: function createAuthFromData(data) {
      var auth = _Auth2.default.createFromData(data);
      auth.setWedeployClient(this.wedeployClient);
      return auth;
    }

    /**
    * Creates user.
    * @param {!Object} data The data to be used to create the user.
    * @return {CancellablePromise}
    */

  }, {
    key: 'createUser',
    value: function createUser(data) {
      var _this2 = this;

      (0, _assertions.assertObject)(data, 'User data must be specified as object');

      var request = this.buildUrl_().path('/users');

      var authScope = this.resolveAuthScope();
      if (authScope) {
        request.auth(authScope.token);
      }

      return request.post(data).then(function (response) {
        return (0, _assertions.assertResponseSucceeded)(response);
      }).then(function (response) {
        return _this2.createAuthFromData(response.body());
      });
    }

    /**
    * Deletes access token cookie.
    */

  }, {
    key: 'deleteAccessTokenCookie',
    value: function deleteAccessTokenCookie() {
      if (_globals2.default.document && _globals2.default.window) {
        _globals2.default.document.cookie = 'access_token=;expires=Thu, 01 Jan 1970 00:00:01 GMT;Domain=' + _globals2.default.window.location.hostname + ';';
      }
    }

    /**
     * Deletes user by id.
     * @param {!string} userId
     * @return {CancellablePromise}
     */

  }, {
    key: 'deleteUser',
    value: function deleteUser(userId) {
      (0, _assertions.assertDefAndNotNull)(userId, 'Cannot delete user without id');
      (0, _assertions.assertUserSignedIn)(this.currentUser);
      return this.buildUrl_().path('/users', userId).auth(this.resolveAuthScope().token).delete().then(function (response) {
        return (0, _assertions.assertResponseSucceeded)(response);
      });
    }

    /**
     * Gets all auth users
     * @param {!string} userId
     * @return {CancellablePromise}
     */

  }, {
    key: 'getAllUsers',
    value: function getAllUsers() {
      var _this3 = this;

      (0, _assertions.assertUserSignedIn)(this.currentUser);
      return this.buildUrl_().path('/users').auth(this.resolveAuthScope().token).get().then(function (response) {
        return (0, _assertions.assertResponseSucceeded)(response);
      }).then(function (response) {
        return response.body().map(_this3.createAuthFromData, _this3);
      });
    }

    /**
    * Gets the current browser url without the fragment part.
    * @return {!string}
    * @protected
    */

  }, {
    key: 'getHrefWithoutFragment_',
    value: function getHrefWithoutFragment_() {
      var location = _globals2.default.window.location;
      return location.protocol + '//' + location.host + location.pathname + (location.search ? location.search : '');
    }

    /**
    * Gets the access token from the url fragment and removes it.
    * @return {?string}
    * @protected
    */

  }, {
    key: 'getRedirectAccessToken_',
    value: function getRedirectAccessToken_() {
      if (_globals2.default.window && _globals2.default.window.location) {
        var fragment = _globals2.default.window.location.hash;
        if (fragment.indexOf('#access_token=') === 0) {
          return fragment.substring(14);
        }
      }
      return null;
    }

    /**
    * Gets user by id.
    * @param {!string} userId
    * @return {CancellablePromise}
    */

  }, {
    key: 'getUser',
    value: function getUser(userId) {
      var _this4 = this;

      (0, _assertions.assertDefAndNotNull)(userId, 'User userId must be specified');
      (0, _assertions.assertUserSignedIn)(this.currentUser);
      return this.buildUrl_().path('/users', userId).auth(this.resolveAuthScope().token).get().then(function (response) {
        return (0, _assertions.assertResponseSucceeded)(response);
      }).then(function (response) {
        return _this4.createAuthFromData(response.body());
      });
    }

    /**
    * Loads current user. Requires a user token as argument.
    * @param {!string} token
    * @return {CancellablePromise}
    */

  }, {
    key: 'loadCurrentUser',
    value: function loadCurrentUser(token) {
      var _this5 = this;

      return this.verifyUser(token).then(function (currentUser) {
        _this5.currentUser = currentUser;
        if (_this5.storage) {
          _this5.storage.set('currentUser', currentUser);
        }
        if (_this5.currentUser.hasToken()) {
          _this5.createAccessTokenCookie(_this5.currentUser.getToken());
        }
        return _this5.currentUser;
      });
    }

    /**
    * Calls the on sign in callback if set.
    * @protected
    */

  }, {
    key: 'maybeCallOnSignInCallback_',
    value: function maybeCallOnSignInCallback_() {
      if (this.onSignInCallback) {
        this.onSignInCallback.call(this, this.currentUser);
      }
    }

    /**
    * Calls the on sign out callback if set.
    * @protected
    */

  }, {
    key: 'maybeCallOnSignOutCallback_',
    value: function maybeCallOnSignOutCallback_() {
      if (this.onSignOutCallback) {
        this.onSignOutCallback.call(this, this.currentUser);
      }
    }

    /**
    * Fires passed callback when a user sign-in. Note that it keeps only the
    * last callback passed.
    * @param {!Function} callback
    */

  }, {
    key: 'onSignIn',
    value: function onSignIn(callback) {
      (0, _assertions.assertFunction)(callback, 'Sign-in callback must be a function');
      this.onSignInCallback = callback;
    }

    /**
    * Fires passed callback when a user sign-out. Note that it keeps only the
    * last callback passed.
    * @param {!Function} callback
    */

  }, {
    key: 'onSignOut',
    value: function onSignOut(callback) {
      (0, _assertions.assertFunction)(callback, 'Sign-out callback must be a function');
      this.onSignOutCallback = callback;
    }

    /**
    * Processes sign-in by detecting a presence of a fragment
    * <code>#access_token=</code> in the url or, alternatively, by local
    * storage current user.
    */

  }, {
    key: 'processSignIn_',
    value: function processSignIn_() {
      var _this6 = this;

      var redirectAccessToken = this.getRedirectAccessToken_();
      if (redirectAccessToken) {
        this.removeUrlFragmentCompletely_();
        this.loadCurrentUser(redirectAccessToken).then(function () {
          return _this6.maybeCallOnSignInCallback_();
        });
        return;
      }
      var currentUser = this.storage && this.storage.get('currentUser');
      if (currentUser) {
        this.currentUser = this.createAuthFromData(currentUser);
      }
    }

    /**
    * Removes fragment from url by performing a push state to the current path.
    * @protected
    */

  }, {
    key: 'removeUrlFragmentCompletely_',
    value: function removeUrlFragmentCompletely_() {
      _globals2.default.window.history.pushState({}, '', window.location.pathname + window.location.search);
    }

    /**
    * Resolves auth scope from last login or api helper.
    * @return {Auth}
    */

  }, {
    key: 'resolveAuthScope',
    value: function resolveAuthScope() {
      if (this.helperAuthScope) {
        return this.helperAuthScope;
      }
      return this.currentUser;
    }

    /**
    * Sends password reset email to the specified email if found in database.
    * For security reasons call do not fail if email not found.
    * @param {!string} email
    * @return {CancellablePromise}
    */

  }, {
    key: 'sendPasswordResetEmail',
    value: function sendPasswordResetEmail(email) {
      (0, _assertions.assertDefAndNotNull)(email, 'Send password reset email must be specified');
      return this.buildUrl_().path('/user/recover').param('email', email).post().then(function (response) {
        return (0, _assertions.assertResponseSucceeded)(response);
      });
    }

    /**
    * Signs in using email and password.
    * @param {!string} email
    * @param {!string} password
    * @return {CancellablePromise}
    */

  }, {
    key: 'signInWithEmailAndPassword',
    value: function signInWithEmailAndPassword(email, password) {
      var _this7 = this;

      (0, _assertions.assertDefAndNotNull)(email, 'Sign-in email must be specified');
      (0, _assertions.assertDefAndNotNull)(password, 'Sign-in password must be specified');

      return this.buildUrl_().path('/oauth/token').param('grant_type', 'password').param('username', email).param('password', password).get().then(function (response) {
        return (0, _assertions.assertResponseSucceeded)(response);
      }).then(function (response) {
        return _this7.loadCurrentUser(response.body().access_token);
      }).then(function (user) {
        _this7.maybeCallOnSignInCallback_();
        return user;
      });
    }

    /**
    * Signs in with redirect. Some providers and environment may not support
    * this flow.
    * @param {AuthProvider} provider
    */

  }, {
    key: 'signInWithRedirect',
    value: function signInWithRedirect(provider) {
      (0, _assertions.assertBrowserEnvironment)();
      (0, _assertions.assertDefAndNotNull)(provider, 'Sign-in provider must be defined');
      assertSupportedProvider(provider);

      if (!provider.hasRedirectUri()) {
        provider.setRedirectUri(this.getHrefWithoutFragment_());
      }
      _globals2.default.window.location.href = provider.makeAuthorizationUrl(this.wedeployClient.authUrl_);
    }

    /**
    * Signs out <code>currentUser</code> and removes from
    *   <code>localStorage</code>.
    * @return {CancellablePromise}
    */

  }, {
    key: 'signOut',
    value: function signOut() {
      var _this8 = this;

      (0, _assertions.assertUserSignedIn)(this.currentUser);
      return this.buildUrl_().path('/oauth/revoke').param('token', this.currentUser.token).get().then(function (response) {
        return (0, _assertions.assertResponseSucceeded)(response);
      }).then(function (response) {
        _this8.maybeCallOnSignOutCallback_();
        _this8.unloadCurrentUser_();
        return response;
      });
    }

    /**
     * Builds URL by joining the headers.
     * @return {WeDeploy} Returns the {@link WeDeploy} object itself, so calls can
     *   be chained.
     * @chainable
     */

  }, {
    key: 'buildUrl_',
    value: function buildUrl_() {
      return this.wedeployClient.url(this.wedeployClient.authUrl_).headers(this.headers_);
    }

    /**
    * Unloads all information for <code>currentUser</code> and removes from
    * <code>localStorage</code> if present.
    */

  }, {
    key: 'unloadCurrentUser_',
    value: function unloadCurrentUser_() {
      this.currentUser = null;
      if (this.storage) {
        this.storage.remove('currentUser');
      }
      this.deleteAccessTokenCookie();
    }

    /**
    * Method for verifying tokens. If the provided token has the correct
    * format, is not expired, and is properly signed, the method returns the
    * decoded token.
    * @param {!string} token
    * @return {CancellablePromise}
    */

  }, {
    key: 'verifyToken',
    value: function verifyToken(token) {
      (0, _assertions.assertDefAndNotNull)(token, 'Token must be specified');
      return this.buildUrl_().path('/oauth/tokeninfo').param('token', token).get().then(function (response) {
        return (0, _assertions.assertResponseSucceeded)(response);
      }).then(function (response) {
        return response.body();
      });
    }

    /**
    * Method for verifying user by token. If the provided token has the correct
    * format, is not expired, and is properly signed, the method returns the
    * user payload.
    * @param {!string} tokenOrEmail Either an authorization token,
    * or the email.
    * @param {string=} opt_password If a email is given as the first param,
    * this should be the password.
    * @return {CancellablePromise}
    */

  }, {
    key: 'verifyUser',
    value: function verifyUser(tokenOrEmail, opt_password) {
      var _this9 = this;

      (0, _assertions.assertDefAndNotNull)(tokenOrEmail, 'Token or email must be specified');
      return this.buildUrl_().path('/user').auth(tokenOrEmail, opt_password).get().then(function (response) {
        return (0, _assertions.assertResponseSucceeded)(response);
      }).then(function (response) {
        var data = response.body();
        if (opt_password) {
          data.email = tokenOrEmail;
          data.password = opt_password;
        } else {
          data.token = tokenOrEmail;
        }
        return _this9.createAuthFromData(data);
      });
    }
  }]);

  return AuthApiHelper;
}(_ApiHelper3.default);

/**
 * Asserts a passed sign-in provider is supported.
 * Throws an exception if the passed provider is not one of:
 * - FacebookAuthProvider.PROVIDER
 * - GithubAuthProvider.PROVIDER
 * - GoogleAuthProvider.PROVIDER
 * @param {!string} provider
 */


function assertSupportedProvider(provider) {
  switch (provider.constructor.PROVIDER) {
    case _FacebookAuthProvider2.default.PROVIDER:
    case _GithubAuthProvider2.default.PROVIDER:
    case _GoogleAuthProvider2.default.PROVIDER:
      break;
    default:
      throw new Error('Sign-in provider not supported');
  }
}

exports.default = AuthApiHelper;

/***/ }),
/* 26 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _AuthProvider2 = __webpack_require__(11);

var _AuthProvider3 = _interopRequireDefault(_AuthProvider2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * Facebook auth provider implementation.
 */
var FacebookAuthProvider = function (_AuthProvider) {
  _inherits(FacebookAuthProvider, _AuthProvider);

  /**
  * Constructs an {@link FacebookAuthProvider} instance.
  * @constructor
  */
  function FacebookAuthProvider() {
    _classCallCheck(this, FacebookAuthProvider);

    var _this = _possibleConstructorReturn(this, (FacebookAuthProvider.__proto__ || Object.getPrototypeOf(FacebookAuthProvider)).call(this));

    _this.provider = FacebookAuthProvider.PROVIDER;
    return _this;
  }

  return FacebookAuthProvider;
}(_AuthProvider3.default);

FacebookAuthProvider.PROVIDER = 'facebook';

exports.default = FacebookAuthProvider;

/***/ }),
/* 27 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _AuthProvider2 = __webpack_require__(11);

var _AuthProvider3 = _interopRequireDefault(_AuthProvider2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * Github auth provider implementation.
 */
var GithubAuthProvider = function (_AuthProvider) {
  _inherits(GithubAuthProvider, _AuthProvider);

  /**
  * Constructs an {@link GithubAuthProvider} instance.
  * @constructor
  */
  function GithubAuthProvider() {
    _classCallCheck(this, GithubAuthProvider);

    var _this = _possibleConstructorReturn(this, (GithubAuthProvider.__proto__ || Object.getPrototypeOf(GithubAuthProvider)).call(this));

    _this.provider = GithubAuthProvider.PROVIDER;
    return _this;
  }

  return GithubAuthProvider;
}(_AuthProvider3.default);

GithubAuthProvider.PROVIDER = 'github';

exports.default = GithubAuthProvider;

/***/ }),
/* 28 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _AuthProvider2 = __webpack_require__(11);

var _AuthProvider3 = _interopRequireDefault(_AuthProvider2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * Google auth provider implementation.
 */
var GoogleAuthProvider = function (_AuthProvider) {
  _inherits(GoogleAuthProvider, _AuthProvider);

  /**
  * Constructs an {@link GoogleAuthProvider} instance.
  * @constructor
  */
  function GoogleAuthProvider() {
    _classCallCheck(this, GoogleAuthProvider);

    var _this = _possibleConstructorReturn(this, (GoogleAuthProvider.__proto__ || Object.getPrototypeOf(GoogleAuthProvider)).call(this));

    _this.provider = GoogleAuthProvider.PROVIDER;
    return _this;
  }

  return GoogleAuthProvider;
}(_AuthProvider3.default);

GoogleAuthProvider.PROVIDER = 'google';

exports.default = GoogleAuthProvider;

/***/ }),
/* 29 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _metalAjax = __webpack_require__(38);

var _metalAjax2 = _interopRequireDefault(_metalAjax);

var _Transport2 = __webpack_require__(23);

var _Transport3 = _interopRequireDefault(_Transport2);

var _ClientResponse = __webpack_require__(22);

var _ClientResponse2 = _interopRequireDefault(_ClientResponse);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * The implementation of an ajax transport to be used with {@link WeDeploy}.
 * @extends {Transport}
 */
var AjaxTransport = function (_Transport) {
  _inherits(AjaxTransport, _Transport);

  function AjaxTransport() {
    _classCallCheck(this, AjaxTransport);

    return _possibleConstructorReturn(this, (AjaxTransport.__proto__ || Object.getPrototypeOf(AjaxTransport)).apply(this, arguments));
  }

  _createClass(AjaxTransport, [{
    key: 'send',

    /**
    * @inheritDoc
    */
    value: function send(clientRequest) {
      var deferred = _metalAjax2.default.request(clientRequest.url(), clientRequest.method(), clientRequest.body(), clientRequest.headers(), clientRequest.params(), null, false, clientRequest.withCredentials());

      return deferred.then(function (response) {
        var clientResponse = new _ClientResponse2.default(clientRequest);
        clientResponse.body(response.responseText);
        clientResponse.statusCode(response.status);
        clientResponse.statusText(response.statusText);
        _metalAjax2.default.parseResponseHeaders(response.getAllResponseHeaders()).forEach(function (header) {
          clientResponse.header(header.name, header.value);
        });
        return clientResponse;
      });
    }
  }]);

  return AjaxTransport;
}(_Transport3.default);

exports.default = AjaxTransport;

/***/ }),
/* 30 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
		value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _ApiHelper2 = __webpack_require__(9);

var _ApiHelper3 = _interopRequireDefault(_ApiHelper2);

var _Query = __webpack_require__(7);

var _Query2 = _interopRequireDefault(_Query);

var _Filter = __webpack_require__(4);

var _Filter2 = _interopRequireDefault(_Filter);

var _assertions = __webpack_require__(3);

var _metal = __webpack_require__(0);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * Class responsible for encapsulate data api calls.
 */
var DataApiHelper = function (_ApiHelper) {
		_inherits(DataApiHelper, _ApiHelper);

		/**
  * Constructs an {@link DataApiHelper} instance.
  * @param {!WeDeploy} wedeployClient {@link WeDeploy} client reference.
  * @constructor
  */
		function DataApiHelper(wedeployClient) {
				_classCallCheck(this, DataApiHelper);

				var _this = _possibleConstructorReturn(this, (DataApiHelper.__proto__ || Object.getPrototypeOf(DataApiHelper)).call(this, wedeployClient));

				_this.isSearch_ = false;
				return _this;
		}

		/**
  * Adds a filter to this request's {@link Query}.
  * @param {!Filter|string} fieldOrFilter Either a Filter instance or the
  *   name of the field to filter by.
  * @param {*=} opt_operatorOrValue Either the field's operator or its value.
  * @param {*=} opt_value The filter's value.
  * @return {DataApiHelper} Returns the {@link DataApiHelper} object itself, so
  *   calls can be chained.
  * @chainable
  */


		_createClass(DataApiHelper, [{
				key: 'where',
				value: function where(fieldOrFilter, opt_operatorOrValue, opt_value) {
						this.getOrCreateFilter_().and(fieldOrFilter, opt_operatorOrValue, opt_value);
						return this;
				}

				/**
    * Adds a filter to be composed with this filter using the "or" operator.
    * @param {!Filter|string} fieldOrFilter Either a {@link Filter} instance or
    *   the name of the field to filter by.
    * @param {*=} opt_operatorOrValue Either the field's operator or its value.
    * @param {*=} opt_value The filter's value.
    * @return {DataApiHelper} Returns the {@link DataApiHelper} object itself, so
    *   calls can be chained.
    * @chainnable
    */

		}, {
				key: 'or',
				value: function or(fieldOrFilter, opt_operatorOrValue, opt_value) {
						if (this.getOrCreateFilter_().body().and.length === 0) {
								throw Error('It\'s required to have a condition before using an \'or()\' ' + 'for the first time.');
						}
						this.getOrCreateFilter_().or(fieldOrFilter, opt_operatorOrValue, opt_value);
						return this;
				}

				/**
    * Adds a filter to be compose with this filter using "none" operator.
    * @param {string} field The name of the field to filter by.
    * @param {!(Array|*)} args A variable amount of values to be used with
    * the "none" operator. Can be passed either as a single array or as
    * separate params.
    * @return {DataApiHelper} Returns the {@link DataApiHelper} object itself, so
    *   calls can be chained.
    * @chainnable
    */

		}, {
				key: 'none',
				value: function none(field) {
						for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
								args[_key - 1] = arguments[_key];
						}

						return this.where(_Filter2.default.none(field, args));
				}

				/**
    * Adds a filter to be compose with this filter using "match" operator.
    * @param {string} field If no second string argument is given, this
    *   should be the query string, in which case all fields will be matched.
    *   Otherwise, this should be the name of the field to match.
    * @param {string=} opt_query The query string.
    * @return {DataApiHelper} Returns the {@link DataApiHelper} object itself, so
    *   calls can be chained.
    * @chainnable
    */

		}, {
				key: 'match',
				value: function match(field, opt_query) {
						return this.where(_Filter2.default.match(field, opt_query));
				}

				/**
    * Adds a filter to be compose with this filter using "prefix" operator.
    * @param {string} field The name of the field to filter by.
    * @param {string=} opt_query The query string.
    * @return {DataApiHelper} Returns the {@link DataApiHelper} object itself, so
    *   calls can be chained.
    * @chainnable
    */

		}, {
				key: 'prefix',
				value: function prefix(field, opt_query) {
						return this.where(_Filter2.default.prefix(field, opt_query));
				}

				/**
    * Adds a filter to be compose with this filter using "similar" operator.
    * @param {string} fieldOrQuery If no second string argument is given, this
    * should be the query string, in which case all fields will be matched.
    * Otherwise, this should be the name of the field to match.
    * @param {?string} query The query string.
    * @return {DataApiHelper} Returns the {@link DataApiHelper} object itself, so
    *   calls can be chained.
    * @chainnable
    */

		}, {
				key: 'similar',
				value: function similar(fieldOrQuery, query) {
						return this.where(_Filter2.default.similar(fieldOrQuery, query));
				}

				/**
    * Returns a {@link Filter} instance that uses the "<" operator.
    * @param {string} field The name of the field to filter by.
    * @param {*} value The filter's value.
    * @return {DataApiHelper} Returns the {@link DataApiHelper} object itself, so
    *   calls can be chained.
    * @chainnable
    */

		}, {
				key: 'lt',
				value: function lt(field, value) {
						return this.where(_Filter2.default.lt(field, value));
				}

				/**
    * Returns a {@link Filter} instance that uses the "<=" operator.
    * @param {string} field The name of the field to filter by.
    * @param {*} value The filter's value.
    * @return {DataApiHelper} Returns the {@link DataApiHelper} object itself, so
    *   calls can be chained.
    * @chainnable
    */

		}, {
				key: 'lte',
				value: function lte(field, value) {
						return this.where(_Filter2.default.lte(field, value));
				}

				/**
    * Returns a {@link Filter} instance that uses the ">" operator.
    * @param {string} field The name of the field to filter by.
    * @param {*} value The filter's value.
    * @return {DataApiHelper} Returns the {@link DataApiHelper} object itself, so
    *   calls can be chained.
    * @chainnable
    */

		}, {
				key: 'gt',
				value: function gt(field, value) {
						return this.where(_Filter2.default.gt(field, value));
				}

				/**
    * Returns a {@link Filter} instance that uses the ">=" operator.
    * @param {string} field The name of the field to filter by.
    * @param {*} value The filter's value.
    * @return {DataApiHelper} Returns the {@link DataApiHelper} object itself, so
    *   calls can be chained.
    * @chainnable
    */

		}, {
				key: 'gte',
				value: function gte(field, value) {
						return this.where(_Filter2.default.gte(field, value));
				}

				/**
    * Adds a filter to be compose with this filter using "any" operator.
    * @param {string} field The name of the field to filter by.
    * @param {!(Array|*)} args A variable amount of values to be used with
    * the "none" operator. Can be passed either as a single array or as
    * separate params.
    * @return {DataApiHelper} Returns the {@link DataApiHelper} object itself, so
    *   calls can be chained.
    * @chainnable
    */

		}, {
				key: 'any',
				value: function any(field) {
						for (var _len2 = arguments.length, args = Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
								args[_key2 - 1] = arguments[_key2];
						}

						return this.where(_Filter2.default.any(field, args));
				}

				/**
    * Adds a filter to be compose with this filter using "gp" operator. This is a
    * special use case of `Filter.polygon` for bounding boxes.
    * @param {string} field The field's name.
    * @param {*} boxOrUpperLeft Either a `Geo.BoundingBox` instance, or a
    * bounding box's upper left coordinate.
    * @param {*=} opt_lowerRight A bounding box's lower right coordinate.
    * @return {DataApiHelper} Returns the {@link DataApiHelper} object itself, so
    *   calls can be chained.
    * @chainnable
    */

		}, {
				key: 'boundingBox',
				value: function boundingBox(field, boxOrUpperLeft, opt_lowerRight) {
						return this.where(_Filter2.default.boundingBox(field, boxOrUpperLeft, opt_lowerRight));
				}

				/**
    * Adds a filter to be compose with this filter using "gd" operator.
    * @param {string} field The field's name.
    * @param {*} locationOrCircle Either a `Geo.Circle` instance or a
    * coordinate.
    * @param {Range|string=} opt_rangeOrDistance Either a `Range` instance or
    * the distance value.
    * @return {DataApiHelper} Returns the {@link DataApiHelper} object itself, so
    *   calls can be chained.
    * @chainnable
    */

		}, {
				key: 'distance',
				value: function distance(field, locationOrCircle, opt_rangeOrDistance) {
						return this.where(_Filter2.default.distance(field, locationOrCircle, opt_rangeOrDistance));
				}

				/**
    * Adds a filter to be compose with this filter using "range" operator.
    * @param {string} field The field's name.
    * @param {*} rangeOrMin Either a `Range` instance or a the range's min
    * value.
    * @param {*=} opt_max The range's max value.
    * @return {DataApiHelper} Returns the {@link DataApiHelper} object itself, so
    *   calls can be chained.
    * @chainnable
    */

		}, {
				key: 'range',
				value: function range(field, rangeOrMin, opt_max) {
						return this.where(_Filter2.default.range(field, rangeOrMin, opt_max));
				}

				/**
    * Sets the limit for this request's {@link Query}.
    * @param {number} limit The max amount of entries that this request should
    *   return.
    * @return {DataApiHelper} Returns the {@link DataApiHelper} object itself, so
    *   calls can be chained.
    * @chainnable
    */

		}, {
				key: 'limit',
				value: function limit(_limit) {
						this.getOrCreateQuery_().limit(_limit);
						return this;
				}

				/**
    * Sets the offset for this request's {@link Query}.
    * @param {number} offset The index of the first entry that should be
    * returned by this query.
    * @return {DataApiHelper} Returns the {@link DataApiHelper} object itself, so
    *   calls can be chained.
    * @chainnable
    */

		}, {
				key: 'offset',
				value: function offset(_offset) {
						this.getOrCreateQuery_().offset(_offset);
						return this;
				}

				/**
    * Adds a highlight entry to this request's {@link Query} instance.
    * @param {string} field The field's name.
    * @return {DataApiHelper} Returns the {@link DataApiHelper} object itself, so
    *   calls can be chained.
    * @chainnable
    */

		}, {
				key: 'highlight',
				value: function highlight(field) {
						this.getOrCreateQuery_().highlight(field);
						return this;
				}

				/**
    * Adds an aggregation to this {@link Query} instance.
    * @param {string} name The aggregation name.
    * @param {!Aggregation|string} aggregationOrField Either an {@link
    * Aggregation} instance or the name of the aggregation field.
    * @param {string=} opt_operator The aggregation operator.
    * @return {DataApiHelper} Returns the {@link DataApiHelper} object itself, so
    *   calls can be chained.
    * @chainnable
    */

		}, {
				key: 'aggregate',
				value: function aggregate(name, aggregationOrField, opt_operator) {
						this.getOrCreateQuery_().aggregate(name, aggregationOrField, opt_operator);
						return this;
				}

				/**
    * Sets this request's query type to 'count'.
    * @return {DataApiHelper} Returns the {@link DataApiHelper} object itself, so
    *   calls can be chained.
    * @chainnable
    */

		}, {
				key: 'count',
				value: function count() {
						this.getOrCreateQuery_().type('count');
						return this;
				}

				/**
    * Adds a sort query to this request's body.
    * @param {string} field The field that the query should be sorted by.
    * @param {string=} opt_direction The direction the sort operation should
    * use. If none is given, 'asc' is used by default.
    * @return {DataApiHelper} Returns the {@link DataApiHelper} object itself, so
    *   calls can be chained.
    * @chainnable
    */

		}, {
				key: 'orderBy',
				value: function orderBy(field, opt_direction) {
						this.getOrCreateQuery_().sort(field, opt_direction);
						return this;
				}

				/**
    * Creates an object (or multiple objects) and saves it to WeDeploy data. If
    * there's a validation registered in the collection and the request is
    * successful, the resulting object (or array of objects) is returned. The
    * data parameter can be either an Object or an Array of Objects.
    * These Objects describe the attributes on the objects that are to be
    *   created.
    * ```javascript
    * var data = WeDeploy.data('http://demodata.wedeploy.io');
    *
    * data.create(
    *   'movies', {'title'=> 'Star Wars: Episode I – The Phantom Menace'})
    * 	 .then(function(movie){
    *     console.log(movie)
    *   });
    *
    * data.create(
    *   'movies', [{'title'=> 'Star Wars: Episode II – Attack of the Clones'},
    * 						  {'title'=> 'Star Wars: Episode III – Revenge of the Sith'})
    * 		 .then(function(movies){
    * 			 console.log(movies)
    *     });
    * ```
    * @param {string} collection Collection (key) used to create the new data.
    * @param {Object} data Attributes on the object that is to be created.
    * @return {!CancellablePromise}
    */

		}, {
				key: 'create',
				value: function create(collection, data) {
						(0, _assertions.assertDefAndNotNull)(collection, 'Collection key must be specified.');
						(0, _assertions.assertObject)(data, 'Data can\'t be empty.');

						return this.buildUrl_().path(collection).post(data).then(function (response) {
								return (0, _assertions.assertResponseSucceeded)(response);
						}).then(function (response) {
								return response.body();
						});
				}

				/**
    * Replaces the attributes of a document form the passed-in object and saves
    * the record. If the object is invalid, the saving will fail and an error
    * object will be returned.
    *
    * ```javascript
    * var data = WeDeploy.data('http://demodata.wedeploy.io');
    *
    * data.replace('movies/1019112353', {'title'=> 'Star Wars: Episode I'})
    * 		 .then(function(movie){
    * 			 console.log(movie)
    *     });
    * ```
    * @param {string} doc Key used to update the document.
    * @param {Object} data Attributes on the object that is to be updated.
    * @return {!CancellablePromise}
    */

		}, {
				key: 'replace',
				value: function replace(doc, data) {
						(0, _assertions.assertDefAndNotNull)(doc, 'Document key must be specified.');
						(0, _assertions.assertObject)(data, 'Data must be specified.');

						return this.buildUrl_().path(doc).put(data).then(function (response) {
								return (0, _assertions.assertResponseSucceeded)(response);
						}).then(function (response) {
								return response.body();
						});
				}

				/**
    * Update the attributes of a document form the passed-in object and saves
    * the record. If the object is invalid, the saving will fail and an error
    * object will be returned.
    *
    * ```javascript
    * var data = WeDeploy.data('http://demodata.wedeploy.io');
    *
    * data.update('movies/1019112353', {'title'=> 'Star Wars: Episode I'})
    * 		 .then(function(movie){
    * 			 console.log(movie)
    *     });
    * ```
    * @param {string} doc Key used to update the document.
    * @param {Object} data Attributes on the object that is to be updated.
    * @return {!CancellablePromise}
    */

		}, {
				key: 'update',
				value: function update(doc, data) {
						(0, _assertions.assertDefAndNotNull)(doc, 'Document key must be specified.');
						(0, _assertions.assertObject)(data, 'Data must be specified.');

						return this.buildUrl_().path(doc).patch(data).then(function (response) {
								return (0, _assertions.assertResponseSucceeded)(response);
						}).then(function (response) {
								return response.body();
						});
				}

				/**
    * Deletes a [document/field/collection].
    * @param {string} key Key used to delete the
    * document/field/collection.
    * @return {!CancellablePromise}
    */

		}, {
				key: 'delete',
				value: function _delete(key) {
						(0, _assertions.assertDefAndNotNull)(key, 'Document/Field/Collection key must be specified');

						return this.buildUrl_().path(key).delete().then(function (response) {
								return (0, _assertions.assertResponseSucceeded)(response);
						}).then(function () {
								return undefined;
						});
				}

				/**
    * Retrieve data from a [document/field/collection].
    * @param {string} key Key used to delete the document/field/collection.
    * @return {!CancellablePromise}
    */

		}, {
				key: 'get',
				value: function get(key) {
						(0, _assertions.assertDefAndNotNull)(key, 'Document/Field/Collection key must be specified');

						return this.buildUrl_().path(key).get(this.processAndResetQueryState()).then(function (response) {
								return (0, _assertions.assertResponseSucceeded)(response);
						}).then(function (response) {
								return response.body();
						});
				}

				/**
    * Retrieve data from a [document/field/collection] and put it in a search
    * format.
    * @param {string} key Key used to delete the document/field/collection.
    * @return {!CancellablePromise}
    */

		}, {
				key: 'search',
				value: function search(key) {
						(0, _assertions.assertDefAndNotNull)(key, 'Document/Field/Collection key must be specified');

						this.isSearch_ = true;

						return this.buildUrl_().path(key).get(this.processAndResetQueryState()).then(function (response) {
								return (0, _assertions.assertResponseSucceeded)(response);
						}).then(function (response) {
								return response.body();
						});
				}

				/**
    * Creates new socket.io instance. Monitor the arrival of new broadcasted
    * data.
    * @param  {string} collection key/collection used to find organized data.
    * @param  {Object=} opt_options Object with Socket IO options.
    * @return {!io} Socket IO reference. Server events can be listened on it.
    */

		}, {
				key: 'watch',
				value: function watch(collection, opt_options) {
						(0, _assertions.assertDefAndNotNull)(collection, 'Collection key must be specified');

						return this.buildUrl_().path(collection).watch(this.processAndResetQueryState(), opt_options);
				}

				/**
    * Builds URL by joining the headers and auth.
    * @return {WeDeploy} Returns the {@link WeDeploy} object itself, so calls can
    *   be chained.
    * @chainable
    */

		}, {
				key: 'buildUrl_',
				value: function buildUrl_() {
						return this.wedeployClient.url(this.wedeployClient.dataUrl_).headers(this.headers_).auth(this.helperAuthScope);
				}

				/**
    * Gets the currently used main {@link Filter} object. If none exists yet, a
    * new one is created.
    * @return {!Query}
    * @protected
    */

		}, {
				key: 'getOrCreateFilter_',
				value: function getOrCreateFilter_() {
						if (!this.filter_) {
								this.filter_ = new _Filter2.default();
						}
						return this.filter_;
				}

				/**
    * Gets the currently used {@link Query} object. If none exists yet,
    * a new one is created.
    * @return {!Query}
    * @protected
    */

		}, {
				key: 'getOrCreateQuery_',
				value: function getOrCreateQuery_() {
						if (!this.query_) {
								this.query_ = new _Query2.default();
						}
						return this.query_;
				}

				/**
    * Aggregate filters into query and return its latest value. Query and
    * filters are cleaned after aggregation.
    * @return {Query}
    * @protected
    */

		}, {
				key: 'processAndResetQueryState',
				value: function processAndResetQueryState() {
						var filter = void 0;

						if (_metal.core.isDefAndNotNull(this.filter_)) {
								filter = this.getOrCreateFilter_();
						}

						if (this.isSearch_) {
								this.getOrCreateQuery_().search(filter);
						} else if (filter) {
								this.getOrCreateQuery_().filter(filter);
						}

						var query = this.query_;
						this.headers_.clear();
						this.filter_ = null;
						this.isSearch_ = false;
						this.query_ = null;
						return query;
				}
		}]);

		return DataApiHelper;
}(_ApiHelper3.default);

exports.default = DataApiHelper;

/***/ }),
/* 31 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _assertions = __webpack_require__(3);

var _metalStructs = __webpack_require__(2);

var _ApiHelper2 = __webpack_require__(9);

var _ApiHelper3 = _interopRequireDefault(_ApiHelper2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * Class responsible for encapsulate email api calls.
 */
var EmailApiHelper = function (_ApiHelper) {
  _inherits(EmailApiHelper, _ApiHelper);

  /**
  * Constructs an {@link EmailApiHelper} instance.
  * @param {!WeDeploy} wedeployClient {@link WeDeploy} client reference.
  * @constructor
  */
  function EmailApiHelper(wedeployClient) {
    _classCallCheck(this, EmailApiHelper);

    var _this = _possibleConstructorReturn(this, (EmailApiHelper.__proto__ || Object.getPrototypeOf(EmailApiHelper)).call(this, wedeployClient));

    _this.params = new _metalStructs.MultiMap();
    return _this;
  }

  /**
  * Set from attribute on params to be send on email request.
  * @param  {string} from
  * @return {EmailApiHelper} Returns the {@link EmailApiHelper} object itself,
  *   so calls can be chained.
  * @chainable
  */


  _createClass(EmailApiHelper, [{
    key: 'from',
    value: function from(_from) {
      (0, _assertions.assertDefAndNotNull)(_from, 'Parameter "from" must be specified');

      this.params.set('from', _from);

      return this;
    }

    /**
    * Set bcc attribute on params to be send on email request.
    * @param  {string} bcc
    * @return {EmailApiHelper} Returns the {@link EmailApiHelper} object itself,
    *   so calls can be chained.
    * @chainable
    */

  }, {
    key: 'bcc',
    value: function bcc(_bcc) {
      (0, _assertions.assertDefAndNotNull)(_bcc, 'Parameter "bcc" must be specified');

      this.params.add('bcc', _bcc);

      return this;
    }

    /**
    * Set cc attribute on params to be send on email request.
    * @param  {string} cc
    * @return {EmailApiHelper} Returns the {@link EmailApiHelper} object itself,
    *   so calls can be chained.
    * @chainable
    */

  }, {
    key: 'cc',
    value: function cc(_cc) {
      (0, _assertions.assertDefAndNotNull)(_cc, 'Parameter "cc" must be specified');

      this.params.add('cc', _cc);

      return this;
    }

    /**
    * Set message attribute on params to be send on email request.
    * @param  {string} message
    * @return {EmailApiHelper} Returns the {@link EmailApiHelper} object itself,
    *   so calls can be chained.
    * @chainable
    */

  }, {
    key: 'message',
    value: function message(_message) {
      (0, _assertions.assertDefAndNotNull)(_message, 'Parameter "message" must be specified');

      this.params.set('message', _message);

      return this;
    }

    /**
    * Set priority attribute on params to be send on email request.
    * @param  {string} priority
    * @return {EmailApiHelper} Returns the {@link EmailApiHelper} object itself,
    *   so calls can be chained.
    * @chainable
    */

  }, {
    key: 'priority',
    value: function priority(_priority) {
      (0, _assertions.assertDefAndNotNull)(_priority, 'Parameter "priority" must be specified');

      this.params.set('priority', _priority);

      return this;
    }

    /**
    * Set replyTo attribute on params to be send on email request.
    * @param  {string} replyTo
    * @return {EmailApiHelper} Returns the {@link EmailApiHelper} object itself,
    *   so calls can be chained.
    * @chainable
    */

  }, {
    key: 'replyTo',
    value: function replyTo(_replyTo) {
      (0, _assertions.assertDefAndNotNull)(_replyTo, 'Parameter "replyTo" must be specified');

      this.params.set('replyTo', _replyTo);

      return this;
    }

    /**
    * Set to attribute on params to be send on email request.
    * @param  {string} to
    * @return {EmailApiHelper} Returns the {@link EmailApiHelper} object itself,
    *   so calls can be chained.
    * @chainable
    */

  }, {
    key: 'to',
    value: function to(_to) {
      (0, _assertions.assertDefAndNotNull)(_to, 'Parameter "to" must be specified');

      this.params.add('to', _to);

      return this;
    }

    /**
    * Set subject attribute on params to be send on email request.
    * @param  {string} subject
    * @return {EmailApiHelper} Returns the {@link EmailApiHelper} object itself,
    *   so calls can be chained.
    * @chainable
    */

  }, {
    key: 'subject',
    value: function subject(_subject) {
      (0, _assertions.assertDefAndNotNull)(_subject, 'Parameter "subject" must be specified');

      this.params.set('subject', _subject);

      return this;
    }

    /**
    * Sends an email based on given params.
    * @return {!CancellablePromise}
    */

  }, {
    key: 'send',
    value: function send() {
      var _this2 = this;

      var client = this.buildUrl_().path('emails');

      this.params.names().forEach(function (name) {
        var values = _this2.params.getAll(name);

        values.forEach(function (value) {
          client.form(name, value);
        });
      });

      this.params.clear();
      this.headers_.clear();

      return client.post().then(function (response) {
        return (0, _assertions.assertResponseSucceeded)(response);
      }).then(function (response) {
        return response.body();
      });
    }

    /**
    * Checks the status of an email.
    * @param  {string} emailId
    * @return {!CancellablePromise}
    */

  }, {
    key: 'status',
    value: function status(emailId) {
      (0, _assertions.assertDefAndNotNull)(emailId, 'Parameter "emailId" param must be specified');

      return this.buildUrl_().path('emails', emailId, 'status').get().then(function (response) {
        return (0, _assertions.assertResponseSucceeded)(response);
      }).then(function (response) {
        return response.body();
      });
    }

    /**
     * Builds URL by joining the headers and auth.
     * @return {WeDeploy} Returns the {@link WeDeploy} object itself, so calls can
     *   be chained.
     * @chainable
     */

  }, {
    key: 'buildUrl_',
    value: function buildUrl_() {
      return this.wedeployClient.url(this.wedeployClient.emailUrl_).headers(this.headers_).auth(this.helperAuthScope);
    }
  }]);

  return EmailApiHelper;
}(_ApiHelper3.default);

exports.default = EmailApiHelper;

/***/ }),
/* 32 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(Buffer) {

/**
 * Abstraction layer for string to base64 conversion
 * reference: https://github.com/nodejs/node/issues/3462
 */

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var Base64 = function () {
  function Base64() {
    _classCallCheck(this, Base64);
  }

  _createClass(Base64, null, [{
    key: 'encodeString',

    /**
    * Creates a base-64 encoded ASCII string from a "string" of binary data.
    * @param {string} string to be encoded.
    * @return {string}
    * @static
    */
    value: function encodeString(string) {
      if (typeof btoa === 'function') {
        return btoa(string);
      }

      return new Buffer(string.toString(), 'binary').toString('base64');
    }
  }]);

  return Base64;
}();

exports.default = Base64;
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(35).Buffer))

/***/ }),
/* 33 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.WeDeploy = exports.Range = exports.Query = exports.Geo = exports.Filter = undefined;

var _globals = __webpack_require__(5);

var _globals2 = _interopRequireDefault(_globals);

var _Filter = __webpack_require__(4);

var _Filter2 = _interopRequireDefault(_Filter);

var _Geo = __webpack_require__(15);

var _Geo2 = _interopRequireDefault(_Geo);

var _WeDeploy = __webpack_require__(18);

var _WeDeploy2 = _interopRequireDefault(_WeDeploy);

var _Query = __webpack_require__(7);

var _Query2 = _interopRequireDefault(_Query);

var _Range = __webpack_require__(8);

var _Range2 = _interopRequireDefault(_Range);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

_globals2.default.window.Filter = _Filter2.default;
_globals2.default.window.Geo = _Geo2.default;
_globals2.default.window.Query = _Query2.default;
_globals2.default.window.Range = _Range2.default;
_globals2.default.window.WeDeploy = _WeDeploy2.default;

exports.Filter = _Filter2.default;
exports.Geo = _Geo2.default;
exports.Query = _Query2.default;
exports.Range = _Range2.default;
exports.WeDeploy = _WeDeploy2.default;
exports.default = _WeDeploy2.default;

/***/ }),
/* 34 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.byteLength = byteLength
exports.toByteArray = toByteArray
exports.fromByteArray = fromByteArray

var lookup = []
var revLookup = []
var Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array

var code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'
for (var i = 0, len = code.length; i < len; ++i) {
  lookup[i] = code[i]
  revLookup[code.charCodeAt(i)] = i
}

revLookup['-'.charCodeAt(0)] = 62
revLookup['_'.charCodeAt(0)] = 63

function placeHoldersCount (b64) {
  var len = b64.length
  if (len % 4 > 0) {
    throw new Error('Invalid string. Length must be a multiple of 4')
  }

  // the number of equal signs (place holders)
  // if there are two placeholders, than the two characters before it
  // represent one byte
  // if there is only one, then the three characters before it represent 2 bytes
  // this is just a cheap hack to not do indexOf twice
  return b64[len - 2] === '=' ? 2 : b64[len - 1] === '=' ? 1 : 0
}

function byteLength (b64) {
  // base64 is 4/3 + up to two characters of the original data
  return (b64.length * 3 / 4) - placeHoldersCount(b64)
}

function toByteArray (b64) {
  var i, l, tmp, placeHolders, arr
  var len = b64.length
  placeHolders = placeHoldersCount(b64)

  arr = new Arr((len * 3 / 4) - placeHolders)

  // if there are placeholders, only get up to the last complete 4 chars
  l = placeHolders > 0 ? len - 4 : len

  var L = 0

  for (i = 0; i < l; i += 4) {
    tmp = (revLookup[b64.charCodeAt(i)] << 18) | (revLookup[b64.charCodeAt(i + 1)] << 12) | (revLookup[b64.charCodeAt(i + 2)] << 6) | revLookup[b64.charCodeAt(i + 3)]
    arr[L++] = (tmp >> 16) & 0xFF
    arr[L++] = (tmp >> 8) & 0xFF
    arr[L++] = tmp & 0xFF
  }

  if (placeHolders === 2) {
    tmp = (revLookup[b64.charCodeAt(i)] << 2) | (revLookup[b64.charCodeAt(i + 1)] >> 4)
    arr[L++] = tmp & 0xFF
  } else if (placeHolders === 1) {
    tmp = (revLookup[b64.charCodeAt(i)] << 10) | (revLookup[b64.charCodeAt(i + 1)] << 4) | (revLookup[b64.charCodeAt(i + 2)] >> 2)
    arr[L++] = (tmp >> 8) & 0xFF
    arr[L++] = tmp & 0xFF
  }

  return arr
}

function tripletToBase64 (num) {
  return lookup[num >> 18 & 0x3F] + lookup[num >> 12 & 0x3F] + lookup[num >> 6 & 0x3F] + lookup[num & 0x3F]
}

function encodeChunk (uint8, start, end) {
  var tmp
  var output = []
  for (var i = start; i < end; i += 3) {
    tmp = (uint8[i] << 16) + (uint8[i + 1] << 8) + (uint8[i + 2])
    output.push(tripletToBase64(tmp))
  }
  return output.join('')
}

function fromByteArray (uint8) {
  var tmp
  var len = uint8.length
  var extraBytes = len % 3 // if we have 1 byte left, pad 2 bytes
  var output = ''
  var parts = []
  var maxChunkLength = 16383 // must be multiple of 3

  // go through the array every three bytes, we'll deal with trailing stuff later
  for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {
    parts.push(encodeChunk(uint8, i, (i + maxChunkLength) > len2 ? len2 : (i + maxChunkLength)))
  }

  // pad the end with zeros, but make sure to not forget the extra bytes
  if (extraBytes === 1) {
    tmp = uint8[len - 1]
    output += lookup[tmp >> 2]
    output += lookup[(tmp << 4) & 0x3F]
    output += '=='
  } else if (extraBytes === 2) {
    tmp = (uint8[len - 2] << 8) + (uint8[len - 1])
    output += lookup[tmp >> 10]
    output += lookup[(tmp >> 4) & 0x3F]
    output += lookup[(tmp << 2) & 0x3F]
    output += '='
  }

  parts.push(output)

  return parts.join('')
}


/***/ }),
/* 35 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(global) {/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>
 * @license  MIT
 */
/* eslint-disable no-proto */



var base64 = __webpack_require__(34)
var ieee754 = __webpack_require__(36)
var isArray = __webpack_require__(37)

exports.Buffer = Buffer
exports.SlowBuffer = SlowBuffer
exports.INSPECT_MAX_BYTES = 50

/**
 * If `Buffer.TYPED_ARRAY_SUPPORT`:
 *   === true    Use Uint8Array implementation (fastest)
 *   === false   Use Object implementation (most compatible, even IE6)
 *
 * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,
 * Opera 11.6+, iOS 4.2+.
 *
 * Due to various browser bugs, sometimes the Object implementation will be used even
 * when the browser supports typed arrays.
 *
 * Note:
 *
 *   - Firefox 4-29 lacks support for adding new properties to `Uint8Array` instances,
 *     See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438.
 *
 *   - Chrome 9-10 is missing the `TypedArray.prototype.subarray` function.
 *
 *   - IE10 has a broken `TypedArray.prototype.subarray` function which returns arrays of
 *     incorrect length in some situations.

 * We detect these buggy browsers and set `Buffer.TYPED_ARRAY_SUPPORT` to `false` so they
 * get the Object implementation, which is slower but behaves correctly.
 */
Buffer.TYPED_ARRAY_SUPPORT = global.TYPED_ARRAY_SUPPORT !== undefined
  ? global.TYPED_ARRAY_SUPPORT
  : typedArraySupport()

/*
 * Export kMaxLength after typed array support is determined.
 */
exports.kMaxLength = kMaxLength()

function typedArraySupport () {
  try {
    var arr = new Uint8Array(1)
    arr.__proto__ = {__proto__: Uint8Array.prototype, foo: function () { return 42 }}
    return arr.foo() === 42 && // typed array instances can be augmented
        typeof arr.subarray === 'function' && // chrome 9-10 lack `subarray`
        arr.subarray(1, 1).byteLength === 0 // ie10 has broken `subarray`
  } catch (e) {
    return false
  }
}

function kMaxLength () {
  return Buffer.TYPED_ARRAY_SUPPORT
    ? 0x7fffffff
    : 0x3fffffff
}

function createBuffer (that, length) {
  if (kMaxLength() < length) {
    throw new RangeError('Invalid typed array length')
  }
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    // Return an augmented `Uint8Array` instance, for best performance
    that = new Uint8Array(length)
    that.__proto__ = Buffer.prototype
  } else {
    // Fallback: Return an object instance of the Buffer class
    if (that === null) {
      that = new Buffer(length)
    }
    that.length = length
  }

  return that
}

/**
 * The Buffer constructor returns instances of `Uint8Array` that have their
 * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of
 * `Uint8Array`, so the returned instances will have all the node `Buffer` methods
 * and the `Uint8Array` methods. Square bracket notation works as expected -- it
 * returns a single octet.
 *
 * The `Uint8Array` prototype remains unmodified.
 */

function Buffer (arg, encodingOrOffset, length) {
  if (!Buffer.TYPED_ARRAY_SUPPORT && !(this instanceof Buffer)) {
    return new Buffer(arg, encodingOrOffset, length)
  }

  // Common case.
  if (typeof arg === 'number') {
    if (typeof encodingOrOffset === 'string') {
      throw new Error(
        'If encoding is specified then the first argument must be a string'
      )
    }
    return allocUnsafe(this, arg)
  }
  return from(this, arg, encodingOrOffset, length)
}

Buffer.poolSize = 8192 // not used by this implementation

// TODO: Legacy, not needed anymore. Remove in next major version.
Buffer._augment = function (arr) {
  arr.__proto__ = Buffer.prototype
  return arr
}

function from (that, value, encodingOrOffset, length) {
  if (typeof value === 'number') {
    throw new TypeError('"value" argument must not be a number')
  }

  if (typeof ArrayBuffer !== 'undefined' && value instanceof ArrayBuffer) {
    return fromArrayBuffer(that, value, encodingOrOffset, length)
  }

  if (typeof value === 'string') {
    return fromString(that, value, encodingOrOffset)
  }

  return fromObject(that, value)
}

/**
 * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError
 * if value is a number.
 * Buffer.from(str[, encoding])
 * Buffer.from(array)
 * Buffer.from(buffer)
 * Buffer.from(arrayBuffer[, byteOffset[, length]])
 **/
Buffer.from = function (value, encodingOrOffset, length) {
  return from(null, value, encodingOrOffset, length)
}

if (Buffer.TYPED_ARRAY_SUPPORT) {
  Buffer.prototype.__proto__ = Uint8Array.prototype
  Buffer.__proto__ = Uint8Array
  if (typeof Symbol !== 'undefined' && Symbol.species &&
      Buffer[Symbol.species] === Buffer) {
    // Fix subarray() in ES2016. See: https://github.com/feross/buffer/pull/97
    Object.defineProperty(Buffer, Symbol.species, {
      value: null,
      configurable: true
    })
  }
}

function assertSize (size) {
  if (typeof size !== 'number') {
    throw new TypeError('"size" argument must be a number')
  } else if (size < 0) {
    throw new RangeError('"size" argument must not be negative')
  }
}

function alloc (that, size, fill, encoding) {
  assertSize(size)
  if (size <= 0) {
    return createBuffer(that, size)
  }
  if (fill !== undefined) {
    // Only pay attention to encoding if it's a string. This
    // prevents accidentally sending in a number that would
    // be interpretted as a start offset.
    return typeof encoding === 'string'
      ? createBuffer(that, size).fill(fill, encoding)
      : createBuffer(that, size).fill(fill)
  }
  return createBuffer(that, size)
}

/**
 * Creates a new filled Buffer instance.
 * alloc(size[, fill[, encoding]])
 **/
Buffer.alloc = function (size, fill, encoding) {
  return alloc(null, size, fill, encoding)
}

function allocUnsafe (that, size) {
  assertSize(size)
  that = createBuffer(that, size < 0 ? 0 : checked(size) | 0)
  if (!Buffer.TYPED_ARRAY_SUPPORT) {
    for (var i = 0; i < size; ++i) {
      that[i] = 0
    }
  }
  return that
}

/**
 * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.
 * */
Buffer.allocUnsafe = function (size) {
  return allocUnsafe(null, size)
}
/**
 * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.
 */
Buffer.allocUnsafeSlow = function (size) {
  return allocUnsafe(null, size)
}

function fromString (that, string, encoding) {
  if (typeof encoding !== 'string' || encoding === '') {
    encoding = 'utf8'
  }

  if (!Buffer.isEncoding(encoding)) {
    throw new TypeError('"encoding" must be a valid string encoding')
  }

  var length = byteLength(string, encoding) | 0
  that = createBuffer(that, length)

  var actual = that.write(string, encoding)

  if (actual !== length) {
    // Writing a hex string, for example, that contains invalid characters will
    // cause everything after the first invalid character to be ignored. (e.g.
    // 'abxxcd' will be treated as 'ab')
    that = that.slice(0, actual)
  }

  return that
}

function fromArrayLike (that, array) {
  var length = array.length < 0 ? 0 : checked(array.length) | 0
  that = createBuffer(that, length)
  for (var i = 0; i < length; i += 1) {
    that[i] = array[i] & 255
  }
  return that
}

function fromArrayBuffer (that, array, byteOffset, length) {
  array.byteLength // this throws if `array` is not a valid ArrayBuffer

  if (byteOffset < 0 || array.byteLength < byteOffset) {
    throw new RangeError('\'offset\' is out of bounds')
  }

  if (array.byteLength < byteOffset + (length || 0)) {
    throw new RangeError('\'length\' is out of bounds')
  }

  if (byteOffset === undefined && length === undefined) {
    array = new Uint8Array(array)
  } else if (length === undefined) {
    array = new Uint8Array(array, byteOffset)
  } else {
    array = new Uint8Array(array, byteOffset, length)
  }

  if (Buffer.TYPED_ARRAY_SUPPORT) {
    // Return an augmented `Uint8Array` instance, for best performance
    that = array
    that.__proto__ = Buffer.prototype
  } else {
    // Fallback: Return an object instance of the Buffer class
    that = fromArrayLike(that, array)
  }
  return that
}

function fromObject (that, obj) {
  if (Buffer.isBuffer(obj)) {
    var len = checked(obj.length) | 0
    that = createBuffer(that, len)

    if (that.length === 0) {
      return that
    }

    obj.copy(that, 0, 0, len)
    return that
  }

  if (obj) {
    if ((typeof ArrayBuffer !== 'undefined' &&
        obj.buffer instanceof ArrayBuffer) || 'length' in obj) {
      if (typeof obj.length !== 'number' || isnan(obj.length)) {
        return createBuffer(that, 0)
      }
      return fromArrayLike(that, obj)
    }

    if (obj.type === 'Buffer' && isArray(obj.data)) {
      return fromArrayLike(that, obj.data)
    }
  }

  throw new TypeError('First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object.')
}

function checked (length) {
  // Note: cannot use `length < kMaxLength()` here because that fails when
  // length is NaN (which is otherwise coerced to zero.)
  if (length >= kMaxLength()) {
    throw new RangeError('Attempt to allocate Buffer larger than maximum ' +
                         'size: 0x' + kMaxLength().toString(16) + ' bytes')
  }
  return length | 0
}

function SlowBuffer (length) {
  if (+length != length) { // eslint-disable-line eqeqeq
    length = 0
  }
  return Buffer.alloc(+length)
}

Buffer.isBuffer = function isBuffer (b) {
  return !!(b != null && b._isBuffer)
}

Buffer.compare = function compare (a, b) {
  if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {
    throw new TypeError('Arguments must be Buffers')
  }

  if (a === b) return 0

  var x = a.length
  var y = b.length

  for (var i = 0, len = Math.min(x, y); i < len; ++i) {
    if (a[i] !== b[i]) {
      x = a[i]
      y = b[i]
      break
    }
  }

  if (x < y) return -1
  if (y < x) return 1
  return 0
}

Buffer.isEncoding = function isEncoding (encoding) {
  switch (String(encoding).toLowerCase()) {
    case 'hex':
    case 'utf8':
    case 'utf-8':
    case 'ascii':
    case 'latin1':
    case 'binary':
    case 'base64':
    case 'ucs2':
    case 'ucs-2':
    case 'utf16le':
    case 'utf-16le':
      return true
    default:
      return false
  }
}

Buffer.concat = function concat (list, length) {
  if (!isArray(list)) {
    throw new TypeError('"list" argument must be an Array of Buffers')
  }

  if (list.length === 0) {
    return Buffer.alloc(0)
  }

  var i
  if (length === undefined) {
    length = 0
    for (i = 0; i < list.length; ++i) {
      length += list[i].length
    }
  }

  var buffer = Buffer.allocUnsafe(length)
  var pos = 0
  for (i = 0; i < list.length; ++i) {
    var buf = list[i]
    if (!Buffer.isBuffer(buf)) {
      throw new TypeError('"list" argument must be an Array of Buffers')
    }
    buf.copy(buffer, pos)
    pos += buf.length
  }
  return buffer
}

function byteLength (string, encoding) {
  if (Buffer.isBuffer(string)) {
    return string.length
  }
  if (typeof ArrayBuffer !== 'undefined' && typeof ArrayBuffer.isView === 'function' &&
      (ArrayBuffer.isView(string) || string instanceof ArrayBuffer)) {
    return string.byteLength
  }
  if (typeof string !== 'string') {
    string = '' + string
  }

  var len = string.length
  if (len === 0) return 0

  // Use a for loop to avoid recursion
  var loweredCase = false
  for (;;) {
    switch (encoding) {
      case 'ascii':
      case 'latin1':
      case 'binary':
        return len
      case 'utf8':
      case 'utf-8':
      case undefined:
        return utf8ToBytes(string).length
      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return len * 2
      case 'hex':
        return len >>> 1
      case 'base64':
        return base64ToBytes(string).length
      default:
        if (loweredCase) return utf8ToBytes(string).length // assume utf8
        encoding = ('' + encoding).toLowerCase()
        loweredCase = true
    }
  }
}
Buffer.byteLength = byteLength

function slowToString (encoding, start, end) {
  var loweredCase = false

  // No need to verify that "this.length <= MAX_UINT32" since it's a read-only
  // property of a typed array.

  // This behaves neither like String nor Uint8Array in that we set start/end
  // to their upper/lower bounds if the value passed is out of range.
  // undefined is handled specially as per ECMA-262 6th Edition,
  // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.
  if (start === undefined || start < 0) {
    start = 0
  }
  // Return early if start > this.length. Done here to prevent potential uint32
  // coercion fail below.
  if (start > this.length) {
    return ''
  }

  if (end === undefined || end > this.length) {
    end = this.length
  }

  if (end <= 0) {
    return ''
  }

  // Force coersion to uint32. This will also coerce falsey/NaN values to 0.
  end >>>= 0
  start >>>= 0

  if (end <= start) {
    return ''
  }

  if (!encoding) encoding = 'utf8'

  while (true) {
    switch (encoding) {
      case 'hex':
        return hexSlice(this, start, end)

      case 'utf8':
      case 'utf-8':
        return utf8Slice(this, start, end)

      case 'ascii':
        return asciiSlice(this, start, end)

      case 'latin1':
      case 'binary':
        return latin1Slice(this, start, end)

      case 'base64':
        return base64Slice(this, start, end)

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return utf16leSlice(this, start, end)

      default:
        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
        encoding = (encoding + '').toLowerCase()
        loweredCase = true
    }
  }
}

// The property is used by `Buffer.isBuffer` and `is-buffer` (in Safari 5-7) to detect
// Buffer instances.
Buffer.prototype._isBuffer = true

function swap (b, n, m) {
  var i = b[n]
  b[n] = b[m]
  b[m] = i
}

Buffer.prototype.swap16 = function swap16 () {
  var len = this.length
  if (len % 2 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 16-bits')
  }
  for (var i = 0; i < len; i += 2) {
    swap(this, i, i + 1)
  }
  return this
}

Buffer.prototype.swap32 = function swap32 () {
  var len = this.length
  if (len % 4 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 32-bits')
  }
  for (var i = 0; i < len; i += 4) {
    swap(this, i, i + 3)
    swap(this, i + 1, i + 2)
  }
  return this
}

Buffer.prototype.swap64 = function swap64 () {
  var len = this.length
  if (len % 8 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 64-bits')
  }
  for (var i = 0; i < len; i += 8) {
    swap(this, i, i + 7)
    swap(this, i + 1, i + 6)
    swap(this, i + 2, i + 5)
    swap(this, i + 3, i + 4)
  }
  return this
}

Buffer.prototype.toString = function toString () {
  var length = this.length | 0
  if (length === 0) return ''
  if (arguments.length === 0) return utf8Slice(this, 0, length)
  return slowToString.apply(this, arguments)
}

Buffer.prototype.equals = function equals (b) {
  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')
  if (this === b) return true
  return Buffer.compare(this, b) === 0
}

Buffer.prototype.inspect = function inspect () {
  var str = ''
  var max = exports.INSPECT_MAX_BYTES
  if (this.length > 0) {
    str = this.toString('hex', 0, max).match(/.{2}/g).join(' ')
    if (this.length > max) str += ' ... '
  }
  return '<Buffer ' + str + '>'
}

Buffer.prototype.compare = function compare (target, start, end, thisStart, thisEnd) {
  if (!Buffer.isBuffer(target)) {
    throw new TypeError('Argument must be a Buffer')
  }

  if (start === undefined) {
    start = 0
  }
  if (end === undefined) {
    end = target ? target.length : 0
  }
  if (thisStart === undefined) {
    thisStart = 0
  }
  if (thisEnd === undefined) {
    thisEnd = this.length
  }

  if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
    throw new RangeError('out of range index')
  }

  if (thisStart >= thisEnd && start >= end) {
    return 0
  }
  if (thisStart >= thisEnd) {
    return -1
  }
  if (start >= end) {
    return 1
  }

  start >>>= 0
  end >>>= 0
  thisStart >>>= 0
  thisEnd >>>= 0

  if (this === target) return 0

  var x = thisEnd - thisStart
  var y = end - start
  var len = Math.min(x, y)

  var thisCopy = this.slice(thisStart, thisEnd)
  var targetCopy = target.slice(start, end)

  for (var i = 0; i < len; ++i) {
    if (thisCopy[i] !== targetCopy[i]) {
      x = thisCopy[i]
      y = targetCopy[i]
      break
    }
  }

  if (x < y) return -1
  if (y < x) return 1
  return 0
}

// Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,
// OR the last index of `val` in `buffer` at offset <= `byteOffset`.
//
// Arguments:
// - buffer - a Buffer to search
// - val - a string, Buffer, or number
// - byteOffset - an index into `buffer`; will be clamped to an int32
// - encoding - an optional encoding, relevant is val is a string
// - dir - true for indexOf, false for lastIndexOf
function bidirectionalIndexOf (buffer, val, byteOffset, encoding, dir) {
  // Empty buffer means no match
  if (buffer.length === 0) return -1

  // Normalize byteOffset
  if (typeof byteOffset === 'string') {
    encoding = byteOffset
    byteOffset = 0
  } else if (byteOffset > 0x7fffffff) {
    byteOffset = 0x7fffffff
  } else if (byteOffset < -0x80000000) {
    byteOffset = -0x80000000
  }
  byteOffset = +byteOffset  // Coerce to Number.
  if (isNaN(byteOffset)) {
    // byteOffset: it it's undefined, null, NaN, "foo", etc, search whole buffer
    byteOffset = dir ? 0 : (buffer.length - 1)
  }

  // Normalize byteOffset: negative offsets start from the end of the buffer
  if (byteOffset < 0) byteOffset = buffer.length + byteOffset
  if (byteOffset >= buffer.length) {
    if (dir) return -1
    else byteOffset = buffer.length - 1
  } else if (byteOffset < 0) {
    if (dir) byteOffset = 0
    else return -1
  }

  // Normalize val
  if (typeof val === 'string') {
    val = Buffer.from(val, encoding)
  }

  // Finally, search either indexOf (if dir is true) or lastIndexOf
  if (Buffer.isBuffer(val)) {
    // Special case: looking for empty string/buffer always fails
    if (val.length === 0) {
      return -1
    }
    return arrayIndexOf(buffer, val, byteOffset, encoding, dir)
  } else if (typeof val === 'number') {
    val = val & 0xFF // Search for a byte value [0-255]
    if (Buffer.TYPED_ARRAY_SUPPORT &&
        typeof Uint8Array.prototype.indexOf === 'function') {
      if (dir) {
        return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset)
      } else {
        return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset)
      }
    }
    return arrayIndexOf(buffer, [ val ], byteOffset, encoding, dir)
  }

  throw new TypeError('val must be string, number or Buffer')
}

function arrayIndexOf (arr, val, byteOffset, encoding, dir) {
  var indexSize = 1
  var arrLength = arr.length
  var valLength = val.length

  if (encoding !== undefined) {
    encoding = String(encoding).toLowerCase()
    if (encoding === 'ucs2' || encoding === 'ucs-2' ||
        encoding === 'utf16le' || encoding === 'utf-16le') {
      if (arr.length < 2 || val.length < 2) {
        return -1
      }
      indexSize = 2
      arrLength /= 2
      valLength /= 2
      byteOffset /= 2
    }
  }

  function read (buf, i) {
    if (indexSize === 1) {
      return buf[i]
    } else {
      return buf.readUInt16BE(i * indexSize)
    }
  }

  var i
  if (dir) {
    var foundIndex = -1
    for (i = byteOffset; i < arrLength; i++) {
      if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {
        if (foundIndex === -1) foundIndex = i
        if (i - foundIndex + 1 === valLength) return foundIndex * indexSize
      } else {
        if (foundIndex !== -1) i -= i - foundIndex
        foundIndex = -1
      }
    }
  } else {
    if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength
    for (i = byteOffset; i >= 0; i--) {
      var found = true
      for (var j = 0; j < valLength; j++) {
        if (read(arr, i + j) !== read(val, j)) {
          found = false
          break
        }
      }
      if (found) return i
    }
  }

  return -1
}

Buffer.prototype.includes = function includes (val, byteOffset, encoding) {
  return this.indexOf(val, byteOffset, encoding) !== -1
}

Buffer.prototype.indexOf = function indexOf (val, byteOffset, encoding) {
  return bidirectionalIndexOf(this, val, byteOffset, encoding, true)
}

Buffer.prototype.lastIndexOf = function lastIndexOf (val, byteOffset, encoding) {
  return bidirectionalIndexOf(this, val, byteOffset, encoding, false)
}

function hexWrite (buf, string, offset, length) {
  offset = Number(offset) || 0
  var remaining = buf.length - offset
  if (!length) {
    length = remaining
  } else {
    length = Number(length)
    if (length > remaining) {
      length = remaining
    }
  }

  // must be an even number of digits
  var strLen = string.length
  if (strLen % 2 !== 0) throw new TypeError('Invalid hex string')

  if (length > strLen / 2) {
    length = strLen / 2
  }
  for (var i = 0; i < length; ++i) {
    var parsed = parseInt(string.substr(i * 2, 2), 16)
    if (isNaN(parsed)) return i
    buf[offset + i] = parsed
  }
  return i
}

function utf8Write (buf, string, offset, length) {
  return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length)
}

function asciiWrite (buf, string, offset, length) {
  return blitBuffer(asciiToBytes(string), buf, offset, length)
}

function latin1Write (buf, string, offset, length) {
  return asciiWrite(buf, string, offset, length)
}

function base64Write (buf, string, offset, length) {
  return blitBuffer(base64ToBytes(string), buf, offset, length)
}

function ucs2Write (buf, string, offset, length) {
  return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length)
}

Buffer.prototype.write = function write (string, offset, length, encoding) {
  // Buffer#write(string)
  if (offset === undefined) {
    encoding = 'utf8'
    length = this.length
    offset = 0
  // Buffer#write(string, encoding)
  } else if (length === undefined && typeof offset === 'string') {
    encoding = offset
    length = this.length
    offset = 0
  // Buffer#write(string, offset[, length][, encoding])
  } else if (isFinite(offset)) {
    offset = offset | 0
    if (isFinite(length)) {
      length = length | 0
      if (encoding === undefined) encoding = 'utf8'
    } else {
      encoding = length
      length = undefined
    }
  // legacy write(string, encoding, offset, length) - remove in v0.13
  } else {
    throw new Error(
      'Buffer.write(string, encoding, offset[, length]) is no longer supported'
    )
  }

  var remaining = this.length - offset
  if (length === undefined || length > remaining) length = remaining

  if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {
    throw new RangeError('Attempt to write outside buffer bounds')
  }

  if (!encoding) encoding = 'utf8'

  var loweredCase = false
  for (;;) {
    switch (encoding) {
      case 'hex':
        return hexWrite(this, string, offset, length)

      case 'utf8':
      case 'utf-8':
        return utf8Write(this, string, offset, length)

      case 'ascii':
        return asciiWrite(this, string, offset, length)

      case 'latin1':
      case 'binary':
        return latin1Write(this, string, offset, length)

      case 'base64':
        // Warning: maxLength not taken into account in base64Write
        return base64Write(this, string, offset, length)

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return ucs2Write(this, string, offset, length)

      default:
        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
        encoding = ('' + encoding).toLowerCase()
        loweredCase = true
    }
  }
}

Buffer.prototype.toJSON = function toJSON () {
  return {
    type: 'Buffer',
    data: Array.prototype.slice.call(this._arr || this, 0)
  }
}

function base64Slice (buf, start, end) {
  if (start === 0 && end === buf.length) {
    return base64.fromByteArray(buf)
  } else {
    return base64.fromByteArray(buf.slice(start, end))
  }
}

function utf8Slice (buf, start, end) {
  end = Math.min(buf.length, end)
  var res = []

  var i = start
  while (i < end) {
    var firstByte = buf[i]
    var codePoint = null
    var bytesPerSequence = (firstByte > 0xEF) ? 4
      : (firstByte > 0xDF) ? 3
      : (firstByte > 0xBF) ? 2
      : 1

    if (i + bytesPerSequence <= end) {
      var secondByte, thirdByte, fourthByte, tempCodePoint

      switch (bytesPerSequence) {
        case 1:
          if (firstByte < 0x80) {
            codePoint = firstByte
          }
          break
        case 2:
          secondByte = buf[i + 1]
          if ((secondByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0x1F) << 0x6 | (secondByte & 0x3F)
            if (tempCodePoint > 0x7F) {
              codePoint = tempCodePoint
            }
          }
          break
        case 3:
          secondByte = buf[i + 1]
          thirdByte = buf[i + 2]
          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | (thirdByte & 0x3F)
            if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {
              codePoint = tempCodePoint
            }
          }
          break
        case 4:
          secondByte = buf[i + 1]
          thirdByte = buf[i + 2]
          fourthByte = buf[i + 3]
          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | (fourthByte & 0x3F)
            if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {
              codePoint = tempCodePoint
            }
          }
      }
    }

    if (codePoint === null) {
      // we did not generate a valid codePoint so insert a
      // replacement char (U+FFFD) and advance only 1 byte
      codePoint = 0xFFFD
      bytesPerSequence = 1
    } else if (codePoint > 0xFFFF) {
      // encode to utf16 (surrogate pair dance)
      codePoint -= 0x10000
      res.push(codePoint >>> 10 & 0x3FF | 0xD800)
      codePoint = 0xDC00 | codePoint & 0x3FF
    }

    res.push(codePoint)
    i += bytesPerSequence
  }

  return decodeCodePointsArray(res)
}

// Based on http://stackoverflow.com/a/22747272/680742, the browser with
// the lowest limit is Chrome, with 0x10000 args.
// We go 1 magnitude less, for safety
var MAX_ARGUMENTS_LENGTH = 0x1000

function decodeCodePointsArray (codePoints) {
  var len = codePoints.length
  if (len <= MAX_ARGUMENTS_LENGTH) {
    return String.fromCharCode.apply(String, codePoints) // avoid extra slice()
  }

  // Decode in chunks to avoid "call stack size exceeded".
  var res = ''
  var i = 0
  while (i < len) {
    res += String.fromCharCode.apply(
      String,
      codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)
    )
  }
  return res
}

function asciiSlice (buf, start, end) {
  var ret = ''
  end = Math.min(buf.length, end)

  for (var i = start; i < end; ++i) {
    ret += String.fromCharCode(buf[i] & 0x7F)
  }
  return ret
}

function latin1Slice (buf, start, end) {
  var ret = ''
  end = Math.min(buf.length, end)

  for (var i = start; i < end; ++i) {
    ret += String.fromCharCode(buf[i])
  }
  return ret
}

function hexSlice (buf, start, end) {
  var len = buf.length

  if (!start || start < 0) start = 0
  if (!end || end < 0 || end > len) end = len

  var out = ''
  for (var i = start; i < end; ++i) {
    out += toHex(buf[i])
  }
  return out
}

function utf16leSlice (buf, start, end) {
  var bytes = buf.slice(start, end)
  var res = ''
  for (var i = 0; i < bytes.length; i += 2) {
    res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256)
  }
  return res
}

Buffer.prototype.slice = function slice (start, end) {
  var len = this.length
  start = ~~start
  end = end === undefined ? len : ~~end

  if (start < 0) {
    start += len
    if (start < 0) start = 0
  } else if (start > len) {
    start = len
  }

  if (end < 0) {
    end += len
    if (end < 0) end = 0
  } else if (end > len) {
    end = len
  }

  if (end < start) end = start

  var newBuf
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    newBuf = this.subarray(start, end)
    newBuf.__proto__ = Buffer.prototype
  } else {
    var sliceLen = end - start
    newBuf = new Buffer(sliceLen, undefined)
    for (var i = 0; i < sliceLen; ++i) {
      newBuf[i] = this[i + start]
    }
  }

  return newBuf
}

/*
 * Need to make sure that buffer isn't trying to write out of bounds.
 */
function checkOffset (offset, ext, length) {
  if ((offset % 1) !== 0 || offset < 0) throw new RangeError('offset is not uint')
  if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length')
}

Buffer.prototype.readUIntLE = function readUIntLE (offset, byteLength, noAssert) {
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var val = this[offset]
  var mul = 1
  var i = 0
  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul
  }

  return val
}

Buffer.prototype.readUIntBE = function readUIntBE (offset, byteLength, noAssert) {
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) {
    checkOffset(offset, byteLength, this.length)
  }

  var val = this[offset + --byteLength]
  var mul = 1
  while (byteLength > 0 && (mul *= 0x100)) {
    val += this[offset + --byteLength] * mul
  }

  return val
}

Buffer.prototype.readUInt8 = function readUInt8 (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 1, this.length)
  return this[offset]
}

Buffer.prototype.readUInt16LE = function readUInt16LE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length)
  return this[offset] | (this[offset + 1] << 8)
}

Buffer.prototype.readUInt16BE = function readUInt16BE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length)
  return (this[offset] << 8) | this[offset + 1]
}

Buffer.prototype.readUInt32LE = function readUInt32LE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)

  return ((this[offset]) |
      (this[offset + 1] << 8) |
      (this[offset + 2] << 16)) +
      (this[offset + 3] * 0x1000000)
}

Buffer.prototype.readUInt32BE = function readUInt32BE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset] * 0x1000000) +
    ((this[offset + 1] << 16) |
    (this[offset + 2] << 8) |
    this[offset + 3])
}

Buffer.prototype.readIntLE = function readIntLE (offset, byteLength, noAssert) {
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var val = this[offset]
  var mul = 1
  var i = 0
  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul
  }
  mul *= 0x80

  if (val >= mul) val -= Math.pow(2, 8 * byteLength)

  return val
}

Buffer.prototype.readIntBE = function readIntBE (offset, byteLength, noAssert) {
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var i = byteLength
  var mul = 1
  var val = this[offset + --i]
  while (i > 0 && (mul *= 0x100)) {
    val += this[offset + --i] * mul
  }
  mul *= 0x80

  if (val >= mul) val -= Math.pow(2, 8 * byteLength)

  return val
}

Buffer.prototype.readInt8 = function readInt8 (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 1, this.length)
  if (!(this[offset] & 0x80)) return (this[offset])
  return ((0xff - this[offset] + 1) * -1)
}

Buffer.prototype.readInt16LE = function readInt16LE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length)
  var val = this[offset] | (this[offset + 1] << 8)
  return (val & 0x8000) ? val | 0xFFFF0000 : val
}

Buffer.prototype.readInt16BE = function readInt16BE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length)
  var val = this[offset + 1] | (this[offset] << 8)
  return (val & 0x8000) ? val | 0xFFFF0000 : val
}

Buffer.prototype.readInt32LE = function readInt32LE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset]) |
    (this[offset + 1] << 8) |
    (this[offset + 2] << 16) |
    (this[offset + 3] << 24)
}

Buffer.prototype.readInt32BE = function readInt32BE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset] << 24) |
    (this[offset + 1] << 16) |
    (this[offset + 2] << 8) |
    (this[offset + 3])
}

Buffer.prototype.readFloatLE = function readFloatLE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)
  return ieee754.read(this, offset, true, 23, 4)
}

Buffer.prototype.readFloatBE = function readFloatBE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)
  return ieee754.read(this, offset, false, 23, 4)
}

Buffer.prototype.readDoubleLE = function readDoubleLE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 8, this.length)
  return ieee754.read(this, offset, true, 52, 8)
}

Buffer.prototype.readDoubleBE = function readDoubleBE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 8, this.length)
  return ieee754.read(this, offset, false, 52, 8)
}

function checkInt (buf, value, offset, ext, max, min) {
  if (!Buffer.isBuffer(buf)) throw new TypeError('"buffer" argument must be a Buffer instance')
  if (value > max || value < min) throw new RangeError('"value" argument is out of bounds')
  if (offset + ext > buf.length) throw new RangeError('Index out of range')
}

Buffer.prototype.writeUIntLE = function writeUIntLE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) {
    var maxBytes = Math.pow(2, 8 * byteLength) - 1
    checkInt(this, value, offset, byteLength, maxBytes, 0)
  }

  var mul = 1
  var i = 0
  this[offset] = value & 0xFF
  while (++i < byteLength && (mul *= 0x100)) {
    this[offset + i] = (value / mul) & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeUIntBE = function writeUIntBE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) {
    var maxBytes = Math.pow(2, 8 * byteLength) - 1
    checkInt(this, value, offset, byteLength, maxBytes, 0)
  }

  var i = byteLength - 1
  var mul = 1
  this[offset + i] = value & 0xFF
  while (--i >= 0 && (mul *= 0x100)) {
    this[offset + i] = (value / mul) & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeUInt8 = function writeUInt8 (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0)
  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)
  this[offset] = (value & 0xff)
  return offset + 1
}

function objectWriteUInt16 (buf, value, offset, littleEndian) {
  if (value < 0) value = 0xffff + value + 1
  for (var i = 0, j = Math.min(buf.length - offset, 2); i < j; ++i) {
    buf[offset + i] = (value & (0xff << (8 * (littleEndian ? i : 1 - i)))) >>>
      (littleEndian ? i : 1 - i) * 8
  }
}

Buffer.prototype.writeUInt16LE = function writeUInt16LE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value & 0xff)
    this[offset + 1] = (value >>> 8)
  } else {
    objectWriteUInt16(this, value, offset, true)
  }
  return offset + 2
}

Buffer.prototype.writeUInt16BE = function writeUInt16BE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 8)
    this[offset + 1] = (value & 0xff)
  } else {
    objectWriteUInt16(this, value, offset, false)
  }
  return offset + 2
}

function objectWriteUInt32 (buf, value, offset, littleEndian) {
  if (value < 0) value = 0xffffffff + value + 1
  for (var i = 0, j = Math.min(buf.length - offset, 4); i < j; ++i) {
    buf[offset + i] = (value >>> (littleEndian ? i : 3 - i) * 8) & 0xff
  }
}

Buffer.prototype.writeUInt32LE = function writeUInt32LE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset + 3] = (value >>> 24)
    this[offset + 2] = (value >>> 16)
    this[offset + 1] = (value >>> 8)
    this[offset] = (value & 0xff)
  } else {
    objectWriteUInt32(this, value, offset, true)
  }
  return offset + 4
}

Buffer.prototype.writeUInt32BE = function writeUInt32BE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 24)
    this[offset + 1] = (value >>> 16)
    this[offset + 2] = (value >>> 8)
    this[offset + 3] = (value & 0xff)
  } else {
    objectWriteUInt32(this, value, offset, false)
  }
  return offset + 4
}

Buffer.prototype.writeIntLE = function writeIntLE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) {
    var limit = Math.pow(2, 8 * byteLength - 1)

    checkInt(this, value, offset, byteLength, limit - 1, -limit)
  }

  var i = 0
  var mul = 1
  var sub = 0
  this[offset] = value & 0xFF
  while (++i < byteLength && (mul *= 0x100)) {
    if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {
      sub = 1
    }
    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeIntBE = function writeIntBE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) {
    var limit = Math.pow(2, 8 * byteLength - 1)

    checkInt(this, value, offset, byteLength, limit - 1, -limit)
  }

  var i = byteLength - 1
  var mul = 1
  var sub = 0
  this[offset + i] = value & 0xFF
  while (--i >= 0 && (mul *= 0x100)) {
    if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {
      sub = 1
    }
    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeInt8 = function writeInt8 (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80)
  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)
  if (value < 0) value = 0xff + value + 1
  this[offset] = (value & 0xff)
  return offset + 1
}

Buffer.prototype.writeInt16LE = function writeInt16LE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value & 0xff)
    this[offset + 1] = (value >>> 8)
  } else {
    objectWriteUInt16(this, value, offset, true)
  }
  return offset + 2
}

Buffer.prototype.writeInt16BE = function writeInt16BE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 8)
    this[offset + 1] = (value & 0xff)
  } else {
    objectWriteUInt16(this, value, offset, false)
  }
  return offset + 2
}

Buffer.prototype.writeInt32LE = function writeInt32LE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value & 0xff)
    this[offset + 1] = (value >>> 8)
    this[offset + 2] = (value >>> 16)
    this[offset + 3] = (value >>> 24)
  } else {
    objectWriteUInt32(this, value, offset, true)
  }
  return offset + 4
}

Buffer.prototype.writeInt32BE = function writeInt32BE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
  if (value < 0) value = 0xffffffff + value + 1
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 24)
    this[offset + 1] = (value >>> 16)
    this[offset + 2] = (value >>> 8)
    this[offset + 3] = (value & 0xff)
  } else {
    objectWriteUInt32(this, value, offset, false)
  }
  return offset + 4
}

function checkIEEE754 (buf, value, offset, ext, max, min) {
  if (offset + ext > buf.length) throw new RangeError('Index out of range')
  if (offset < 0) throw new RangeError('Index out of range')
}

function writeFloat (buf, value, offset, littleEndian, noAssert) {
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38)
  }
  ieee754.write(buf, value, offset, littleEndian, 23, 4)
  return offset + 4
}

Buffer.prototype.writeFloatLE = function writeFloatLE (value, offset, noAssert) {
  return writeFloat(this, value, offset, true, noAssert)
}

Buffer.prototype.writeFloatBE = function writeFloatBE (value, offset, noAssert) {
  return writeFloat(this, value, offset, false, noAssert)
}

function writeDouble (buf, value, offset, littleEndian, noAssert) {
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308)
  }
  ieee754.write(buf, value, offset, littleEndian, 52, 8)
  return offset + 8
}

Buffer.prototype.writeDoubleLE = function writeDoubleLE (value, offset, noAssert) {
  return writeDouble(this, value, offset, true, noAssert)
}

Buffer.prototype.writeDoubleBE = function writeDoubleBE (value, offset, noAssert) {
  return writeDouble(this, value, offset, false, noAssert)
}

// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)
Buffer.prototype.copy = function copy (target, targetStart, start, end) {
  if (!start) start = 0
  if (!end && end !== 0) end = this.length
  if (targetStart >= target.length) targetStart = target.length
  if (!targetStart) targetStart = 0
  if (end > 0 && end < start) end = start

  // Copy 0 bytes; we're done
  if (end === start) return 0
  if (target.length === 0 || this.length === 0) return 0

  // Fatal error conditions
  if (targetStart < 0) {
    throw new RangeError('targetStart out of bounds')
  }
  if (start < 0 || start >= this.length) throw new RangeError('sourceStart out of bounds')
  if (end < 0) throw new RangeError('sourceEnd out of bounds')

  // Are we oob?
  if (end > this.length) end = this.length
  if (target.length - targetStart < end - start) {
    end = target.length - targetStart + start
  }

  var len = end - start
  var i

  if (this === target && start < targetStart && targetStart < end) {
    // descending copy from end
    for (i = len - 1; i >= 0; --i) {
      target[i + targetStart] = this[i + start]
    }
  } else if (len < 1000 || !Buffer.TYPED_ARRAY_SUPPORT) {
    // ascending copy from start
    for (i = 0; i < len; ++i) {
      target[i + targetStart] = this[i + start]
    }
  } else {
    Uint8Array.prototype.set.call(
      target,
      this.subarray(start, start + len),
      targetStart
    )
  }

  return len
}

// Usage:
//    buffer.fill(number[, offset[, end]])
//    buffer.fill(buffer[, offset[, end]])
//    buffer.fill(string[, offset[, end]][, encoding])
Buffer.prototype.fill = function fill (val, start, end, encoding) {
  // Handle string cases:
  if (typeof val === 'string') {
    if (typeof start === 'string') {
      encoding = start
      start = 0
      end = this.length
    } else if (typeof end === 'string') {
      encoding = end
      end = this.length
    }
    if (val.length === 1) {
      var code = val.charCodeAt(0)
      if (code < 256) {
        val = code
      }
    }
    if (encoding !== undefined && typeof encoding !== 'string') {
      throw new TypeError('encoding must be a string')
    }
    if (typeof encoding === 'string' && !Buffer.isEncoding(encoding)) {
      throw new TypeError('Unknown encoding: ' + encoding)
    }
  } else if (typeof val === 'number') {
    val = val & 255
  }

  // Invalid ranges are not set to a default, so can range check early.
  if (start < 0 || this.length < start || this.length < end) {
    throw new RangeError('Out of range index')
  }

  if (end <= start) {
    return this
  }

  start = start >>> 0
  end = end === undefined ? this.length : end >>> 0

  if (!val) val = 0

  var i
  if (typeof val === 'number') {
    for (i = start; i < end; ++i) {
      this[i] = val
    }
  } else {
    var bytes = Buffer.isBuffer(val)
      ? val
      : utf8ToBytes(new Buffer(val, encoding).toString())
    var len = bytes.length
    for (i = 0; i < end - start; ++i) {
      this[i + start] = bytes[i % len]
    }
  }

  return this
}

// HELPER FUNCTIONS
// ================

var INVALID_BASE64_RE = /[^+\/0-9A-Za-z-_]/g

function base64clean (str) {
  // Node strips out invalid characters like \n and \t from the string, base64-js does not
  str = stringtrim(str).replace(INVALID_BASE64_RE, '')
  // Node converts strings with length < 2 to ''
  if (str.length < 2) return ''
  // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not
  while (str.length % 4 !== 0) {
    str = str + '='
  }
  return str
}

function stringtrim (str) {
  if (str.trim) return str.trim()
  return str.replace(/^\s+|\s+$/g, '')
}

function toHex (n) {
  if (n < 16) return '0' + n.toString(16)
  return n.toString(16)
}

function utf8ToBytes (string, units) {
  units = units || Infinity
  var codePoint
  var length = string.length
  var leadSurrogate = null
  var bytes = []

  for (var i = 0; i < length; ++i) {
    codePoint = string.charCodeAt(i)

    // is surrogate component
    if (codePoint > 0xD7FF && codePoint < 0xE000) {
      // last char was a lead
      if (!leadSurrogate) {
        // no lead yet
        if (codePoint > 0xDBFF) {
          // unexpected trail
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
          continue
        } else if (i + 1 === length) {
          // unpaired lead
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
          continue
        }

        // valid lead
        leadSurrogate = codePoint

        continue
      }

      // 2 leads in a row
      if (codePoint < 0xDC00) {
        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
        leadSurrogate = codePoint
        continue
      }

      // valid surrogate pair
      codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000
    } else if (leadSurrogate) {
      // valid bmp char, but last char was a lead
      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
    }

    leadSurrogate = null

    // encode utf8
    if (codePoint < 0x80) {
      if ((units -= 1) < 0) break
      bytes.push(codePoint)
    } else if (codePoint < 0x800) {
      if ((units -= 2) < 0) break
      bytes.push(
        codePoint >> 0x6 | 0xC0,
        codePoint & 0x3F | 0x80
      )
    } else if (codePoint < 0x10000) {
      if ((units -= 3) < 0) break
      bytes.push(
        codePoint >> 0xC | 0xE0,
        codePoint >> 0x6 & 0x3F | 0x80,
        codePoint & 0x3F | 0x80
      )
    } else if (codePoint < 0x110000) {
      if ((units -= 4) < 0) break
      bytes.push(
        codePoint >> 0x12 | 0xF0,
        codePoint >> 0xC & 0x3F | 0x80,
        codePoint >> 0x6 & 0x3F | 0x80,
        codePoint & 0x3F | 0x80
      )
    } else {
      throw new Error('Invalid code point')
    }
  }

  return bytes
}

function asciiToBytes (str) {
  var byteArray = []
  for (var i = 0; i < str.length; ++i) {
    // Node's code seems to be doing this and not & 0x7F..
    byteArray.push(str.charCodeAt(i) & 0xFF)
  }
  return byteArray
}

function utf16leToBytes (str, units) {
  var c, hi, lo
  var byteArray = []
  for (var i = 0; i < str.length; ++i) {
    if ((units -= 2) < 0) break

    c = str.charCodeAt(i)
    hi = c >> 8
    lo = c % 256
    byteArray.push(lo)
    byteArray.push(hi)
  }

  return byteArray
}

function base64ToBytes (str) {
  return base64.toByteArray(base64clean(str))
}

function blitBuffer (src, dst, offset, length) {
  for (var i = 0; i < length; ++i) {
    if ((i + offset >= dst.length) || (i >= src.length)) break
    dst[i + offset] = src[i]
  }
  return i
}

function isnan (val) {
  return val !== val // eslint-disable-line no-self-compare
}

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(14)))

/***/ }),
/* 36 */
/***/ (function(module, exports) {

exports.read = function (buffer, offset, isLE, mLen, nBytes) {
  var e, m
  var eLen = nBytes * 8 - mLen - 1
  var eMax = (1 << eLen) - 1
  var eBias = eMax >> 1
  var nBits = -7
  var i = isLE ? (nBytes - 1) : 0
  var d = isLE ? -1 : 1
  var s = buffer[offset + i]

  i += d

  e = s & ((1 << (-nBits)) - 1)
  s >>= (-nBits)
  nBits += eLen
  for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8) {}

  m = e & ((1 << (-nBits)) - 1)
  e >>= (-nBits)
  nBits += mLen
  for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8) {}

  if (e === 0) {
    e = 1 - eBias
  } else if (e === eMax) {
    return m ? NaN : ((s ? -1 : 1) * Infinity)
  } else {
    m = m + Math.pow(2, mLen)
    e = e - eBias
  }
  return (s ? -1 : 1) * m * Math.pow(2, e - mLen)
}

exports.write = function (buffer, value, offset, isLE, mLen, nBytes) {
  var e, m, c
  var eLen = nBytes * 8 - mLen - 1
  var eMax = (1 << eLen) - 1
  var eBias = eMax >> 1
  var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0)
  var i = isLE ? 0 : (nBytes - 1)
  var d = isLE ? 1 : -1
  var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0

  value = Math.abs(value)

  if (isNaN(value) || value === Infinity) {
    m = isNaN(value) ? 1 : 0
    e = eMax
  } else {
    e = Math.floor(Math.log(value) / Math.LN2)
    if (value * (c = Math.pow(2, -e)) < 1) {
      e--
      c *= 2
    }
    if (e + eBias >= 1) {
      value += rt / c
    } else {
      value += rt * Math.pow(2, 1 - eBias)
    }
    if (value * c >= 2) {
      e++
      c /= 2
    }

    if (e + eBias >= eMax) {
      m = 0
      e = eMax
    } else if (e + eBias >= 1) {
      m = (value * c - 1) * Math.pow(2, mLen)
      e = e + eBias
    } else {
      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen)
      e = 0
    }
  }

  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}

  e = (e << mLen) | m
  eLen += mLen
  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}

  buffer[offset + i - d] |= s * 128
}


/***/ }),
/* 37 */
/***/ (function(module, exports) {

var toString = {}.toString;

module.exports = Array.isArray || function (arr) {
  return toString.call(arr) == '[object Array]';
};


/***/ }),
/* 38 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _metal = __webpack_require__(0);

var _metalUri = __webpack_require__(6);

var _metalUri2 = _interopRequireDefault(_metalUri);

var _metalPromise = __webpack_require__(39);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var Ajax = function () {
	function Ajax() {
		_classCallCheck(this, Ajax);
	}

	_createClass(Ajax, null, [{
		key: 'parseResponseHeaders',


		/**
   * XmlHttpRequest's getAllResponseHeaders() method returns a string of
   * response headers according to the format described on the spec:
   * {@link http://www.w3.org/TR/XMLHttpRequest/#the-getallresponseheaders-method}.
   * This method parses that string into a user-friendly name/value pair
   * object.
   * @param {string} allHeaders All headers as string.
   * @return {!Array.<Object<string, string>>}
   */
		value: function parseResponseHeaders(allHeaders) {
			var headers = [];
			if (!allHeaders) {
				return headers;
			}
			var pairs = allHeaders.split('\r\n');
			for (var i = 0; i < pairs.length; i++) {
				var index = pairs[i].indexOf(': ');
				if (index > 0) {
					var name = pairs[i].substring(0, index);
					var value = pairs[i].substring(index + 2);
					headers.push({
						name: name,
						value: value
					});
				}
			}
			return headers;
		}

		/**
   * Requests the url using XMLHttpRequest.
   * @param {!string} url
   * @param {!string} method
   * @param {?string} body
   * @param {MultiMap=} opt_headers
   * @param {MultiMap=} opt_params
   * @param {number=} opt_timeout
   * @param {boolean=} opt_sync
   * @param {boolean=} opt_withCredentials
   * @return {Promise} Deferred ajax request.
   * @protected
   */

	}, {
		key: 'request',
		value: function request(url, method, body, opt_headers, opt_params, opt_timeout, opt_sync, opt_withCredentials) {
			url = url || '';
			method = method || 'GET';

			var request = new XMLHttpRequest();

			var promise = new _metalPromise.CancellablePromise(function (resolve, reject) {
				request.onload = function () {
					if (request.aborted) {
						request.onerror();
						return;
					}
					resolve(request);
				};
				request.onerror = function () {
					var error = new Error('Request error');
					error.request = request;
					reject(error);
				};
			}).thenCatch(function (reason) {
				request.abort();
				throw reason;
			}).thenAlways(function () {
				clearTimeout(timeout);
			});

			url = new _metalUri2.default(url);

			if (opt_params) {
				url.addParametersFromMultiMap(opt_params).toString();
			}

			url = url.toString();

			request.open(method, url, !opt_sync);

			if (opt_withCredentials) {
				request.withCredentials = true;
			}

			if (opt_headers) {
				opt_headers.names().forEach(function (name) {
					request.setRequestHeader(name, opt_headers.getAll(name).join(', '));
				});
			}

			request.send((0, _metal.isDef)(body) ? body : null);

			if ((0, _metal.isDefAndNotNull)(opt_timeout)) {
				var timeout = setTimeout(function () {
					promise.cancel('Request timeout');
				}, opt_timeout);
			}

			return promise;
		}
	}]);

	return Ajax;
}();

exports.default = Ajax;

/***/ }),
/* 39 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*!
 * Promises polyfill from Google's Closure Library.
 *
 *      Copyright 2013 The Closure Library Authors. All Rights Reserved.
 *
 * NOTE(eduardo): Promise support is not ready on all supported browsers,
 * therefore metal-promise is temporarily using Google's promises as polyfill.
 * It supports cancellable promises and has clean and fast implementation.
 */



Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.CancellablePromise = undefined;

var _metal = __webpack_require__(0);

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * Provides a more strict interface for Thenables in terms of
 * http://promisesaplus.com for interop with {@see CancellablePromise}.
 *
 * @interface
 * @extends {IThenable.<TYPE>}
 * @template TYPE
 */
var Thenable = function Thenable() {};

/**
 * Adds callbacks that will operate on the result of the Thenable, returning a
 * new child Promise.
 *
 * If the Thenable is fulfilled, the {@code onFulfilled} callback will be
 * invoked with the fulfillment value as argument, and the child Promise will
 * be fulfilled with the return value of the callback. If the callback throws
 * an exception, the child Promise will be rejected with the thrown value
 * instead.
 *
 * If the Thenable is rejected, the {@code onRejected} callback will be invoked
 * with the rejection reason as argument, and the child Promise will be rejected
 * with the return value of the callback or thrown value.
 *
 * @param {?(function(this:THIS, TYPE):
 *             (RESULT|IThenable.<RESULT>|Thenable))=} opt_onFulfilled A
 *     function that will be invoked with the fulfillment value if the Promise
 *     is fullfilled.
 * @param {?(function(*): *)=} opt_onRejected A function that will be invoked
 *     with the rejection reason if the Promise is rejected.
 * @param {THIS=} opt_context An optional context object that will be the
 *     execution context for the callbacks. By default, functions are executed
 *     with the default this.
 * @return {!CancellablePromise.<RESULT>} A new Promise that will receive the
 *     result of the fulfillment or rejection callback.
 * @template RESULT,THIS
 */
Thenable.prototype.then = function () {};

/**
 * An expando property to indicate that an object implements
 * {@code Thenable}.
 *
 * {@see addImplementation}.
 *
 * @const
 */
Thenable.IMPLEMENTED_BY_PROP = '$goog_Thenable';

/**
 * Marks a given class (constructor) as an implementation of Thenable, so
 * that we can query that fact at runtime. The class must have already
 * implemented the interface.
 * Exports a 'then' method on the constructor prototype, so that the objects
 * also implement the extern {@see Thenable} interface for interop with
 * other Promise implementations.
 * @param {function(new:Thenable,...[?])} ctor The class constructor. The
 *     corresponding class must have already implemented the interface.
 */
Thenable.addImplementation = function (ctor) {
  ctor.prototype.then = ctor.prototype.then;
  ctor.prototype.$goog_Thenable = true;
};

/**
 * @param {*} object
 * @return {boolean} Whether a given instance implements {@code Thenable}.
 *     The class/superclass of the instance must call {@code addImplementation}.
 */
Thenable.isImplementedBy = function (object) {
  if (!object) {
    return false;
  }
  try {
    return !!object.$goog_Thenable;
  } catch (e) {
    // Property access seems to be forbidden.
    return false;
  }
};

/**
 * Like bind(), except that a 'this object' is not required. Useful when the
 * target function is already bound.
 *
 * Usage:
 * var g = partial(f, arg1, arg2);
 * g(arg3, arg4);
 *
 * @param {Function} fn A function to partially apply.
 * @param {...*} var_args Additional arguments that are partially applied to fn.
 * @return {!Function} A partially-applied form of the function bind() was
 *     invoked as a method of.
 */
var partial = function partial(fn) {
  var args = Array.prototype.slice.call(arguments, 1);
  return function () {
    // Clone the array (with slice()) and append additional arguments
    // to the existing arguments.
    var newArgs = args.slice();
    newArgs.push.apply(newArgs, arguments);
    return fn.apply(this, newArgs);
  };
};

/**
 * Promises provide a result that may be resolved asynchronously. A Promise may
 * be resolved by being fulfilled or rejected with a value, which will be known
 * as the fulfillment value or the rejection reason. Whether fulfilled or
 * rejected, the Promise result is immutable once it is set.
 *
 * Promises may represent results of any type, including undefined. Rejection
 * reasons are typically Errors, but may also be of any type. Closure Promises
 * allow for optional type annotations that enforce that fulfillment values are
 * of the appropriate types at compile time.
 *
 * The result of a Promise is accessible by calling {@code then} and registering
 * {@code onFulfilled} and {@code onRejected} callbacks. Once the Promise
 * resolves, the relevant callbacks are invoked with the fulfillment value or
 * rejection reason as argument. Callbacks are always invoked in the order they
 * were registered, even when additional {@code then} calls are made from inside
 * another callback. A callback is always run asynchronously sometime after the
 * scope containing the registering {@code then} invocation has returned.
 *
 * If a Promise is resolved with another Promise, the first Promise will block
 * until the second is resolved, and then assumes the same result as the second
 * Promise. This allows Promises to depend on the results of other Promises,
 * linking together multiple asynchronous operations.
 *
 * This implementation is compatible with the Promises/A+ specification and
 * passes that specification's conformance test suite. A Closure Promise may be
 * resolved with a Promise instance (or sufficiently compatible Promise-like
 * object) created by other Promise implementations. From the specification,
 * Promise-like objects are known as "Thenables".
 *
 * @see http://promisesaplus.com/
 *
 * @param {function(
 *             this:RESOLVER_CONTEXT,
 *             function((TYPE|IThenable.<TYPE>|Thenable)),
 *             function(*)): void} resolver
 *     Initialization function that is invoked immediately with {@code resolve}
 *     and {@code reject} functions as arguments. The Promise is resolved or
 *     rejected with the first argument passed to either function.
 * @param {RESOLVER_CONTEXT=} opt_context An optional context for executing the
 *     resolver function. If unspecified, the resolver function will be executed
 *     in the default scope.
 * @constructor
 * @struct
 * @final
 * @implements {Thenable.<TYPE>}
 * @template TYPE,RESOLVER_CONTEXT
 */
var CancellablePromise = function CancellablePromise(resolver, opt_context) {
  /**
   * The internal state of this Promise. Either PENDING, FULFILLED, REJECTED, or
   * BLOCKED.
   * @private {CancellablePromise.State_}
   */
  this.state_ = CancellablePromise.State_.PENDING;

  /**
   * The resolved result of the Promise. Immutable once set with either a
   * fulfillment value or rejection reason.
   * @private {*}
   */
  this.result_ = undefined;

  /**
   * For Promises created by calling {@code then()}, the originating parent.
   * @private {CancellablePromise}
   */
  this.parent_ = null;

  /**
   * The list of {@code onFulfilled} and {@code onRejected} callbacks added to
   * this Promise by calls to {@code then()}.
   * @private {Array.<CancellablePromise.CallbackEntry_>}
   */
  this.callbackEntries_ = null;

  /**
   * Whether the Promise is in the queue of Promises to execute.
   * @private {boolean}
   */
  this.executing_ = false;

  if (CancellablePromise.UNHANDLED_REJECTION_DELAY > 0) {
    /**
     * A timeout ID used when the {@code UNHANDLED_REJECTION_DELAY} is greater
     * than 0 milliseconds. The ID is set when the Promise is rejected, and
     * cleared only if an {@code onRejected} callback is invoked for the
     * Promise (or one of its descendants) before the delay is exceeded.
     *
     * If the rejection is not handled before the timeout completes, the
     * rejection reason is passed to the unhandled rejection handler.
     * @private {number}
     */
    this.unhandledRejectionId_ = 0;
  } else if (CancellablePromise.UNHANDLED_REJECTION_DELAY === 0) {
    /**
     * When the {@code UNHANDLED_REJECTION_DELAY} is set to 0 milliseconds, a
     * boolean that is set if the Promise is rejected, and reset to false if an
     * {@code onRejected} callback is invoked for the Promise (or one of its
     * descendants). If the rejection is not handled before the next timestep,
     * the rejection reason is passed to the unhandled rejection handler.
     * @private {boolean}
     */
    this.hadUnhandledRejection_ = false;
  }

  try {
    var self = this;
    resolver.call(opt_context, function (value) {
      self.resolve_(CancellablePromise.State_.FULFILLED, value);
    }, function (reason) {
      self.resolve_(CancellablePromise.State_.REJECTED, reason);
    });
  } catch (e) {
    this.resolve_(CancellablePromise.State_.REJECTED, e);
  }
};

/**
 * The delay in milliseconds before a rejected Promise's reason is passed to
 * the rejection handler. By default, the rejection handler rethrows the
 * rejection reason so that it appears in the developer console or
 * {@code window.onerror} handler.
 * Rejections are rethrown as quickly as possible by default. A negative value
 * disables rejection handling entirely.
 * @type {number}
 */
CancellablePromise.UNHANDLED_REJECTION_DELAY = 0;

/**
 * The possible internal states for a Promise. These states are not directly
 * observable to external callers.
 * @enum {number}
 * @private
 */
CancellablePromise.State_ = {
  /** The Promise is waiting for resolution. */
  PENDING: 0,

  /** The Promise is blocked waiting for the result of another Thenable. */
  BLOCKED: 1,

  /** The Promise has been resolved with a fulfillment value. */
  FULFILLED: 2,

  /** The Promise has been resolved with a rejection reason. */
  REJECTED: 3
};

/**
 * Typedef for entries in the callback chain. Each call to {@code then},
 * {@code thenCatch}, or {@code thenAlways} creates an entry containing the
 * functions that may be invoked once the Promise is resolved.
 *
 * @typedef {{
 *   child: CancellablePromise,
 *   onFulfilled: function(*),
 *   onRejected: function(*)
 * }}
 * @private
 */
CancellablePromise.CallbackEntry_ = null;

/**
 * @param {(TYPE|Thenable.<TYPE>|Thenable)=} opt_value
 * @return {!CancellablePromise.<TYPE>} A new Promise that is immediately resolved
 *     with the given value.
 * @template TYPE
 */
CancellablePromise.resolve = function (opt_value) {
  return new CancellablePromise(function (resolve) {
    resolve(opt_value);
  });
};

/**
 * @param {*=} opt_reason
 * @return {!CancellablePromise} A new Promise that is immediately rejected with the
 *     given reason.
 */
CancellablePromise.reject = function (opt_reason) {
  return new CancellablePromise(function (resolve, reject) {
    reject(opt_reason);
  });
};

/**
 * @param {!Array.<!(Thenable.<TYPE>|Thenable)>} promises
 * @return {!CancellablePromise.<TYPE>} A Promise that receives the result of the
 *     first Promise (or Promise-like) input to complete.
 * @template TYPE
 */
CancellablePromise.race = function (promises) {
  return new CancellablePromise(function (resolve, reject) {
    if (!promises.length) {
      resolve(undefined);
    }
    for (var i = 0, promise; promise = promises[i]; i++) {
      promise.then(resolve, reject);
    }
  });
};

/**
 * @param {!Array.<!(Thenable.<TYPE>|Thenable)>} promises
 * @return {!CancellablePromise.<!Array.<TYPE>>} A Promise that receives a list of
 *     every fulfilled value once every input Promise (or Promise-like) is
 *     successfully fulfilled, or is rejected by the first rejection result.
 * @template TYPE
 */
CancellablePromise.all = function (promises) {
  return new CancellablePromise(function (resolve, reject) {
    var toFulfill = promises.length;
    var values = [];

    if (!toFulfill) {
      resolve(values);
      return;
    }

    var onFulfill = function onFulfill(index, value) {
      toFulfill--;
      values[index] = value;
      if (toFulfill === 0) {
        resolve(values);
      }
    };

    var onReject = function onReject(reason) {
      reject(reason);
    };

    for (var i = 0, promise; promise = promises[i]; i++) {
      promise.then(partial(onFulfill, i), onReject);
    }
  });
};

/**
 * @param {!Array.<!(Thenable.<TYPE>|Thenable)>} promises
 * @return {!CancellablePromise.<TYPE>} A Promise that receives the value of
 *     the first input to be fulfilled, or is rejected with a list of every
 *     rejection reason if all inputs are rejected.
 * @template TYPE
 */
CancellablePromise.firstFulfilled = function (promises) {
  return new CancellablePromise(function (resolve, reject) {
    var toReject = promises.length;
    var reasons = [];

    if (!toReject) {
      resolve(undefined);
      return;
    }

    var onFulfill = function onFulfill(value) {
      resolve(value);
    };

    var onReject = function onReject(index, reason) {
      toReject--;
      reasons[index] = reason;
      if (toReject === 0) {
        reject(reasons);
      }
    };

    for (var i = 0, promise; promise = promises[i]; i++) {
      promise.then(onFulfill, partial(onReject, i));
    }
  });
};

/**
 * Adds callbacks that will operate on the result of the Promise, returning a
 * new child Promise.
 *
 * If the Promise is fulfilled, the {@code onFulfilled} callback will be invoked
 * with the fulfillment value as argument, and the child Promise will be
 * fulfilled with the return value of the callback. If the callback throws an
 * exception, the child Promise will be rejected with the thrown value instead.
 *
 * If the Promise is rejected, the {@code onRejected} callback will be invoked
 * with the rejection reason as argument, and the child Promise will be rejected
 * with the return value (or thrown value) of the callback.
 *
 * @override
 */
CancellablePromise.prototype.then = function (opt_onFulfilled, opt_onRejected, opt_context) {
  return this.addChildPromise_((0, _metal.isFunction)(opt_onFulfilled) ? opt_onFulfilled : null, (0, _metal.isFunction)(opt_onRejected) ? opt_onRejected : null, opt_context);
};
Thenable.addImplementation(CancellablePromise);

/**
 * Adds a callback that will be invoked whether the Promise is fulfilled or
 * rejected. The callback receives no argument, and no new child Promise is
 * created. This is useful for ensuring that cleanup takes place after certain
 * asynchronous operations. Callbacks added with {@code thenAlways} will be
 * executed in the same order with other calls to {@code then},
 * {@code thenAlways}, or {@code thenCatch}.
 *
 * Since it does not produce a new child Promise, cancellation propagation is
 * not prevented by adding callbacks with {@code thenAlways}. A Promise that has
 * a cleanup handler added with {@code thenAlways} will be canceled if all of
 * its children created by {@code then} (or {@code thenCatch}) are canceled.
 *
 * @param {function(this:THIS): void} onResolved A function that will be invoked
 *     when the Promise is resolved.
 * @param {THIS=} opt_context An optional context object that will be the
 *     execution context for the callbacks. By default, functions are executed
 *     in the global scope.
 * @return {!CancellablePromise.<TYPE>} This Promise, for chaining additional calls.
 * @template THIS
 */
CancellablePromise.prototype.thenAlways = function (onResolved, opt_context) {
  var callback = function callback() {
    try {
      // Ensure that no arguments are passed to onResolved.
      onResolved.call(opt_context);
    } catch (err) {
      CancellablePromise.handleRejection_.call(null, err);
    }
  };

  this.addCallbackEntry_({
    child: null,
    onRejected: callback,
    onFulfilled: callback
  });
  return this;
};

/**
 * Adds a callback that will be invoked only if the Promise is rejected. This
 * is equivalent to {@code then(null, onRejected)}.
 *
 * @param {!function(this:THIS, *): *} onRejected A function that will be
 *     invoked with the rejection reason if the Promise is rejected.
 * @param {THIS=} opt_context An optional context object that will be the
 *     execution context for the callbacks. By default, functions are executed
 *     in the global scope.
 * @return {!CancellablePromise} A new Promise that will receive the result of the
 *     callback.
 * @template THIS
 */
CancellablePromise.prototype.thenCatch = function (onRejected, opt_context) {
  return this.addChildPromise_(null, onRejected, opt_context);
};

/**
 * Alias of {@link CancellablePromise.prototype.thenCatch}
 */
CancellablePromise.prototype.catch = CancellablePromise.prototype.thenCatch;

/**
 * Cancels the Promise if it is still pending by rejecting it with a cancel
 * Error. No action is performed if the Promise is already resolved.
 *
 * All child Promises of the canceled Promise will be rejected with the same
 * cancel error, as with normal Promise rejection. If the Promise to be canceled
 * is the only child of a pending Promise, the parent Promise will also be
 * canceled. Cancellation may propagate upward through multiple generations.
 *
 * @param {string=} opt_message An optional debugging message for describing the
 *     cancellation reason.
 */
CancellablePromise.prototype.cancel = function (opt_message) {
  if (this.state_ === CancellablePromise.State_.PENDING) {
    _metal.async.run(function () {
      var err = new CancellablePromise.CancellationError(opt_message);
      err.IS_CANCELLATION_ERROR = true;
      this.cancelInternal_(err);
    }, this);
  }
};

/**
 * Cancels this Promise with the given error.
 *
 * @param {!Error} err The cancellation error.
 * @private
 */
CancellablePromise.prototype.cancelInternal_ = function (err) {
  if (this.state_ === CancellablePromise.State_.PENDING) {
    if (this.parent_) {
      // Cancel the Promise and remove it from the parent's child list.
      this.parent_.cancelChild_(this, err);
    } else {
      this.resolve_(CancellablePromise.State_.REJECTED, err);
    }
  }
};

/**
 * Cancels a child Promise from the list of callback entries. If the Promise has
 * not already been resolved, reject it with a cancel error. If there are no
 * other children in the list of callback entries, propagate the cancellation
 * by canceling this Promise as well.
 *
 * @param {!CancellablePromise} childPromise The Promise to cancel.
 * @param {!Error} err The cancel error to use for rejecting the Promise.
 * @private
 */
CancellablePromise.prototype.cancelChild_ = function (childPromise, err) {
  if (!this.callbackEntries_) {
    return;
  }
  var childCount = 0;
  var childIndex = -1;

  // Find the callback entry for the childPromise, and count whether there are
  // additional child Promises.
  for (var i = 0, entry; entry = this.callbackEntries_[i]; i++) {
    var child = entry.child;
    if (child) {
      childCount++;
      if (child === childPromise) {
        childIndex = i;
      }
      if (childIndex >= 0 && childCount > 1) {
        break;
      }
    }
  }

  // If the child Promise was the only child, cancel this Promise as well.
  // Otherwise, reject only the child Promise with the cancel error.
  if (childIndex >= 0) {
    if (this.state_ === CancellablePromise.State_.PENDING && childCount === 1) {
      this.cancelInternal_(err);
    } else {
      var callbackEntry = this.callbackEntries_.splice(childIndex, 1)[0];
      this.executeCallback_(callbackEntry, CancellablePromise.State_.REJECTED, err);
    }
  }
};

/**
 * Adds a callback entry to the current Promise, and schedules callback
 * execution if the Promise has already been resolved.
 *
 * @param {CancellablePromise.CallbackEntry_} callbackEntry Record containing
 *     {@code onFulfilled} and {@code onRejected} callbacks to execute after
 *     the Promise is resolved.
 * @private
 */
CancellablePromise.prototype.addCallbackEntry_ = function (callbackEntry) {
  if ((!this.callbackEntries_ || !this.callbackEntries_.length) && (this.state_ === CancellablePromise.State_.FULFILLED || this.state_ === CancellablePromise.State_.REJECTED)) {
    this.scheduleCallbacks_();
  }
  if (!this.callbackEntries_) {
    this.callbackEntries_ = [];
  }
  this.callbackEntries_.push(callbackEntry);
};

/**
 * Creates a child Promise and adds it to the callback entry list. The result of
 * the child Promise is determined by the state of the parent Promise and the
 * result of the {@code onFulfilled} or {@code onRejected} callbacks as
 * specified in the Promise resolution procedure.
 *
 * @see http://promisesaplus.com/#the__method
 *
 * @param {?function(this:THIS, TYPE):
 *          (RESULT|CancellablePromise.<RESULT>|Thenable)} onFulfilled A callback that
 *     will be invoked if the Promise is fullfilled, or null.
 * @param {?function(this:THIS, *): *} onRejected A callback that will be
 *     invoked if the Promise is rejected, or null.
 * @param {THIS=} opt_context An optional execution context for the callbacks.
 *     in the default calling context.
 * @return {!CancellablePromise} The child Promise.
 * @template RESULT,THIS
 * @private
 */
CancellablePromise.prototype.addChildPromise_ = function (onFulfilled, onRejected, opt_context) {

  var callbackEntry = {
    child: null,
    onFulfilled: null,
    onRejected: null
  };

  callbackEntry.child = new CancellablePromise(function (resolve, reject) {
    // Invoke onFulfilled, or resolve with the parent's value if absent.
    callbackEntry.onFulfilled = onFulfilled ? function (value) {
      try {
        var result = onFulfilled.call(opt_context, value);
        resolve(result);
      } catch (err) {
        reject(err);
      }
    } : resolve;

    // Invoke onRejected, or reject with the parent's reason if absent.
    callbackEntry.onRejected = onRejected ? function (reason) {
      try {
        var result = onRejected.call(opt_context, reason);
        if (!(0, _metal.isDef)(result) && reason.IS_CANCELLATION_ERROR) {
          // Propagate cancellation to children if no other result is returned.
          reject(reason);
        } else {
          resolve(result);
        }
      } catch (err) {
        reject(err);
      }
    } : reject;
  });

  callbackEntry.child.parent_ = this;
  this.addCallbackEntry_(
  /** @type {CancellablePromise.CallbackEntry_} */callbackEntry);
  return callbackEntry.child;
};

/**
 * Unblocks the Promise and fulfills it with the given value.
 *
 * @param {TYPE} value
 * @private
 */
CancellablePromise.prototype.unblockAndFulfill_ = function (value) {
  if (this.state_ !== CancellablePromise.State_.BLOCKED) {
    throw new Error('CancellablePromise is not blocked.');
  }
  this.state_ = CancellablePromise.State_.PENDING;
  this.resolve_(CancellablePromise.State_.FULFILLED, value);
};

/**
 * Unblocks the Promise and rejects it with the given rejection reason.
 *
 * @param {*} reason
 * @private
 */
CancellablePromise.prototype.unblockAndReject_ = function (reason) {
  if (this.state_ !== CancellablePromise.State_.BLOCKED) {
    throw new Error('CancellablePromise is not blocked.');
  }
  this.state_ = CancellablePromise.State_.PENDING;
  this.resolve_(CancellablePromise.State_.REJECTED, reason);
};

/**
 * Attempts to resolve a Promise with a given resolution state and value. This
 * is a no-op if the given Promise has already been resolved.
 *
 * If the given result is a Thenable (such as another Promise), the Promise will
 * be resolved with the same state and result as the Thenable once it is itself
 * resolved.
 *
 * If the given result is not a Thenable, the Promise will be fulfilled or
 * rejected with that result based on the given state.
 *
 * @see http://promisesaplus.com/#the_promise_resolution_procedure
 *
 * @param {CancellablePromise.State_} state
 * @param {*} x The result to apply to the Promise.
 * @private
 */
CancellablePromise.prototype.resolve_ = function (state, x) {
  if (this.state_ !== CancellablePromise.State_.PENDING) {
    return;
  }

  if (this === x) {
    state = CancellablePromise.State_.REJECTED;
    x = new TypeError('CancellablePromise cannot resolve to itself');
  } else if (Thenable.isImplementedBy(x)) {
    x = /** @type {!Thenable} */x;
    this.state_ = CancellablePromise.State_.BLOCKED;
    x.then(this.unblockAndFulfill_, this.unblockAndReject_, this);
    return;
  } else if ((0, _metal.isObject)(x)) {
    try {
      var then = x.then;
      if ((0, _metal.isFunction)(then)) {
        this.tryThen_(x, then);
        return;
      }
    } catch (e) {
      state = CancellablePromise.State_.REJECTED;
      x = e;
    }
  }

  this.result_ = x;
  this.state_ = state;
  this.scheduleCallbacks_();

  if (state === CancellablePromise.State_.REJECTED && !x.IS_CANCELLATION_ERROR) {
    CancellablePromise.addUnhandledRejection_(this, x);
  }
};

/**
 * Attempts to call the {@code then} method on an object in the hopes that it is
 * a Promise-compatible instance. This allows interoperation between different
 * Promise implementations, however a non-compliant object may cause a Promise
 * to hang indefinitely. If the {@code then} method throws an exception, the
 * dependent Promise will be rejected with the thrown value.
 *
 * @see http://promisesaplus.com/#point-70
 *
 * @param {Thenable} thenable An object with a {@code then} method that may be
 *     compatible with the Promise/A+ specification.
 * @param {!Function} then The {@code then} method of the Thenable object.
 * @private
 */
CancellablePromise.prototype.tryThen_ = function (thenable, then) {
  this.state_ = CancellablePromise.State_.BLOCKED;
  var promise = this;
  var called = false;

  var resolve = function resolve(value) {
    if (!called) {
      called = true;
      promise.unblockAndFulfill_(value);
    }
  };

  var reject = function reject(reason) {
    if (!called) {
      called = true;
      promise.unblockAndReject_(reason);
    }
  };

  try {
    then.call(thenable, resolve, reject);
  } catch (e) {
    reject(e);
  }
};

/**
 * Executes the pending callbacks of a resolved Promise after a timeout.
 *
 * Section 2.2.4 of the Promises/A+ specification requires that Promise
 * callbacks must only be invoked from a call stack that only contains Promise
 * implementation code, which we accomplish by invoking callback execution after
 * a timeout. If {@code startExecution_} is called multiple times for the same
 * Promise, the callback chain will be evaluated only once. Additional callbacks
 * may be added during the evaluation phase, and will be executed in the same
 * event loop.
 *
 * All Promises added to the waiting list during the same browser event loop
 * will be executed in one batch to avoid using a separate timeout per Promise.
 *
 * @private
 */
CancellablePromise.prototype.scheduleCallbacks_ = function () {
  if (!this.executing_) {
    this.executing_ = true;
    _metal.async.run(this.executeCallbacks_, this);
  }
};

/**
 * Executes all pending callbacks for this Promise.
 *
 * @private
 */
CancellablePromise.prototype.executeCallbacks_ = function () {
  while (this.callbackEntries_ && this.callbackEntries_.length) {
    var entries = this.callbackEntries_;
    this.callbackEntries_ = [];

    for (var i = 0; i < entries.length; i++) {
      this.executeCallback_(entries[i], this.state_, this.result_);
    }
  }
  this.executing_ = false;
};

/**
 * Executes a pending callback for this Promise. Invokes an {@code onFulfilled}
 * or {@code onRejected} callback based on the resolved state of the Promise.
 *
 * @param {!CancellablePromise.CallbackEntry_} callbackEntry An entry containing the
 *     onFulfilled and/or onRejected callbacks for this step.
 * @param {CancellablePromise.State_} state The resolution status of the Promise,
 *     either FULFILLED or REJECTED.
 * @param {*} result The resolved result of the Promise.
 * @private
 */
CancellablePromise.prototype.executeCallback_ = function (callbackEntry, state, result) {
  if (state === CancellablePromise.State_.FULFILLED) {
    callbackEntry.onFulfilled(result);
  } else {
    this.removeUnhandledRejection_();
    callbackEntry.onRejected(result);
  }
};

/**
 * Marks this rejected Promise as having being handled. Also marks any parent
 * Promises in the rejected state as handled. The rejection handler will no
 * longer be invoked for this Promise (if it has not been called already).
 *
 * @private
 */
CancellablePromise.prototype.removeUnhandledRejection_ = function () {
  var p;
  if (CancellablePromise.UNHANDLED_REJECTION_DELAY > 0) {
    for (p = this; p && p.unhandledRejectionId_; p = p.parent_) {
      clearTimeout(p.unhandledRejectionId_);
      p.unhandledRejectionId_ = 0;
    }
  } else if (CancellablePromise.UNHANDLED_REJECTION_DELAY === 0) {
    for (p = this; p && p.hadUnhandledRejection_; p = p.parent_) {
      p.hadUnhandledRejection_ = false;
    }
  }
};

/**
 * Marks this rejected Promise as unhandled. If no {@code onRejected} callback
 * is called for this Promise before the {@code UNHANDLED_REJECTION_DELAY}
 * expires, the reason will be passed to the unhandled rejection handler. The
 * handler typically rethrows the rejection reason so that it becomes visible in
 * the developer console.
 *
 * @param {!CancellablePromise} promise The rejected Promise.
 * @param {*} reason The Promise rejection reason.
 * @private
 */
CancellablePromise.addUnhandledRejection_ = function (promise, reason) {
  if (CancellablePromise.UNHANDLED_REJECTION_DELAY > 0) {
    promise.unhandledRejectionId_ = setTimeout(function () {
      CancellablePromise.handleRejection_.call(null, reason);
    }, CancellablePromise.UNHANDLED_REJECTION_DELAY);
  } else if (CancellablePromise.UNHANDLED_REJECTION_DELAY === 0) {
    promise.hadUnhandledRejection_ = true;
    _metal.async.run(function () {
      if (promise.hadUnhandledRejection_) {
        CancellablePromise.handleRejection_.call(null, reason);
      }
    });
  }
};

/**
 * A method that is invoked with the rejection reasons for Promises that are
 * rejected but have no {@code onRejected} callbacks registered yet.
 * @type {function(*)}
 * @private
 */
CancellablePromise.handleRejection_ = _metal.async.throwException;

/**
 * Sets a handler that will be called with reasons from unhandled rejected
 * Promises. If the rejected Promise (or one of its descendants) has an
 * {@code onRejected} callback registered, the rejection will be considered
 * handled, and the rejection handler will not be called.
 *
 * By default, unhandled rejections are rethrown so that the error may be
 * captured by the developer console or a {@code window.onerror} handler.
 *
 * @param {function(*)} handler A function that will be called with reasons from
 *     rejected Promises. Defaults to {@code async.throwException}.
 */
CancellablePromise.setUnhandledRejectionHandler = function (handler) {
  CancellablePromise.handleRejection_ = handler;
};

/**
 * Error used as a rejection reason for canceled Promises.
 *
 * @param {string=} opt_message
 * @constructor
 * @extends {Error}
 * @final
 */
CancellablePromise.CancellationError = function (_Error) {
  _inherits(_class, _Error);

  function _class(opt_message) {
    _classCallCheck(this, _class);

    var _this = _possibleConstructorReturn(this, _Error.call(this, opt_message));

    if (opt_message) {
      _this.message = opt_message;
    }
    return _this;
  }

  return _class;
}(Error);

/** @override */
CancellablePromise.CancellationError.prototype.name = 'cancel';

exports.CancellablePromise = CancellablePromise;
exports.default = CancellablePromise;

/***/ }),
/* 40 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _metal = __webpack_require__(0);

var _metal2 = _interopRequireDefault(_metal);

var _StorageMechanism = __webpack_require__(12);

var _StorageMechanism2 = _interopRequireDefault(_StorageMechanism);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var Storage = function () {

	/**
  * Provides a convenient API for data persistence using a selected data
  * storage mechanism.
  * @param {!StorageMechanism} mechanism The underlying storage mechanism.
  * @constructor
  */
	function Storage(mechanism) {
		_classCallCheck(this, Storage);

		assertMechanismDefAndNotNull(mechanism);
		assertMechanismInstanceOf(mechanism);

		/**
   * The mechanism used to persist key-value pairs.
   * @type {StorageMechanism}
   * @protected
   */
		this.mechanism = mechanism;
	}

	/**
  * Clear all items from the data storage.
  */


	_createClass(Storage, [{
		key: 'clear',
		value: function clear() {
			this.mechanism.clear();
		}

		/**
   * Sets an item in the data storage.
   * @param {string} key The key to set.
   * @param {*} value The value to serialize to a string and save.
   */

	}, {
		key: 'set',
		value: function set(key, value) {
			if (!_metal2.default.isDef(value)) {
				this.mechanism.remove(key);
				return;
			}
			this.mechanism.set(key, JSON.stringify(value));
		}

		/**
   * Gets an item from the data storage.
   * @param {string} key The key to get.
   * @return {*} Deserialized value or undefined if not found.
   */

	}, {
		key: 'get',
		value: function get(key) {
			var json;
			try {
				json = this.mechanism.get(key);
			} catch (e) {
				return undefined;
			}
			if (_metal2.default.isNull(json)) {
				return undefined;
			}
			try {
				return JSON.parse(json);
			} catch (e) {
				throw Storage.ErrorCode.INVALID_VALUE;
			}
		}

		/**
   * Returns the list of keys stored in the Storage object.
   * @param {!Array<string>} keys
   */

	}, {
		key: 'keys',
		value: function keys() {
			return this.mechanism.keys();
		}

		/**
   * Removes an item from the data storage.
   * @param {string} key The key to remove.
   */

	}, {
		key: 'remove',
		value: function remove(key) {
			this.mechanism.remove(key);
		}

		/**
   * Returns the number of data items stored in the Storage object.
   * @return {number}
   */

	}, {
		key: 'size',
		value: function size() {
			return this.mechanism.size();
		}

		/**
   * Returns the list of values stored in the Storage object.
   * @param {!Array<string>} values
   */

	}, {
		key: 'values',
		value: function values() {
			var _this = this;

			return this.keys().map(function (key) {
				return _this.get(key);
			});
		}
	}]);

	return Storage;
}();

/**
 * Errors thrown by the storage.
 * @enum {string}
 */


Storage.ErrorCode = {
	INVALID_VALUE: 'Storage: Invalid value was encountered'
};

function assertMechanismDefAndNotNull(mechanism) {
	if (!_metal2.default.isDefAndNotNull(mechanism)) {
		throw Error('Storage mechanism is required');
	}
}

function assertMechanismInstanceOf(mechanism) {
	if (!(mechanism instanceof _StorageMechanism2.default)) {
		throw Error('Storage mechanism must me an implementation of StorageMechanism');
	}
}

exports.default = Storage;

/***/ }),
/* 41 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.LocalStorageMechanism = exports.StorageMechanism = exports.Storage = undefined;

var _Storage = __webpack_require__(40);

var _Storage2 = _interopRequireDefault(_Storage);

var _StorageMechanism = __webpack_require__(12);

var _StorageMechanism2 = _interopRequireDefault(_StorageMechanism);

var _LocalStorageMechanism = __webpack_require__(42);

var _LocalStorageMechanism2 = _interopRequireDefault(_LocalStorageMechanism);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.Storage = _Storage2.default;
exports.StorageMechanism = _StorageMechanism2.default;
exports.LocalStorageMechanism = _LocalStorageMechanism2.default;

/***/ }),
/* 42 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _StorageMechanism2 = __webpack_require__(12);

var _StorageMechanism3 = _interopRequireDefault(_StorageMechanism2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * Abstract interface for storing and retrieving data using some persistence
 * mechanism.
 * @constructor
 */
var LocalStorageMechanism = function (_StorageMechanism) {
	_inherits(LocalStorageMechanism, _StorageMechanism);

	function LocalStorageMechanism() {
		_classCallCheck(this, LocalStorageMechanism);

		return _possibleConstructorReturn(this, (LocalStorageMechanism.__proto__ || Object.getPrototypeOf(LocalStorageMechanism)).apply(this, arguments));
	}

	_createClass(LocalStorageMechanism, [{
		key: 'storage',

		/**
   * Returns reference for global local storage. by default
   */
		value: function storage() {
			return LocalStorageMechanism.globals.localStorage;
		}

		/**
   * @inheritDoc
   */

	}, {
		key: 'clear',
		value: function clear() {
			this.storage().clear();
		}

		/**
   * @inheritDoc
   */

	}, {
		key: 'keys',
		value: function keys() {
			return Object.keys(this.storage());
		}

		/**
   * @inheritDoc
   */

	}, {
		key: 'get',
		value: function get(key) {
			return this.storage().getItem(key);
		}

		/**
   * @inheritDoc
   */

	}, {
		key: 'remove',


		/**
   * @inheritDoc
   */
		value: function remove(key) {
			this.storage().removeItem(key);
		}

		/**
   * @inheritDoc
   */

	}, {
		key: 'set',
		value: function set(key, value) {
			this.storage().setItem(key, value);
		}

		/**
   * @inheritDoc
   */

	}, {
		key: 'size',
		value: function size() {
			return this.storage().length;
		}
	}], [{
		key: 'isSupported',
		value: function isSupported() {
			return typeof window !== 'undefined' && typeof window.localStorage !== 'undefined';
		}
	}]);

	return LocalStorageMechanism;
}(_StorageMechanism3.default);

if (LocalStorageMechanism.isSupported()) {
	LocalStorageMechanism.globals = {
		localStorage: window.localStorage
	};
}

exports.default = LocalStorageMechanism;

/***/ }),
/* 43 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _metal = __webpack_require__(0);

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * A cached reference to the create function.
 */
var create = Object.create;

/**
 * Case insensitive string Multimap implementation. Allows multiple values for
 * the same key name.
 * @extends {Disposable}
 */

var MultiMap = function (_Disposable) {
	_inherits(MultiMap, _Disposable);

	function MultiMap() {
		_classCallCheck(this, MultiMap);

		var _this = _possibleConstructorReturn(this, _Disposable.call(this));

		_this.keys = create(null);
		_this.values = create(null);
		return _this;
	}

	/**
  * Adds value to a key name.
  * @param {string} name
  * @param {*} value
  * @chainable
  */


	MultiMap.prototype.add = function add(name, value) {
		this.keys[name.toLowerCase()] = name;
		this.values[name.toLowerCase()] = this.values[name.toLowerCase()] || [];
		this.values[name.toLowerCase()].push(value);
		return this;
	};

	/**
  * Clears map names and values.
  * @chainable
  */


	MultiMap.prototype.clear = function clear() {
		this.keys = create(null);
		this.values = create(null);
		return this;
	};

	/**
  * Checks if map contains a value to the key name.
  * @param {string} name
  * @return {boolean}
  * @chainable
  */


	MultiMap.prototype.contains = function contains(name) {
		return name.toLowerCase() in this.values;
	};

	/**
  * @inheritDoc
  */


	MultiMap.prototype.disposeInternal = function disposeInternal() {
		this.values = null;
	};

	/**
  * Creates a `MultiMap` instance from the given object.
  * @param {!Object} obj
  * @return {!MultiMap}
  */


	MultiMap.fromObject = function fromObject(obj) {
		var map = new MultiMap();
		var keys = Object.keys(obj);
		for (var i = 0; i < keys.length; i++) {
			map.set(keys[i], obj[keys[i]]);
		}
		return map;
	};

	/**
  * Gets the first added value from a key name.
  * @param {string} name
  * @return {*}
  * @chainable
  */


	MultiMap.prototype.get = function get(name) {
		var values = this.values[name.toLowerCase()];
		if (values) {
			return values[0];
		}
	};

	/**
  * Gets all values from a key name.
  * @param {string} name
  * @return {Array.<*>}
  */


	MultiMap.prototype.getAll = function getAll(name) {
		return this.values[name.toLowerCase()];
	};

	/**
  * Returns true if the map is empty, false otherwise.
  * @return {boolean}
  */


	MultiMap.prototype.isEmpty = function isEmpty() {
		return this.size() === 0;
	};

	/**
  * Gets array of key names.
  * @return {Array.<string>}
  */


	MultiMap.prototype.names = function names() {
		var _this2 = this;

		return Object.keys(this.values).map(function (key) {
			return _this2.keys[key];
		});
	};

	/**
  * Removes all values from a key name.
  * @param {string} name
  * @chainable
  */


	MultiMap.prototype.remove = function remove(name) {
		delete this.keys[name.toLowerCase()];
		delete this.values[name.toLowerCase()];
		return this;
	};

	/**
  * Sets the value of a key name. Relevant to replace the current values with
  * a new one.
  * @param {string} name
  * @param {*} value
  * @chainable
  */


	MultiMap.prototype.set = function set(name, value) {
		this.keys[name.toLowerCase()] = name;
		this.values[name.toLowerCase()] = [value];
		return this;
	};

	/**
  * Gets the size of the map key names.
  * @return {number}
  */


	MultiMap.prototype.size = function size() {
		return this.names().length;
	};

	/**
  * Returns the parsed values as a string.
  * @return {string}
  */


	MultiMap.prototype.toString = function toString() {
		return JSON.stringify(this.values);
	};

	return MultiMap;
}(_metal.Disposable);

exports.default = MultiMap;

/***/ }),
/* 44 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _metal = __webpack_require__(0);

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * Generic tree node data structure with arbitrary number of child nodes.
 * @param {V} value Value.
 * @constructor
 */
var TreeNode = function () {
	function TreeNode(value) {
		_classCallCheck(this, TreeNode);

		/**
   * The value.
   * @private {V}
   */
		this.value_ = value;

		/**
   * Reference to the parent node or null if it has no parent.
   * @private {TreeNode}
   */
		this.parent_ = null;

		/**
   * Child nodes or null in case of leaf node.
   * @private {Array<!TreeNode>}
   */
		this.children_ = null;
	}

	/**
  * Appends a child node to this node.
  * @param {!TreeNode} child Orphan child node.
  */


	TreeNode.prototype.addChild = function addChild(child) {
		assertChildHasNoParent(child);
		child.setParent(this);
		this.children_ = this.children_ || [];
		this.children_.push(child);
	};

	/**
  * Tells whether this node is the ancestor of the given node.
  * @param {!TreeNode} node A node.
  * @return {boolean} Whether this node is the ancestor of {@code node}.
  */


	TreeNode.prototype.contains = function contains(node) {
		var current = node.getParent();
		while (current) {
			if (current === this) {
				return true;
			}
			current = current.getParent();
		}
		return false;
	};

	/**
  * @return {!Array<TreeNode>} All ancestor nodes in bottom-up order.
  */


	TreeNode.prototype.getAncestors = function getAncestors() {
		var ancestors = [];
		var node = this.getParent();
		while (node) {
			ancestors.push(node);
			node = node.getParent();
		}
		return ancestors;
	};

	/**
  * Gets the child node of this node at the given index.
  * @param {number} index Child index.
  * @return {?TreeNode} The node at the given index
  * or null if not found.
  */


	TreeNode.prototype.getChildAt = function getChildAt(index) {
		return this.getChildren()[index] || null;
	};

	/**
  * @return {?Array<!TreeNode>} Child nodes or null in case of leaf node.
  */


	TreeNode.prototype.getChildren = function getChildren() {
		return this.children_ || TreeNode.EMPTY_ARRAY;
	};

	/**
  * @return {number} The number of children.
  */


	TreeNode.prototype.getChildCount = function getChildCount() {
		return this.getChildren().length;
	};

	/**
  * @return {number} The number of ancestors of the node.
  */


	TreeNode.prototype.getDepth = function getDepth() {
		var depth = 0;
		var node = this;
		while (node.getParent()) {
			depth++;
			node = node.getParent();
		}
		return depth;
	};

	/**
  * @return {?TreeNode} Parent node or null if it has no parent.
  */


	TreeNode.prototype.getParent = function getParent() {
		return this.parent_;
	};

	/**
  * @return {!TreeNode} The root of the tree structure, i.e. the farthest
  * ancestor of the node or the node itself if it has no parents.
  */


	TreeNode.prototype.getRoot = function getRoot() {
		var root = this;
		while (root.getParent()) {
			root = root.getParent();
		}
		return root;
	};

	/**
  * Gets the value.
  * @return {V} The value.
  */


	TreeNode.prototype.getValue = function getValue() {
		return this.value_;
	};

	/**
  * @return {boolean} Whether the node is a leaf node.
  */


	TreeNode.prototype.isLeaf = function isLeaf() {
		return !this.getChildCount();
	};

	/**
  * Removes the given child node of this node.
  * @param {TreeNode} child The node to remove.
  * @return {TreeNode} The removed node if any, null otherwise.
  */


	TreeNode.prototype.removeChild = function removeChild(child) {
		if (_metal.array.remove(this.getChildren(), child)) {
			return child;
		}
		return null;
	};

	/**
  * Sets the parent node of this node. The callers must ensure that the
  * parent node and only that has this node among its children.
  * @param {TreeNode} parent The parent to set. If null, the node will be
  * detached from the tree.
  * @protected
  */


	TreeNode.prototype.setParent = function setParent(parent) {
		this.parent_ = parent;
	};

	/**
  * Traverses the subtree. The first callback starts with this node,
  * and visits the descendant nodes depth-first, in preorder.
  * The second callback, starts with deepest child then visits
  * the ancestor nodes depth-first, in postorder. E.g.
  *
  *  	 A
  *    / \
  *   B   C
  *  /   / \
  * D   E   F
  *
  * preorder -> ['A', 'B', 'D', 'C', 'E', 'F']
  * postorder -> ['D', 'B', 'E', 'F', 'C', 'A']
  *
  * @param {function=} opt_preorderFn The callback to execute when visiting a node.
  * @param {function=} opt_postorderFn The callback to execute before leaving a node.
  */


	TreeNode.prototype.traverse = function traverse(opt_preorderFn, opt_postorderFn) {
		if (opt_preorderFn) {
			opt_preorderFn(this);
		}
		this.getChildren().forEach(function (child) {
			return child.traverse(opt_preorderFn, opt_postorderFn);
		});
		if (opt_postorderFn) {
			opt_postorderFn(this);
		}
	};

	return TreeNode;
}();

/**
 * Constant for empty array to avoid unnecessary allocations.
 * @private
 */


TreeNode.EMPTY_ARRAY = [];

/**
 * Asserts that child has no parent.
 * @param {TreeNode} child A child.
 * @private
 */
var assertChildHasNoParent = function assertChildHasNoParent(child) {
	if (child.getParent()) {
		throw new Error('Cannot add child with parent.');
	}
};

exports.default = TreeNode;

/***/ }),
/* 45 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _metal = __webpack_require__(0);

var _parse = __webpack_require__(46);

var _parse2 = _interopRequireDefault(_parse);

var _metalStructs = __webpack_require__(2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var parseFn_ = _parse2.default;

var Uri = function () {

	/**
  * This class contains setters and getters for the parts of the URI.
  * The following figure displays an example URIs and their component parts.
  *
  *                                  path
  *	                             ┌───┴────┐
  *	  abc://example.com:123/path/data?key=value#fragid1
  *	  └┬┘   └────┬────┘ └┬┘           └───┬───┘ └──┬──┘
  * protocol  hostname  port            search    hash
  *          └──────┬───────┘
  *                host
  *
  * @param {*=} opt_uri Optional string URI to parse
  * @constructor
  */
	function Uri() {
		var opt_uri = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';

		_classCallCheck(this, Uri);

		this.url = Uri.parse(this.maybeAddProtocolAndHostname_(opt_uri));
	}

	/**
  * Adds parameters to uri from a <code>MultiMap</code> as source.
  * @param {MultiMap} multimap The <code>MultiMap</code> containing the
  *   parameters.
  * @protected
  * @chainable
  */


	_createClass(Uri, [{
		key: 'addParametersFromMultiMap',
		value: function addParametersFromMultiMap(multimap) {
			var _this = this;

			multimap.names().forEach(function (name) {
				multimap.getAll(name).forEach(function (value) {
					_this.addParameterValue(name, value);
				});
			});
			return this;
		}

		/**
   * Adds the value of the named query parameters.
   * @param {string} key The parameter to set.
   * @param {*} value The new value. Will be explicitly casted to String.
   * @chainable
   */

	}, {
		key: 'addParameterValue',
		value: function addParameterValue(name, value) {
			this.ensureQueryInitialized_();
			if ((0, _metal.isDef)(value)) {
				value = String(value);
			}
			this.query.add(name, value);
			return this;
		}

		/**
   * Adds the values of the named query parameter.
   * @param {string} key The parameter to set.
   * @param {*} value The new value.
   * @chainable
   */

	}, {
		key: 'addParameterValues',
		value: function addParameterValues(name, values) {
			var _this2 = this;

			values.forEach(function (value) {
				return _this2.addParameterValue(name, value);
			});
			return this;
		}

		/**
   * Ensures query internal map is initialized and synced with initial value
   * extracted from URI search part.
   * @protected
   */

	}, {
		key: 'ensureQueryInitialized_',
		value: function ensureQueryInitialized_() {
			var _this3 = this;

			if (this.query) {
				return;
			}
			this.query = new _metalStructs.MultiMap();
			var search = this.url.search;
			if (search) {
				search.substring(1).split('&').forEach(function (param) {
					var _param$split = param.split('='),
					    _param$split2 = _slicedToArray(_param$split, 2),
					    key = _param$split2[0],
					    value = _param$split2[1];

					if ((0, _metal.isDef)(value)) {
						value = Uri.urlDecode(value);
					}
					_this3.addParameterValue(key, value);
				});
			}
		}

		/**
   * Gets the hash part of uri.
   * @return {string}
   */

	}, {
		key: 'getHash',
		value: function getHash() {
			return this.url.hash || '';
		}

		/**
   * Gets the host part of uri. E.g. <code>[hostname]:[port]</code>.
   * @return {string}
   */

	}, {
		key: 'getHost',
		value: function getHost() {
			var host = this.getHostname();
			if (host) {
				var port = this.getPort();
				if (port && port !== '80') {
					host += ':' + port;
				}
			}
			return host;
		}

		/**
   * Gets the hostname part of uri without protocol and port.
   * @return {string}
   */

	}, {
		key: 'getHostname',
		value: function getHostname() {
			var hostname = this.url.hostname;
			if (hostname === Uri.HOSTNAME_PLACEHOLDER) {
				return '';
			}
			return hostname;
		}

		/**
   * Gets the origin part of uri. E.g. <code>http://[hostname]:[port]</code>.
   * @return {string}
   */

	}, {
		key: 'getOrigin',
		value: function getOrigin() {
			var host = this.getHost();
			if (host) {
				return this.getProtocol() + '//' + host;
			}
			return '';
		}

		/**
   * Returns the first value for a given parameter or undefined if the given
   * parameter name does not appear in the query string.
   * @param {string} paramName Unescaped parameter name.
   * @return {string|undefined} The first value for a given parameter or
   *   undefined if the given parameter name does not appear in the query
   *   string.
   */

	}, {
		key: 'getParameterValue',
		value: function getParameterValue(name) {
			this.ensureQueryInitialized_();
			return this.query.get(name);
		}

		/**
   * Returns the value<b>s</b> for a given parameter as a list of decoded
   * query parameter values.
   * @param {string} name The parameter to get values for.
   * @return {!Array<?>} The values for a given parameter as a list of decoded
   *   query parameter values.
   */

	}, {
		key: 'getParameterValues',
		value: function getParameterValues(name) {
			this.ensureQueryInitialized_();
			return this.query.getAll(name);
		}

		/**
   * Returns the name<b>s</b> of the parameters.
   * @return {!Array<string>} The names for the parameters as a list of
   *   strings.
   */

	}, {
		key: 'getParameterNames',
		value: function getParameterNames() {
			this.ensureQueryInitialized_();
			return this.query.names();
		}

		/**
   * Gets the function currently being used to parse URIs.
   * @return {!function()}
   */

	}, {
		key: 'getPathname',


		/**
   * Gets the pathname part of uri.
   * @return {string}
   */
		value: function getPathname() {
			return this.url.pathname;
		}

		/**
   * Gets the port number part of uri as string.
   * @return {string}
   */

	}, {
		key: 'getPort',
		value: function getPort() {
			return this.url.port;
		}

		/**
   * Gets the protocol part of uri. E.g. <code>http:</code>.
   * @return {string}
   */

	}, {
		key: 'getProtocol',
		value: function getProtocol() {
			return this.url.protocol;
		}

		/**
   * Gets the search part of uri. Search value is retrieved from query
   * parameters.
   * @return {string}
   */

	}, {
		key: 'getSearch',
		value: function getSearch() {
			var _this4 = this;

			var search = '';
			var querystring = '';
			this.getParameterNames().forEach(function (name) {
				_this4.getParameterValues(name).forEach(function (value) {
					querystring += name;
					if ((0, _metal.isDef)(value)) {
						querystring += '=' + encodeURIComponent(value);
					}
					querystring += '&';
				});
			});
			querystring = querystring.slice(0, -1);
			if (querystring) {
				search += '?' + querystring;
			}
			return search;
		}

		/**
   * Checks if uri contains the parameter.
   * @param {string} name
   * @return {boolean}
   */

	}, {
		key: 'hasParameter',
		value: function hasParameter(name) {
			this.ensureQueryInitialized_();
			return this.query.contains(name);
		}

		/**
   * Makes this URL unique by adding a random param to it. Useful for avoiding
   * cache.
   */

	}, {
		key: 'makeUnique',
		value: function makeUnique() {
			this.setParameterValue(Uri.RANDOM_PARAM, _metal.string.getRandomString());
			return this;
		}

		/**
   * Maybe adds protocol and a hostname placeholder on a parial URI if needed.
   * Relevent for compatibility with <code>URL</code> native object.
   * @param {string=} opt_uri
   * @return {string} URI with protocol and hostname placeholder.
   */

	}, {
		key: 'maybeAddProtocolAndHostname_',
		value: function maybeAddProtocolAndHostname_(opt_uri) {
			var url = opt_uri;
			if (opt_uri.indexOf('://') === -1 && opt_uri.indexOf('javascript:') !== 0) {
				// jshint ignore:line

				url = Uri.DEFAULT_PROTOCOL;
				if (opt_uri[0] !== '/' || opt_uri[1] !== '/') {
					url += '//';
				}

				switch (opt_uri.charAt(0)) {
					case '.':
					case '?':
					case '#':
						url += Uri.HOSTNAME_PLACEHOLDER;
						url += '/';
						url += opt_uri;
						break;
					case '':
					case '/':
						if (opt_uri[1] !== '/') {
							url += Uri.HOSTNAME_PLACEHOLDER;
						}
						url += opt_uri;
						break;
					default:
						url += opt_uri;
				}
			}
			return url;
		}

		/**
   * Parses the given uri string into an object.
   * @param {*=} opt_uri Optional string URI to parse
   */

	}, {
		key: 'removeParameter',


		/**
   * Removes the named query parameter.
   * @param {string} name The parameter to remove.
   * @chainable
   */
		value: function removeParameter(name) {
			this.ensureQueryInitialized_();
			this.query.remove(name);
			return this;
		}

		/**
   * Removes uniqueness parameter of the uri.
   * @chainable
   */

	}, {
		key: 'removeUnique',
		value: function removeUnique() {
			this.removeParameter(Uri.RANDOM_PARAM);
			return this;
		}

		/**
   * Sets the hash.
   * @param {string} hash
   * @chainable
   */

	}, {
		key: 'setHash',
		value: function setHash(hash) {
			this.url.hash = hash;
			return this;
		}

		/**
   * Sets the hostname.
   * @param {string} hostname
   * @chainable
   */

	}, {
		key: 'setHostname',
		value: function setHostname(hostname) {
			this.url.hostname = hostname;
			return this;
		}

		/**
   * Sets the value of the named query parameters, clearing previous values
   * for that key.
   * @param {string} key The parameter to set.
   * @param {*} value The new value.
   * @chainable
   */

	}, {
		key: 'setParameterValue',
		value: function setParameterValue(name, value) {
			this.removeParameter(name);
			this.addParameterValue(name, value);
			return this;
		}

		/**
   * Sets the values of the named query parameters, clearing previous values
   * for that key.
   * @param {string} key The parameter to set.
   * @param {*} value The new value.
   * @chainable
   */

	}, {
		key: 'setParameterValues',
		value: function setParameterValues(name, values) {
			var _this5 = this;

			this.removeParameter(name);
			values.forEach(function (value) {
				return _this5.addParameterValue(name, value);
			});
			return this;
		}

		/**
   * Sets the pathname.
   * @param {string} pathname
   * @chainable
   */

	}, {
		key: 'setPathname',
		value: function setPathname(pathname) {
			this.url.pathname = pathname;
			return this;
		}

		/**
   * Sets the port number.
   * @param {*} port Port number.
   * @chainable
   */

	}, {
		key: 'setPort',
		value: function setPort(port) {
			this.url.port = port;
			return this;
		}

		/**
   * Sets the function that will be used for parsing the original string uri
   * into an object.
   * @param {!function()} parseFn
   */

	}, {
		key: 'setProtocol',


		/**
   * Sets the protocol. If missing <code>http:</code> is used as default.
   * @param {string} protocol
   * @chainable
   */
		value: function setProtocol(protocol) {
			this.url.protocol = protocol;
			if (this.url.protocol[this.url.protocol.length - 1] !== ':') {
				this.url.protocol += ':';
			}
			return this;
		}

		/**
   * @return {string} The string form of the url.
   * @override
   */

	}, {
		key: 'toString',
		value: function toString() {
			var href = '';
			var host = this.getHost();
			if (host) {
				href += this.getProtocol() + '//';
			}
			href += host + this.getPathname() + this.getSearch() + this.getHash();
			return href;
		}

		/**
   * Joins the given paths.
   * @param {string} basePath
   * @param {...string} ...paths Any number of paths to be joined with the base url.
   * @static
   */

	}], [{
		key: 'getParseFn',
		value: function getParseFn() {
			return parseFn_;
		}
	}, {
		key: 'parse',
		value: function parse(opt_uri) {
			return parseFn_(opt_uri);
		}
	}, {
		key: 'setParseFn',
		value: function setParseFn(parseFn) {
			parseFn_ = parseFn;
		}
	}, {
		key: 'joinPaths',
		value: function joinPaths(basePath) {
			for (var _len = arguments.length, paths = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
				paths[_key - 1] = arguments[_key];
			}

			if (basePath.charAt(basePath.length - 1) === '/') {
				basePath = basePath.substring(0, basePath.length - 1);
			}
			paths = paths.map(function (path) {
				return path.charAt(0) === '/' ? path.substring(1) : path;
			});
			return [basePath].concat(paths).join('/').replace(/\/$/, '');
		}

		/**
   * URL-decodes the string. We need to specially handle '+'s because
   * the javascript library doesn't convert them to spaces.
   * @param {string} str The string to url decode.
   * @return {string} The decoded {@code str}.
   */

	}, {
		key: 'urlDecode',
		value: function urlDecode(str) {
			return decodeURIComponent(str.replace(/\+/g, ' '));
		}
	}]);

	return Uri;
}();

/**
 * Default protocol value.
 * @type {string}
 * @default http:
 * @static
 */


var isSecure = function isSecure() {
	return typeof window !== 'undefined' && window.location && window.location.protocol && window.location.protocol.indexOf('https') === 0;
};

Uri.DEFAULT_PROTOCOL = isSecure() ? 'https:' : 'http:';

/**
 * Hostname placeholder. Relevant to internal usage only.
 * @type {string}
 * @static
 */
Uri.HOSTNAME_PLACEHOLDER = 'hostname' + Date.now();

/**
 * Name used by the param generated by `makeUnique`.
 * @type {string}
 * @static
 */
Uri.RANDOM_PARAM = 'zx';

exports.default = Uri;

/***/ }),
/* 46 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _metal = __webpack_require__(0);

var _parseFromAnchor = __webpack_require__(47);

var _parseFromAnchor2 = _interopRequireDefault(_parseFromAnchor);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Parses the given uri string into an object. The URL function will be used
 * when present, otherwise we'll fall back to the anchor node element.
 * @param {*=} opt_uri Optional string URI to parse
 */
function parse(opt_uri) {
	if ((0, _metal.isFunction)(URL) && URL.length) {
		var url = new URL(opt_uri);

		// Safari Browsers will cap port to the max 16-bit unsigned integer (65535) instead
		// of throwing a TypeError as per spec. It will still keep the port number in the
		// href attribute, so we can use this mismatch to raise the expected exception.
		if (url.port && url.href.indexOf(url.port) === -1) {
			throw new TypeError(opt_uri + ' is not a valid URL');
		}

		return url;
	} else {
		return (0, _parseFromAnchor2.default)(opt_uri);
	}
}

exports.default = parse;

/***/ }),
/* 47 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * Parses the given uri string into an object.
 * @param {*=} opt_uri Optional string URI to parse
 */

Object.defineProperty(exports, "__esModule", {
	value: true
});
function parseFromAnchor(opt_uri) {
	var link = document.createElement('a');
	link.href = opt_uri;

	if (link.protocol === ':' || !/:/.test(link.href)) {
		throw new TypeError(opt_uri + ' is not a valid URL');
	}

	return {
		hash: link.hash,
		hostname: link.hostname,
		password: link.password,
		pathname: link.pathname[0] === '/' ? link.pathname : '/' + link.pathname,
		port: link.port,
		protocol: link.protocol,
		search: link.search,
		username: link.username
	};
}

exports.default = parseFromAnchor;

/***/ }),
/* 48 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _core = __webpack_require__(17);

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var array = function () {
	function array() {
		_classCallCheck(this, array);
	}

	_createClass(array, null, [{
		key: 'equal',

		/**
   * Checks if the given arrays have the same content.
   * @param {!Array<*>} arr1
   * @param {!Array<*>} arr2
   * @return {boolean}
   */
		value: function equal(arr1, arr2) {
			if (arr1 === arr2) {
				return true;
			}
			if (arr1.length !== arr2.length) {
				return false;
			}
			for (var i = 0; i < arr1.length; i++) {
				if (arr1[i] !== arr2[i]) {
					return false;
				}
			}
			return true;
		}

		/**
   * Returns the first value in the given array that isn't undefined.
   * @param {!Array} arr
   * @return {*}
   */

	}, {
		key: 'firstDefinedValue',
		value: function firstDefinedValue(arr) {
			for (var i = 0; i < arr.length; i++) {
				if (arr[i] !== undefined) {
					return arr[i];
				}
			}
		}

		/**
   * Transforms the input nested array to become flat.
   * @param {Array.<*|Array.<*>>} arr Nested array to flatten.
   * @param {Array.<*>} opt_output Optional output array.
   * @return {Array.<*>} Flat array.
   */

	}, {
		key: 'flatten',
		value: function flatten(arr, opt_output) {
			var output = opt_output || [];
			for (var i = 0; i < arr.length; i++) {
				if (Array.isArray(arr[i])) {
					array.flatten(arr[i], output);
				} else {
					output.push(arr[i]);
				}
			}
			return output;
		}

		/**
   * Removes the first occurrence of a particular value from an array.
   * @param {Array.<T>} arr Array from which to remove value.
   * @param {T} obj Object to remove.
   * @return {boolean} True if an element was removed.
   * @template T
   */

	}, {
		key: 'remove',
		value: function remove(arr, obj) {
			var i = arr.indexOf(obj);
			var rv = void 0;
			if (rv = i >= 0) {
				array.removeAt(arr, i);
			}
			return rv;
		}

		/**
   * Removes from an array the element at index i
   * @param {Array} arr Array or array like object from which to remove value.
   * @param {number} i The index to remove.
   * @return {boolean} True if an element was removed.
   */

	}, {
		key: 'removeAt',
		value: function removeAt(arr, i) {
			return Array.prototype.splice.call(arr, i, 1).length === 1;
		}

		/**
   * Slices the given array, just like Array.prototype.slice, but this
   * is faster and working on all array-like objects (like arguments).
   * @param {!Object} arr Array-like object to slice.
   * @param {number} start The index that should start the slice.
   * @param {number=} opt_end The index where the slice should end, not
   *   included in the final array. If not given, all elements after the
   *   start index will be included.
   * @return {!Array}
   */

	}, {
		key: 'slice',
		value: function slice(arr, start, opt_end) {
			var sliced = [];
			var end = (0, _core.isDef)(opt_end) ? opt_end : arr.length;
			for (var i = start; i < end; i++) {
				sliced.push(arr[i]);
			}
			return sliced;
		}
	}]);

	return array;
}();

exports.default = array;

/***/ }),
/* 49 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(setImmediate) {/*!
 * Polyfill from Google's Closure Library.
 * Copyright 2013 The Closure Library Authors. All Rights Reserved.
 */



Object.defineProperty(exports, "__esModule", {
	value: true
});
var async = {};

/**
 * Throw an item without interrupting the current execution context.  For
 * example, if processing a group of items in a loop, sometimes it is useful
 * to report an error while still allowing the rest of the batch to be
 * processed.
 * @param {*} exception
 */
async.throwException = function (exception) {
	// Each throw needs to be in its own context.
	async.nextTick(function () {
		throw exception;
	});
};

/**
 * Fires the provided callback just before the current callstack unwinds, or as
 * soon as possible after the current JS execution context.
 * @param {function(this:THIS)} callback
 * @param {THIS=} opt_context Object to use as the "this value" when calling
 *     the provided function.
 * @template THIS
 */
async.run = function (callback, opt_context) {
	if (!async.run.workQueueScheduled_) {
		// Nothing is currently scheduled, schedule it now.
		async.nextTick(async.run.processWorkQueue);
		async.run.workQueueScheduled_ = true;
	}

	async.run.workQueue_.push(new async.run.WorkItem_(callback, opt_context));
};

/** @private {boolean} */
async.run.workQueueScheduled_ = false;

/** @private {!Array.<!async.run.WorkItem_>} */
async.run.workQueue_ = [];

/**
 * Run any pending async.run work items. This function is not intended
 * for general use, but for use by entry point handlers to run items ahead of
 * async.nextTick.
 */
async.run.processWorkQueue = function () {
	// NOTE: additional work queue items may be pushed while processing.
	while (async.run.workQueue_.length) {
		// Don't let the work queue grow indefinitely.
		var workItems = async.run.workQueue_;
		async.run.workQueue_ = [];
		for (var i = 0; i < workItems.length; i++) {
			var workItem = workItems[i];
			try {
				workItem.fn.call(workItem.scope);
			} catch (e) {
				async.throwException(e);
			}
		}
	}

	// There are no more work items, reset the work queue.
	async.run.workQueueScheduled_ = false;
};

/**
 * @constructor
 * @final
 * @struct
 * @private
 *
 * @param {function()} fn
 * @param {Object|null|undefined} scope
 */
async.run.WorkItem_ = function (fn, scope) {
	/** @const */
	this.fn = fn;
	/** @const */
	this.scope = scope;
};

/**
 * Fires the provided callbacks as soon as possible after the current JS
 * execution context. setTimeout(…, 0) always takes at least 5ms for legacy
 * reasons.
 * @param {function(this:SCOPE)} callback Callback function to fire as soon as
 *     possible.
 * @param {SCOPE=} opt_context Object in whose scope to call the listener.
 * @template SCOPE
 */
async.nextTick = function (callback, opt_context) {
	var cb = callback;
	if (opt_context) {
		cb = callback.bind(opt_context);
	}
	cb = async.nextTick.wrapCallback_(cb);
	// Introduced and currently only supported by IE10.
	// Verify if variable is defined on the current runtime (i.e., node, browser).
	// Can't use typeof enclosed in a function (such as core.isFunction) or an
	// exception will be thrown when the function is called on an environment
	// where the variable is undefined.
	if (typeof setImmediate === 'function') {
		setImmediate(cb);
		return;
	}
	// Look for and cache the custom fallback version of setImmediate.
	if (!async.nextTick.setImmediate_) {
		async.nextTick.setImmediate_ = async.nextTick.getSetImmediateEmulator_();
	}
	async.nextTick.setImmediate_(cb);
};

/**
 * Cache for the setImmediate implementation.
 * @type {function(function())}
 * @private
 */
async.nextTick.setImmediate_ = null;

/**
 * Determines the best possible implementation to run a function as soon as
 * the JS event loop is idle.
 * @return {function(function())} The "setImmediate" implementation.
 * @private
 */
async.nextTick.getSetImmediateEmulator_ = function () {
	// Create a private message channel and use it to postMessage empty messages
	// to ourselves.
	var Channel = void 0;

	// Verify if variable is defined on the current runtime (i.e., node, browser).
	// Can't use typeof enclosed in a function (such as core.isFunction) or an
	// exception will be thrown when the function is called on an environment
	// where the variable is undefined.
	if (typeof MessageChannel === 'function') {
		Channel = MessageChannel;
	}

	// If MessageChannel is not available and we are in a browser, implement
	// an iframe based polyfill in browsers that have postMessage and
	// document.addEventListener. The latter excludes IE8 because it has a
	// synchronous postMessage implementation.
	if (typeof Channel === 'undefined' && typeof window !== 'undefined' && window.postMessage && window.addEventListener) {
		/** @constructor */
		Channel = function Channel() {
			// Make an empty, invisible iframe.
			var iframe = document.createElement('iframe');
			iframe.style.display = 'none';
			iframe.src = '';
			document.documentElement.appendChild(iframe);
			var win = iframe.contentWindow;
			var doc = win.document;
			doc.open();
			doc.write('');
			doc.close();
			var message = 'callImmediate' + Math.random();
			var origin = win.location.protocol + '//' + win.location.host;
			var onmessage = function (e) {
				// Validate origin and message to make sure that this message was
				// intended for us.
				if (e.origin !== origin && e.data !== message) {
					return;
				}
				this.port1.onmessage();
			}.bind(this);
			win.addEventListener('message', onmessage, false);
			this.port1 = {};
			this.port2 = {
				postMessage: function postMessage() {
					win.postMessage(message, origin);
				}
			};
		};
	}
	if (typeof Channel !== 'undefined') {
		var channel = new Channel();
		// Use a fifo linked list to call callbacks in the right order.
		var head = {};
		var tail = head;
		channel.port1.onmessage = function () {
			head = head.next;
			var cb = head.cb;
			head.cb = null;
			cb();
		};
		return function (cb) {
			tail.next = {
				cb: cb
			};
			tail = tail.next;
			channel.port2.postMessage(0);
		};
	}
	// Implementation for IE6-8: Script elements fire an asynchronous
	// onreadystatechange event when inserted into the DOM.
	if (typeof document !== 'undefined' && 'onreadystatechange' in document.createElement('script')) {
		return function (cb) {
			var script = document.createElement('script');
			script.onreadystatechange = function () {
				// Clean up and call the callback.
				script.onreadystatechange = null;
				script.parentNode.removeChild(script);
				script = null;
				cb();
				cb = null;
			};
			document.documentElement.appendChild(script);
		};
	}
	// Fall back to setTimeout with 0. In browsers this creates a delay of 5ms
	// or more.
	return function (cb) {
		setTimeout(cb, 0);
	};
};

/**
 * Helper function that is overrided to protect callbacks with entry point
 * monitor if the application monitors entry points.
 * @param {function()} callback Callback function to fire as soon as possible.
 * @return {function()} The wrapped callback.
 * @private
 */
async.nextTick.wrapCallback_ = function (opt_returnValue) {
	return opt_returnValue;
};

exports.default = async;
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(60).setImmediate))

/***/ }),
/* 50 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {

/**
 * A collection of core utility functions.
 * @const
 */

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

exports.abstractMethod = abstractMethod;
exports.disableCompatibilityMode = disableCompatibilityMode;
exports.enableCompatibilityMode = enableCompatibilityMode;
exports.getCompatibilityModeData = getCompatibilityModeData;
exports.getFunctionName = getFunctionName;
exports.getStaticProperty = getStaticProperty;
exports.getUid = getUid;
exports.identityFunction = identityFunction;
exports.isBoolean = isBoolean;
exports.isDef = isDef;
exports.isDefAndNotNull = isDefAndNotNull;
exports.isDocument = isDocument;
exports.isDocumentFragment = isDocumentFragment;
exports.isElement = isElement;
exports.isFunction = isFunction;
exports.isNull = isNull;
exports.isNumber = isNumber;
exports.isWindow = isWindow;
exports.isObject = isObject;
exports.isPromise = isPromise;
exports.isString = isString;
exports.isServerSide = isServerSide;
exports.nullFunction = nullFunction;
var compatibilityModeData_ = void 0;

/**
 * Counter for unique id.
 * @type {Number}
 * @private
 */
var uniqueIdCounter_ = 1;

/**
 * Unique id property prefix.
 * @type {String}
 * @protected
 */
var UID_PROPERTY = exports.UID_PROPERTY = 'core_' + (Math.random() * 1e9 >>> 0);

/**
 * When defining a class Foo with an abstract method bar(), you can do:
 * Foo.prototype.bar = abstractMethod
 *
 * Now if a subclass of Foo fails to override bar(), an error will be thrown
 * when bar() is invoked.
 *
 * @type {!Function}
 * @throws {Error} when invoked to indicate the method should be overridden.
 */
function abstractMethod() {
  throw Error('Unimplemented abstract method');
}

/**
 * Disables Metal.js's compatibility mode.
 */
function disableCompatibilityMode() {
  compatibilityModeData_ = undefined;
}

/**
 * Enables Metal.js's compatibility mode with the following features from rc
 * and 1.x versions:
 *     - Using "key" to reference component instances. In the current version
 *       this should be done via "ref" instead. This allows old code still
 *       using "key" to keep working like before. NOTE: this may cause
 *       problems, since "key" is meant to be used differently. Only use this
 *       if it's not possible to upgrade the code to use "ref" instead.
 * @param {Object=} opt_data Optional object with data to specify more
 *     details, such as:
 *         - renderers {Array} the template renderers that should be in
 *           compatibility mode, either their constructors or strings
 *           representing them (e.g. 'soy' or 'jsx'). By default, all the ones
 *           that extend from IncrementalDomRenderer.
 * @type {Object}
 */
function enableCompatibilityMode() {
  var opt_data = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

  compatibilityModeData_ = opt_data;
}

/**
 * Returns the data used for compatibility mode, or nothing if it hasn't been
 * enabled.
 * @return {Object}
 */
function getCompatibilityModeData() {
  // Compatibility mode can be set via the __METAL_COMPATIBILITY__ global var.
  if (compatibilityModeData_ === undefined) {
    if (typeof window !== 'undefined' && window.__METAL_COMPATIBILITY__) {
      enableCompatibilityMode(window.__METAL_COMPATIBILITY__);
    }
  }
  return compatibilityModeData_;
}

/**
 * Returns the first argument if it's truthy, or the second otherwise.
 * @param {*} a
 * @param {*} b
 * @return {*}
 * @protected
 */
function getFirstTruthy_(a, b) {
  return a || b;
}

/**
 * Gets the name of the given function. If the current browser doesn't
 * support the `name` property, this will calculate it from the function's
 * content string.
 * @param {!function()} fn
 * @return {string}
 */
function getFunctionName(fn) {
  if (!fn.name) {
    var str = fn.toString();
    fn.name = str.substring(9, str.indexOf('('));
  }
  return fn.name;
}

/**
 * Gets the value of a static property in the given class. The value will be
 * inherited from ancestors as expected, unless a custom merge function is given,
 * which can change how the super classes' value for that property will be merged
 * together.
 * The final merged value will be stored in another property, so that it won't
 * be recalculated even if this function is called multiple times.
 * @param {!function()} ctor Class constructor.
 * @param {string} propertyName Property name to be merged.
 * @param {function(*, *):*=} opt_mergeFn Function that receives the merged
 *     value of the property so far and the next value to be merged to it.
 *     Should return these two merged together. If not passed the final property
 *     will be the first truthy value among ancestors.
 */
function getStaticProperty(ctor, propertyName, opt_mergeFn) {
  var mergedName = propertyName + '_MERGED';
  if (!ctor.hasOwnProperty(mergedName)) {
    var merged = ctor.hasOwnProperty(propertyName) ? ctor[propertyName] : null;
    if (ctor.__proto__ && !ctor.__proto__.isPrototypeOf(Function)) {
      var mergeFn = opt_mergeFn || getFirstTruthy_;
      merged = mergeFn(merged, getStaticProperty(ctor.__proto__, propertyName, mergeFn));
    }
    ctor[mergedName] = merged;
  }
  return ctor[mergedName];
}

/**
 * Gets an unique id. If `opt_object` argument is passed, the object is
 * mutated with an unique id. Consecutive calls with the same object
 * reference won't mutate the object again, instead the current object uid
 * returns. See {@link UID_PROPERTY}.
 * @param {Object=} opt_object Optional object to be mutated with the uid. If
 *     not specified this method only returns the uid.
 * @param {boolean=} opt_noInheritance Optional flag indicating if this
 *     object's uid property can be inherited from parents or not.
 * @throws {Error} when invoked to indicate the method should be overridden.
 */
function getUid(opt_object, opt_noInheritance) {
  if (opt_object) {
    var id = opt_object[UID_PROPERTY];
    if (opt_noInheritance && !opt_object.hasOwnProperty(UID_PROPERTY)) {
      id = null;
    }
    return id || (opt_object[UID_PROPERTY] = uniqueIdCounter_++);
  }
  return uniqueIdCounter_++;
}

/**
 * The identity function. Returns its first argument.
 * @param {*=} opt_returnValue The single value that will be returned.
 * @return {?} The first argument.
 */
function identityFunction(opt_returnValue) {
  return opt_returnValue;
}

/**
 * Returns true if the specified value is a boolean.
 * @param {?} val Variable to test.
 * @return {boolean} Whether variable is boolean.
 */
function isBoolean(val) {
  return typeof val === 'boolean';
}

/**
 * Returns true if the specified value is not undefined.
 * @param {?} val Variable to test.
 * @return {boolean} Whether variable is defined.
 */
function isDef(val) {
  return val !== undefined;
}

/**
 * Returns true if value is not undefined or null.
 * @param {*} val
 * @return {boolean}
 */
function isDefAndNotNull(val) {
  return isDef(val) && !isNull(val);
}

/**
 * Returns true if value is a document.
 * @param {*} val
 * @return {boolean}
 */
function isDocument(val) {
  return val && (typeof val === 'undefined' ? 'undefined' : _typeof(val)) === 'object' && val.nodeType === 9;
}

/**
 * Returns true if value is a document-fragment.
 * @param {*} val
 * @return {boolean}
 */
function isDocumentFragment(val) {
  return val && (typeof val === 'undefined' ? 'undefined' : _typeof(val)) === 'object' && val.nodeType === 11;
}

/**
 * Returns true if value is a dom element.
 * @param {*} val
 * @return {boolean}
 */
function isElement(val) {
  return val && (typeof val === 'undefined' ? 'undefined' : _typeof(val)) === 'object' && val.nodeType === 1;
}

/**
 * Returns true if the specified value is a function.
 * @param {?} val Variable to test.
 * @return {boolean} Whether variable is a function.
 */
function isFunction(val) {
  return typeof val === 'function';
}

/**
 * Returns true if value is null.
 * @param {*} val
 * @return {boolean}
 */
function isNull(val) {
  return val === null;
}

/**
 * Returns true if the specified value is a number.
 * @param {?} val Variable to test.
 * @return {boolean} Whether variable is a number.
 */
function isNumber(val) {
  return typeof val === 'number';
}

/**
 * Returns true if value is a window.
 * @param {*} val
 * @return {boolean}
 */
function isWindow(val) {
  return val !== null && val === val.window;
}

/**
 * Returns true if the specified value is an object. This includes arrays
 * and functions.
 * @param {?} val Variable to test.
 * @return {boolean} Whether variable is an object.
 */
function isObject(val) {
  var type = typeof val === 'undefined' ? 'undefined' : _typeof(val);
  return type === 'object' && val !== null || type === 'function';
}

/**
 * Returns true if value is a Promise.
 * @param {*} val
 * @return {boolean}
 */
function isPromise(val) {
  return val && (typeof val === 'undefined' ? 'undefined' : _typeof(val)) === 'object' && typeof val.then === 'function';
}

/**
 * Returns true if value is a string.
 * @param {*} val
 * @return {boolean}
 */
function isString(val) {
  return typeof val === 'string' || val instanceof String;
}

/**
 * Sets to true if running inside Node.js environment with extra check for
 * `process.browser` to skip Karma runner environment. Karma environment has
 * `process` defined even though it runs on the browser.
 * @return {boolean}
 */
function isServerSide() {
  return typeof process !== 'undefined' && typeof process.env !== 'undefined' && process.env.NODE_ENV !== 'test' && !process.browser;
}

/**
 * Null function used for default values of callbacks, etc.
 * @return {void} Nothing.
 */
function nullFunction() {}
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(13)))

/***/ }),
/* 51 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * Disposable utility. When inherited provides the `dispose` function to its
 * subclass, which is responsible for disposing of any object references
 * when an instance won't be used anymore. Subclasses should override
 * `disposeInternal` to implement any specific disposing logic.
 * @constructor
 */

Object.defineProperty(exports, "__esModule", {
	value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var Disposable = function () {
	function Disposable() {
		_classCallCheck(this, Disposable);

		/**
   * Flag indicating if this instance has already been disposed.
   * @type {boolean}
   * @protected
   */
		this.disposed_ = false;
	}

	/**
  * Disposes of this instance's object references. Calls `disposeInternal`.
  */


	_createClass(Disposable, [{
		key: 'dispose',
		value: function dispose() {
			if (!this.disposed_) {
				this.disposeInternal();
				this.disposed_ = true;
			}
		}

		/**
   * Subclasses should override this method to implement any specific
   * disposing logic (like clearing references and calling `dispose` on other
   * disposables).
   */

	}, {
		key: 'disposeInternal',
		value: function disposeInternal() {}

		/**
   * Checks if this instance has already been disposed.
   * @return {boolean}
   */

	}, {
		key: 'isDisposed',
		value: function isDisposed() {
			return this.disposed_;
		}
	}]);

	return Disposable;
}();

exports.default = Disposable;

/***/ }),
/* 52 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var object = function () {
	function object() {
		_classCallCheck(this, object);
	}

	_createClass(object, null, [{
		key: 'mixin',

		/**
   * Copies all the members of a source object to a target object.
   * @param {Object} target Target object.
   * @param {...Object} var_args The objects from which values will be copied.
   * @return {Object} Returns the target object reference.
   */
		value: function mixin(target) {
			var key = void 0,
			    source = void 0;
			for (var i = 1; i < arguments.length; i++) {
				source = arguments[i];
				for (key in source) {
					target[key] = source[key];
				}
			}
			return target;
		}

		/**
   * Returns an object based on its fully qualified external name.
   * @param {string} name The fully qualified name.
   * @param {object=} opt_obj The object within which to look; default is
   *     <code>window</code>.
   * @return {?} The value (object or primitive) or, if not found, undefined.
   */

	}, {
		key: 'getObjectByName',
		value: function getObjectByName(name, opt_obj) {
			var scope = opt_obj || window;
			var parts = name.split('.');
			return parts.reduce(function (part, key) {
				return part[key];
			}, scope);
		}

		/**
   * Returns a new object with the same keys as the given one, but with
   * their values set to the return values of the specified function.
   * @param {!Object} obj
   * @param {!function(string, *)} fn
   * @return {!Object}
   */

	}, {
		key: 'map',
		value: function map(obj, fn) {
			var mappedObj = {};
			var keys = Object.keys(obj);
			for (var i = 0; i < keys.length; i++) {
				mappedObj[keys[i]] = fn(keys[i], obj[keys[i]]);
			}
			return mappedObj;
		}

		/**
   * Checks if the two given objects are equal. This is done via a shallow
   * check, including only the keys directly contained by the 2 objects.
   * @return {boolean}
   */

	}, {
		key: 'shallowEqual',
		value: function shallowEqual(obj1, obj2) {
			if (obj1 === obj2) {
				return true;
			}

			var keys1 = Object.keys(obj1);
			var keys2 = Object.keys(obj2);
			if (keys1.length !== keys2.length) {
				return false;
			}

			for (var i = 0; i < keys1.length; i++) {
				if (obj1[keys1[i]] !== obj2[keys1[i]]) {
					return false;
				}
			}
			return true;
		}
	}]);

	return object;
}();

exports.default = object;

/***/ }),
/* 53 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var string = function () {
	function string() {
		_classCallCheck(this, string);
	}

	_createClass(string, null, [{
		key: 'caseInsensitiveCompare',

		/**
   * Compares the given strings without taking the case into account.
   * @param {string|number} str1
   * @param {string|number} str2
   * @return {number} Either -1, 0 or 1, according to if the first string is
   *     "smaller", equal or "bigger" than the second given string.
   */
		value: function caseInsensitiveCompare(str1, str2) {
			var test1 = String(str1).toLowerCase();
			var test2 = String(str2).toLowerCase();

			if (test1 < test2) {
				return -1;
			} else if (test1 === test2) {
				return 0;
			} else {
				return 1;
			}
		}

		/**
   * Removes the breaking spaces from the left and right of the string and
   * collapses the sequences of breaking spaces in the middle into single spaces.
   * The original and the result strings render the same way in HTML.
   * @param {string} str A string in which to collapse spaces.
   * @return {string} Copy of the string with normalized breaking spaces.
   */

	}, {
		key: 'collapseBreakingSpaces',
		value: function collapseBreakingSpaces(str) {
			return str.replace(/[\t\r\n ]+/g, ' ').replace(/^[\t\r\n ]+|[\t\r\n ]+$/g, '');
		}

		/**
  * Escapes characters in the string that are not safe to use in a RegExp.
  * @param {*} str The string to escape. If not a string, it will be casted
  *     to one.
  * @return {string} A RegExp safe, escaped copy of {@code s}.
  */

	}, {
		key: 'escapeRegex',
		value: function escapeRegex(str) {
			return String(str).replace(/([-()\[\]{}+?*.$\^|,:#<!\\])/g, '\\$1').replace(/\x08/g, '\\x08');
		}

		/**
  * Returns a string with at least 64-bits of randomness.
  * @return {string} A random string, e.g. sn1s7vb4gcic.
  */

	}, {
		key: 'getRandomString',
		value: function getRandomString() {
			var x = 2147483648;
			return Math.floor(Math.random() * x).toString(36) + Math.abs(Math.floor(Math.random() * x) ^ Date.now()).toString(36);
		}

		/**
   * Calculates the hashcode for a string. The hashcode value is computed by
   * the sum algorithm: s[0]*31^(n-1) + s[1]*31^(n-2) + ... + s[n-1]. A nice
   * property of using 31 prime is that the multiplication can be replaced by
   * a shift and a subtraction for better performance: 31*i == (i<<5)-i.
   * Modern VMs do this sort of optimization automatically.
   * @param {String} val Target string.
   * @return {Number} Returns the string hashcode.
   */

	}, {
		key: 'hashCode',
		value: function hashCode(val) {
			var hash = 0;
			for (var i = 0, len = val.length; i < len; i++) {
				hash = 31 * hash + val.charCodeAt(i);
				hash %= 0x100000000;
			}
			return hash;
		}

		/**
   * Replaces interval into the string with specified value, e.g.
   * `replaceInterval("abcde", 1, 4, "")` returns "ae".
   * @param {string} str The input string.
   * @param {Number} start Start interval position to be replaced.
   * @param {Number} end End interval position to be replaced.
   * @param {string} value The value that replaces the specified interval.
   * @return {string}
   */

	}, {
		key: 'replaceInterval',
		value: function replaceInterval(str, start, end, value) {
			return str.substring(0, start) + value + str.substring(end);
		}
	}]);

	return string;
}();

exports.default = string;

/***/ }),
/* 54 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(process) {// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// resolves . and .. elements in a path array with directory names there
// must be no slashes, empty elements, or device names (c:\) in the array
// (so also no leading and trailing slashes - it does not distinguish
// relative and absolute paths)
function normalizeArray(parts, allowAboveRoot) {
  // if the path tries to go above the root, `up` ends up > 0
  var up = 0;
  for (var i = parts.length - 1; i >= 0; i--) {
    var last = parts[i];
    if (last === '.') {
      parts.splice(i, 1);
    } else if (last === '..') {
      parts.splice(i, 1);
      up++;
    } else if (up) {
      parts.splice(i, 1);
      up--;
    }
  }

  // if the path is allowed to go above the root, restore leading ..s
  if (allowAboveRoot) {
    for (; up--; up) {
      parts.unshift('..');
    }
  }

  return parts;
}

// Split a filename into [root, dir, basename, ext], unix version
// 'root' is just a slash, or nothing.
var splitPathRe =
    /^(\/?|)([\s\S]*?)((?:\.{1,2}|[^\/]+?|)(\.[^.\/]*|))(?:[\/]*)$/;
var splitPath = function(filename) {
  return splitPathRe.exec(filename).slice(1);
};

// path.resolve([from ...], to)
// posix version
exports.resolve = function() {
  var resolvedPath = '',
      resolvedAbsolute = false;

  for (var i = arguments.length - 1; i >= -1 && !resolvedAbsolute; i--) {
    var path = (i >= 0) ? arguments[i] : process.cwd();

    // Skip empty and invalid entries
    if (typeof path !== 'string') {
      throw new TypeError('Arguments to path.resolve must be strings');
    } else if (!path) {
      continue;
    }

    resolvedPath = path + '/' + resolvedPath;
    resolvedAbsolute = path.charAt(0) === '/';
  }

  // At this point the path should be resolved to a full absolute path, but
  // handle relative paths to be safe (might happen when process.cwd() fails)

  // Normalize the path
  resolvedPath = normalizeArray(filter(resolvedPath.split('/'), function(p) {
    return !!p;
  }), !resolvedAbsolute).join('/');

  return ((resolvedAbsolute ? '/' : '') + resolvedPath) || '.';
};

// path.normalize(path)
// posix version
exports.normalize = function(path) {
  var isAbsolute = exports.isAbsolute(path),
      trailingSlash = substr(path, -1) === '/';

  // Normalize the path
  path = normalizeArray(filter(path.split('/'), function(p) {
    return !!p;
  }), !isAbsolute).join('/');

  if (!path && !isAbsolute) {
    path = '.';
  }
  if (path && trailingSlash) {
    path += '/';
  }

  return (isAbsolute ? '/' : '') + path;
};

// posix version
exports.isAbsolute = function(path) {
  return path.charAt(0) === '/';
};

// posix version
exports.join = function() {
  var paths = Array.prototype.slice.call(arguments, 0);
  return exports.normalize(filter(paths, function(p, index) {
    if (typeof p !== 'string') {
      throw new TypeError('Arguments to path.join must be strings');
    }
    return p;
  }).join('/'));
};


// path.relative(from, to)
// posix version
exports.relative = function(from, to) {
  from = exports.resolve(from).substr(1);
  to = exports.resolve(to).substr(1);

  function trim(arr) {
    var start = 0;
    for (; start < arr.length; start++) {
      if (arr[start] !== '') break;
    }

    var end = arr.length - 1;
    for (; end >= 0; end--) {
      if (arr[end] !== '') break;
    }

    if (start > end) return [];
    return arr.slice(start, end - start + 1);
  }

  var fromParts = trim(from.split('/'));
  var toParts = trim(to.split('/'));

  var length = Math.min(fromParts.length, toParts.length);
  var samePartsLength = length;
  for (var i = 0; i < length; i++) {
    if (fromParts[i] !== toParts[i]) {
      samePartsLength = i;
      break;
    }
  }

  var outputParts = [];
  for (var i = samePartsLength; i < fromParts.length; i++) {
    outputParts.push('..');
  }

  outputParts = outputParts.concat(toParts.slice(samePartsLength));

  return outputParts.join('/');
};

exports.sep = '/';
exports.delimiter = ':';

exports.dirname = function(path) {
  var result = splitPath(path),
      root = result[0],
      dir = result[1];

  if (!root && !dir) {
    // No dirname whatsoever
    return '.';
  }

  if (dir) {
    // It has a dirname, strip trailing slash
    dir = dir.substr(0, dir.length - 1);
  }

  return root + dir;
};


exports.basename = function(path, ext) {
  var f = splitPath(path)[2];
  // TODO: make this comparison case-insensitive on windows?
  if (ext && f.substr(-1 * ext.length) === ext) {
    f = f.substr(0, f.length - ext.length);
  }
  return f;
};


exports.extname = function(path) {
  return splitPath(path)[3];
};

function filter (xs, f) {
    if (xs.filter) return xs.filter(f);
    var res = [];
    for (var i = 0; i < xs.length; i++) {
        if (f(xs[i], i, xs)) res.push(xs[i]);
    }
    return res;
}

// String.prototype.substr - negative index don't work in IE8
var substr = 'ab'.substr(-1) === 'b'
    ? function (str, start, len) { return str.substr(start, len) }
    : function (str, start, len) {
        if (start < 0) start = str.length + start;
        return str.substr(start, len);
    }
;

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(13)))

/***/ }),
/* 55 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(module, global) {var __WEBPACK_AMD_DEFINE_RESULT__;/*! https://mths.be/punycode v1.3.2 by @mathias */
;(function(root) {

	/** Detect free variables */
	var freeExports = typeof exports == 'object' && exports &&
		!exports.nodeType && exports;
	var freeModule = typeof module == 'object' && module &&
		!module.nodeType && module;
	var freeGlobal = typeof global == 'object' && global;
	if (
		freeGlobal.global === freeGlobal ||
		freeGlobal.window === freeGlobal ||
		freeGlobal.self === freeGlobal
	) {
		root = freeGlobal;
	}

	/**
	 * The `punycode` object.
	 * @name punycode
	 * @type Object
	 */
	var punycode,

	/** Highest positive signed 32-bit float value */
	maxInt = 2147483647, // aka. 0x7FFFFFFF or 2^31-1

	/** Bootstring parameters */
	base = 36,
	tMin = 1,
	tMax = 26,
	skew = 38,
	damp = 700,
	initialBias = 72,
	initialN = 128, // 0x80
	delimiter = '-', // '\x2D'

	/** Regular expressions */
	regexPunycode = /^xn--/,
	regexNonASCII = /[^\x20-\x7E]/, // unprintable ASCII chars + non-ASCII chars
	regexSeparators = /[\x2E\u3002\uFF0E\uFF61]/g, // RFC 3490 separators

	/** Error messages */
	errors = {
		'overflow': 'Overflow: input needs wider integers to process',
		'not-basic': 'Illegal input >= 0x80 (not a basic code point)',
		'invalid-input': 'Invalid input'
	},

	/** Convenience shortcuts */
	baseMinusTMin = base - tMin,
	floor = Math.floor,
	stringFromCharCode = String.fromCharCode,

	/** Temporary variable */
	key;

	/*--------------------------------------------------------------------------*/

	/**
	 * A generic error utility function.
	 * @private
	 * @param {String} type The error type.
	 * @returns {Error} Throws a `RangeError` with the applicable error message.
	 */
	function error(type) {
		throw RangeError(errors[type]);
	}

	/**
	 * A generic `Array#map` utility function.
	 * @private
	 * @param {Array} array The array to iterate over.
	 * @param {Function} callback The function that gets called for every array
	 * item.
	 * @returns {Array} A new array of values returned by the callback function.
	 */
	function map(array, fn) {
		var length = array.length;
		var result = [];
		while (length--) {
			result[length] = fn(array[length]);
		}
		return result;
	}

	/**
	 * A simple `Array#map`-like wrapper to work with domain name strings or email
	 * addresses.
	 * @private
	 * @param {String} domain The domain name or email address.
	 * @param {Function} callback The function that gets called for every
	 * character.
	 * @returns {Array} A new string of characters returned by the callback
	 * function.
	 */
	function mapDomain(string, fn) {
		var parts = string.split('@');
		var result = '';
		if (parts.length > 1) {
			// In email addresses, only the domain name should be punycoded. Leave
			// the local part (i.e. everything up to `@`) intact.
			result = parts[0] + '@';
			string = parts[1];
		}
		// Avoid `split(regex)` for IE8 compatibility. See #17.
		string = string.replace(regexSeparators, '\x2E');
		var labels = string.split('.');
		var encoded = map(labels, fn).join('.');
		return result + encoded;
	}

	/**
	 * Creates an array containing the numeric code points of each Unicode
	 * character in the string. While JavaScript uses UCS-2 internally,
	 * this function will convert a pair of surrogate halves (each of which
	 * UCS-2 exposes as separate characters) into a single code point,
	 * matching UTF-16.
	 * @see `punycode.ucs2.encode`
	 * @see <https://mathiasbynens.be/notes/javascript-encoding>
	 * @memberOf punycode.ucs2
	 * @name decode
	 * @param {String} string The Unicode input string (UCS-2).
	 * @returns {Array} The new array of code points.
	 */
	function ucs2decode(string) {
		var output = [],
		    counter = 0,
		    length = string.length,
		    value,
		    extra;
		while (counter < length) {
			value = string.charCodeAt(counter++);
			if (value >= 0xD800 && value <= 0xDBFF && counter < length) {
				// high surrogate, and there is a next character
				extra = string.charCodeAt(counter++);
				if ((extra & 0xFC00) == 0xDC00) { // low surrogate
					output.push(((value & 0x3FF) << 10) + (extra & 0x3FF) + 0x10000);
				} else {
					// unmatched surrogate; only append this code unit, in case the next
					// code unit is the high surrogate of a surrogate pair
					output.push(value);
					counter--;
				}
			} else {
				output.push(value);
			}
		}
		return output;
	}

	/**
	 * Creates a string based on an array of numeric code points.
	 * @see `punycode.ucs2.decode`
	 * @memberOf punycode.ucs2
	 * @name encode
	 * @param {Array} codePoints The array of numeric code points.
	 * @returns {String} The new Unicode string (UCS-2).
	 */
	function ucs2encode(array) {
		return map(array, function(value) {
			var output = '';
			if (value > 0xFFFF) {
				value -= 0x10000;
				output += stringFromCharCode(value >>> 10 & 0x3FF | 0xD800);
				value = 0xDC00 | value & 0x3FF;
			}
			output += stringFromCharCode(value);
			return output;
		}).join('');
	}

	/**
	 * Converts a basic code point into a digit/integer.
	 * @see `digitToBasic()`
	 * @private
	 * @param {Number} codePoint The basic numeric code point value.
	 * @returns {Number} The numeric value of a basic code point (for use in
	 * representing integers) in the range `0` to `base - 1`, or `base` if
	 * the code point does not represent a value.
	 */
	function basicToDigit(codePoint) {
		if (codePoint - 48 < 10) {
			return codePoint - 22;
		}
		if (codePoint - 65 < 26) {
			return codePoint - 65;
		}
		if (codePoint - 97 < 26) {
			return codePoint - 97;
		}
		return base;
	}

	/**
	 * Converts a digit/integer into a basic code point.
	 * @see `basicToDigit()`
	 * @private
	 * @param {Number} digit The numeric value of a basic code point.
	 * @returns {Number} The basic code point whose value (when used for
	 * representing integers) is `digit`, which needs to be in the range
	 * `0` to `base - 1`. If `flag` is non-zero, the uppercase form is
	 * used; else, the lowercase form is used. The behavior is undefined
	 * if `flag` is non-zero and `digit` has no uppercase form.
	 */
	function digitToBasic(digit, flag) {
		//  0..25 map to ASCII a..z or A..Z
		// 26..35 map to ASCII 0..9
		return digit + 22 + 75 * (digit < 26) - ((flag != 0) << 5);
	}

	/**
	 * Bias adaptation function as per section 3.4 of RFC 3492.
	 * http://tools.ietf.org/html/rfc3492#section-3.4
	 * @private
	 */
	function adapt(delta, numPoints, firstTime) {
		var k = 0;
		delta = firstTime ? floor(delta / damp) : delta >> 1;
		delta += floor(delta / numPoints);
		for (/* no initialization */; delta > baseMinusTMin * tMax >> 1; k += base) {
			delta = floor(delta / baseMinusTMin);
		}
		return floor(k + (baseMinusTMin + 1) * delta / (delta + skew));
	}

	/**
	 * Converts a Punycode string of ASCII-only symbols to a string of Unicode
	 * symbols.
	 * @memberOf punycode
	 * @param {String} input The Punycode string of ASCII-only symbols.
	 * @returns {String} The resulting string of Unicode symbols.
	 */
	function decode(input) {
		// Don't use UCS-2
		var output = [],
		    inputLength = input.length,
		    out,
		    i = 0,
		    n = initialN,
		    bias = initialBias,
		    basic,
		    j,
		    index,
		    oldi,
		    w,
		    k,
		    digit,
		    t,
		    /** Cached calculation results */
		    baseMinusT;

		// Handle the basic code points: let `basic` be the number of input code
		// points before the last delimiter, or `0` if there is none, then copy
		// the first basic code points to the output.

		basic = input.lastIndexOf(delimiter);
		if (basic < 0) {
			basic = 0;
		}

		for (j = 0; j < basic; ++j) {
			// if it's not a basic code point
			if (input.charCodeAt(j) >= 0x80) {
				error('not-basic');
			}
			output.push(input.charCodeAt(j));
		}

		// Main decoding loop: start just after the last delimiter if any basic code
		// points were copied; start at the beginning otherwise.

		for (index = basic > 0 ? basic + 1 : 0; index < inputLength; /* no final expression */) {

			// `index` is the index of the next character to be consumed.
			// Decode a generalized variable-length integer into `delta`,
			// which gets added to `i`. The overflow checking is easier
			// if we increase `i` as we go, then subtract off its starting
			// value at the end to obtain `delta`.
			for (oldi = i, w = 1, k = base; /* no condition */; k += base) {

				if (index >= inputLength) {
					error('invalid-input');
				}

				digit = basicToDigit(input.charCodeAt(index++));

				if (digit >= base || digit > floor((maxInt - i) / w)) {
					error('overflow');
				}

				i += digit * w;
				t = k <= bias ? tMin : (k >= bias + tMax ? tMax : k - bias);

				if (digit < t) {
					break;
				}

				baseMinusT = base - t;
				if (w > floor(maxInt / baseMinusT)) {
					error('overflow');
				}

				w *= baseMinusT;

			}

			out = output.length + 1;
			bias = adapt(i - oldi, out, oldi == 0);

			// `i` was supposed to wrap around from `out` to `0`,
			// incrementing `n` each time, so we'll fix that now:
			if (floor(i / out) > maxInt - n) {
				error('overflow');
			}

			n += floor(i / out);
			i %= out;

			// Insert `n` at position `i` of the output
			output.splice(i++, 0, n);

		}

		return ucs2encode(output);
	}

	/**
	 * Converts a string of Unicode symbols (e.g. a domain name label) to a
	 * Punycode string of ASCII-only symbols.
	 * @memberOf punycode
	 * @param {String} input The string of Unicode symbols.
	 * @returns {String} The resulting Punycode string of ASCII-only symbols.
	 */
	function encode(input) {
		var n,
		    delta,
		    handledCPCount,
		    basicLength,
		    bias,
		    j,
		    m,
		    q,
		    k,
		    t,
		    currentValue,
		    output = [],
		    /** `inputLength` will hold the number of code points in `input`. */
		    inputLength,
		    /** Cached calculation results */
		    handledCPCountPlusOne,
		    baseMinusT,
		    qMinusT;

		// Convert the input in UCS-2 to Unicode
		input = ucs2decode(input);

		// Cache the length
		inputLength = input.length;

		// Initialize the state
		n = initialN;
		delta = 0;
		bias = initialBias;

		// Handle the basic code points
		for (j = 0; j < inputLength; ++j) {
			currentValue = input[j];
			if (currentValue < 0x80) {
				output.push(stringFromCharCode(currentValue));
			}
		}

		handledCPCount = basicLength = output.length;

		// `handledCPCount` is the number of code points that have been handled;
		// `basicLength` is the number of basic code points.

		// Finish the basic string - if it is not empty - with a delimiter
		if (basicLength) {
			output.push(delimiter);
		}

		// Main encoding loop:
		while (handledCPCount < inputLength) {

			// All non-basic code points < n have been handled already. Find the next
			// larger one:
			for (m = maxInt, j = 0; j < inputLength; ++j) {
				currentValue = input[j];
				if (currentValue >= n && currentValue < m) {
					m = currentValue;
				}
			}

			// Increase `delta` enough to advance the decoder's <n,i> state to <m,0>,
			// but guard against overflow
			handledCPCountPlusOne = handledCPCount + 1;
			if (m - n > floor((maxInt - delta) / handledCPCountPlusOne)) {
				error('overflow');
			}

			delta += (m - n) * handledCPCountPlusOne;
			n = m;

			for (j = 0; j < inputLength; ++j) {
				currentValue = input[j];

				if (currentValue < n && ++delta > maxInt) {
					error('overflow');
				}

				if (currentValue == n) {
					// Represent delta as a generalized variable-length integer
					for (q = delta, k = base; /* no condition */; k += base) {
						t = k <= bias ? tMin : (k >= bias + tMax ? tMax : k - bias);
						if (q < t) {
							break;
						}
						qMinusT = q - t;
						baseMinusT = base - t;
						output.push(
							stringFromCharCode(digitToBasic(t + qMinusT % baseMinusT, 0))
						);
						q = floor(qMinusT / baseMinusT);
					}

					output.push(stringFromCharCode(digitToBasic(q, 0)));
					bias = adapt(delta, handledCPCountPlusOne, handledCPCount == basicLength);
					delta = 0;
					++handledCPCount;
				}
			}

			++delta;
			++n;

		}
		return output.join('');
	}

	/**
	 * Converts a Punycode string representing a domain name or an email address
	 * to Unicode. Only the Punycoded parts of the input will be converted, i.e.
	 * it doesn't matter if you call it on a string that has already been
	 * converted to Unicode.
	 * @memberOf punycode
	 * @param {String} input The Punycoded domain name or email address to
	 * convert to Unicode.
	 * @returns {String} The Unicode representation of the given Punycode
	 * string.
	 */
	function toUnicode(input) {
		return mapDomain(input, function(string) {
			return regexPunycode.test(string)
				? decode(string.slice(4).toLowerCase())
				: string;
		});
	}

	/**
	 * Converts a Unicode string representing a domain name or an email address to
	 * Punycode. Only the non-ASCII parts of the domain name will be converted,
	 * i.e. it doesn't matter if you call it with a domain that's already in
	 * ASCII.
	 * @memberOf punycode
	 * @param {String} input The domain name or email address to convert, as a
	 * Unicode string.
	 * @returns {String} The Punycode representation of the given domain name or
	 * email address.
	 */
	function toASCII(input) {
		return mapDomain(input, function(string) {
			return regexNonASCII.test(string)
				? 'xn--' + encode(string)
				: string;
		});
	}

	/*--------------------------------------------------------------------------*/

	/** Define the public API */
	punycode = {
		/**
		 * A string representing the current Punycode.js version number.
		 * @memberOf punycode
		 * @type String
		 */
		'version': '1.3.2',
		/**
		 * An object of methods to convert from JavaScript's internal character
		 * representation (UCS-2) to Unicode code points, and back.
		 * @see <https://mathiasbynens.be/notes/javascript-encoding>
		 * @memberOf punycode
		 * @type Object
		 */
		'ucs2': {
			'decode': ucs2decode,
			'encode': ucs2encode
		},
		'decode': decode,
		'encode': encode,
		'toASCII': toASCII,
		'toUnicode': toUnicode
	};

	/** Expose `punycode` */
	// Some AMD build optimizers, like r.js, check for specific condition patterns
	// like the following:
	if (
		true
	) {
		!(__WEBPACK_AMD_DEFINE_RESULT__ = function() {
			return punycode;
		}.call(exports, __webpack_require__, exports, module),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
	} else if (freeExports && freeModule) {
		if (module.exports == freeExports) { // in Node.js or RingoJS v0.8.0+
			freeModule.exports = punycode;
		} else { // in Narwhal or RingoJS v0.7.0-
			for (key in punycode) {
				punycode.hasOwnProperty(key) && (freeExports[key] = punycode[key]);
			}
		}
	} else { // in Rhino or a web browser
		root.punycode = punycode;
	}

}(this));

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(63)(module), __webpack_require__(14)))

/***/ }),
/* 56 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.



// If obj.hasOwnProperty has been overridden, then calling
// obj.hasOwnProperty(prop) will break.
// See: https://github.com/joyent/node/issues/1707
function hasOwnProperty(obj, prop) {
  return Object.prototype.hasOwnProperty.call(obj, prop);
}

module.exports = function(qs, sep, eq, options) {
  sep = sep || '&';
  eq = eq || '=';
  var obj = {};

  if (typeof qs !== 'string' || qs.length === 0) {
    return obj;
  }

  var regexp = /\+/g;
  qs = qs.split(sep);

  var maxKeys = 1000;
  if (options && typeof options.maxKeys === 'number') {
    maxKeys = options.maxKeys;
  }

  var len = qs.length;
  // maxKeys <= 0 means that we should not limit keys count
  if (maxKeys > 0 && len > maxKeys) {
    len = maxKeys;
  }

  for (var i = 0; i < len; ++i) {
    var x = qs[i].replace(regexp, '%20'),
        idx = x.indexOf(eq),
        kstr, vstr, k, v;

    if (idx >= 0) {
      kstr = x.substr(0, idx);
      vstr = x.substr(idx + 1);
    } else {
      kstr = x;
      vstr = '';
    }

    k = decodeURIComponent(kstr);
    v = decodeURIComponent(vstr);

    if (!hasOwnProperty(obj, k)) {
      obj[k] = v;
    } else if (isArray(obj[k])) {
      obj[k].push(v);
    } else {
      obj[k] = [obj[k], v];
    }
  }

  return obj;
};

var isArray = Array.isArray || function (xs) {
  return Object.prototype.toString.call(xs) === '[object Array]';
};


/***/ }),
/* 57 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.



var stringifyPrimitive = function(v) {
  switch (typeof v) {
    case 'string':
      return v;

    case 'boolean':
      return v ? 'true' : 'false';

    case 'number':
      return isFinite(v) ? v : '';

    default:
      return '';
  }
};

module.exports = function(obj, sep, eq, name) {
  sep = sep || '&';
  eq = eq || '=';
  if (obj === null) {
    obj = undefined;
  }

  if (typeof obj === 'object') {
    return map(objectKeys(obj), function(k) {
      var ks = encodeURIComponent(stringifyPrimitive(k)) + eq;
      if (isArray(obj[k])) {
        return map(obj[k], function(v) {
          return ks + encodeURIComponent(stringifyPrimitive(v));
        }).join(sep);
      } else {
        return ks + encodeURIComponent(stringifyPrimitive(obj[k]));
      }
    }).join(sep);

  }

  if (!name) return '';
  return encodeURIComponent(stringifyPrimitive(name)) + eq +
         encodeURIComponent(stringifyPrimitive(obj));
};

var isArray = Array.isArray || function (xs) {
  return Object.prototype.toString.call(xs) === '[object Array]';
};

function map (xs, f) {
  if (xs.map) return xs.map(f);
  var res = [];
  for (var i = 0; i < xs.length; i++) {
    res.push(f(xs[i], i));
  }
  return res;
}

var objectKeys = Object.keys || function (obj) {
  var res = [];
  for (var key in obj) {
    if (Object.prototype.hasOwnProperty.call(obj, key)) res.push(key);
  }
  return res;
};


/***/ }),
/* 58 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.decode = exports.parse = __webpack_require__(56);
exports.encode = exports.stringify = __webpack_require__(57);


/***/ }),
/* 59 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global, process) {(function (global, undefined) {
    "use strict";

    if (global.setImmediate) {
        return;
    }

    var nextHandle = 1; // Spec says greater than zero
    var tasksByHandle = {};
    var currentlyRunningATask = false;
    var doc = global.document;
    var registerImmediate;

    function setImmediate(callback) {
      // Callback can either be a function or a string
      if (typeof callback !== "function") {
        callback = new Function("" + callback);
      }
      // Copy function arguments
      var args = new Array(arguments.length - 1);
      for (var i = 0; i < args.length; i++) {
          args[i] = arguments[i + 1];
      }
      // Store and register the task
      var task = { callback: callback, args: args };
      tasksByHandle[nextHandle] = task;
      registerImmediate(nextHandle);
      return nextHandle++;
    }

    function clearImmediate(handle) {
        delete tasksByHandle[handle];
    }

    function run(task) {
        var callback = task.callback;
        var args = task.args;
        switch (args.length) {
        case 0:
            callback();
            break;
        case 1:
            callback(args[0]);
            break;
        case 2:
            callback(args[0], args[1]);
            break;
        case 3:
            callback(args[0], args[1], args[2]);
            break;
        default:
            callback.apply(undefined, args);
            break;
        }
    }

    function runIfPresent(handle) {
        // From the spec: "Wait until any invocations of this algorithm started before this one have completed."
        // So if we're currently running a task, we'll need to delay this invocation.
        if (currentlyRunningATask) {
            // Delay by doing a setTimeout. setImmediate was tried instead, but in Firefox 7 it generated a
            // "too much recursion" error.
            setTimeout(runIfPresent, 0, handle);
        } else {
            var task = tasksByHandle[handle];
            if (task) {
                currentlyRunningATask = true;
                try {
                    run(task);
                } finally {
                    clearImmediate(handle);
                    currentlyRunningATask = false;
                }
            }
        }
    }

    function installNextTickImplementation() {
        registerImmediate = function(handle) {
            process.nextTick(function () { runIfPresent(handle); });
        };
    }

    function canUsePostMessage() {
        // The test against `importScripts` prevents this implementation from being installed inside a web worker,
        // where `global.postMessage` means something completely different and can't be used for this purpose.
        if (global.postMessage && !global.importScripts) {
            var postMessageIsAsynchronous = true;
            var oldOnMessage = global.onmessage;
            global.onmessage = function() {
                postMessageIsAsynchronous = false;
            };
            global.postMessage("", "*");
            global.onmessage = oldOnMessage;
            return postMessageIsAsynchronous;
        }
    }

    function installPostMessageImplementation() {
        // Installs an event handler on `global` for the `message` event: see
        // * https://developer.mozilla.org/en/DOM/window.postMessage
        // * http://www.whatwg.org/specs/web-apps/current-work/multipage/comms.html#crossDocumentMessages

        var messagePrefix = "setImmediate$" + Math.random() + "$";
        var onGlobalMessage = function(event) {
            if (event.source === global &&
                typeof event.data === "string" &&
                event.data.indexOf(messagePrefix) === 0) {
                runIfPresent(+event.data.slice(messagePrefix.length));
            }
        };

        if (global.addEventListener) {
            global.addEventListener("message", onGlobalMessage, false);
        } else {
            global.attachEvent("onmessage", onGlobalMessage);
        }

        registerImmediate = function(handle) {
            global.postMessage(messagePrefix + handle, "*");
        };
    }

    function installMessageChannelImplementation() {
        var channel = new MessageChannel();
        channel.port1.onmessage = function(event) {
            var handle = event.data;
            runIfPresent(handle);
        };

        registerImmediate = function(handle) {
            channel.port2.postMessage(handle);
        };
    }

    function installReadyStateChangeImplementation() {
        var html = doc.documentElement;
        registerImmediate = function(handle) {
            // Create a <script> element; its readystatechange event will be fired asynchronously once it is inserted
            // into the document. Do so, thus queuing up the task. Remember to clean up once it's been called.
            var script = doc.createElement("script");
            script.onreadystatechange = function () {
                runIfPresent(handle);
                script.onreadystatechange = null;
                html.removeChild(script);
                script = null;
            };
            html.appendChild(script);
        };
    }

    function installSetTimeoutImplementation() {
        registerImmediate = function(handle) {
            setTimeout(runIfPresent, 0, handle);
        };
    }

    // If supported, we should attach to the prototype of global, since that is where setTimeout et al. live.
    var attachTo = Object.getPrototypeOf && Object.getPrototypeOf(global);
    attachTo = attachTo && attachTo.setTimeout ? attachTo : global;

    // Don't get fooled by e.g. browserify environments.
    if ({}.toString.call(global.process) === "[object process]") {
        // For Node.js before 0.9
        installNextTickImplementation();

    } else if (canUsePostMessage()) {
        // For non-IE10 modern browsers
        installPostMessageImplementation();

    } else if (global.MessageChannel) {
        // For web workers, where supported
        installMessageChannelImplementation();

    } else if (doc && "onreadystatechange" in doc.createElement("script")) {
        // For IE 6–8
        installReadyStateChangeImplementation();

    } else {
        // For older browsers
        installSetTimeoutImplementation();
    }

    attachTo.setImmediate = setImmediate;
    attachTo.clearImmediate = clearImmediate;
}(typeof self === "undefined" ? typeof global === "undefined" ? this : global : self));

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(14), __webpack_require__(13)))

/***/ }),
/* 60 */
/***/ (function(module, exports, __webpack_require__) {

var apply = Function.prototype.apply;

// DOM APIs, for completeness

exports.setTimeout = function() {
  return new Timeout(apply.call(setTimeout, window, arguments), clearTimeout);
};
exports.setInterval = function() {
  return new Timeout(apply.call(setInterval, window, arguments), clearInterval);
};
exports.clearTimeout =
exports.clearInterval = function(timeout) {
  if (timeout) {
    timeout.close();
  }
};

function Timeout(id, clearFn) {
  this._id = id;
  this._clearFn = clearFn;
}
Timeout.prototype.unref = Timeout.prototype.ref = function() {};
Timeout.prototype.close = function() {
  this._clearFn.call(window, this._id);
};

// Does not start the time, just sets up the members needed.
exports.enroll = function(item, msecs) {
  clearTimeout(item._idleTimeoutId);
  item._idleTimeout = msecs;
};

exports.unenroll = function(item) {
  clearTimeout(item._idleTimeoutId);
  item._idleTimeout = -1;
};

exports._unrefActive = exports.active = function(item) {
  clearTimeout(item._idleTimeoutId);

  var msecs = item._idleTimeout;
  if (msecs >= 0) {
    item._idleTimeoutId = setTimeout(function onTimeout() {
      if (item._onTimeout)
        item._onTimeout();
    }, msecs);
  }
};

// setimmediate attaches itself to the global object
__webpack_require__(59);
exports.setImmediate = setImmediate;
exports.clearImmediate = clearImmediate;


/***/ }),
/* 61 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.



var punycode = __webpack_require__(55);
var util = __webpack_require__(62);

exports.parse = urlParse;
exports.resolve = urlResolve;
exports.resolveObject = urlResolveObject;
exports.format = urlFormat;

exports.Url = Url;

function Url() {
  this.protocol = null;
  this.slashes = null;
  this.auth = null;
  this.host = null;
  this.port = null;
  this.hostname = null;
  this.hash = null;
  this.search = null;
  this.query = null;
  this.pathname = null;
  this.path = null;
  this.href = null;
}

// Reference: RFC 3986, RFC 1808, RFC 2396

// define these here so at least they only have to be
// compiled once on the first module load.
var protocolPattern = /^([a-z0-9.+-]+:)/i,
    portPattern = /:[0-9]*$/,

    // Special case for a simple path URL
    simplePathPattern = /^(\/\/?(?!\/)[^\?\s]*)(\?[^\s]*)?$/,

    // RFC 2396: characters reserved for delimiting URLs.
    // We actually just auto-escape these.
    delims = ['<', '>', '"', '`', ' ', '\r', '\n', '\t'],

    // RFC 2396: characters not allowed for various reasons.
    unwise = ['{', '}', '|', '\\', '^', '`'].concat(delims),

    // Allowed by RFCs, but cause of XSS attacks.  Always escape these.
    autoEscape = ['\''].concat(unwise),
    // Characters that are never ever allowed in a hostname.
    // Note that any invalid chars are also handled, but these
    // are the ones that are *expected* to be seen, so we fast-path
    // them.
    nonHostChars = ['%', '/', '?', ';', '#'].concat(autoEscape),
    hostEndingChars = ['/', '?', '#'],
    hostnameMaxLen = 255,
    hostnamePartPattern = /^[+a-z0-9A-Z_-]{0,63}$/,
    hostnamePartStart = /^([+a-z0-9A-Z_-]{0,63})(.*)$/,
    // protocols that can allow "unsafe" and "unwise" chars.
    unsafeProtocol = {
      'javascript': true,
      'javascript:': true
    },
    // protocols that never have a hostname.
    hostlessProtocol = {
      'javascript': true,
      'javascript:': true
    },
    // protocols that always contain a // bit.
    slashedProtocol = {
      'http': true,
      'https': true,
      'ftp': true,
      'gopher': true,
      'file': true,
      'http:': true,
      'https:': true,
      'ftp:': true,
      'gopher:': true,
      'file:': true
    },
    querystring = __webpack_require__(58);

function urlParse(url, parseQueryString, slashesDenoteHost) {
  if (url && util.isObject(url) && url instanceof Url) return url;

  var u = new Url;
  u.parse(url, parseQueryString, slashesDenoteHost);
  return u;
}

Url.prototype.parse = function(url, parseQueryString, slashesDenoteHost) {
  if (!util.isString(url)) {
    throw new TypeError("Parameter 'url' must be a string, not " + typeof url);
  }

  // Copy chrome, IE, opera backslash-handling behavior.
  // Back slashes before the query string get converted to forward slashes
  // See: https://code.google.com/p/chromium/issues/detail?id=25916
  var queryIndex = url.indexOf('?'),
      splitter =
          (queryIndex !== -1 && queryIndex < url.indexOf('#')) ? '?' : '#',
      uSplit = url.split(splitter),
      slashRegex = /\\/g;
  uSplit[0] = uSplit[0].replace(slashRegex, '/');
  url = uSplit.join(splitter);

  var rest = url;

  // trim before proceeding.
  // This is to support parse stuff like "  http://foo.com  \n"
  rest = rest.trim();

  if (!slashesDenoteHost && url.split('#').length === 1) {
    // Try fast path regexp
    var simplePath = simplePathPattern.exec(rest);
    if (simplePath) {
      this.path = rest;
      this.href = rest;
      this.pathname = simplePath[1];
      if (simplePath[2]) {
        this.search = simplePath[2];
        if (parseQueryString) {
          this.query = querystring.parse(this.search.substr(1));
        } else {
          this.query = this.search.substr(1);
        }
      } else if (parseQueryString) {
        this.search = '';
        this.query = {};
      }
      return this;
    }
  }

  var proto = protocolPattern.exec(rest);
  if (proto) {
    proto = proto[0];
    var lowerProto = proto.toLowerCase();
    this.protocol = lowerProto;
    rest = rest.substr(proto.length);
  }

  // figure out if it's got a host
  // user@server is *always* interpreted as a hostname, and url
  // resolution will treat //foo/bar as host=foo,path=bar because that's
  // how the browser resolves relative URLs.
  if (slashesDenoteHost || proto || rest.match(/^\/\/[^@\/]+@[^@\/]+/)) {
    var slashes = rest.substr(0, 2) === '//';
    if (slashes && !(proto && hostlessProtocol[proto])) {
      rest = rest.substr(2);
      this.slashes = true;
    }
  }

  if (!hostlessProtocol[proto] &&
      (slashes || (proto && !slashedProtocol[proto]))) {

    // there's a hostname.
    // the first instance of /, ?, ;, or # ends the host.
    //
    // If there is an @ in the hostname, then non-host chars *are* allowed
    // to the left of the last @ sign, unless some host-ending character
    // comes *before* the @-sign.
    // URLs are obnoxious.
    //
    // ex:
    // http://a@b@c/ => user:a@b host:c
    // http://a@b?@c => user:a host:c path:/?@c

    // v0.12 TODO(isaacs): This is not quite how Chrome does things.
    // Review our test case against browsers more comprehensively.

    // find the first instance of any hostEndingChars
    var hostEnd = -1;
    for (var i = 0; i < hostEndingChars.length; i++) {
      var hec = rest.indexOf(hostEndingChars[i]);
      if (hec !== -1 && (hostEnd === -1 || hec < hostEnd))
        hostEnd = hec;
    }

    // at this point, either we have an explicit point where the
    // auth portion cannot go past, or the last @ char is the decider.
    var auth, atSign;
    if (hostEnd === -1) {
      // atSign can be anywhere.
      atSign = rest.lastIndexOf('@');
    } else {
      // atSign must be in auth portion.
      // http://a@b/c@d => host:b auth:a path:/c@d
      atSign = rest.lastIndexOf('@', hostEnd);
    }

    // Now we have a portion which is definitely the auth.
    // Pull that off.
    if (atSign !== -1) {
      auth = rest.slice(0, atSign);
      rest = rest.slice(atSign + 1);
      this.auth = decodeURIComponent(auth);
    }

    // the host is the remaining to the left of the first non-host char
    hostEnd = -1;
    for (var i = 0; i < nonHostChars.length; i++) {
      var hec = rest.indexOf(nonHostChars[i]);
      if (hec !== -1 && (hostEnd === -1 || hec < hostEnd))
        hostEnd = hec;
    }
    // if we still have not hit it, then the entire thing is a host.
    if (hostEnd === -1)
      hostEnd = rest.length;

    this.host = rest.slice(0, hostEnd);
    rest = rest.slice(hostEnd);

    // pull out port.
    this.parseHost();

    // we've indicated that there is a hostname,
    // so even if it's empty, it has to be present.
    this.hostname = this.hostname || '';

    // if hostname begins with [ and ends with ]
    // assume that it's an IPv6 address.
    var ipv6Hostname = this.hostname[0] === '[' &&
        this.hostname[this.hostname.length - 1] === ']';

    // validate a little.
    if (!ipv6Hostname) {
      var hostparts = this.hostname.split(/\./);
      for (var i = 0, l = hostparts.length; i < l; i++) {
        var part = hostparts[i];
        if (!part) continue;
        if (!part.match(hostnamePartPattern)) {
          var newpart = '';
          for (var j = 0, k = part.length; j < k; j++) {
            if (part.charCodeAt(j) > 127) {
              // we replace non-ASCII char with a temporary placeholder
              // we need this to make sure size of hostname is not
              // broken by replacing non-ASCII by nothing
              newpart += 'x';
            } else {
              newpart += part[j];
            }
          }
          // we test again with ASCII char only
          if (!newpart.match(hostnamePartPattern)) {
            var validParts = hostparts.slice(0, i);
            var notHost = hostparts.slice(i + 1);
            var bit = part.match(hostnamePartStart);
            if (bit) {
              validParts.push(bit[1]);
              notHost.unshift(bit[2]);
            }
            if (notHost.length) {
              rest = '/' + notHost.join('.') + rest;
            }
            this.hostname = validParts.join('.');
            break;
          }
        }
      }
    }

    if (this.hostname.length > hostnameMaxLen) {
      this.hostname = '';
    } else {
      // hostnames are always lower case.
      this.hostname = this.hostname.toLowerCase();
    }

    if (!ipv6Hostname) {
      // IDNA Support: Returns a punycoded representation of "domain".
      // It only converts parts of the domain name that
      // have non-ASCII characters, i.e. it doesn't matter if
      // you call it with a domain that already is ASCII-only.
      this.hostname = punycode.toASCII(this.hostname);
    }

    var p = this.port ? ':' + this.port : '';
    var h = this.hostname || '';
    this.host = h + p;
    this.href += this.host;

    // strip [ and ] from the hostname
    // the host field still retains them, though
    if (ipv6Hostname) {
      this.hostname = this.hostname.substr(1, this.hostname.length - 2);
      if (rest[0] !== '/') {
        rest = '/' + rest;
      }
    }
  }

  // now rest is set to the post-host stuff.
  // chop off any delim chars.
  if (!unsafeProtocol[lowerProto]) {

    // First, make 100% sure that any "autoEscape" chars get
    // escaped, even if encodeURIComponent doesn't think they
    // need to be.
    for (var i = 0, l = autoEscape.length; i < l; i++) {
      var ae = autoEscape[i];
      if (rest.indexOf(ae) === -1)
        continue;
      var esc = encodeURIComponent(ae);
      if (esc === ae) {
        esc = escape(ae);
      }
      rest = rest.split(ae).join(esc);
    }
  }


  // chop off from the tail first.
  var hash = rest.indexOf('#');
  if (hash !== -1) {
    // got a fragment string.
    this.hash = rest.substr(hash);
    rest = rest.slice(0, hash);
  }
  var qm = rest.indexOf('?');
  if (qm !== -1) {
    this.search = rest.substr(qm);
    this.query = rest.substr(qm + 1);
    if (parseQueryString) {
      this.query = querystring.parse(this.query);
    }
    rest = rest.slice(0, qm);
  } else if (parseQueryString) {
    // no query string, but parseQueryString still requested
    this.search = '';
    this.query = {};
  }
  if (rest) this.pathname = rest;
  if (slashedProtocol[lowerProto] &&
      this.hostname && !this.pathname) {
    this.pathname = '/';
  }

  //to support http.request
  if (this.pathname || this.search) {
    var p = this.pathname || '';
    var s = this.search || '';
    this.path = p + s;
  }

  // finally, reconstruct the href based on what has been validated.
  this.href = this.format();
  return this;
};

// format a parsed object into a url string
function urlFormat(obj) {
  // ensure it's an object, and not a string url.
  // If it's an obj, this is a no-op.
  // this way, you can call url_format() on strings
  // to clean up potentially wonky urls.
  if (util.isString(obj)) obj = urlParse(obj);
  if (!(obj instanceof Url)) return Url.prototype.format.call(obj);
  return obj.format();
}

Url.prototype.format = function() {
  var auth = this.auth || '';
  if (auth) {
    auth = encodeURIComponent(auth);
    auth = auth.replace(/%3A/i, ':');
    auth += '@';
  }

  var protocol = this.protocol || '',
      pathname = this.pathname || '',
      hash = this.hash || '',
      host = false,
      query = '';

  if (this.host) {
    host = auth + this.host;
  } else if (this.hostname) {
    host = auth + (this.hostname.indexOf(':') === -1 ?
        this.hostname :
        '[' + this.hostname + ']');
    if (this.port) {
      host += ':' + this.port;
    }
  }

  if (this.query &&
      util.isObject(this.query) &&
      Object.keys(this.query).length) {
    query = querystring.stringify(this.query);
  }

  var search = this.search || (query && ('?' + query)) || '';

  if (protocol && protocol.substr(-1) !== ':') protocol += ':';

  // only the slashedProtocols get the //.  Not mailto:, xmpp:, etc.
  // unless they had them to begin with.
  if (this.slashes ||
      (!protocol || slashedProtocol[protocol]) && host !== false) {
    host = '//' + (host || '');
    if (pathname && pathname.charAt(0) !== '/') pathname = '/' + pathname;
  } else if (!host) {
    host = '';
  }

  if (hash && hash.charAt(0) !== '#') hash = '#' + hash;
  if (search && search.charAt(0) !== '?') search = '?' + search;

  pathname = pathname.replace(/[?#]/g, function(match) {
    return encodeURIComponent(match);
  });
  search = search.replace('#', '%23');

  return protocol + host + pathname + search + hash;
};

function urlResolve(source, relative) {
  return urlParse(source, false, true).resolve(relative);
}

Url.prototype.resolve = function(relative) {
  return this.resolveObject(urlParse(relative, false, true)).format();
};

function urlResolveObject(source, relative) {
  if (!source) return relative;
  return urlParse(source, false, true).resolveObject(relative);
}

Url.prototype.resolveObject = function(relative) {
  if (util.isString(relative)) {
    var rel = new Url();
    rel.parse(relative, false, true);
    relative = rel;
  }

  var result = new Url();
  var tkeys = Object.keys(this);
  for (var tk = 0; tk < tkeys.length; tk++) {
    var tkey = tkeys[tk];
    result[tkey] = this[tkey];
  }

  // hash is always overridden, no matter what.
  // even href="" will remove it.
  result.hash = relative.hash;

  // if the relative url is empty, then there's nothing left to do here.
  if (relative.href === '') {
    result.href = result.format();
    return result;
  }

  // hrefs like //foo/bar always cut to the protocol.
  if (relative.slashes && !relative.protocol) {
    // take everything except the protocol from relative
    var rkeys = Object.keys(relative);
    for (var rk = 0; rk < rkeys.length; rk++) {
      var rkey = rkeys[rk];
      if (rkey !== 'protocol')
        result[rkey] = relative[rkey];
    }

    //urlParse appends trailing / to urls like http://www.example.com
    if (slashedProtocol[result.protocol] &&
        result.hostname && !result.pathname) {
      result.path = result.pathname = '/';
    }

    result.href = result.format();
    return result;
  }

  if (relative.protocol && relative.protocol !== result.protocol) {
    // if it's a known url protocol, then changing
    // the protocol does weird things
    // first, if it's not file:, then we MUST have a host,
    // and if there was a path
    // to begin with, then we MUST have a path.
    // if it is file:, then the host is dropped,
    // because that's known to be hostless.
    // anything else is assumed to be absolute.
    if (!slashedProtocol[relative.protocol]) {
      var keys = Object.keys(relative);
      for (var v = 0; v < keys.length; v++) {
        var k = keys[v];
        result[k] = relative[k];
      }
      result.href = result.format();
      return result;
    }

    result.protocol = relative.protocol;
    if (!relative.host && !hostlessProtocol[relative.protocol]) {
      var relPath = (relative.pathname || '').split('/');
      while (relPath.length && !(relative.host = relPath.shift()));
      if (!relative.host) relative.host = '';
      if (!relative.hostname) relative.hostname = '';
      if (relPath[0] !== '') relPath.unshift('');
      if (relPath.length < 2) relPath.unshift('');
      result.pathname = relPath.join('/');
    } else {
      result.pathname = relative.pathname;
    }
    result.search = relative.search;
    result.query = relative.query;
    result.host = relative.host || '';
    result.auth = relative.auth;
    result.hostname = relative.hostname || relative.host;
    result.port = relative.port;
    // to support http.request
    if (result.pathname || result.search) {
      var p = result.pathname || '';
      var s = result.search || '';
      result.path = p + s;
    }
    result.slashes = result.slashes || relative.slashes;
    result.href = result.format();
    return result;
  }

  var isSourceAbs = (result.pathname && result.pathname.charAt(0) === '/'),
      isRelAbs = (
          relative.host ||
          relative.pathname && relative.pathname.charAt(0) === '/'
      ),
      mustEndAbs = (isRelAbs || isSourceAbs ||
                    (result.host && relative.pathname)),
      removeAllDots = mustEndAbs,
      srcPath = result.pathname && result.pathname.split('/') || [],
      relPath = relative.pathname && relative.pathname.split('/') || [],
      psychotic = result.protocol && !slashedProtocol[result.protocol];

  // if the url is a non-slashed url, then relative
  // links like ../.. should be able
  // to crawl up to the hostname, as well.  This is strange.
  // result.protocol has already been set by now.
  // Later on, put the first path part into the host field.
  if (psychotic) {
    result.hostname = '';
    result.port = null;
    if (result.host) {
      if (srcPath[0] === '') srcPath[0] = result.host;
      else srcPath.unshift(result.host);
    }
    result.host = '';
    if (relative.protocol) {
      relative.hostname = null;
      relative.port = null;
      if (relative.host) {
        if (relPath[0] === '') relPath[0] = relative.host;
        else relPath.unshift(relative.host);
      }
      relative.host = null;
    }
    mustEndAbs = mustEndAbs && (relPath[0] === '' || srcPath[0] === '');
  }

  if (isRelAbs) {
    // it's absolute.
    result.host = (relative.host || relative.host === '') ?
                  relative.host : result.host;
    result.hostname = (relative.hostname || relative.hostname === '') ?
                      relative.hostname : result.hostname;
    result.search = relative.search;
    result.query = relative.query;
    srcPath = relPath;
    // fall through to the dot-handling below.
  } else if (relPath.length) {
    // it's relative
    // throw away the existing file, and take the new path instead.
    if (!srcPath) srcPath = [];
    srcPath.pop();
    srcPath = srcPath.concat(relPath);
    result.search = relative.search;
    result.query = relative.query;
  } else if (!util.isNullOrUndefined(relative.search)) {
    // just pull out the search.
    // like href='?foo'.
    // Put this after the other two cases because it simplifies the booleans
    if (psychotic) {
      result.hostname = result.host = srcPath.shift();
      //occationaly the auth can get stuck only in host
      //this especially happens in cases like
      //url.resolveObject('mailto:local1@domain1', 'local2@domain2')
      var authInHost = result.host && result.host.indexOf('@') > 0 ?
                       result.host.split('@') : false;
      if (authInHost) {
        result.auth = authInHost.shift();
        result.host = result.hostname = authInHost.shift();
      }
    }
    result.search = relative.search;
    result.query = relative.query;
    //to support http.request
    if (!util.isNull(result.pathname) || !util.isNull(result.search)) {
      result.path = (result.pathname ? result.pathname : '') +
                    (result.search ? result.search : '');
    }
    result.href = result.format();
    return result;
  }

  if (!srcPath.length) {
    // no path at all.  easy.
    // we've already handled the other stuff above.
    result.pathname = null;
    //to support http.request
    if (result.search) {
      result.path = '/' + result.search;
    } else {
      result.path = null;
    }
    result.href = result.format();
    return result;
  }

  // if a url ENDs in . or .., then it must get a trailing slash.
  // however, if it ends in anything else non-slashy,
  // then it must NOT get a trailing slash.
  var last = srcPath.slice(-1)[0];
  var hasTrailingSlash = (
      (result.host || relative.host || srcPath.length > 1) &&
      (last === '.' || last === '..') || last === '');

  // strip single dots, resolve double dots to parent dir
  // if the path tries to go above the root, `up` ends up > 0
  var up = 0;
  for (var i = srcPath.length; i >= 0; i--) {
    last = srcPath[i];
    if (last === '.') {
      srcPath.splice(i, 1);
    } else if (last === '..') {
      srcPath.splice(i, 1);
      up++;
    } else if (up) {
      srcPath.splice(i, 1);
      up--;
    }
  }

  // if the path is allowed to go above the root, restore leading ..s
  if (!mustEndAbs && !removeAllDots) {
    for (; up--; up) {
      srcPath.unshift('..');
    }
  }

  if (mustEndAbs && srcPath[0] !== '' &&
      (!srcPath[0] || srcPath[0].charAt(0) !== '/')) {
    srcPath.unshift('');
  }

  if (hasTrailingSlash && (srcPath.join('/').substr(-1) !== '/')) {
    srcPath.push('');
  }

  var isAbsolute = srcPath[0] === '' ||
      (srcPath[0] && srcPath[0].charAt(0) === '/');

  // put the host back
  if (psychotic) {
    result.hostname = result.host = isAbsolute ? '' :
                                    srcPath.length ? srcPath.shift() : '';
    //occationaly the auth can get stuck only in host
    //this especially happens in cases like
    //url.resolveObject('mailto:local1@domain1', 'local2@domain2')
    var authInHost = result.host && result.host.indexOf('@') > 0 ?
                     result.host.split('@') : false;
    if (authInHost) {
      result.auth = authInHost.shift();
      result.host = result.hostname = authInHost.shift();
    }
  }

  mustEndAbs = mustEndAbs || (result.host && srcPath.length);

  if (mustEndAbs && !isAbsolute) {
    srcPath.unshift('');
  }

  if (!srcPath.length) {
    result.pathname = null;
    result.path = null;
  } else {
    result.pathname = srcPath.join('/');
  }

  //to support request.http
  if (!util.isNull(result.pathname) || !util.isNull(result.search)) {
    result.path = (result.pathname ? result.pathname : '') +
                  (result.search ? result.search : '');
  }
  result.auth = relative.auth || result.auth;
  result.slashes = result.slashes || relative.slashes;
  result.href = result.format();
  return result;
};

Url.prototype.parseHost = function() {
  var host = this.host;
  var port = portPattern.exec(host);
  if (port) {
    port = port[0];
    if (port !== ':') {
      this.port = port.substr(1);
    }
    host = host.substr(0, host.length - port.length);
  }
  if (host) this.hostname = host;
};


/***/ }),
/* 62 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = {
  isString: function(arg) {
    return typeof(arg) === 'string';
  },
  isObject: function(arg) {
    return typeof(arg) === 'object' && arg !== null;
  },
  isNull: function(arg) {
    return arg === null;
  },
  isNullOrUndefined: function(arg) {
    return arg == null;
  }
};


/***/ }),
/* 63 */
/***/ (function(module, exports) {

module.exports = function(module) {
	if(!module.webpackPolyfill) {
		module.deprecate = function() {};
		module.paths = [];
		// module.parent = undefined by default
		if(!module.children) module.children = [];
		Object.defineProperty(module, "loaded", {
			enumerable: true,
			get: function() {
				return module.l;
			}
		});
		Object.defineProperty(module, "id", {
			enumerable: true,
			get: function() {
				return module.i;
			}
		});
		module.webpackPolyfill = 1;
	}
	return module;
};


/***/ })
/******/ ]);
});

//# sourceMappingURL=data:application/json;charset=utf8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vd2VicGFjay91bml2ZXJzYWxNb2R1bGVEZWZpbml0aW9uIiwid2VicGFjazovLy9zb2NrZXQuaW8uc2xpbS5qcyIsIndlYnBhY2s6L3dlYnBhY2svYm9vdHN0cmFwIDZlZmMzM2Y0NTY2OTFmNDU4YTkwIiwid2VicGFjazovLy9saWIvaW5kZXguanMiLCJ3ZWJwYWNrOi8vL2xpYi91cmwuanMiLCJ3ZWJwYWNrOi8vL34vcGFyc2V1cmkvaW5kZXguanMiLCJ3ZWJwYWNrOi8vL3N1cHBvcnQvbm9vcC5qcyIsIndlYnBhY2s6Ly8vfi9zb2NrZXQuaW8tcGFyc2VyL2luZGV4LmpzIiwid2VicGFjazovLy9+L2NvbXBvbmVudC1lbWl0dGVyL2luZGV4LmpzIiwid2VicGFjazovLy9+L2hhcy1iaW5hcnkyL2luZGV4LmpzIiwid2VicGFjazovLy9+L2lzYXJyYXkvaW5kZXguanMiLCJ3ZWJwYWNrOi8vL34vc29ja2V0LmlvLXBhcnNlci9iaW5hcnkuanMiLCJ3ZWJwYWNrOi8vL34vc29ja2V0LmlvLXBhcnNlci9pcy1idWZmZXIuanMiLCJ3ZWJwYWNrOi8vL2xpYi9tYW5hZ2VyLmpzIiwid2VicGFjazovLy9+L2VuZ2luZS5pby1jbGllbnQvaW5kZXguanMiLCJ3ZWJwYWNrOi8vL34vZW5naW5lLmlvLWNsaWVudC9saWIvaW5kZXguanMiLCJ3ZWJwYWNrOi8vL34vZW5naW5lLmlvLWNsaWVudC9saWIvc29ja2V0LmpzIiwid2VicGFjazovLy9+L2VuZ2luZS5pby1jbGllbnQvbGliL3RyYW5zcG9ydHMvaW5kZXguanMiLCJ3ZWJwYWNrOi8vL34vZW5naW5lLmlvLWNsaWVudC9saWIveG1saHR0cHJlcXVlc3QuanMiLCJ3ZWJwYWNrOi8vL34vaGFzLWNvcnMvaW5kZXguanMiLCJ3ZWJwYWNrOi8vL34vZW5naW5lLmlvLWNsaWVudC9saWIvdHJhbnNwb3J0cy9wb2xsaW5nLXhoci5qcyIsIndlYnBhY2s6Ly8vfi9lbmdpbmUuaW8tY2xpZW50L2xpYi90cmFuc3BvcnRzL3BvbGxpbmcuanMiLCJ3ZWJwYWNrOi8vL34vZW5naW5lLmlvLWNsaWVudC9saWIvdHJhbnNwb3J0LmpzIiwid2VicGFjazovLy9+L2VuZ2luZS5pby1wYXJzZXIvbGliL2Jyb3dzZXIuanMiLCJ3ZWJwYWNrOi8vL34vZW5naW5lLmlvLXBhcnNlci9saWIva2V5cy5qcyIsIndlYnBhY2s6Ly8vfi9hcnJheWJ1ZmZlci5zbGljZS9pbmRleC5qcyIsIndlYnBhY2s6Ly8vfi9hZnRlci9pbmRleC5qcyIsIndlYnBhY2s6Ly8vfi9lbmdpbmUuaW8tcGFyc2VyL2xpYi91dGY4LmpzIiwid2VicGFjazovLy8od2VicGFjaykvYnVpbGRpbi9tb2R1bGUuanMiLCJ3ZWJwYWNrOi8vL34vYmFzZTY0LWFycmF5YnVmZmVyL2xpYi9iYXNlNjQtYXJyYXlidWZmZXIuanMiLCJ3ZWJwYWNrOi8vL34vYmxvYi9pbmRleC5qcyIsIndlYnBhY2s6Ly8vfi9wYXJzZXFzL2luZGV4LmpzIiwid2VicGFjazovLy9+L2NvbXBvbmVudC1pbmhlcml0L2luZGV4LmpzIiwid2VicGFjazovLy9+L3llYXN0L2luZGV4LmpzIiwid2VicGFjazovLy9+L2VuZ2luZS5pby1jbGllbnQvbGliL3RyYW5zcG9ydHMvcG9sbGluZy1qc29ucC5qcyIsIndlYnBhY2s6Ly8vfi9lbmdpbmUuaW8tY2xpZW50L2xpYi90cmFuc3BvcnRzL3dlYnNvY2tldC5qcyIsIndlYnBhY2s6Ly8vfi9pbmRleG9mL2luZGV4LmpzIiwid2VicGFjazovLy9+L3BhcnNlanNvbi9pbmRleC5qcyIsIndlYnBhY2s6Ly8vbGliL3NvY2tldC5qcyIsIndlYnBhY2s6Ly8vfi90by1hcnJheS9pbmRleC5qcyIsIndlYnBhY2s6Ly8vbGliL29uLmpzIiwid2VicGFjazovLy9+L2NvbXBvbmVudC1iaW5kL2luZGV4LmpzIiwid2VicGFjazovLy9+L2JhY2tvMi9pbmRleC5qcyIsIndlYnBhY2s6L3dlYnBhY2svYm9vdHN0cmFwIDZjYWFmYTA5MzQwZDhiNzcyYzhmIiwid2VicGFjazovLy9+L21ldGFsL2xpYi9tZXRhbC5qcyIsIndlYnBhY2s6Ly8vc3JjL2FwaS1xdWVyeS9FbWJvZGllZC5qcyIsIndlYnBhY2s6Ly8vfi9tZXRhbC1zdHJ1Y3RzL2xpYi9hbGwvc3RydWN0cy5qcyIsIndlYnBhY2s6Ly8vc3JjL2FwaS9hc3NlcnRpb25zLmpzIiwid2VicGFjazovLy9zcmMvYXBpLXF1ZXJ5L0ZpbHRlci5qcyIsIndlYnBhY2s6Ly8vc3JjL2dsb2JhbHMvZ2xvYmFscy5qcyIsIndlYnBhY2s6Ly8vfi9tZXRhbC11cmkvbm9kZS5qcyIsIndlYnBhY2s6Ly8vc3JjL2FwaS1xdWVyeS9RdWVyeS5qcyIsIndlYnBhY2s6Ly8vc3JjL2FwaS1xdWVyeS9SYW5nZS5qcyIsIndlYnBhY2s6Ly8vc3JjL2FwaS9BcGlIZWxwZXIuanMiLCJ3ZWJwYWNrOi8vL3NyYy9hcGkvYXV0aC9BdXRoLmpzIiwid2VicGFjazovLy9zcmMvYXBpL2F1dGgvQXV0aFByb3ZpZGVyLmpzIiwid2VicGFjazovLy9+L21ldGFsLXN0b3JhZ2UvbGliL21lY2hhbmlzbS9TdG9yYWdlTWVjaGFuaXNtLmpzIiwid2VicGFjazovLy9+L3Byb2Nlc3MvYnJvd3Nlci5qcyIsIndlYnBhY2s6Ly8vKHdlYnBhY2spL2J1aWxkaW4vZ2xvYmFsLmpzIiwid2VicGFjazovLy9zcmMvYXBpLXF1ZXJ5L0dlby5qcyIsIndlYnBhY2s6Ly8vc3JjL2FwaS9DbGllbnRNZXNzYWdlLmpzIiwid2VicGFjazovLy9+L21ldGFsL2xpYi9jb3JlLmpzIiwid2VicGFjazovLy9zcmMvYXBpL1dlRGVwbG95LmpzIiwid2VicGFjazovLy9zcmMvYXBpLXF1ZXJ5L0FnZ3JlZ2F0aW9uLmpzIiwid2VicGFjazovLy9zcmMvYXBpLXF1ZXJ5L0ZpbHRlckJvZHkuanMiLCJ3ZWJwYWNrOi8vL3NyYy9hcGkvQ2xpZW50UmVxdWVzdC5qcyIsIndlYnBhY2s6Ly8vc3JjL2FwaS9DbGllbnRSZXNwb25zZS5qcyIsIndlYnBhY2s6Ly8vc3JjL2FwaS9UcmFuc3BvcnQuanMiLCJ3ZWJwYWNrOi8vL3NyYy9hcGkvVHJhbnNwb3J0RmFjdG9yeS5qcyIsIndlYnBhY2s6Ly8vc3JjL2FwaS9hdXRoL0F1dGhBcGlIZWxwZXIuanMiLCJ3ZWJwYWNrOi8vL3NyYy9hcGkvYXV0aC9GYWNlYm9va0F1dGhQcm92aWRlci5qcyIsIndlYnBhY2s6Ly8vc3JjL2FwaS9hdXRoL0dpdGh1YkF1dGhQcm92aWRlci5qcyIsIndlYnBhY2s6Ly8vc3JjL2FwaS9hdXRoL0dvb2dsZUF1dGhQcm92aWRlci5qcyIsIndlYnBhY2s6Ly8vc3JjL2FwaS9icm93c2VyL0FqYXhUcmFuc3BvcnQuanMiLCJ3ZWJwYWNrOi8vL3NyYy9hcGkvZGF0YS9EYXRhQXBpSGVscGVyLmpzIiwid2VicGFjazovLy9zcmMvYXBpL2VtYWlsL0VtYWlsQXBpSGVscGVyLmpzIiwid2VicGFjazovLy9zcmMvY3J5cHQvQmFzZTY0LmpzIiwid2VicGFjazovLy9zcmMvZW52L2Jyb3dzZXIuanMiLCJ3ZWJwYWNrOi8vL34vYmFzZTY0LWpzL2luZGV4LmpzIiwid2VicGFjazovLy9+L2J1ZmZlci9pbmRleC5qcyIsIndlYnBhY2s6Ly8vfi9pZWVlNzU0L2luZGV4LmpzIiwid2VicGFjazovLy9+L21ldGFsLWFqYXgvbGliL0FqYXguanMiLCJ3ZWJwYWNrOi8vL34vbWV0YWwtcHJvbWlzZS9saWIvcHJvbWlzZS9Qcm9taXNlLmpzIiwid2VicGFjazovLy9+L21ldGFsLXN0b3JhZ2UvbGliL1N0b3JhZ2UuanMiLCJ3ZWJwYWNrOi8vL34vbWV0YWwtc3RvcmFnZS9saWIvYWxsL3N0b3JhZ2UuanMiLCJ3ZWJwYWNrOi8vL34vbWV0YWwtc3RvcmFnZS9saWIvbWVjaGFuaXNtL0xvY2FsU3RvcmFnZU1lY2hhbmlzbS5qcyIsIndlYnBhY2s6Ly8vfi9tZXRhbC1zdHJ1Y3RzL2xpYi9NdWx0aU1hcC5qcyIsIndlYnBhY2s6Ly8vfi9tZXRhbC1zdHJ1Y3RzL2xpYi9UcmVlTm9kZS5qcyIsIndlYnBhY2s6Ly8vfi9tZXRhbC11cmkvbGliL1VyaS5qcyIsIndlYnBhY2s6Ly8vfi9tZXRhbC11cmkvbGliL3BhcnNlLmpzIiwid2VicGFjazovLy9+L21ldGFsLXVyaS9saWIvcGFyc2VGcm9tQW5jaG9yLmpzIiwid2VicGFjazovLy9+L21ldGFsL2xpYi9hcnJheS9hcnJheS5qcyIsIndlYnBhY2s6Ly8vfi9tZXRhbC9saWIvYXN5bmMvYXN5bmMuanMiLCJ3ZWJwYWNrOi8vL34vbWV0YWwvbGliL2NvcmVOYW1lZC5qcyIsIndlYnBhY2s6Ly8vfi9tZXRhbC9saWIvZGlzcG9zYWJsZS9EaXNwb3NhYmxlLmpzIiwid2VicGFjazovLy9+L21ldGFsL2xpYi9vYmplY3Qvb2JqZWN0LmpzIiwid2VicGFjazovLy9+L21ldGFsL2xpYi9zdHJpbmcvc3RyaW5nLmpzIiwid2VicGFjazovLy9+L3BhdGgtYnJvd3NlcmlmeS9pbmRleC5qcyIsIndlYnBhY2s6Ly8vfi9wdW55Y29kZS9wdW55Y29kZS5qcyIsIndlYnBhY2s6Ly8vfi9xdWVyeXN0cmluZy1lczMvZGVjb2RlLmpzIiwid2VicGFjazovLy9+L3F1ZXJ5c3RyaW5nLWVzMy9lbmNvZGUuanMiLCJ3ZWJwYWNrOi8vL34vcXVlcnlzdHJpbmctZXMzL2luZGV4LmpzIiwid2VicGFjazovLy9+L3NldGltbWVkaWF0ZS9zZXRJbW1lZGlhdGUuanMiLCJ3ZWJwYWNrOi8vL34vdGltZXJzLWJyb3dzZXJpZnkvbWFpbi5qcyIsIndlYnBhY2s6Ly8vfi91cmwvdXJsLmpzIiwid2VicGFjazovLy9+L3VybC91dGlsLmpzIl0sIm5hbWVzIjpbInJvb3QiLCJmYWN0b3J5IiwiZXhwb3J0cyIsIm1vZHVsZSIsImRlZmluZSIsImFtZCIsInRoaXMiLCJtb2R1bGVzIiwiX193ZWJwYWNrX3JlcXVpcmVfXyIsIm1vZHVsZUlkIiwiaW5zdGFsbGVkTW9kdWxlcyIsImlkIiwibG9hZGVkIiwiY2FsbCIsIm0iLCJjIiwicCIsImxvb2t1cCIsInVyaSIsIm9wdHMiLCJfdHlwZW9mIiwidW5kZWZpbmVkIiwiaW8iLCJwYXJzZWQiLCJ1cmwiLCJzb3VyY2UiLCJwYXRoIiwic2FtZU5hbWVzcGFjZSIsImNhY2hlIiwibnNwcyIsIm5ld0Nvbm5lY3Rpb24iLCJmb3JjZU5ldyIsIm11bHRpcGxleCIsIk1hbmFnZXIiLCJxdWVyeSIsInNvY2tldCIsIlN5bWJvbCIsIml0ZXJhdG9yIiwib2JqIiwiY29uc3RydWN0b3IiLCJwcm90b3R5cGUiLCJwYXJzZXIiLCJtYW5hZ2VycyIsInByb3RvY29sIiwiY29ubmVjdCIsIlNvY2tldCIsImdsb2JhbCIsImxvYyIsImxvY2F0aW9uIiwiaG9zdCIsImNoYXJBdCIsInRlc3QiLCJwYXJzZXVyaSIsInBvcnQiLCJpcHY2IiwiaW5kZXhPZiIsImhyZWYiLCJyZSIsInBhcnRzIiwic3RyIiwic3JjIiwiYiIsImUiLCJzdWJzdHJpbmciLCJyZXBsYWNlIiwibGVuZ3RoIiwiZXhlYyIsImkiLCJhdXRob3JpdHkiLCJpcHY2dXJpIiwiRW5jb2RlciIsImVuY29kZUFzU3RyaW5nIiwidHlwZSIsIkJJTkFSWV9FVkVOVCIsIkJJTkFSWV9BQ0siLCJhdHRhY2htZW50cyIsIm5zcCIsImRhdGEiLCJKU09OIiwic3RyaW5naWZ5IiwiZW5jb2RlQXNCaW5hcnkiLCJjYWxsYmFjayIsIndyaXRlRW5jb2RpbmciLCJibG9ibGVzc0RhdGEiLCJkZWNvbnN0cnVjdGlvbiIsImJpbmFyeSIsImRlY29uc3RydWN0UGFja2V0IiwicGFjayIsInBhY2tldCIsImJ1ZmZlcnMiLCJ1bnNoaWZ0IiwicmVtb3ZlQmxvYnMiLCJEZWNvZGVyIiwicmVjb25zdHJ1Y3RvciIsImRlY29kZVN0cmluZyIsIk51bWJlciIsInR5cGVzIiwiZXJyb3IiLCJidWYiLCJFcnJvciIsIm5leHQiLCJ0cnlQYXJzZSIsInN1YnN0ciIsInBhcnNlIiwiQmluYXJ5UmVjb25zdHJ1Y3RvciIsInJlY29uUGFjayIsIkVSUk9SIiwiRW1pdHRlciIsImhhc0JpbiIsImlzQnVmIiwiQ09OTkVDVCIsIkRJU0NPTk5FQ1QiLCJFVkVOVCIsIkFDSyIsImVuY29kZSIsImVuY29kaW5nIiwiYWRkIiwiZW1pdCIsImJhc2U2NCIsInRha2VCaW5hcnlEYXRhIiwiZGVzdHJveSIsImZpbmlzaGVkUmVjb25zdHJ1Y3Rpb24iLCJiaW5EYXRhIiwicHVzaCIsInJlY29uc3RydWN0UGFja2V0IiwibWl4aW4iLCJrZXkiLCJvbiIsImFkZEV2ZW50TGlzdGVuZXIiLCJldmVudCIsImZuIiwiX2NhbGxiYWNrcyIsIm9uY2UiLCJvZmYiLCJhcHBseSIsImFyZ3VtZW50cyIsInJlbW92ZUxpc3RlbmVyIiwicmVtb3ZlQWxsTGlzdGVuZXJzIiwicmVtb3ZlRXZlbnRMaXN0ZW5lciIsImNhbGxiYWNrcyIsImNiIiwic3BsaWNlIiwiYXJncyIsInNsaWNlIiwibGVuIiwibGlzdGVuZXJzIiwiaGFzTGlzdGVuZXJzIiwiaGFzQmluYXJ5IiwiaXNBcnJheSIsImwiLCJCdWZmZXIiLCJpc0J1ZmZlciIsIkFycmF5QnVmZmVyIiwid2l0aE5hdGl2ZUJsb2IiLCJCbG9iIiwid2l0aE5hdGl2ZUZpbGUiLCJGaWxlIiwidG9KU09OIiwiT2JqZWN0IiwiaGFzT3duUHJvcGVydHkiLCJ0b1N0cmluZyIsIkFycmF5IiwiYXJyIiwiX2RlY29uc3RydWN0UGFja2V0IiwicGxhY2Vob2xkZXIiLCJfcGxhY2Vob2xkZXIiLCJudW0iLCJuZXdEYXRhIiwiRGF0ZSIsIl9yZWNvbnN0cnVjdFBhY2tldCIsInBhY2tldERhdGEiLCJfcmVtb3ZlQmxvYnMiLCJjdXJLZXkiLCJjb250YWluaW5nT2JqZWN0IiwicGVuZGluZ0Jsb2JzIiwiZmlsZVJlYWRlciIsIkZpbGVSZWFkZXIiLCJvbmxvYWQiLCJyZXN1bHQiLCJyZWFkQXNBcnJheUJ1ZmZlciIsInN1YnMiLCJyZWNvbm5lY3Rpb24iLCJyZWNvbm5lY3Rpb25BdHRlbXB0cyIsIkluZmluaXR5IiwicmVjb25uZWN0aW9uRGVsYXkiLCJyZWNvbm5lY3Rpb25EZWxheU1heCIsInJhbmRvbWl6YXRpb25GYWN0b3IiLCJiYWNrb2ZmIiwiQmFja29mZiIsIm1pbiIsIm1heCIsImppdHRlciIsInRpbWVvdXQiLCJyZWFkeVN0YXRlIiwiY29ubmVjdGluZyIsImxhc3RQaW5nIiwicGFja2V0QnVmZmVyIiwiX3BhcnNlciIsImVuY29kZXIiLCJkZWNvZGVyIiwiYXV0b0Nvbm5lY3QiLCJvcGVuIiwiZWlvIiwiYmluZCIsImhhcyIsImVtaXRBbGwiLCJ1cGRhdGVTb2NrZXRJZHMiLCJnZW5lcmF0ZUlkIiwiZW5naW5lIiwidiIsIl9yZWNvbm5lY3Rpb24iLCJfcmVjb25uZWN0aW9uQXR0ZW1wdHMiLCJfcmVjb25uZWN0aW9uRGVsYXkiLCJzZXRNaW4iLCJfcmFuZG9taXphdGlvbkZhY3RvciIsInNldEppdHRlciIsIl9yZWNvbm5lY3Rpb25EZWxheU1heCIsInNldE1heCIsIl90aW1lb3V0IiwibWF5YmVSZWNvbm5lY3RPbk9wZW4iLCJyZWNvbm5lY3RpbmciLCJhdHRlbXB0cyIsInJlY29ubmVjdCIsInNlbGYiLCJza2lwUmVjb25uZWN0Iiwib3BlblN1YiIsIm9ub3BlbiIsImVycm9yU3ViIiwiY2xlYW51cCIsImVyciIsInRpbWVyIiwic2V0VGltZW91dCIsImNsb3NlIiwiY2xlYXJUaW1lb3V0Iiwib25waW5nIiwib25wb25nIiwib25kYXRhIiwib25kZWNvZGVkIiwib25lcnJvciIsIm9uQ29ubmVjdGluZyIsImluZGV4IiwiZW5jb2RlZFBhY2tldHMiLCJ3cml0ZSIsIm9wdGlvbnMiLCJwcm9jZXNzUGFja2V0UXVldWUiLCJzaGlmdCIsInN1YnNMZW5ndGgiLCJzdWIiLCJkaXNjb25uZWN0IiwicmVzZXQiLCJvbmNsb3NlIiwicmVhc29uIiwiZGVsYXkiLCJkdXJhdGlvbiIsIm9ucmVjb25uZWN0IiwiYXR0ZW1wdCIsImhvc3RuYW1lIiwic2VjdXJlIiwiYWdlbnQiLCJwYXJzZXFzIiwiZGVjb2RlIiwidXBncmFkZSIsImZvcmNlSlNPTlAiLCJqc29ucCIsImZvcmNlQmFzZTY0IiwiZW5hYmxlc1hEUiIsInRpbWVzdGFtcFBhcmFtIiwidGltZXN0YW1wUmVxdWVzdHMiLCJ0cmFuc3BvcnRzIiwidHJhbnNwb3J0T3B0aW9ucyIsIndyaXRlQnVmZmVyIiwicHJldkJ1ZmZlckxlbiIsInBvbGljeVBvcnQiLCJyZW1lbWJlclVwZ3JhZGUiLCJiaW5hcnlUeXBlIiwib25seUJpbmFyeVVwZ3JhZGVzIiwicGVyTWVzc2FnZURlZmxhdGUiLCJ0aHJlc2hvbGQiLCJwZngiLCJwYXNzcGhyYXNlIiwiY2VydCIsImNhIiwiY2lwaGVycyIsInJlamVjdFVuYXV0aG9yaXplZCIsImZvcmNlTm9kZSIsImZyZWVHbG9iYWwiLCJleHRyYUhlYWRlcnMiLCJrZXlzIiwibG9jYWxBZGRyZXNzIiwidXBncmFkZXMiLCJwaW5nSW50ZXJ2YWwiLCJwaW5nVGltZW91dCIsInBpbmdJbnRlcnZhbFRpbWVyIiwicGluZ1RpbWVvdXRUaW1lciIsImNsb25lIiwibyIsInBhcnNlanNvbiIsInByaW9yV2Vic29ja2V0U3VjY2VzcyIsIlRyYW5zcG9ydCIsImNyZWF0ZVRyYW5zcG9ydCIsIm5hbWUiLCJFSU8iLCJ0cmFuc3BvcnQiLCJzaWQiLCJyZXF1ZXN0VGltZW91dCIsInByb3RvY29scyIsInNldFRyYW5zcG9ydCIsIm9uRHJhaW4iLCJvblBhY2tldCIsIm9uRXJyb3IiLCJvbkNsb3NlIiwicHJvYmUiLCJvblRyYW5zcG9ydE9wZW4iLCJ1cGdyYWRlTG9zZXNCaW5hcnkiLCJzdXBwb3J0c0JpbmFyeSIsImZhaWxlZCIsInNlbmQiLCJtc2ciLCJ1cGdyYWRpbmciLCJwYXVzZSIsImZsdXNoIiwiZnJlZXplVHJhbnNwb3J0Iiwib25UcmFuc3BvcnRDbG9zZSIsIm9udXBncmFkZSIsInRvIiwib25PcGVuIiwib25IYW5kc2hha2UiLCJzZXRQaW5nIiwiY29kZSIsImZpbHRlclVwZ3JhZGVzIiwib25IZWFydGJlYXQiLCJwaW5nIiwic2VuZFBhY2tldCIsIndyaXRhYmxlIiwiY29tcHJlc3MiLCJjbGVhbnVwQW5kQ2xvc2UiLCJ3YWl0Rm9yVXBncmFkZSIsImRlc2MiLCJmaWx0ZXJlZFVwZ3JhZGVzIiwiaiIsInBvbGxpbmciLCJ4aHIiLCJ4ZCIsInhzIiwiaXNTU0wiLCJ4ZG9tYWluIiwieHNjaGVtZSIsIlhNTEh0dHBSZXF1ZXN0IiwiWEhSIiwiSlNPTlAiLCJ3ZWJzb2NrZXQiLCJoYXNDT1JTIiwiWERvbWFpblJlcXVlc3QiLCJjb25jYXQiLCJqb2luIiwiZW1wdHkiLCJQb2xsaW5nIiwiUmVxdWVzdCIsIm1ldGhvZCIsImFzeW5jIiwiaXNCaW5hcnkiLCJjcmVhdGUiLCJ1bmxvYWRIYW5kbGVyIiwicmVxdWVzdHMiLCJhYm9ydCIsImluaGVyaXQiLCJyZXF1ZXN0IiwiZG9Xcml0ZSIsInJlcSIsInNlbmRYaHIiLCJkb1BvbGwiLCJvbkRhdGEiLCJwb2xsWGhyIiwic2V0RGlzYWJsZUhlYWRlckNoZWNrIiwic2V0UmVxdWVzdEhlYWRlciIsIndpdGhDcmVkZW50aWFscyIsImhhc1hEUiIsIm9uTG9hZCIsInJlc3BvbnNlVGV4dCIsIm9ucmVhZHlzdGF0ZWNoYW5nZSIsImNvbnRlbnRUeXBlIiwiZ2V0UmVzcG9uc2VIZWFkZXIiLCJyZXNwb25zZVR5cGUiLCJzdGF0dXMiLCJkb2N1bWVudCIsInJlcXVlc3RzQ291bnQiLCJvblN1Y2Nlc3MiLCJmcm9tRXJyb3IiLCJyZXNwb25zZSIsImF0dGFjaEV2ZW50IiwiaGFzWEhSMiIsInllYXN0IiwiZG9PcGVuIiwicG9sbCIsIm9uUGF1c2UiLCJ0b3RhbCIsImRlY29kZVBheWxvYWQiLCJkb0Nsb3NlIiwicGFja2V0cyIsImNhbGxiYWNrZm4iLCJlbmNvZGVQYXlsb2FkIiwic2NoZW1hIiwiYjY0IiwiZGVzY3JpcHRpb24iLCJkZWNvZGVQYWNrZXQiLCJlbmNvZGVCYXNlNjRPYmplY3QiLCJtZXNzYWdlIiwiZW5jb2RlQXJyYXlCdWZmZXIiLCJlbmNvZGVCYXNlNjRQYWNrZXQiLCJjb250ZW50QXJyYXkiLCJVaW50OEFycmF5IiwicmVzdWx0QnVmZmVyIiwiYnl0ZUxlbmd0aCIsImJ1ZmZlciIsImVuY29kZUJsb2JBc0FycmF5QnVmZmVyIiwiZnIiLCJlbmNvZGVQYWNrZXQiLCJlbmNvZGVCbG9iIiwiZG9udFNlbmRCbG9icyIsImJsb2IiLCJ0cnlEZWNvZGUiLCJ1dGY4Iiwic3RyaWN0IiwibWFwIiwiYXJ5IiwiZWFjaCIsImRvbmUiLCJhZnRlciIsImVhY2hXaXRoSW5kZXgiLCJlbCIsImJhc2U2NGVuY29kZXIiLCJzbGljZUJ1ZmZlciIsImlzQW5kcm9pZCIsIm5hdmlnYXRvciIsInVzZXJBZ2VudCIsImlzUGhhbnRvbUpTIiwicG9uZyIsIm5vb3AiLCJwYWNrZXRzbGlzdCIsInV0ZjhlbmNvZGUiLCJlbmNvZGVkIiwiU3RyaW5nIiwic3BsaXQiLCJyZWFkQXNEYXRhVVJMIiwiYjY0ZGF0YSIsImZyb21DaGFyQ29kZSIsInR5cGVkIiwiYmFzaWMiLCJidG9hIiwidXRmOGRlY29kZSIsImRlY29kZUJhc2U2NFBhY2tldCIsImFzQXJyYXkiLCJyZXN0Iiwic2V0TGVuZ3RoSGVhZGVyIiwiZW5jb2RlT25lIiwiZG9uZUNhbGxiYWNrIiwiZW5jb2RlUGF5bG9hZEFzQmxvYiIsImVuY29kZVBheWxvYWRBc0FycmF5QnVmZmVyIiwicmVzdWx0cyIsImRlY29kZVBheWxvYWRBc0JpbmFyeSIsIm4iLCJjaHIiLCJyZXQiLCJ0b3RhbExlbmd0aCIsInJlZHVjZSIsImFjYyIsInJlc3VsdEFycmF5IiwiYnVmZmVySW5kZXgiLCJmb3JFYWNoIiwiaXNTdHJpbmciLCJhYiIsInZpZXciLCJjaGFyQ29kZUF0IiwibGVuU3RyIiwicGFyc2VJbnQiLCJiaW5hcnlJZGVudGlmaWVyIiwic2l6ZSIsImxlbmd0aEFyeSIsImJ1ZmZlclRhaWwiLCJ0YWlsQXJyYXkiLCJtc2dMZW5ndGgiLCJhcnJheWJ1ZmZlciIsInN0YXJ0IiwiZW5kIiwiYnl0ZXMiLCJhYnYiLCJpaSIsImNvdW50IiwiZXJyX2NiIiwicHJveHkiLCJiYWlsIiwiX19XRUJQQUNLX0FNRF9ERUZJTkVfUkVTVUxUX18iLCJ1Y3MyZGVjb2RlIiwic3RyaW5nIiwidmFsdWUiLCJleHRyYSIsIm91dHB1dCIsImNvdW50ZXIiLCJ1Y3MyZW5jb2RlIiwiYXJyYXkiLCJzdHJpbmdGcm9tQ2hhckNvZGUiLCJjaGVja1NjYWxhclZhbHVlIiwiY29kZVBvaW50IiwidG9VcHBlckNhc2UiLCJjcmVhdGVCeXRlIiwiZW5jb2RlQ29kZVBvaW50Iiwic3ltYm9sIiwiY29kZVBvaW50cyIsImJ5dGVTdHJpbmciLCJyZWFkQ29udGludWF0aW9uQnl0ZSIsImJ5dGVJbmRleCIsImJ5dGVDb3VudCIsImNvbnRpbnVhdGlvbkJ5dGUiLCJieXRlQXJyYXkiLCJkZWNvZGVTeW1ib2wiLCJieXRlMSIsImJ5dGUyIiwiYnl0ZTMiLCJieXRlNCIsInRtcCIsImZyZWVFeHBvcnRzIiwid2luZG93IiwidmVyc2lvbiIsIndlYnBhY2tQb2x5ZmlsbCIsImRlcHJlY2F0ZSIsInBhdGhzIiwiY2hpbGRyZW4iLCJjaGFycyIsImVuY29kZWQxIiwiZW5jb2RlZDIiLCJlbmNvZGVkMyIsImVuY29kZWQ0IiwiYnVmZmVyTGVuZ3RoIiwibWFwQXJyYXlCdWZmZXJWaWV3cyIsImNodW5rIiwiY29weSIsInNldCIsImJ5dGVPZmZzZXQiLCJCbG9iQnVpbGRlckNvbnN0cnVjdG9yIiwiYmIiLCJCbG9iQnVpbGRlciIsImFwcGVuZCIsImdldEJsb2IiLCJCbG9iQ29uc3RydWN0b3IiLCJXZWJLaXRCbG9iQnVpbGRlciIsIk1TQmxvYkJ1aWxkZXIiLCJNb3pCbG9iQnVpbGRlciIsImJsb2JTdXBwb3J0ZWQiLCJhIiwiYmxvYlN1cHBvcnRzQXJyYXlCdWZmZXJWaWV3IiwiYmxvYkJ1aWxkZXJTdXBwb3J0ZWQiLCJlbmNvZGVVUklDb21wb25lbnQiLCJxcyIsInFyeSIsInBhaXJzIiwicGFpciIsImRlY29kZVVSSUNvbXBvbmVudCIsImFscGhhYmV0IiwiTWF0aCIsImZsb29yIiwiZGVjb2RlZCIsIm5vdyIsInByZXYiLCJzZWVkIiwiSlNPTlBQb2xsaW5nIiwiX19fZWlvIiwic2NyaXB0Iiwick5ld2xpbmUiLCJyRXNjYXBlZE5ld2xpbmUiLCJwYXJlbnROb2RlIiwicmVtb3ZlQ2hpbGQiLCJmb3JtIiwiaWZyYW1lIiwiY3JlYXRlRWxlbWVudCIsImluc2VydEF0IiwiZ2V0RWxlbWVudHNCeVRhZ05hbWUiLCJpbnNlcnRCZWZvcmUiLCJoZWFkIiwiYm9keSIsImFwcGVuZENoaWxkIiwiaXNVQWdlY2tvIiwiY29tcGxldGUiLCJpbml0SWZyYW1lIiwiaHRtbCIsImlmcmFtZUlkIiwiYXJlYSIsImNsYXNzTmFtZSIsInN0eWxlIiwicG9zaXRpb24iLCJ0b3AiLCJsZWZ0IiwidGFyZ2V0Iiwic2V0QXR0cmlidXRlIiwiYWN0aW9uIiwic3VibWl0IiwiV1MiLCJ1c2luZ0Jyb3dzZXJXZWJTb2NrZXQiLCJCcm93c2VyV2ViU29ja2V0IiwiV2ViU29ja2V0IiwiTm9kZVdlYlNvY2tldCIsIk1veldlYlNvY2tldCIsImNoZWNrIiwiaGVhZGVycyIsIndzIiwic3VwcG9ydHMiLCJhZGRFdmVudExpc3RlbmVycyIsIm9ubWVzc2FnZSIsImV2IiwicnZhbGlkY2hhcnMiLCJydmFsaWRlc2NhcGUiLCJydmFsaWR0b2tlbnMiLCJydmFsaWRicmFjZXMiLCJydHJpbUxlZnQiLCJydHJpbVJpZ2h0IiwiRnVuY3Rpb24iLCJqc29uIiwiaWRzIiwiYWNrcyIsInJlY2VpdmVCdWZmZXIiLCJzZW5kQnVmZmVyIiwiY29ubmVjdGVkIiwiZGlzY29ubmVjdGVkIiwidG9BcnJheSIsImV2ZW50cyIsImNvbm5lY3RfZXJyb3IiLCJjb25uZWN0X3RpbWVvdXQiLCJyZWNvbm5lY3RfYXR0ZW1wdCIsInJlY29ubmVjdF9mYWlsZWQiLCJyZWNvbm5lY3RfZXJyb3IiLCJzdWJFdmVudHMiLCJmbGFncyIsInBvcCIsIm9ucGFja2V0Iiwib25jb25uZWN0Iiwib25ldmVudCIsIm9uYWNrIiwib25kaXNjb25uZWN0IiwiYWNrIiwic2VudCIsImVtaXRCdWZmZXJlZCIsImxpc3QiLCJtcyIsImZhY3RvciIsInBvdyIsInJhbmQiLCJyYW5kb20iLCJkZXZpYXRpb24iLCJFbWJvZGllZCIsImJvZHlfIiwiYXNzZXJ0QnJvd3NlckVudmlyb25tZW50IiwiYXNzZXJ0RGVmQW5kTm90TnVsbCIsImVycm9yTWVzc2FnZSIsImlzRGVmQW5kTm90TnVsbCIsImFzc2VydE5vdE51bGwiLCJpc051bGwiLCJhc3NlcnRGdW5jdGlvbiIsImlzRnVuY3Rpb24iLCJhc3NlcnRPYmplY3QiLCJpc09iamVjdCIsImFzc2VydFJlc3BvbnNlU3VjY2VlZGVkIiwic3VjY2VlZGVkIiwiYXNzZXJ0VXNlclNpZ25lZEluIiwidXNlciIsImFzc2VydFVyaVdpdGhOb1BhdGgiLCJnZXRQYXRobmFtZSIsIkZpbHRlciIsImZpZWxkIiwib3BlcmF0b3JPclZhbHVlIiwib3B0X3ZhbHVlIiwib3BlcmF0b3IiLCJmaWVsZE9yRmlsdGVyIiwib3B0X29wZXJhdG9yT3JWYWx1ZSIsImZpbHRlciIsInRvRmlsdGVyIiwiZmlsdGVycyIsImFkZE1hbnkiLCJnZXRPYmplY3QiLCJ2YWx1ZXMiLCJib3hPclVwcGVyTGVmdCIsIm9wdF9sb3dlclJpZ2h0IiwiQm91bmRpbmdCb3giLCJwb2x5Z29uIiwiZ2V0UG9pbnRzIiwibG9jYXRpb25PckNpcmNsZSIsIm9wdF9yYW5nZU9yRGlzdGFuY2UiLCJyYW5nZSIsIkNpcmNsZSIsImdldENlbnRlciIsImdldFJhZGl1cyIsImRpc3RhbmNlSW50ZXJuYWxfIiwidG9Cb2R5IiwiZnJvbSIsImZpZWxkT3JRdWVyeSIsIm9wdF9xdWVyeU9yRnV6emluZXNzIiwib3B0X2Z1enppbmVzcyIsImZ1enp5SW50ZXJuYWxfIiwiYXJnMklzU3RyaW5nIiwiZnV6emluZXNzIiwiQUxMIiwib3B0X3F1ZXJ5IiwicG9pbnRzIiwicG9pbnQiLCJyYW5nZU9yTWluIiwib3B0X21heCIsInNoYXBlcyIsInNoYXBlIiwiZ2VvbWV0cmllcyIsImdsb2JhbHMiLCJRdWVyeSIsImFnZ3JlZ2F0aW9uT3JGaWVsZCIsIm9wdF9vcGVyYXRvciIsImFnZ3JlZ2F0aW9uIiwiZ2V0RmllbGQiLCJnZXRPcGVyYXRvciIsImdldFZhbHVlIiwib2Zmc2V0IiwiaGlnaGxpZ2h0IiwibGltaXQiLCJmaWx0ZXJPclRleHRPckZpZWxkIiwib3B0X3RleHRPck9wZXJhdG9yIiwibWF0Y2giLCJvcHRfZGlyZWN0aW9uIiwic29ydCIsInNvcnRFbnRyeSIsImFnZ3JlZ2F0ZSIsInNlYXJjaCIsIlJhbmdlIiwib3B0X3RvIiwiQXBpSGVscGVyIiwid2VkZXBsb3lDbGllbnQiLCJoZWFkZXJzXyIsImF1dGhPclRva2VuT3JFbWFpbCIsIm9wdF9wYXNzd29yZCIsImhlbHBlckF1dGhTY29wZSIsIkF1dGgiLCJ0b2tlbk9yRW1haWwiLCJ0b2tlbiIsImVtYWlsIiwicGFzc3dvcmQiLCJjcmVhdGVkQXQiLCJwaG90b1VybCIsInN1cHBvcnRlZFNjb3BlcyIsInNjb3BlcyIsImV2ZXJ5IiwidmFsIiwiZnJvbU9iamVjdCIsIm5hbWVzIiwiZ2V0QWxsIiwiYnVpbGRVcmxfIiwiZ2V0SWQiLCJhdXRoIiwicGF0Y2giLCJ0aGVuIiwiZGVsZXRlIiwiYXV0aFVybF8iLCJjcmVhdGVGcm9tRGF0YSIsInByb3BlcnRpZXMiLCJlbnVtZXJhYmxlIiwiZGVmaW5lUHJvcGVydGllcyIsInNldFdlZGVwbG95Q2xpZW50IiwiQXV0aFByb3ZpZGVyIiwicHJvdmlkZXIiLCJwcm92aWRlclNjb3BlIiwicmVkaXJlY3RVcmkiLCJzY29wZSIsIm9wdF9hdXRoVXJsIiwic2V0UGF0aG5hbWUiLCJoYXNQcm92aWRlciIsInNldFBhcmFtZXRlclZhbHVlIiwiZ2V0UHJvdmlkZXIiLCJoYXNQcm92aWRlclNjb3BlIiwiZ2V0UHJvdmlkZXJTY29wZSIsImhhc1JlZGlyZWN0VXJpIiwiZ2V0UmVkaXJlY3RVcmkiLCJoYXNTY29wZSIsImdldFNjb3BlIiwiYXNzZXJ0U3RyaW5nSWZEZWZBbmROb3ROdWxsIiwiR2VvIiwidXBwZXJMZWZ0IiwibG93ZXJSaWdodCIsImNlbnRlciIsInJhZGl1cyIsIkxpbmUiLCJsYXQiLCJsb24iLCJQb2ludCIsIlBvbHlnb24iLCJjb29yZGluYXRlcyIsImFkZENvb3JkaW5hdGVzXyIsIkNsaWVudE1lc3NhZ2UiLCJvcHRfYm9keSIsImlzRGVmIiwib3B0X2hlYWRlcnMiLCJGb3JtRGF0YUltcGwiLCJGb3JtRGF0YSIsIldlRGVwbG95IiwiYXV0aF8iLCJkYXRhXyIsInVybF8iLCJqb2luUGF0aHMiLCJwYXJhbXNfIiwid2l0aENyZWRlbnRpYWxzXyIsImhlYWRlciIsImNsaWVudFJlcXVlc3QiLCJwYXJhbSIsImZvcm1EYXRhXyIsInBhcmFtcyIsImNsaWVudFJlc3BvbnNlIiwiaXNDb250ZW50VHlwZUpzb24iLCJzZW5kQXN5bmMiLCJpc0VsZW1lbnQiLCJtYXliZVdyYXBXaXRoUXVlcnlfIiwiY29udmVydEJvZHlUb1BhcmFtc18iLCJyZW1vdmVCb2R5IiwicmVtb3ZlIiwiZW5jb2RlUGFyYW1zXyIsInJlc29sdmVBdXRoZW50aWNhdGlvbl8iLCJvcHRfcGFyYW1zIiwiZW1ib2RpZWQiLCJ1c2UiLCJjdXN0b21UcmFuc3BvcnRfIiwiaGFzVG9rZW4iLCJoYXNFbWFpbCIsImhhc1Bhc3N3b3JkIiwiY3JlZGVudGlhbHMiLCJlbmNvZGVTdHJpbmciLCJpbnN0YW5jZSIsImdldERlZmF1bHQiLCJjcmVhdGVDbGllbnRSZXF1ZXN0XyIsIm9wdF9vcHRpb25zIiwiYWRkUGFyYW1ldGVyc0Zyb21NdWx0aU1hcCIsInByb2R1Y3QiLCJnZXRTZWFyY2giLCJyZXNvbHZlVHJhbnNwb3J0T3B0aW9uc18iLCJnZXRQcm90b2NvbCIsImdldEhvc3QiLCJBdXRob3JpemF0aW9uIiwiZ2V0VG9rZW4iLCJnZXRFbWFpbCIsImdldFBhc3N3b3JkIiwib3B0X2RhdGFVcmwiLCJkYXRhVXJsXyIsImN1cnJlbnRVc2VyIiwib3B0X2VtYWlsVXJsIiwiZW1haWxVcmxfIiwiZW1haWxfIiwiY2xpZW50TWVzc2FnZSIsImdldCIsImZvcm1EYXRhIiwiQWdncmVnYXRpb24iLCJmaWVsZF8iLCJvcGVyYXRvcl8iLCJ2YWx1ZV8iLCJyYW5nZXMiLCJEaXN0YW5jZUFnZ3JlZ2F0aW9uIiwiaW50ZXJ2YWwiLCJSYW5nZUFnZ3JlZ2F0aW9uIiwicmFuZ2VPckZyb20iLCJ1bml0IiwiRmlsdGVyQm9keSIsImNyZWF0ZUJvZHlfIiwib3B0X2ZpbHRlciIsImFkZEFycmF5T3BlcmF0b3JfIiwiQ2xpZW50UmVxdWVzdCIsIm9wdF93aXRoQ3JlZGVudGlhbHMiLCJvcHRfbWV0aG9kIiwibWV0aG9kXyIsIkRFRkFVTFRfTUVUSE9EIiwib3B0X3VybCIsIkNsaWVudFJlc3BvbnNlIiwiY2xpZW50UmVxdWVzdF8iLCJvcHRfc3RhdHVzQ29kZSIsInN0YXR1c0NvZGVfIiwib3B0X3N0YXR1c1RleHQiLCJzdGF0dXNUZXh0XyIsInN0YXR1c0NvZGUiLCJUcmFuc3BvcnRGYWN0b3J5IiwiREVGQVVMVF9UUkFOU1BPUlRfTkFNRSIsImltcGxlbWVudGF0aW9uTmFtZSIsIlRyYW5zcG9ydENsYXNzIiwiaW5zdGFuY2VfIiwiQXV0aEFwaUhlbHBlciIsIm9uU2lnbkluQ2FsbGJhY2siLCJvblNpZ25PdXRDYWxsYmFjayIsImlzU3VwcG9ydGVkIiwic3RvcmFnZSIsInByb2Nlc3NTaWduSW5fIiwiRmFjZWJvb2siLCJHb29nbGUiLCJHaXRodWIiLCJhY2Nlc3NUb2tlbiIsImNvb2tpZSIsImF1dGhTY29wZSIsInJlc29sdmVBdXRoU2NvcGUiLCJwb3N0IiwiY3JlYXRlQXV0aEZyb21EYXRhIiwidXNlcklkIiwicGF0aG5hbWUiLCJmcmFnbWVudCIsImhhc2giLCJ2ZXJpZnlVc2VyIiwiY3JlYXRlQWNjZXNzVG9rZW5Db29raWUiLCJyZWRpcmVjdEFjY2Vzc1Rva2VuIiwiZ2V0UmVkaXJlY3RBY2Nlc3NUb2tlbl8iLCJyZW1vdmVVcmxGcmFnbWVudENvbXBsZXRlbHlfIiwibG9hZEN1cnJlbnRVc2VyIiwibWF5YmVDYWxsT25TaWduSW5DYWxsYmFja18iLCJoaXN0b3J5IiwicHVzaFN0YXRlIiwiYWNjZXNzX3Rva2VuIiwiYXNzZXJ0U3VwcG9ydGVkUHJvdmlkZXIiLCJzZXRSZWRpcmVjdFVyaSIsImdldEhyZWZXaXRob3V0RnJhZ21lbnRfIiwibWFrZUF1dGhvcml6YXRpb25VcmwiLCJtYXliZUNhbGxPblNpZ25PdXRDYWxsYmFja18iLCJ1bmxvYWRDdXJyZW50VXNlcl8iLCJkZWxldGVBY2Nlc3NUb2tlbkNvb2tpZSIsIlBST1ZJREVSIiwiRmFjZWJvb2tBdXRoUHJvdmlkZXIiLCJHaXRodWJBdXRoUHJvdmlkZXIiLCJHb29nbGVBdXRoUHJvdmlkZXIiLCJBamF4VHJhbnNwb3J0IiwiZGVmZXJyZWQiLCJzdGF0dXNUZXh0IiwicGFyc2VSZXNwb25zZUhlYWRlcnMiLCJnZXRBbGxSZXNwb25zZUhlYWRlcnMiLCJEYXRhQXBpSGVscGVyIiwiaXNTZWFyY2hfIiwiZ2V0T3JDcmVhdGVGaWx0ZXJfIiwiYW5kIiwib3IiLCJ3aGVyZSIsIm5vbmUiLCJwcmVmaXgiLCJzaW1pbGFyIiwibHQiLCJsdGUiLCJndCIsImd0ZSIsImFueSIsImJvdW5kaW5nQm94IiwiZGlzdGFuY2UiLCJnZXRPckNyZWF0ZVF1ZXJ5XyIsImNvbGxlY3Rpb24iLCJkb2MiLCJwdXQiLCJwcm9jZXNzQW5kUmVzZXRRdWVyeVN0YXRlIiwid2F0Y2giLCJmaWx0ZXJfIiwicXVlcnlfIiwiY2xlYXIiLCJFbWFpbEFwaUhlbHBlciIsImJjYyIsImNjIiwicHJpb3JpdHkiLCJyZXBseVRvIiwic3ViamVjdCIsImNsaWVudCIsImVtYWlsSWQiLCJCYXNlNjQiXSwibWFwcGluZ3MiOiJDQUFBLFNBQUFBLEVBQUFDLEdBQ0EsZ0JBQUFDLFVBQUEsZ0JBQUFDLFFBQ0FBLE9BQUFELFFBQUFELElBQ0Esa0JBQUFHLGdCQUFBQyxJQUNBRCxVQUFBSCxHQUNBLGdCQUFBQyxTQUNBQSxRQUFBLEdBQUFELElBRUFELEVBQUEsR0FBQUMsS0FDQ0ssS0FBQSxXQUNELE1DQWdCLFVBQVVDLEdDTjFCLFFBQUFDLEdBQUFDLEdBR0EsR0FBQUMsRUFBQUQsR0FDQSxNQUFBQyxHQUFBRCxHQUFBUCxPQUdBLElBQUFDLEdBQUFPLEVBQUFELElB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QUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixzQkFBc0I7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHFDQUFxQzs7QUFFckM7QUFDQTtBQUNBOztBQUVBLDJCQUEyQjtB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QUFFQTs7QUFFQTtBQUNBOzs7Ozs7OztBQ2pIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixtREFBbUQ7QUFDeEU7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixVQUFVO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixZQUFZO0FBQzdCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSwwQkFBMEI7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUEsdUNBQXVDLFNBQVM7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZUFBZSxpQkFBaUI7QUFDaEM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxhQUFhLGlCQUFpQjtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsU0FBUztBQUMxQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLFNBQVM7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLFNBQVM7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnREFBZ0QsRUFBRTtBQUNsRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxpQkFBaUIsU0FBUztBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUNBQXlDO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsZUFBZTtBQUN2QztBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSx3QkFBd0IsUUFBUTtBQUNoQztBQUNBLHFCQUFxQixlQUFlO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixZQUFZO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxxQkFBcUIsU0FBUztBQUM5QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEscUJBQXFCLFNBQVM7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EscUJBQXFCLFNBQVM7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLGtCQUFrQjtBQUNuQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsbUJBQW1CLGNBQWM7QUFDakM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHVEQUF1RCxPQUFPO0FBQzlEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSx1REFBdUQsT0FBTztBQUM5RDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNB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Q0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLHNCQUFzQjtBQUN2QztBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsV0FBVztBQUN0QixXQUFXLHNCQUFzQjtBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcscUJBQXFCO0FBQ2hDO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsWUFBWSxxQkFBcUI7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFF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QTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUFBO0FBQ0gsRUFBRTtBQUNGLHNDQUFzQztBQUN0QztBQUNBLEdBQUcsT0FBTztBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRSxPQUFPO0FBQ1Q7QUFDQTs7QUFFQSxDQUFDOzs7Ozs7Ozs7QUNqaEJEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsaUJBQWlCLFNBQVM7QUFDMUI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7Ozs7Ozs7QUNuRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxPQUFPO0FBQ1A7QUFDQTtBQUNBLEtBQUs7O0FBRUw7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixlQUFlO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7OztBQ3BGQTs7QUFFQTtBQUNBOzs7Ozs7O0FDSEE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsdUJBQXVCO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLGlCQUFpQjtBQUN0QztBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsMENBQTBDLHNCQUFzQixFQUFFO0FBQ2xFO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EseUNBQXlDO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxVQUFVO0FBQ1Y7QUFDQTs7QUFFQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxDQUFDOzs7Ozs7OztBQ3pMRDs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7OztBQ3BEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGdCQUFnQixLQUFLOztBQUVyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUM7QUFDckM7QUFDQTtBQUNBLDJDQUEyQyxLQUFLO0FBQ2hELDBDQUEwQyxLQUFLO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLG9DQUFvQztBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsbUJBQW1CLDRCQUE0QjtBQUMvQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLG1CQUFtQix5QkFBeUI7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkMsT0FBTztBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQyxPQUFPO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsMENBQTBDLE9BQU87QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxrQkFBa0IsbUJBQW1CO0FBQ3JDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixtQkFBbUI7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixpQkFBaUI7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsUUFBUTtBQUN0QztBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsVUFBVSxNQUFNO0FBQ2hCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7O0FDM3RCQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7O0E3RWZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSIsImZpbGUiOiJhcGkuanMiLCJzb3VyY2VzQ29udGVudCI6WyIoZnVuY3Rpb24gd2VicGFja1VuaXZlcnNhbE1vZHVsZURlZmluaXRpb24ocm9vdCwgZmFjdG9yeSkge1xuXHRpZih0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIG1vZHVsZSA9PT0gJ29iamVjdCcpXG5cdFx0bW9kdWxlLmV4cG9ydHMgPSBmYWN0b3J5KCk7XG5cdGVsc2UgaWYodHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kKVxuXHRcdGRlZmluZShbXSwgZmFjdG9yeSk7XG5cdGVsc2Uge1xuXHRcdHZhciBhID0gZmFjdG9yeSgpO1xuXHRcdGZvcih2YXIgaSBpbiBhKSAodHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnID8gZXhwb3J0cyA6IHJvb3QpW2ldID0gYVtpXTtcblx0fVxufSkodGhpcywgZnVuY3Rpb24oKSB7XG5yZXR1cm4gXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIHdlYnBhY2svdW5pdmVyc2FsTW9kdWxlRGVmaW5pdGlvbiIsIihmdW5jdGlvbiB3ZWJwYWNrVW5pdmVyc2FsTW9kdWxlRGVmaW5pdGlvbihyb290LCBmYWN0b3J5KSB7XG5cdGlmKHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgbW9kdWxlID09PSAnb2JqZWN0Jylcblx0XHRtb2R1bGUuZXhwb3J0cyA9IGZhY3RvcnkoKTtcblx0ZWxzZSBpZih0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQpXG5cdFx0ZGVmaW5lKFtdLCBmYWN0b3J5KTtcblx0ZWxzZSBpZih0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcpXG5cdFx0ZXhwb3J0c1tcImlvXCJdID0gZmFjdG9yeSgpO1xuXHRlbHNlXG5cdFx0cm9vdFtcImlvXCJdID0gZmFjdG9yeSgpO1xufSkodGhpcywgZnVuY3Rpb24oKSB7XG5yZXR1cm4gLyoqKioqKi8gKGZ1bmN0aW9uKG1vZHVsZXMpIHsgLy8gd2VicGFja0Jvb3RzdHJhcFxuLyoqKioqKi8gXHQvLyBUaGUgbW9kdWxlIGNhY2hlXG4vKioqKioqLyBcdHZhciBpbnN0YWxsZWRNb2R1bGVzID0ge307XG4vKioqKioqL1xuLyoqKioqKi8gXHQvLyBUaGUgcmVxdWlyZSBmdW5jdGlvblxuLyoqKioqKi8gXHRmdW5jdGlvbiBfX3dlYnBhY2tfcmVxdWlyZV9fKG1vZHVsZUlkKSB7XG4vKioqKioqL1xuLyoqKioqKi8gXHRcdC8vIENoZWNrIGlmIG1vZHVsZSBpcyBpbiBjYWNoZVxuLyoqKioqKi8gXHRcdGlmKGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdKVxuLyoqKioqKi8gXHRcdFx0cmV0dXJuIGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdLmV4cG9ydHM7XG4vKioqKioqL1xuLyoqKioqKi8gXHRcdC8vIENyZWF0ZSBhIG5ldyBtb2R1bGUgKGFuZCBwdXQgaXQgaW50byB0aGUgY2FjaGUpXG4vKioqKioqLyBcdFx0dmFyIG1vZHVsZSA9IGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdID0ge1xuLyoqKioqKi8gXHRcdFx0ZXhwb3J0czoge30sXG4vKioqKioqLyBcdFx0XHRpZDogbW9kdWxlSWQsXG4vKioqKioqLyBcdFx0XHRsb2FkZWQ6IGZhbHNlXG4vKioqKioqLyBcdFx0fTtcbi8qKioqKiovXG4vKioqKioqLyBcdFx0Ly8gRXhlY3V0ZSB0aGUgbW9kdWxlIGZ1bmN0aW9uXG4vKioqKioqLyBcdFx0bW9kdWxlc1ttb2R1bGVJZF0uY2FsbChtb2R1bGUuZXhwb3J0cywgbW9kdWxlLCBtb2R1bGUuZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXyk7XG4vKioqKioqL1xuLyoqKioqKi8gXHRcdC8vIEZsYWcgdGhlIG1vZHVsZSBhcyBsb2FkZWRcbi8qKioqKiovIFx0XHRtb2R1bGUubG9hZGVkID0gdHJ1ZTtcbi8qKioqKiovXG4vKioqKioqLyBcdFx0Ly8gUmV0dXJuIHRoZSBleHBvcnRzIG9mIHRoZSBtb2R1bGVcbi8qKioqKiovIFx0XHRyZXR1cm4gbW9kdWxlLmV4cG9ydHM7XG4vKioqKioqLyBcdH1cbi8qKioqKiovXG4vKioqKioqL1xuLyoqKioqKi8gXHQvLyBleHBvc2UgdGhlIG1vZHVsZXMgb2JqZWN0IChfX3dlYnBhY2tfbW9kdWxlc19fKVxuLyoqKioqKi8gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLm0gPSBtb2R1bGVzO1xuLyoqKioqKi9cbi8qKioqKiovIFx0Ly8gZXhwb3NlIHRoZSBtb2R1bGUgY2FjaGVcbi8qKioqKiovIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5jID0gaW5zdGFsbGVkTW9kdWxlcztcbi8qKioqKiovXG4vKioqKioqLyBcdC8vIF9fd2VicGFja19wdWJsaWNfcGF0aF9fXG4vKioqKioqLyBcdF9fd2VicGFja19yZXF1aXJlX18ucCA9IFwiXCI7XG4vKioqKioqL1xuLyoqKioqKi8gXHQvLyBMb2FkIGVudHJ5IG1vZHVsZSBhbmQgcmV0dXJuIGV4cG9ydHNcbi8qKioqKiovIFx0cmV0dXJuIF9fd2VicGFja19yZXF1aXJlX18oMCk7XG4vKioqKioqLyB9KVxuLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qKioqKiovIChbXG4vKiAwICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblx0J3VzZSBzdHJpY3QnO1xuXHRcblx0dmFyIF90eXBlb2YgPSB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA9PT0gXCJzeW1ib2xcIiA/IGZ1bmN0aW9uIChvYmopIHsgcmV0dXJuIHR5cGVvZiBvYmo7IH0gOiBmdW5jdGlvbiAob2JqKSB7IHJldHVybiBvYmogJiYgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIG9iaiAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2Ygb2JqOyB9O1xuXHRcblx0LyoqXG5cdCAqIE1vZHVsZSBkZXBlbmRlbmNpZXMuXG5cdCAqL1xuXHRcblx0dmFyIHVybCA9IF9fd2VicGFja19yZXF1aXJlX18oMSk7XG5cdHZhciBwYXJzZXIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQpO1xuXHR2YXIgTWFuYWdlciA9IF9fd2VicGFja19yZXF1aXJlX18oMTApO1xuXHR2YXIgZGVidWcgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDMpKCdzb2NrZXQuaW8tY2xpZW50Jyk7XG5cdFxuXHQvKipcblx0ICogTW9kdWxlIGV4cG9ydHMuXG5cdCAqL1xuXHRcblx0bW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzID0gbG9va3VwO1xuXHRcblx0LyoqXG5cdCAqIE1hbmFnZXJzIGNhY2hlLlxuXHQgKi9cblx0XG5cdHZhciBjYWNoZSA9IGV4cG9ydHMubWFuYWdlcnMgPSB7fTtcblx0XG5cdC8qKlxuXHQgKiBMb29rcyB1cCBhbiBleGlzdGluZyBgTWFuYWdlcmAgZm9yIG11bHRpcGxleGluZy5cblx0ICogSWYgdGhlIHVzZXIgc3VtbW9uczpcblx0ICpcblx0ICogICBgaW8oJ2h0dHA6Ly9sb2NhbGhvc3QvYScpO2Bcblx0ICogICBgaW8oJ2h0dHA6Ly9sb2NhbGhvc3QvYicpO2Bcblx0ICpcblx0ICogV2UgcmV1c2UgdGhlIGV4aXN0aW5nIGluc3RhbmNlIGJhc2VkIG9uIHNhbWUgc2NoZW1lL3BvcnQvaG9zdCxcblx0ICogYW5kIHdlIGluaXRpYWxpemUgc29ja2V0cyBmb3IgZWFjaCBuYW1lc3BhY2UuXG5cdCAqXG5cdCAqIEBhcGkgcHVibGljXG5cdCAqL1xuXHRcblx0ZnVuY3Rpb24gbG9va3VwKHVyaSwgb3B0cykge1xuXHQgIGlmICgodHlwZW9mIHVyaSA9PT0gJ3VuZGVmaW5lZCcgPyAndW5kZWZpbmVkJyA6IF90eXBlb2YodXJpKSkgPT09ICdvYmplY3QnKSB7XG5cdCAgICBvcHRzID0gdXJpO1xuXHQgICAgdXJpID0gdW5kZWZpbmVkO1xuXHQgIH1cblx0XG5cdCAgb3B0cyA9IG9wdHMgfHwge307XG5cdFxuXHQgIHZhciBwYXJzZWQgPSB1cmwodXJpKTtcblx0ICB2YXIgc291cmNlID0gcGFyc2VkLnNvdXJjZTtcblx0ICB2YXIgaWQgPSBwYXJzZWQuaWQ7XG5cdCAgdmFyIHBhdGggPSBwYXJzZWQucGF0aDtcblx0ICB2YXIgc2FtZU5hbWVzcGFjZSA9IGNhY2hlW2lkXSAmJiBwYXRoIGluIGNhY2hlW2lkXS5uc3BzO1xuXHQgIHZhciBuZXdDb25uZWN0aW9uID0gb3B0cy5mb3JjZU5ldyB8fCBvcHRzWydmb3JjZSBuZXcgY29ubmVjdGlvbiddIHx8IGZhbHNlID09PSBvcHRzLm11bHRpcGxleCB8fCBzYW1lTmFtZXNwYWNlO1xuXHRcblx0ICB2YXIgaW87XG5cdFxuXHQgIGlmIChuZXdDb25uZWN0aW9uKSB7XG5cdFxuXHQgICAgaW8gPSBNYW5hZ2VyKHNvdXJjZSwgb3B0cyk7XG5cdCAgfSBlbHNlIHtcblx0ICAgIGlmICghY2FjaGVbaWRdKSB7XG5cdFxuXHQgICAgICBjYWNoZVtpZF0gPSBNYW5hZ2VyKHNvdXJjZSwgb3B0cyk7XG5cdCAgICB9XG5cdCAgICBpbyA9IGNhY2hlW2lkXTtcblx0ICB9XG5cdCAgaWYgKHBhcnNlZC5xdWVyeSAmJiAhb3B0cy5xdWVyeSkge1xuXHQgICAgb3B0cy5xdWVyeSA9IHBhcnNlZC5xdWVyeTtcblx0ICB9XG5cdCAgcmV0dXJuIGlvLnNvY2tldChwYXJzZWQucGF0aCwgb3B0cyk7XG5cdH1cblx0XG5cdC8qKlxuXHQgKiBQcm90b2NvbCB2ZXJzaW9uLlxuXHQgKlxuXHQgKiBAYXBpIHB1YmxpY1xuXHQgKi9cblx0XG5cdGV4cG9ydHMucHJvdG9jb2wgPSBwYXJzZXIucHJvdG9jb2w7XG5cdFxuXHQvKipcblx0ICogYGNvbm5lY3RgLlxuXHQgKlxuXHQgKiBAcGFyYW0ge1N0cmluZ30gdXJpXG5cdCAqIEBhcGkgcHVibGljXG5cdCAqL1xuXHRcblx0ZXhwb3J0cy5jb25uZWN0ID0gbG9va3VwO1xuXHRcblx0LyoqXG5cdCAqIEV4cG9zZSBjb25zdHJ1Y3RvcnMgZm9yIHN0YW5kYWxvbmUgYnVpbGQuXG5cdCAqXG5cdCAqIEBhcGkgcHVibGljXG5cdCAqL1xuXHRcblx0ZXhwb3J0cy5NYW5hZ2VyID0gX193ZWJwYWNrX3JlcXVpcmVfXygxMCk7XG5cdGV4cG9ydHMuU29ja2V0ID0gX193ZWJwYWNrX3JlcXVpcmVfXygzNik7XG5cbi8qKiovIH0pLFxuLyogMSAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cdC8qIFdFQlBBQ0sgVkFSIElOSkVDVElPTiAqLyhmdW5jdGlvbihnbG9iYWwpIHsndXNlIHN0cmljdCc7XG5cdFxuXHQvKipcblx0ICogTW9kdWxlIGRlcGVuZGVuY2llcy5cblx0ICovXG5cdFxuXHR2YXIgcGFyc2V1cmkgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIpO1xuXHR2YXIgZGVidWcgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDMpKCdzb2NrZXQuaW8tY2xpZW50OnVybCcpO1xuXHRcblx0LyoqXG5cdCAqIE1vZHVsZSBleHBvcnRzLlxuXHQgKi9cblx0XG5cdG1vZHVsZS5leHBvcnRzID0gdXJsO1xuXHRcblx0LyoqXG5cdCAqIFVSTCBwYXJzZXIuXG5cdCAqXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSB1cmxcblx0ICogQHBhcmFtIHtPYmplY3R9IEFuIG9iamVjdCBtZWFudCB0byBtaW1pYyB3aW5kb3cubG9jYXRpb24uXG5cdCAqICAgICAgICAgICAgICAgICBEZWZhdWx0cyB0byB3aW5kb3cubG9jYXRpb24uXG5cdCAqIEBhcGkgcHVibGljXG5cdCAqL1xuXHRcblx0ZnVuY3Rpb24gdXJsKHVyaSwgbG9jKSB7XG5cdCAgdmFyIG9iaiA9IHVyaTtcblx0XG5cdCAgLy8gZGVmYXVsdCB0byB3aW5kb3cubG9jYXRpb25cblx0ICBsb2MgPSBsb2MgfHwgZ2xvYmFsLmxvY2F0aW9uO1xuXHQgIGlmIChudWxsID09IHVyaSkgdXJpID0gbG9jLnByb3RvY29sICsgJy8vJyArIGxvYy5ob3N0O1xuXHRcblx0ICAvLyByZWxhdGl2ZSBwYXRoIHN1cHBvcnRcblx0ICBpZiAoJ3N0cmluZycgPT09IHR5cGVvZiB1cmkpIHtcblx0ICAgIGlmICgnLycgPT09IHVyaS5jaGFyQXQoMCkpIHtcblx0ICAgICAgaWYgKCcvJyA9PT0gdXJpLmNoYXJBdCgxKSkge1xuXHQgICAgICAgIHVyaSA9IGxvYy5wcm90b2NvbCArIHVyaTtcblx0ICAgICAgfSBlbHNlIHtcblx0ICAgICAgICB1cmkgPSBsb2MuaG9zdCArIHVyaTtcblx0ICAgICAgfVxuXHQgICAgfVxuXHRcblx0ICAgIGlmICghL14oaHR0cHM/fHdzcz8pOlxcL1xcLy8udGVzdCh1cmkpKSB7XG5cdFxuXHQgICAgICBpZiAoJ3VuZGVmaW5lZCcgIT09IHR5cGVvZiBsb2MpIHtcblx0ICAgICAgICB1cmkgPSBsb2MucHJvdG9jb2wgKyAnLy8nICsgdXJpO1xuXHQgICAgICB9IGVsc2Uge1xuXHQgICAgICAgIHVyaSA9ICdodHRwczovLycgKyB1cmk7XG5cdCAgICAgIH1cblx0ICAgIH1cblx0XG5cdCAgICAvLyBwYXJzZVxuXHRcblx0ICAgIG9iaiA9IHBhcnNldXJpKHVyaSk7XG5cdCAgfVxuXHRcblx0ICAvLyBtYWtlIHN1cmUgd2UgdHJlYXQgYGxvY2FsaG9zdDo4MGAgYW5kIGBsb2NhbGhvc3RgIGVxdWFsbHlcblx0ICBpZiAoIW9iai5wb3J0KSB7XG5cdCAgICBpZiAoL14oaHR0cHx3cykkLy50ZXN0KG9iai5wcm90b2NvbCkpIHtcblx0ICAgICAgb2JqLnBvcnQgPSAnODAnO1xuXHQgICAgfSBlbHNlIGlmICgvXihodHRwfHdzKXMkLy50ZXN0KG9iai5wcm90b2NvbCkpIHtcblx0ICAgICAgb2JqLnBvcnQgPSAnNDQzJztcblx0ICAgIH1cblx0ICB9XG5cdFxuXHQgIG9iai5wYXRoID0gb2JqLnBhdGggfHwgJy8nO1xuXHRcblx0ICB2YXIgaXB2NiA9IG9iai5ob3N0LmluZGV4T2YoJzonKSAhPT0gLTE7XG5cdCAgdmFyIGhvc3QgPSBpcHY2ID8gJ1snICsgb2JqLmhvc3QgKyAnXScgOiBvYmouaG9zdDtcblx0XG5cdCAgLy8gZGVmaW5lIHVuaXF1ZSBpZFxuXHQgIG9iai5pZCA9IG9iai5wcm90b2NvbCArICc6Ly8nICsgaG9zdCArICc6JyArIG9iai5wb3J0O1xuXHQgIC8vIGRlZmluZSBocmVmXG5cdCAgb2JqLmhyZWYgPSBvYmoucHJvdG9jb2wgKyAnOi8vJyArIGhvc3QgKyAobG9jICYmIGxvYy5wb3J0ID09PSBvYmoucG9ydCA/ICcnIDogJzonICsgb2JqLnBvcnQpO1xuXHRcblx0ICByZXR1cm4gb2JqO1xuXHR9XG5cdC8qIFdFQlBBQ0sgVkFSIElOSkVDVElPTiAqL30uY2FsbChleHBvcnRzLCAoZnVuY3Rpb24oKSB7IHJldHVybiB0aGlzOyB9KCkpKSlcblxuLyoqKi8gfSksXG4vKiAyICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XG5cblx0LyoqXHJcblx0ICogUGFyc2VzIGFuIFVSSVxyXG5cdCAqXHJcblx0ICogQGF1dGhvciBTdGV2ZW4gTGV2aXRoYW4gPHN0ZXZlbmxldml0aGFuLmNvbT4gKE1JVCBsaWNlbnNlKVxyXG5cdCAqIEBhcGkgcHJpdmF0ZVxyXG5cdCAqL1xyXG5cdFxyXG5cdHZhciByZSA9IC9eKD86KD8hW146QF0rOlteOkBcXC9dKkApKGh0dHB8aHR0cHN8d3N8d3NzKTpcXC9cXC8pPygoPzooKFteOkBdKikoPzo6KFteOkBdKikpPyk/QCk/KCg/OlthLWYwLTldezAsNH06KXsyLDd9W2EtZjAtOV17MCw0fXxbXjpcXC8/I10qKSg/OjooXFxkKikpPykoKChcXC8oPzpbXj8jXSg/IVtePyNcXC9dKlxcLltePyNcXC8uXSsoPzpbPyNdfCQpKSkqXFwvPyk/KFtePyNcXC9dKikpKD86XFw/KFteI10qKSk/KD86IyguKikpPykvO1xyXG5cdFxyXG5cdHZhciBwYXJ0cyA9IFtcclxuXHQgICAgJ3NvdXJjZScsICdwcm90b2NvbCcsICdhdXRob3JpdHknLCAndXNlckluZm8nLCAndXNlcicsICdwYXNzd29yZCcsICdob3N0JywgJ3BvcnQnLCAncmVsYXRpdmUnLCAncGF0aCcsICdkaXJlY3RvcnknLCAnZmlsZScsICdxdWVyeScsICdhbmNob3InXHJcblx0XTtcclxuXHRcclxuXHRtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIHBhcnNldXJpKHN0cikge1xyXG5cdCAgICB2YXIgc3JjID0gc3RyLFxyXG5cdCAgICAgICAgYiA9IHN0ci5pbmRleE9mKCdbJyksXHJcblx0ICAgICAgICBlID0gc3RyLmluZGV4T2YoJ10nKTtcclxuXHRcclxuXHQgICAgaWYgKGIgIT0gLTEgJiYgZSAhPSAtMSkge1xyXG5cdCAgICAgICAgc3RyID0gc3RyLnN1YnN0cmluZygwLCBiKSArIHN0ci5zdWJzdHJpbmcoYiwgZSkucmVwbGFjZSgvOi9nLCAnOycpICsgc3RyLnN1YnN0cmluZyhlLCBzdHIubGVuZ3RoKTtcclxuXHQgICAgfVxyXG5cdFxyXG5cdCAgICB2YXIgbSA9IHJlLmV4ZWMoc3RyIHx8ICcnKSxcclxuXHQgICAgICAgIHVyaSA9IHt9LFxyXG5cdCAgICAgICAgaSA9IDE0O1xyXG5cdFxyXG5cdCAgICB3aGlsZSAoaS0tKSB7XHJcblx0ICAgICAgICB1cmlbcGFydHNbaV1dID0gbVtpXSB8fCAnJztcclxuXHQgICAgfVxyXG5cdFxyXG5cdCAgICBpZiAoYiAhPSAtMSAmJiBlICE9IC0xKSB7XHJcblx0ICAgICAgICB1cmkuc291cmNlID0gc3JjO1xyXG5cdCAgICAgICAgdXJpLmhvc3QgPSB1cmkuaG9zdC5zdWJzdHJpbmcoMSwgdXJpLmhvc3QubGVuZ3RoIC0gMSkucmVwbGFjZSgvOy9nLCAnOicpO1xyXG5cdCAgICAgICAgdXJpLmF1dGhvcml0eSA9IHVyaS5hdXRob3JpdHkucmVwbGFjZSgnWycsICcnKS5yZXBsYWNlKCddJywgJycpLnJlcGxhY2UoLzsvZywgJzonKTtcclxuXHQgICAgICAgIHVyaS5pcHY2dXJpID0gdHJ1ZTtcclxuXHQgICAgfVxyXG5cdFxyXG5cdCAgICByZXR1cm4gdXJpO1xyXG5cdH07XHJcblxuXG4vKioqLyB9KSxcbi8qIDMgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcblxuXHRcInVzZSBzdHJpY3RcIjtcblx0XG5cdG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKCkge1xuXHQgIHJldHVybiBmdW5jdGlvbiAoKSB7fTtcblx0fTtcblxuLyoqKi8gfSksXG4vKiA0ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblx0XG5cdC8qKlxuXHQgKiBNb2R1bGUgZGVwZW5kZW5jaWVzLlxuXHQgKi9cblx0XG5cdHZhciBkZWJ1ZyA9IF9fd2VicGFja19yZXF1aXJlX18oMykoJ3NvY2tldC5pby1wYXJzZXInKTtcblx0dmFyIEVtaXR0ZXIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDUpO1xuXHR2YXIgaGFzQmluID0gX193ZWJwYWNrX3JlcXVpcmVfXyg2KTtcblx0dmFyIGJpbmFyeSA9IF9fd2VicGFja19yZXF1aXJlX18oOCk7XG5cdHZhciBpc0J1ZiA9IF9fd2VicGFja19yZXF1aXJlX18oOSk7XG5cdFxuXHQvKipcblx0ICogUHJvdG9jb2wgdmVyc2lvbi5cblx0ICpcblx0ICogQGFwaSBwdWJsaWNcblx0ICovXG5cdFxuXHRleHBvcnRzLnByb3RvY29sID0gNDtcblx0XG5cdC8qKlxuXHQgKiBQYWNrZXQgdHlwZXMuXG5cdCAqXG5cdCAqIEBhcGkgcHVibGljXG5cdCAqL1xuXHRcblx0ZXhwb3J0cy50eXBlcyA9IFtcblx0ICAnQ09OTkVDVCcsXG5cdCAgJ0RJU0NPTk5FQ1QnLFxuXHQgICdFVkVOVCcsXG5cdCAgJ0FDSycsXG5cdCAgJ0VSUk9SJyxcblx0ICAnQklOQVJZX0VWRU5UJyxcblx0ICAnQklOQVJZX0FDSydcblx0XTtcblx0XG5cdC8qKlxuXHQgKiBQYWNrZXQgdHlwZSBgY29ubmVjdGAuXG5cdCAqXG5cdCAqIEBhcGkgcHVibGljXG5cdCAqL1xuXHRcblx0ZXhwb3J0cy5DT05ORUNUID0gMDtcblx0XG5cdC8qKlxuXHQgKiBQYWNrZXQgdHlwZSBgZGlzY29ubmVjdGAuXG5cdCAqXG5cdCAqIEBhcGkgcHVibGljXG5cdCAqL1xuXHRcblx0ZXhwb3J0cy5ESVNDT05ORUNUID0gMTtcblx0XG5cdC8qKlxuXHQgKiBQYWNrZXQgdHlwZSBgZXZlbnRgLlxuXHQgKlxuXHQgKiBAYXBpIHB1YmxpY1xuXHQgKi9cblx0XG5cdGV4cG9ydHMuRVZFTlQgPSAyO1xuXHRcblx0LyoqXG5cdCAqIFBhY2tldCB0eXBlIGBhY2tgLlxuXHQgKlxuXHQgKiBAYXBpIHB1YmxpY1xuXHQgKi9cblx0XG5cdGV4cG9ydHMuQUNLID0gMztcblx0XG5cdC8qKlxuXHQgKiBQYWNrZXQgdHlwZSBgZXJyb3JgLlxuXHQgKlxuXHQgKiBAYXBpIHB1YmxpY1xuXHQgKi9cblx0XG5cdGV4cG9ydHMuRVJST1IgPSA0O1xuXHRcblx0LyoqXG5cdCAqIFBhY2tldCB0eXBlICdiaW5hcnkgZXZlbnQnXG5cdCAqXG5cdCAqIEBhcGkgcHVibGljXG5cdCAqL1xuXHRcblx0ZXhwb3J0cy5CSU5BUllfRVZFTlQgPSA1O1xuXHRcblx0LyoqXG5cdCAqIFBhY2tldCB0eXBlIGBiaW5hcnkgYWNrYC4gRm9yIGFja3Mgd2l0aCBiaW5hcnkgYXJndW1lbnRzLlxuXHQgKlxuXHQgKiBAYXBpIHB1YmxpY1xuXHQgKi9cblx0XG5cdGV4cG9ydHMuQklOQVJZX0FDSyA9IDY7XG5cdFxuXHQvKipcblx0ICogRW5jb2RlciBjb25zdHJ1Y3Rvci5cblx0ICpcblx0ICogQGFwaSBwdWJsaWNcblx0ICovXG5cdFxuXHRleHBvcnRzLkVuY29kZXIgPSBFbmNvZGVyO1xuXHRcblx0LyoqXG5cdCAqIERlY29kZXIgY29uc3RydWN0b3IuXG5cdCAqXG5cdCAqIEBhcGkgcHVibGljXG5cdCAqL1xuXHRcblx0ZXhwb3J0cy5EZWNvZGVyID0gRGVjb2Rlcjtcblx0XG5cdC8qKlxuXHQgKiBBIHNvY2tldC5pbyBFbmNvZGVyIGluc3RhbmNlXG5cdCAqXG5cdCAqIEBhcGkgcHVibGljXG5cdCAqL1xuXHRcblx0ZnVuY3Rpb24gRW5jb2RlcigpIHt9XG5cdFxuXHQvKipcblx0ICogRW5jb2RlIGEgcGFja2V0IGFzIGEgc2luZ2xlIHN0cmluZyBpZiBub24tYmluYXJ5LCBvciBhcyBhXG5cdCAqIGJ1ZmZlciBzZXF1ZW5jZSwgZGVwZW5kaW5nIG9uIHBhY2tldCB0eXBlLlxuXHQgKlxuXHQgKiBAcGFyYW0ge09iamVjdH0gb2JqIC0gcGFja2V0IG9iamVjdFxuXHQgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFjayAtIGZ1bmN0aW9uIHRvIGhhbmRsZSBlbmNvZGluZ3MgKGxpa2VseSBlbmdpbmUud3JpdGUpXG5cdCAqIEByZXR1cm4gQ2FsbHMgY2FsbGJhY2sgd2l0aCBBcnJheSBvZiBlbmNvZGluZ3Ncblx0ICogQGFwaSBwdWJsaWNcblx0ICovXG5cdFxuXHRFbmNvZGVyLnByb3RvdHlwZS5lbmNvZGUgPSBmdW5jdGlvbihvYmosIGNhbGxiYWNrKXtcblx0ICBpZiAoKG9iai50eXBlID09PSBleHBvcnRzLkVWRU5UIHx8IG9iai50eXBlID09PSBleHBvcnRzLkFDSykgJiYgaGFzQmluKG9iai5kYXRhKSkge1xuXHQgICAgb2JqLnR5cGUgPSBvYmoudHlwZSA9PT0gZXhwb3J0cy5FVkVOVCA/IGV4cG9ydHMuQklOQVJZX0VWRU5UIDogZXhwb3J0cy5CSU5BUllfQUNLO1xuXHQgIH1cblx0XG5cdFxuXHRcblx0ICBpZiAoZXhwb3J0cy5CSU5BUllfRVZFTlQgPT09IG9iai50eXBlIHx8IGV4cG9ydHMuQklOQVJZX0FDSyA9PT0gb2JqLnR5cGUpIHtcblx0ICAgIGVuY29kZUFzQmluYXJ5KG9iaiwgY2FsbGJhY2spO1xuXHQgIH1cblx0ICBlbHNlIHtcblx0ICAgIHZhciBlbmNvZGluZyA9IGVuY29kZUFzU3RyaW5nKG9iaik7XG5cdCAgICBjYWxsYmFjayhbZW5jb2RpbmddKTtcblx0ICB9XG5cdH07XG5cdFxuXHQvKipcblx0ICogRW5jb2RlIHBhY2tldCBhcyBzdHJpbmcuXG5cdCAqXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBwYWNrZXRcblx0ICogQHJldHVybiB7U3RyaW5nfSBlbmNvZGVkXG5cdCAqIEBhcGkgcHJpdmF0ZVxuXHQgKi9cblx0XG5cdGZ1bmN0aW9uIGVuY29kZUFzU3RyaW5nKG9iaikge1xuXHRcblx0ICAvLyBmaXJzdCBpcyB0eXBlXG5cdCAgdmFyIHN0ciA9ICcnICsgb2JqLnR5cGU7XG5cdFxuXHQgIC8vIGF0dGFjaG1lbnRzIGlmIHdlIGhhdmUgdGhlbVxuXHQgIGlmIChleHBvcnRzLkJJTkFSWV9FVkVOVCA9PT0gb2JqLnR5cGUgfHwgZXhwb3J0cy5CSU5BUllfQUNLID09PSBvYmoudHlwZSkge1xuXHQgICAgc3RyICs9IG9iai5hdHRhY2htZW50cyArICctJztcblx0ICB9XG5cdFxuXHQgIC8vIGlmIHdlIGhhdmUgYSBuYW1lc3BhY2Ugb3RoZXIgdGhhbiBgL2Bcblx0ICAvLyB3ZSBhcHBlbmQgaXQgZm9sbG93ZWQgYnkgYSBjb21tYSBgLGBcblx0ICBpZiAob2JqLm5zcCAmJiAnLycgIT09IG9iai5uc3ApIHtcblx0ICAgIHN0ciArPSBvYmoubnNwICsgJywnO1xuXHQgIH1cblx0XG5cdCAgLy8gaW1tZWRpYXRlbHkgZm9sbG93ZWQgYnkgdGhlIGlkXG5cdCAgaWYgKG51bGwgIT0gb2JqLmlkKSB7XG5cdCAgICBzdHIgKz0gb2JqLmlkO1xuXHQgIH1cblx0XG5cdCAgLy8ganNvbiBkYXRhXG5cdCAgaWYgKG51bGwgIT0gb2JqLmRhdGEpIHtcblx0ICAgIHN0ciArPSBKU09OLnN0cmluZ2lmeShvYmouZGF0YSk7XG5cdCAgfVxuXHRcblx0XG5cdCAgcmV0dXJuIHN0cjtcblx0fVxuXHRcblx0LyoqXG5cdCAqIEVuY29kZSBwYWNrZXQgYXMgJ2J1ZmZlciBzZXF1ZW5jZScgYnkgcmVtb3ZpbmcgYmxvYnMsIGFuZFxuXHQgKiBkZWNvbnN0cnVjdGluZyBwYWNrZXQgaW50byBvYmplY3Qgd2l0aCBwbGFjZWhvbGRlcnMgYW5kXG5cdCAqIGEgbGlzdCBvZiBidWZmZXJzLlxuXHQgKlxuXHQgKiBAcGFyYW0ge09iamVjdH0gcGFja2V0XG5cdCAqIEByZXR1cm4ge0J1ZmZlcn0gZW5jb2RlZFxuXHQgKiBAYXBpIHByaXZhdGVcblx0ICovXG5cdFxuXHRmdW5jdGlvbiBlbmNvZGVBc0JpbmFyeShvYmosIGNhbGxiYWNrKSB7XG5cdFxuXHQgIGZ1bmN0aW9uIHdyaXRlRW5jb2RpbmcoYmxvYmxlc3NEYXRhKSB7XG5cdCAgICB2YXIgZGVjb25zdHJ1Y3Rpb24gPSBiaW5hcnkuZGVjb25zdHJ1Y3RQYWNrZXQoYmxvYmxlc3NEYXRhKTtcblx0ICAgIHZhciBwYWNrID0gZW5jb2RlQXNTdHJpbmcoZGVjb25zdHJ1Y3Rpb24ucGFja2V0KTtcblx0ICAgIHZhciBidWZmZXJzID0gZGVjb25zdHJ1Y3Rpb24uYnVmZmVycztcblx0XG5cdCAgICBidWZmZXJzLnVuc2hpZnQocGFjayk7IC8vIGFkZCBwYWNrZXQgaW5mbyB0byBiZWdpbm5pbmcgb2YgZGF0YSBsaXN0XG5cdCAgICBjYWxsYmFjayhidWZmZXJzKTsgLy8gd3JpdGUgYWxsIHRoZSBidWZmZXJzXG5cdCAgfVxuXHRcblx0ICBiaW5hcnkucmVtb3ZlQmxvYnMob2JqLCB3cml0ZUVuY29kaW5nKTtcblx0fVxuXHRcblx0LyoqXG5cdCAqIEEgc29ja2V0LmlvIERlY29kZXIgaW5zdGFuY2Vcblx0ICpcblx0ICogQHJldHVybiB7T2JqZWN0fSBkZWNvZGVyXG5cdCAqIEBhcGkgcHVibGljXG5cdCAqL1xuXHRcblx0ZnVuY3Rpb24gRGVjb2RlcigpIHtcblx0ICB0aGlzLnJlY29uc3RydWN0b3IgPSBudWxsO1xuXHR9XG5cdFxuXHQvKipcblx0ICogTWl4IGluIGBFbWl0dGVyYCB3aXRoIERlY29kZXIuXG5cdCAqL1xuXHRcblx0RW1pdHRlcihEZWNvZGVyLnByb3RvdHlwZSk7XG5cdFxuXHQvKipcblx0ICogRGVjb2RlcyBhbiBlY29kZWQgcGFja2V0IHN0cmluZyBpbnRvIHBhY2tldCBKU09OLlxuXHQgKlxuXHQgKiBAcGFyYW0ge1N0cmluZ30gb2JqIC0gZW5jb2RlZCBwYWNrZXRcblx0ICogQHJldHVybiB7T2JqZWN0fSBwYWNrZXRcblx0ICogQGFwaSBwdWJsaWNcblx0ICovXG5cdFxuXHREZWNvZGVyLnByb3RvdHlwZS5hZGQgPSBmdW5jdGlvbihvYmopIHtcblx0ICB2YXIgcGFja2V0O1xuXHQgIGlmICh0eXBlb2Ygb2JqID09PSAnc3RyaW5nJykge1xuXHQgICAgcGFja2V0ID0gZGVjb2RlU3RyaW5nKG9iaik7XG5cdCAgICBpZiAoZXhwb3J0cy5CSU5BUllfRVZFTlQgPT09IHBhY2tldC50eXBlIHx8IGV4cG9ydHMuQklOQVJZX0FDSyA9PT0gcGFja2V0LnR5cGUpIHsgLy8gYmluYXJ5IHBhY2tldCdzIGpzb25cblx0ICAgICAgdGhpcy5yZWNvbnN0cnVjdG9yID0gbmV3IEJpbmFyeVJlY29uc3RydWN0b3IocGFja2V0KTtcblx0XG5cdCAgICAgIC8vIG5vIGF0dGFjaG1lbnRzLCBsYWJlbGVkIGJpbmFyeSBidXQgbm8gYmluYXJ5IGRhdGEgdG8gZm9sbG93XG5cdCAgICAgIGlmICh0aGlzLnJlY29uc3RydWN0b3IucmVjb25QYWNrLmF0dGFjaG1lbnRzID09PSAwKSB7XG5cdCAgICAgICAgdGhpcy5lbWl0KCdkZWNvZGVkJywgcGFja2V0KTtcblx0ICAgICAgfVxuXHQgICAgfSBlbHNlIHsgLy8gbm9uLWJpbmFyeSBmdWxsIHBhY2tldFxuXHQgICAgICB0aGlzLmVtaXQoJ2RlY29kZWQnLCBwYWNrZXQpO1xuXHQgICAgfVxuXHQgIH1cblx0ICBlbHNlIGlmIChpc0J1ZihvYmopIHx8IG9iai5iYXNlNjQpIHsgLy8gcmF3IGJpbmFyeSBkYXRhXG5cdCAgICBpZiAoIXRoaXMucmVjb25zdHJ1Y3Rvcikge1xuXHQgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2dvdCBiaW5hcnkgZGF0YSB3aGVuIG5vdCByZWNvbnN0cnVjdGluZyBhIHBhY2tldCcpO1xuXHQgICAgfSBlbHNlIHtcblx0ICAgICAgcGFja2V0ID0gdGhpcy5yZWNvbnN0cnVjdG9yLnRha2VCaW5hcnlEYXRhKG9iaik7XG5cdCAgICAgIGlmIChwYWNrZXQpIHsgLy8gcmVjZWl2ZWQgZmluYWwgYnVmZmVyXG5cdCAgICAgICAgdGhpcy5yZWNvbnN0cnVjdG9yID0gbnVsbDtcblx0ICAgICAgICB0aGlzLmVtaXQoJ2RlY29kZWQnLCBwYWNrZXQpO1xuXHQgICAgICB9XG5cdCAgICB9XG5cdCAgfVxuXHQgIGVsc2Uge1xuXHQgICAgdGhyb3cgbmV3IEVycm9yKCdVbmtub3duIHR5cGU6ICcgKyBvYmopO1xuXHQgIH1cblx0fTtcblx0XG5cdC8qKlxuXHQgKiBEZWNvZGUgYSBwYWNrZXQgU3RyaW5nIChKU09OIGRhdGEpXG5cdCAqXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBzdHJcblx0ICogQHJldHVybiB7T2JqZWN0fSBwYWNrZXRcblx0ICogQGFwaSBwcml2YXRlXG5cdCAqL1xuXHRcblx0ZnVuY3Rpb24gZGVjb2RlU3RyaW5nKHN0cikge1xuXHQgIHZhciBpID0gMDtcblx0ICAvLyBsb29rIHVwIHR5cGVcblx0ICB2YXIgcCA9IHtcblx0ICAgIHR5cGU6IE51bWJlcihzdHIuY2hhckF0KDApKVxuXHQgIH07XG5cdFxuXHQgIGlmIChudWxsID09IGV4cG9ydHMudHlwZXNbcC50eXBlXSkgcmV0dXJuIGVycm9yKCk7XG5cdFxuXHQgIC8vIGxvb2sgdXAgYXR0YWNobWVudHMgaWYgdHlwZSBiaW5hcnlcblx0ICBpZiAoZXhwb3J0cy5CSU5BUllfRVZFTlQgPT09IHAudHlwZSB8fCBleHBvcnRzLkJJTkFSWV9BQ0sgPT09IHAudHlwZSkge1xuXHQgICAgdmFyIGJ1ZiA9ICcnO1xuXHQgICAgd2hpbGUgKHN0ci5jaGFyQXQoKytpKSAhPT0gJy0nKSB7XG5cdCAgICAgIGJ1ZiArPSBzdHIuY2hhckF0KGkpO1xuXHQgICAgICBpZiAoaSA9PSBzdHIubGVuZ3RoKSBicmVhaztcblx0ICAgIH1cblx0ICAgIGlmIChidWYgIT0gTnVtYmVyKGJ1ZikgfHwgc3RyLmNoYXJBdChpKSAhPT0gJy0nKSB7XG5cdCAgICAgIHRocm93IG5ldyBFcnJvcignSWxsZWdhbCBhdHRhY2htZW50cycpO1xuXHQgICAgfVxuXHQgICAgcC5hdHRhY2htZW50cyA9IE51bWJlcihidWYpO1xuXHQgIH1cblx0XG5cdCAgLy8gbG9vayB1cCBuYW1lc3BhY2UgKGlmIGFueSlcblx0ICBpZiAoJy8nID09PSBzdHIuY2hhckF0KGkgKyAxKSkge1xuXHQgICAgcC5uc3AgPSAnJztcblx0ICAgIHdoaWxlICgrK2kpIHtcblx0ICAgICAgdmFyIGMgPSBzdHIuY2hhckF0KGkpO1xuXHQgICAgICBpZiAoJywnID09PSBjKSBicmVhaztcblx0ICAgICAgcC5uc3AgKz0gYztcblx0ICAgICAgaWYgKGkgPT09IHN0ci5sZW5ndGgpIGJyZWFrO1xuXHQgICAgfVxuXHQgIH0gZWxzZSB7XG5cdCAgICBwLm5zcCA9ICcvJztcblx0ICB9XG5cdFxuXHQgIC8vIGxvb2sgdXAgaWRcblx0ICB2YXIgbmV4dCA9IHN0ci5jaGFyQXQoaSArIDEpO1xuXHQgIGlmICgnJyAhPT0gbmV4dCAmJiBOdW1iZXIobmV4dCkgPT0gbmV4dCkge1xuXHQgICAgcC5pZCA9ICcnO1xuXHQgICAgd2hpbGUgKCsraSkge1xuXHQgICAgICB2YXIgYyA9IHN0ci5jaGFyQXQoaSk7XG5cdCAgICAgIGlmIChudWxsID09IGMgfHwgTnVtYmVyKGMpICE9IGMpIHtcblx0ICAgICAgICAtLWk7XG5cdCAgICAgICAgYnJlYWs7XG5cdCAgICAgIH1cblx0ICAgICAgcC5pZCArPSBzdHIuY2hhckF0KGkpO1xuXHQgICAgICBpZiAoaSA9PT0gc3RyLmxlbmd0aCkgYnJlYWs7XG5cdCAgICB9XG5cdCAgICBwLmlkID0gTnVtYmVyKHAuaWQpO1xuXHQgIH1cblx0XG5cdCAgLy8gbG9vayB1cCBqc29uIGRhdGFcblx0ICBpZiAoc3RyLmNoYXJBdCgrK2kpKSB7XG5cdCAgICBwID0gdHJ5UGFyc2UocCwgc3RyLnN1YnN0cihpKSk7XG5cdCAgfVxuXHRcblx0XG5cdCAgcmV0dXJuIHA7XG5cdH1cblx0XG5cdGZ1bmN0aW9uIHRyeVBhcnNlKHAsIHN0cikge1xuXHQgIHRyeSB7XG5cdCAgICBwLmRhdGEgPSBKU09OLnBhcnNlKHN0cik7XG5cdCAgfSBjYXRjaChlKXtcblx0ICAgIHJldHVybiBlcnJvcigpO1xuXHQgIH1cblx0ICByZXR1cm4gcDsgXG5cdH1cblx0XG5cdC8qKlxuXHQgKiBEZWFsbG9jYXRlcyBhIHBhcnNlcidzIHJlc291cmNlc1xuXHQgKlxuXHQgKiBAYXBpIHB1YmxpY1xuXHQgKi9cblx0XG5cdERlY29kZXIucHJvdG90eXBlLmRlc3Ryb3kgPSBmdW5jdGlvbigpIHtcblx0ICBpZiAodGhpcy5yZWNvbnN0cnVjdG9yKSB7XG5cdCAgICB0aGlzLnJlY29uc3RydWN0b3IuZmluaXNoZWRSZWNvbnN0cnVjdGlvbigpO1xuXHQgIH1cblx0fTtcblx0XG5cdC8qKlxuXHQgKiBBIG1hbmFnZXIgb2YgYSBiaW5hcnkgZXZlbnQncyAnYnVmZmVyIHNlcXVlbmNlJy4gU2hvdWxkXG5cdCAqIGJlIGNvbnN0cnVjdGVkIHdoZW5ldmVyIGEgcGFja2V0IG9mIHR5cGUgQklOQVJZX0VWRU5UIGlzXG5cdCAqIGRlY29kZWQuXG5cdCAqXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBwYWNrZXRcblx0ICogQHJldHVybiB7QmluYXJ5UmVjb25zdHJ1Y3Rvcn0gaW5pdGlhbGl6ZWQgcmVjb25zdHJ1Y3RvclxuXHQgKiBAYXBpIHByaXZhdGVcblx0ICovXG5cdFxuXHRmdW5jdGlvbiBCaW5hcnlSZWNvbnN0cnVjdG9yKHBhY2tldCkge1xuXHQgIHRoaXMucmVjb25QYWNrID0gcGFja2V0O1xuXHQgIHRoaXMuYnVmZmVycyA9IFtdO1xuXHR9XG5cdFxuXHQvKipcblx0ICogTWV0aG9kIHRvIGJlIGNhbGxlZCB3aGVuIGJpbmFyeSBkYXRhIHJlY2VpdmVkIGZyb20gY29ubmVjdGlvblxuXHQgKiBhZnRlciBhIEJJTkFSWV9FVkVOVCBwYWNrZXQuXG5cdCAqXG5cdCAqIEBwYXJhbSB7QnVmZmVyIHwgQXJyYXlCdWZmZXJ9IGJpbkRhdGEgLSB0aGUgcmF3IGJpbmFyeSBkYXRhIHJlY2VpdmVkXG5cdCAqIEByZXR1cm4ge251bGwgfCBPYmplY3R9IHJldHVybnMgbnVsbCBpZiBtb3JlIGJpbmFyeSBkYXRhIGlzIGV4cGVjdGVkIG9yXG5cdCAqICAgYSByZWNvbnN0cnVjdGVkIHBhY2tldCBvYmplY3QgaWYgYWxsIGJ1ZmZlcnMgaGF2ZSBiZWVuIHJlY2VpdmVkLlxuXHQgKiBAYXBpIHByaXZhdGVcblx0ICovXG5cdFxuXHRCaW5hcnlSZWNvbnN0cnVjdG9yLnByb3RvdHlwZS50YWtlQmluYXJ5RGF0YSA9IGZ1bmN0aW9uKGJpbkRhdGEpIHtcblx0ICB0aGlzLmJ1ZmZlcnMucHVzaChiaW5EYXRhKTtcblx0ICBpZiAodGhpcy5idWZmZXJzLmxlbmd0aCA9PT0gdGhpcy5yZWNvblBhY2suYXR0YWNobWVudHMpIHsgLy8gZG9uZSB3aXRoIGJ1ZmZlciBsaXN0XG5cdCAgICB2YXIgcGFja2V0ID0gYmluYXJ5LnJlY29uc3RydWN0UGFja2V0KHRoaXMucmVjb25QYWNrLCB0aGlzLmJ1ZmZlcnMpO1xuXHQgICAgdGhpcy5maW5pc2hlZFJlY29uc3RydWN0aW9uKCk7XG5cdCAgICByZXR1cm4gcGFja2V0O1xuXHQgIH1cblx0ICByZXR1cm4gbnVsbDtcblx0fTtcblx0XG5cdC8qKlxuXHQgKiBDbGVhbnMgdXAgYmluYXJ5IHBhY2tldCByZWNvbnN0cnVjdGlvbiB2YXJpYWJsZXMuXG5cdCAqXG5cdCAqIEBhcGkgcHJpdmF0ZVxuXHQgKi9cblx0XG5cdEJpbmFyeVJlY29uc3RydWN0b3IucHJvdG90eXBlLmZpbmlzaGVkUmVjb25zdHJ1Y3Rpb24gPSBmdW5jdGlvbigpIHtcblx0ICB0aGlzLnJlY29uUGFjayA9IG51bGw7XG5cdCAgdGhpcy5idWZmZXJzID0gW107XG5cdH07XG5cdFxuXHRmdW5jdGlvbiBlcnJvcigpIHtcblx0ICByZXR1cm4ge1xuXHQgICAgdHlwZTogZXhwb3J0cy5FUlJPUixcblx0ICAgIGRhdGE6ICdwYXJzZXIgZXJyb3InXG5cdCAgfTtcblx0fVxuXG5cbi8qKiovIH0pLFxuLyogNSAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cdFxyXG5cdC8qKlxyXG5cdCAqIEV4cG9zZSBgRW1pdHRlcmAuXHJcblx0ICovXHJcblx0XHJcblx0aWYgKHRydWUpIHtcclxuXHQgIG1vZHVsZS5leHBvcnRzID0gRW1pdHRlcjtcclxuXHR9XHJcblx0XHJcblx0LyoqXHJcblx0ICogSW5pdGlhbGl6ZSBhIG5ldyBgRW1pdHRlcmAuXHJcblx0ICpcclxuXHQgKiBAYXBpIHB1YmxpY1xyXG5cdCAqL1xyXG5cdFxyXG5cdGZ1bmN0aW9uIEVtaXR0ZXIob2JqKSB7XHJcblx0ICBpZiAob2JqKSByZXR1cm4gbWl4aW4ob2JqKTtcclxuXHR9O1xyXG5cdFxyXG5cdC8qKlxyXG5cdCAqIE1peGluIHRoZSBlbWl0dGVyIHByb3BlcnRpZXMuXHJcblx0ICpcclxuXHQgKiBAcGFyYW0ge09iamVjdH0gb2JqXHJcblx0ICogQHJldHVybiB7T2JqZWN0fVxyXG5cdCAqIEBhcGkgcHJpdmF0ZVxyXG5cdCAqL1xyXG5cdFxyXG5cdGZ1bmN0aW9uIG1peGluKG9iaikge1xyXG5cdCAgZm9yICh2YXIga2V5IGluIEVtaXR0ZXIucHJvdG90eXBlKSB7XHJcblx0ICAgIG9ialtrZXldID0gRW1pdHRlci5wcm90b3R5cGVba2V5XTtcclxuXHQgIH1cclxuXHQgIHJldHVybiBvYmo7XHJcblx0fVxyXG5cdFxyXG5cdC8qKlxyXG5cdCAqIExpc3RlbiBvbiB0aGUgZ2l2ZW4gYGV2ZW50YCB3aXRoIGBmbmAuXHJcblx0ICpcclxuXHQgKiBAcGFyYW0ge1N0cmluZ30gZXZlbnRcclxuXHQgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmblxyXG5cdCAqIEByZXR1cm4ge0VtaXR0ZXJ9XHJcblx0ICogQGFwaSBwdWJsaWNcclxuXHQgKi9cclxuXHRcclxuXHRFbWl0dGVyLnByb3RvdHlwZS5vbiA9XHJcblx0RW1pdHRlci5wcm90b3R5cGUuYWRkRXZlbnRMaXN0ZW5lciA9IGZ1bmN0aW9uKGV2ZW50LCBmbil7XHJcblx0ICB0aGlzLl9jYWxsYmFja3MgPSB0aGlzLl9jYWxsYmFja3MgfHwge307XHJcblx0ICAodGhpcy5fY2FsbGJhY2tzWyckJyArIGV2ZW50XSA9IHRoaXMuX2NhbGxiYWNrc1snJCcgKyBldmVudF0gfHwgW10pXHJcblx0ICAgIC5wdXNoKGZuKTtcclxuXHQgIHJldHVybiB0aGlzO1xyXG5cdH07XHJcblx0XHJcblx0LyoqXHJcblx0ICogQWRkcyBhbiBgZXZlbnRgIGxpc3RlbmVyIHRoYXQgd2lsbCBiZSBpbnZva2VkIGEgc2luZ2xlXHJcblx0ICogdGltZSB0aGVuIGF1dG9tYXRpY2FsbHkgcmVtb3ZlZC5cclxuXHQgKlxyXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBldmVudFxyXG5cdCAqIEBwYXJhbSB7RnVuY3Rpb259IGZuXHJcblx0ICogQHJldHVybiB7RW1pdHRlcn1cclxuXHQgKiBAYXBpIHB1YmxpY1xyXG5cdCAqL1xyXG5cdFxyXG5cdEVtaXR0ZXIucHJvdG90eXBlLm9uY2UgPSBmdW5jdGlvbihldmVudCwgZm4pe1xyXG5cdCAgZnVuY3Rpb24gb24oKSB7XHJcblx0ICAgIHRoaXMub2ZmKGV2ZW50LCBvbik7XHJcblx0ICAgIGZuLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XHJcblx0ICB9XHJcblx0XHJcblx0ICBvbi5mbiA9IGZuO1xyXG5cdCAgdGhpcy5vbihldmVudCwgb24pO1xyXG5cdCAgcmV0dXJuIHRoaXM7XHJcblx0fTtcclxuXHRcclxuXHQvKipcclxuXHQgKiBSZW1vdmUgdGhlIGdpdmVuIGNhbGxiYWNrIGZvciBgZXZlbnRgIG9yIGFsbFxyXG5cdCAqIHJlZ2lzdGVyZWQgY2FsbGJhY2tzLlxyXG5cdCAqXHJcblx0ICogQHBhcmFtIHtTdHJpbmd9IGV2ZW50XHJcblx0ICogQHBhcmFtIHtGdW5jdGlvbn0gZm5cclxuXHQgKiBAcmV0dXJuIHtFbWl0dGVyfVxyXG5cdCAqIEBhcGkgcHVibGljXHJcblx0ICovXHJcblx0XHJcblx0RW1pdHRlci5wcm90b3R5cGUub2ZmID1cclxuXHRFbWl0dGVyLnByb3RvdHlwZS5yZW1vdmVMaXN0ZW5lciA9XHJcblx0RW1pdHRlci5wcm90b3R5cGUucmVtb3ZlQWxsTGlzdGVuZXJzID1cclxuXHRFbWl0dGVyLnByb3RvdHlwZS5yZW1vdmVFdmVudExpc3RlbmVyID0gZnVuY3Rpb24oZXZlbnQsIGZuKXtcclxuXHQgIHRoaXMuX2NhbGxiYWNrcyA9IHRoaXMuX2NhbGxiYWNrcyB8fCB7fTtcclxuXHRcclxuXHQgIC8vIGFsbFxyXG5cdCAgaWYgKDAgPT0gYXJndW1lbnRzLmxlbmd0aCkge1xyXG5cdCAgICB0aGlzLl9jYWxsYmFja3MgPSB7fTtcclxuXHQgICAgcmV0dXJuIHRoaXM7XHJcblx0ICB9XHJcblx0XHJcblx0ICAvLyBzcGVjaWZpYyBldmVudFxyXG5cdCAgdmFyIGNhbGxiYWNrcyA9IHRoaXMuX2NhbGxiYWNrc1snJCcgKyBldmVudF07XHJcblx0ICBpZiAoIWNhbGxiYWNrcykgcmV0dXJuIHRoaXM7XHJcblx0XHJcblx0ICAvLyByZW1vdmUgYWxsIGhhbmRsZXJzXHJcblx0ICBpZiAoMSA9PSBhcmd1bWVudHMubGVuZ3RoKSB7XHJcblx0ICAgIGRlbGV0ZSB0aGlzLl9jYWxsYmFja3NbJyQnICsgZXZlbnRdO1xyXG5cdCAgICByZXR1cm4gdGhpcztcclxuXHQgIH1cclxuXHRcclxuXHQgIC8vIHJlbW92ZSBzcGVjaWZpYyBoYW5kbGVyXHJcblx0ICB2YXIgY2I7XHJcblx0ICBmb3IgKHZhciBpID0gMDsgaSA8IGNhbGxiYWNrcy5sZW5ndGg7IGkrKykge1xyXG5cdCAgICBjYiA9IGNhbGxiYWNrc1tpXTtcclxuXHQgICAgaWYgKGNiID09PSBmbiB8fCBjYi5mbiA9PT0gZm4pIHtcclxuXHQgICAgICBjYWxsYmFja3Muc3BsaWNlKGksIDEpO1xyXG5cdCAgICAgIGJyZWFrO1xyXG5cdCAgICB9XHJcblx0ICB9XHJcblx0ICByZXR1cm4gdGhpcztcclxuXHR9O1xyXG5cdFxyXG5cdC8qKlxyXG5cdCAqIEVtaXQgYGV2ZW50YCB3aXRoIHRoZSBnaXZlbiBhcmdzLlxyXG5cdCAqXHJcblx0ICogQHBhcmFtIHtTdHJpbmd9IGV2ZW50XHJcblx0ICogQHBhcmFtIHtNaXhlZH0gLi4uXHJcblx0ICogQHJldHVybiB7RW1pdHRlcn1cclxuXHQgKi9cclxuXHRcclxuXHRFbWl0dGVyLnByb3RvdHlwZS5lbWl0ID0gZnVuY3Rpb24oZXZlbnQpe1xyXG5cdCAgdGhpcy5fY2FsbGJhY2tzID0gdGhpcy5fY2FsbGJhY2tzIHx8IHt9O1xyXG5cdCAgdmFyIGFyZ3MgPSBbXS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMSlcclxuXHQgICAgLCBjYWxsYmFja3MgPSB0aGlzLl9jYWxsYmFja3NbJyQnICsgZXZlbnRdO1xyXG5cdFxyXG5cdCAgaWYgKGNhbGxiYWNrcykge1xyXG5cdCAgICBjYWxsYmFja3MgPSBjYWxsYmFja3Muc2xpY2UoMCk7XHJcblx0ICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBjYWxsYmFja3MubGVuZ3RoOyBpIDwgbGVuOyArK2kpIHtcclxuXHQgICAgICBjYWxsYmFja3NbaV0uYXBwbHkodGhpcywgYXJncyk7XHJcblx0ICAgIH1cclxuXHQgIH1cclxuXHRcclxuXHQgIHJldHVybiB0aGlzO1xyXG5cdH07XHJcblx0XHJcblx0LyoqXHJcblx0ICogUmV0dXJuIGFycmF5IG9mIGNhbGxiYWNrcyBmb3IgYGV2ZW50YC5cclxuXHQgKlxyXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBldmVudFxyXG5cdCAqIEByZXR1cm4ge0FycmF5fVxyXG5cdCAqIEBhcGkgcHVibGljXHJcblx0ICovXHJcblx0XHJcblx0RW1pdHRlci5wcm90b3R5cGUubGlzdGVuZXJzID0gZnVuY3Rpb24oZXZlbnQpe1xyXG5cdCAgdGhpcy5fY2FsbGJhY2tzID0gdGhpcy5fY2FsbGJhY2tzIHx8IHt9O1xyXG5cdCAgcmV0dXJuIHRoaXMuX2NhbGxiYWNrc1snJCcgKyBldmVudF0gfHwgW107XHJcblx0fTtcclxuXHRcclxuXHQvKipcclxuXHQgKiBDaGVjayBpZiB0aGlzIGVtaXR0ZXIgaGFzIGBldmVudGAgaGFuZGxlcnMuXHJcblx0ICpcclxuXHQgKiBAcGFyYW0ge1N0cmluZ30gZXZlbnRcclxuXHQgKiBAcmV0dXJuIHtCb29sZWFufVxyXG5cdCAqIEBhcGkgcHVibGljXHJcblx0ICovXHJcblx0XHJcblx0RW1pdHRlci5wcm90b3R5cGUuaGFzTGlzdGVuZXJzID0gZnVuY3Rpb24oZXZlbnQpe1xyXG5cdCAgcmV0dXJuICEhIHRoaXMubGlzdGVuZXJzKGV2ZW50KS5sZW5ndGg7XHJcblx0fTtcclxuXG5cbi8qKiovIH0pLFxuLyogNiAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cdC8qIFdFQlBBQ0sgVkFSIElOSkVDVElPTiAqLyhmdW5jdGlvbihnbG9iYWwpIHsvKiBnbG9iYWwgQmxvYiBGaWxlICovXG5cdFxuXHQvKlxuXHQgKiBNb2R1bGUgcmVxdWlyZW1lbnRzLlxuXHQgKi9cblx0XG5cdHZhciBpc0FycmF5ID0gX193ZWJwYWNrX3JlcXVpcmVfXyg3KTtcblx0XG5cdHZhciB0b1N0cmluZyA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmc7XG5cdHZhciB3aXRoTmF0aXZlQmxvYiA9IHR5cGVvZiBnbG9iYWwuQmxvYiA9PT0gJ2Z1bmN0aW9uJyB8fCB0b1N0cmluZy5jYWxsKGdsb2JhbC5CbG9iKSA9PT0gJ1tvYmplY3QgQmxvYkNvbnN0cnVjdG9yXSc7XG5cdHZhciB3aXRoTmF0aXZlRmlsZSA9IHR5cGVvZiBnbG9iYWwuRmlsZSA9PT0gJ2Z1bmN0aW9uJyB8fCB0b1N0cmluZy5jYWxsKGdsb2JhbC5GaWxlKSA9PT0gJ1tvYmplY3QgRmlsZUNvbnN0cnVjdG9yXSc7XG5cdFxuXHQvKipcblx0ICogTW9kdWxlIGV4cG9ydHMuXG5cdCAqL1xuXHRcblx0bW9kdWxlLmV4cG9ydHMgPSBoYXNCaW5hcnk7XG5cdFxuXHQvKipcblx0ICogQ2hlY2tzIGZvciBiaW5hcnkgZGF0YS5cblx0ICpcblx0ICogU3VwcG9ydHMgQnVmZmVyLCBBcnJheUJ1ZmZlciwgQmxvYiBhbmQgRmlsZS5cblx0ICpcblx0ICogQHBhcmFtIHtPYmplY3R9IGFueXRoaW5nXG5cdCAqIEBhcGkgcHVibGljXG5cdCAqL1xuXHRcblx0ZnVuY3Rpb24gaGFzQmluYXJ5IChvYmopIHtcblx0ICBpZiAoIW9iaiB8fCB0eXBlb2Ygb2JqICE9PSAnb2JqZWN0Jykge1xuXHQgICAgcmV0dXJuIGZhbHNlO1xuXHQgIH1cblx0XG5cdCAgaWYgKGlzQXJyYXkob2JqKSkge1xuXHQgICAgZm9yICh2YXIgaSA9IDAsIGwgPSBvYmoubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG5cdCAgICAgIGlmIChoYXNCaW5hcnkob2JqW2ldKSkge1xuXHQgICAgICAgIHJldHVybiB0cnVlO1xuXHQgICAgICB9XG5cdCAgICB9XG5cdCAgICByZXR1cm4gZmFsc2U7XG5cdCAgfVxuXHRcblx0ICBpZiAoKHR5cGVvZiBnbG9iYWwuQnVmZmVyID09PSAnZnVuY3Rpb24nICYmIGdsb2JhbC5CdWZmZXIuaXNCdWZmZXIgJiYgZ2xvYmFsLkJ1ZmZlci5pc0J1ZmZlcihvYmopKSB8fFxuXHQgICAgICh0eXBlb2YgZ2xvYmFsLkFycmF5QnVmZmVyID09PSAnZnVuY3Rpb24nICYmIG9iaiBpbnN0YW5jZW9mIEFycmF5QnVmZmVyKSB8fFxuXHQgICAgICh3aXRoTmF0aXZlQmxvYiAmJiBvYmogaW5zdGFuY2VvZiBCbG9iKSB8fFxuXHQgICAgICh3aXRoTmF0aXZlRmlsZSAmJiBvYmogaW5zdGFuY2VvZiBGaWxlKVxuXHQgICAgKSB7XG5cdCAgICByZXR1cm4gdHJ1ZTtcblx0ICB9XG5cdFxuXHQgIC8vIHNlZTogaHR0cHM6Ly9naXRodWIuY29tL0F1dG9tYXR0aWMvaGFzLWJpbmFyeS9wdWxsLzRcblx0ICBpZiAob2JqLnRvSlNPTiAmJiB0eXBlb2Ygb2JqLnRvSlNPTiA9PT0gJ2Z1bmN0aW9uJyAmJiBhcmd1bWVudHMubGVuZ3RoID09PSAxKSB7XG5cdCAgICByZXR1cm4gaGFzQmluYXJ5KG9iai50b0pTT04oKSwgdHJ1ZSk7XG5cdCAgfVxuXHRcblx0ICBmb3IgKHZhciBrZXkgaW4gb2JqKSB7XG5cdCAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwga2V5KSAmJiBoYXNCaW5hcnkob2JqW2tleV0pKSB7XG5cdCAgICAgIHJldHVybiB0cnVlO1xuXHQgICAgfVxuXHQgIH1cblx0XG5cdCAgcmV0dXJuIGZhbHNlO1xuXHR9XG5cdFxuXHQvKiBXRUJQQUNLIFZBUiBJTkpFQ1RJT04gKi99LmNhbGwoZXhwb3J0cywgKGZ1bmN0aW9uKCkgeyByZXR1cm4gdGhpczsgfSgpKSkpXG5cbi8qKiovIH0pLFxuLyogNyAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xuXG5cdHZhciB0b1N0cmluZyA9IHt9LnRvU3RyaW5nO1xuXHRcblx0bW9kdWxlLmV4cG9ydHMgPSBBcnJheS5pc0FycmF5IHx8IGZ1bmN0aW9uIChhcnIpIHtcblx0ICByZXR1cm4gdG9TdHJpbmcuY2FsbChhcnIpID09ICdbb2JqZWN0IEFycmF5XSc7XG5cdH07XG5cblxuLyoqKi8gfSksXG4vKiA4ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblx0LyogV0VCUEFDSyBWQVIgSU5KRUNUSU9OICovKGZ1bmN0aW9uKGdsb2JhbCkgey8qZ2xvYmFsIEJsb2IsRmlsZSovXG5cdFxuXHQvKipcblx0ICogTW9kdWxlIHJlcXVpcmVtZW50c1xuXHQgKi9cblx0XG5cdHZhciBpc0FycmF5ID0gX193ZWJwYWNrX3JlcXVpcmVfXyg3KTtcblx0dmFyIGlzQnVmID0gX193ZWJwYWNrX3JlcXVpcmVfXyg5KTtcblx0dmFyIHRvU3RyaW5nID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZztcblx0dmFyIHdpdGhOYXRpdmVCbG9iID0gdHlwZW9mIGdsb2JhbC5CbG9iID09PSAnZnVuY3Rpb24nIHx8IHRvU3RyaW5nLmNhbGwoZ2xvYmFsLkJsb2IpID09PSAnW29iamVjdCBCbG9iQ29uc3RydWN0b3JdJztcblx0dmFyIHdpdGhOYXRpdmVGaWxlID0gdHlwZW9mIGdsb2JhbC5GaWxlID09PSAnZnVuY3Rpb24nIHx8IHRvU3RyaW5nLmNhbGwoZ2xvYmFsLkZpbGUpID09PSAnW29iamVjdCBGaWxlQ29uc3RydWN0b3JdJztcblx0XG5cdC8qKlxuXHQgKiBSZXBsYWNlcyBldmVyeSBCdWZmZXIgfCBBcnJheUJ1ZmZlciBpbiBwYWNrZXQgd2l0aCBhIG51bWJlcmVkIHBsYWNlaG9sZGVyLlxuXHQgKiBBbnl0aGluZyB3aXRoIGJsb2JzIG9yIGZpbGVzIHNob3VsZCBiZSBmZWQgdGhyb3VnaCByZW1vdmVCbG9icyBiZWZvcmUgY29taW5nXG5cdCAqIGhlcmUuXG5cdCAqXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBwYWNrZXQgLSBzb2NrZXQuaW8gZXZlbnQgcGFja2V0XG5cdCAqIEByZXR1cm4ge09iamVjdH0gd2l0aCBkZWNvbnN0cnVjdGVkIHBhY2tldCBhbmQgbGlzdCBvZiBidWZmZXJzXG5cdCAqIEBhcGkgcHVibGljXG5cdCAqL1xuXHRcblx0ZXhwb3J0cy5kZWNvbnN0cnVjdFBhY2tldCA9IGZ1bmN0aW9uKHBhY2tldCkge1xuXHQgIHZhciBidWZmZXJzID0gW107XG5cdCAgdmFyIHBhY2tldERhdGEgPSBwYWNrZXQuZGF0YTtcblx0ICB2YXIgcGFjayA9IHBhY2tldDtcblx0ICBwYWNrLmRhdGEgPSBfZGVjb25zdHJ1Y3RQYWNrZXQocGFja2V0RGF0YSwgYnVmZmVycyk7XG5cdCAgcGFjay5hdHRhY2htZW50cyA9IGJ1ZmZlcnMubGVuZ3RoOyAvLyBudW1iZXIgb2YgYmluYXJ5ICdhdHRhY2htZW50cydcblx0ICByZXR1cm4ge3BhY2tldDogcGFjaywgYnVmZmVyczogYnVmZmVyc307XG5cdH07XG5cdFxuXHRmdW5jdGlvbiBfZGVjb25zdHJ1Y3RQYWNrZXQoZGF0YSwgYnVmZmVycykge1xuXHQgIGlmICghZGF0YSkgcmV0dXJuIGRhdGE7XG5cdFxuXHQgIGlmIChpc0J1ZihkYXRhKSkge1xuXHQgICAgdmFyIHBsYWNlaG9sZGVyID0geyBfcGxhY2Vob2xkZXI6IHRydWUsIG51bTogYnVmZmVycy5sZW5ndGggfTtcblx0ICAgIGJ1ZmZlcnMucHVzaChkYXRhKTtcblx0ICAgIHJldHVybiBwbGFjZWhvbGRlcjtcblx0ICB9IGVsc2UgaWYgKGlzQXJyYXkoZGF0YSkpIHtcblx0ICAgIHZhciBuZXdEYXRhID0gbmV3IEFycmF5KGRhdGEubGVuZ3RoKTtcblx0ICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZGF0YS5sZW5ndGg7IGkrKykge1xuXHQgICAgICBuZXdEYXRhW2ldID0gX2RlY29uc3RydWN0UGFja2V0KGRhdGFbaV0sIGJ1ZmZlcnMpO1xuXHQgICAgfVxuXHQgICAgcmV0dXJuIG5ld0RhdGE7XG5cdCAgfSBlbHNlIGlmICh0eXBlb2YgZGF0YSA9PT0gJ29iamVjdCcgJiYgIShkYXRhIGluc3RhbmNlb2YgRGF0ZSkpIHtcblx0ICAgIHZhciBuZXdEYXRhID0ge307XG5cdCAgICBmb3IgKHZhciBrZXkgaW4gZGF0YSkge1xuXHQgICAgICBuZXdEYXRhW2tleV0gPSBfZGVjb25zdHJ1Y3RQYWNrZXQoZGF0YVtrZXldLCBidWZmZXJzKTtcblx0ICAgIH1cblx0ICAgIHJldHVybiBuZXdEYXRhO1xuXHQgIH1cblx0ICByZXR1cm4gZGF0YTtcblx0fVxuXHRcblx0LyoqXG5cdCAqIFJlY29uc3RydWN0cyBhIGJpbmFyeSBwYWNrZXQgZnJvbSBpdHMgcGxhY2Vob2xkZXIgcGFja2V0IGFuZCBidWZmZXJzXG5cdCAqXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBwYWNrZXQgLSBldmVudCBwYWNrZXQgd2l0aCBwbGFjZWhvbGRlcnNcblx0ICogQHBhcmFtIHtBcnJheX0gYnVmZmVycyAtIGJpbmFyeSBidWZmZXJzIHRvIHB1dCBpbiBwbGFjZWhvbGRlciBwb3NpdGlvbnNcblx0ICogQHJldHVybiB7T2JqZWN0fSByZWNvbnN0cnVjdGVkIHBhY2tldFxuXHQgKiBAYXBpIHB1YmxpY1xuXHQgKi9cblx0XG5cdGV4cG9ydHMucmVjb25zdHJ1Y3RQYWNrZXQgPSBmdW5jdGlvbihwYWNrZXQsIGJ1ZmZlcnMpIHtcblx0ICBwYWNrZXQuZGF0YSA9IF9yZWNvbnN0cnVjdFBhY2tldChwYWNrZXQuZGF0YSwgYnVmZmVycyk7XG5cdCAgcGFja2V0LmF0dGFjaG1lbnRzID0gdW5kZWZpbmVkOyAvLyBubyBsb25nZXIgdXNlZnVsXG5cdCAgcmV0dXJuIHBhY2tldDtcblx0fTtcblx0XG5cdGZ1bmN0aW9uIF9yZWNvbnN0cnVjdFBhY2tldChkYXRhLCBidWZmZXJzKSB7XG5cdCAgaWYgKCFkYXRhKSByZXR1cm4gZGF0YTtcblx0XG5cdCAgaWYgKGRhdGEgJiYgZGF0YS5fcGxhY2Vob2xkZXIpIHtcblx0ICAgIHJldHVybiBidWZmZXJzW2RhdGEubnVtXTsgLy8gYXBwcm9wcmlhdGUgYnVmZmVyIChzaG91bGQgYmUgbmF0dXJhbCBvcmRlciBhbnl3YXkpXG5cdCAgfSBlbHNlIGlmIChpc0FycmF5KGRhdGEpKSB7XG5cdCAgICBmb3IgKHZhciBpID0gMDsgaSA8IGRhdGEubGVuZ3RoOyBpKyspIHtcblx0ICAgICAgZGF0YVtpXSA9IF9yZWNvbnN0cnVjdFBhY2tldChkYXRhW2ldLCBidWZmZXJzKTtcblx0ICAgIH1cblx0ICB9IGVsc2UgaWYgKHR5cGVvZiBkYXRhID09PSAnb2JqZWN0Jykge1xuXHQgICAgZm9yICh2YXIga2V5IGluIGRhdGEpIHtcblx0ICAgICAgZGF0YVtrZXldID0gX3JlY29uc3RydWN0UGFja2V0KGRhdGFba2V5XSwgYnVmZmVycyk7XG5cdCAgICB9XG5cdCAgfVxuXHRcblx0ICByZXR1cm4gZGF0YTtcblx0fVxuXHRcblx0LyoqXG5cdCAqIEFzeW5jaHJvbm91c2x5IHJlbW92ZXMgQmxvYnMgb3IgRmlsZXMgZnJvbSBkYXRhIHZpYVxuXHQgKiBGaWxlUmVhZGVyJ3MgcmVhZEFzQXJyYXlCdWZmZXIgbWV0aG9kLiBVc2VkIGJlZm9yZSBlbmNvZGluZ1xuXHQgKiBkYXRhIGFzIG1zZ3BhY2suIENhbGxzIGNhbGxiYWNrIHdpdGggdGhlIGJsb2JsZXNzIGRhdGEuXG5cdCAqXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhXG5cdCAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrXG5cdCAqIEBhcGkgcHJpdmF0ZVxuXHQgKi9cblx0XG5cdGV4cG9ydHMucmVtb3ZlQmxvYnMgPSBmdW5jdGlvbihkYXRhLCBjYWxsYmFjaykge1xuXHQgIGZ1bmN0aW9uIF9yZW1vdmVCbG9icyhvYmosIGN1cktleSwgY29udGFpbmluZ09iamVjdCkge1xuXHQgICAgaWYgKCFvYmopIHJldHVybiBvYmo7XG5cdFxuXHQgICAgLy8gY29udmVydCBhbnkgYmxvYlxuXHQgICAgaWYgKCh3aXRoTmF0aXZlQmxvYiAmJiBvYmogaW5zdGFuY2VvZiBCbG9iKSB8fFxuXHQgICAgICAgICh3aXRoTmF0aXZlRmlsZSAmJiBvYmogaW5zdGFuY2VvZiBGaWxlKSkge1xuXHQgICAgICBwZW5kaW5nQmxvYnMrKztcblx0XG5cdCAgICAgIC8vIGFzeW5jIGZpbGVyZWFkZXJcblx0ICAgICAgdmFyIGZpbGVSZWFkZXIgPSBuZXcgRmlsZVJlYWRlcigpO1xuXHQgICAgICBmaWxlUmVhZGVyLm9ubG9hZCA9IGZ1bmN0aW9uKCkgeyAvLyB0aGlzLnJlc3VsdCA9PSBhcnJheWJ1ZmZlclxuXHQgICAgICAgIGlmIChjb250YWluaW5nT2JqZWN0KSB7XG5cdCAgICAgICAgICBjb250YWluaW5nT2JqZWN0W2N1cktleV0gPSB0aGlzLnJlc3VsdDtcblx0ICAgICAgICB9XG5cdCAgICAgICAgZWxzZSB7XG5cdCAgICAgICAgICBibG9ibGVzc0RhdGEgPSB0aGlzLnJlc3VsdDtcblx0ICAgICAgICB9XG5cdFxuXHQgICAgICAgIC8vIGlmIG5vdGhpbmcgcGVuZGluZyBpdHMgY2FsbGJhY2sgdGltZVxuXHQgICAgICAgIGlmKCEgLS1wZW5kaW5nQmxvYnMpIHtcblx0ICAgICAgICAgIGNhbGxiYWNrKGJsb2JsZXNzRGF0YSk7XG5cdCAgICAgICAgfVxuXHQgICAgICB9O1xuXHRcblx0ICAgICAgZmlsZVJlYWRlci5yZWFkQXNBcnJheUJ1ZmZlcihvYmopOyAvLyBibG9iIC0+IGFycmF5YnVmZmVyXG5cdCAgICB9IGVsc2UgaWYgKGlzQXJyYXkob2JqKSkgeyAvLyBoYW5kbGUgYXJyYXlcblx0ICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBvYmoubGVuZ3RoOyBpKyspIHtcblx0ICAgICAgICBfcmVtb3ZlQmxvYnMob2JqW2ldLCBpLCBvYmopO1xuXHQgICAgICB9XG5cdCAgICB9IGVsc2UgaWYgKHR5cGVvZiBvYmogPT09ICdvYmplY3QnICYmICFpc0J1ZihvYmopKSB7IC8vIGFuZCBvYmplY3Rcblx0ICAgICAgZm9yICh2YXIga2V5IGluIG9iaikge1xuXHQgICAgICAgIF9yZW1vdmVCbG9icyhvYmpba2V5XSwga2V5LCBvYmopO1xuXHQgICAgICB9XG5cdCAgICB9XG5cdCAgfVxuXHRcblx0ICB2YXIgcGVuZGluZ0Jsb2JzID0gMDtcblx0ICB2YXIgYmxvYmxlc3NEYXRhID0gZGF0YTtcblx0ICBfcmVtb3ZlQmxvYnMoYmxvYmxlc3NEYXRhKTtcblx0ICBpZiAoIXBlbmRpbmdCbG9icykge1xuXHQgICAgY2FsbGJhY2soYmxvYmxlc3NEYXRhKTtcblx0ICB9XG5cdH07XG5cdFxuXHQvKiBXRUJQQUNLIFZBUiBJTkpFQ1RJT04gKi99LmNhbGwoZXhwb3J0cywgKGZ1bmN0aW9uKCkgeyByZXR1cm4gdGhpczsgfSgpKSkpXG5cbi8qKiovIH0pLFxuLyogOSAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xuXG5cdC8qIFdFQlBBQ0sgVkFSIElOSkVDVElPTiAqLyhmdW5jdGlvbihnbG9iYWwpIHtcblx0bW9kdWxlLmV4cG9ydHMgPSBpc0J1Zjtcblx0XG5cdC8qKlxuXHQgKiBSZXR1cm5zIHRydWUgaWYgb2JqIGlzIGEgYnVmZmVyIG9yIGFuIGFycmF5YnVmZmVyLlxuXHQgKlxuXHQgKiBAYXBpIHByaXZhdGVcblx0ICovXG5cdFxuXHRmdW5jdGlvbiBpc0J1ZihvYmopIHtcblx0ICByZXR1cm4gKGdsb2JhbC5CdWZmZXIgJiYgZ2xvYmFsLkJ1ZmZlci5pc0J1ZmZlcihvYmopKSB8fFxuXHQgICAgICAgICAoZ2xvYmFsLkFycmF5QnVmZmVyICYmIG9iaiBpbnN0YW5jZW9mIEFycmF5QnVmZmVyKTtcblx0fVxuXHRcblx0LyogV0VCUEFDSyBWQVIgSU5KRUNUSU9OICovfS5jYWxsKGV4cG9ydHMsIChmdW5jdGlvbigpIHsgcmV0dXJuIHRoaXM7IH0oKSkpKVxuXG4vKioqLyB9KSxcbi8qIDEwICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblx0J3VzZSBzdHJpY3QnO1xuXHRcblx0dmFyIF90eXBlb2YgPSB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA9PT0gXCJzeW1ib2xcIiA/IGZ1bmN0aW9uIChvYmopIHsgcmV0dXJuIHR5cGVvZiBvYmo7IH0gOiBmdW5jdGlvbiAob2JqKSB7IHJldHVybiBvYmogJiYgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIG9iaiAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2Ygb2JqOyB9O1xuXHRcblx0LyoqXG5cdCAqIE1vZHVsZSBkZXBlbmRlbmNpZXMuXG5cdCAqL1xuXHRcblx0dmFyIGVpbyA9IF9fd2VicGFja19yZXF1aXJlX18oMTEpO1xuXHR2YXIgU29ja2V0ID0gX193ZWJwYWNrX3JlcXVpcmVfXygzNik7XG5cdHZhciBFbWl0dGVyID0gX193ZWJwYWNrX3JlcXVpcmVfXyg1KTtcblx0dmFyIHBhcnNlciA9IF9fd2VicGFja19yZXF1aXJlX18oNCk7XG5cdHZhciBvbiA9IF9fd2VicGFja19yZXF1aXJlX18oMzgpO1xuXHR2YXIgYmluZCA9IF9fd2VicGFja19yZXF1aXJlX18oMzkpO1xuXHR2YXIgZGVidWcgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDMpKCdzb2NrZXQuaW8tY2xpZW50Om1hbmFnZXInKTtcblx0dmFyIGluZGV4T2YgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDM0KTtcblx0dmFyIEJhY2tvZmYgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQwKTtcblx0XG5cdC8qKlxuXHQgKiBJRTYrIGhhc093blByb3BlcnR5XG5cdCAqL1xuXHRcblx0dmFyIGhhcyA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG5cdFxuXHQvKipcblx0ICogTW9kdWxlIGV4cG9ydHNcblx0ICovXG5cdFxuXHRtb2R1bGUuZXhwb3J0cyA9IE1hbmFnZXI7XG5cdFxuXHQvKipcblx0ICogYE1hbmFnZXJgIGNvbnN0cnVjdG9yLlxuXHQgKlxuXHQgKiBAcGFyYW0ge1N0cmluZ30gZW5naW5lIGluc3RhbmNlIG9yIGVuZ2luZSB1cmkvb3B0c1xuXHQgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuXHQgKiBAYXBpIHB1YmxpY1xuXHQgKi9cblx0XG5cdGZ1bmN0aW9uIE1hbmFnZXIodXJpLCBvcHRzKSB7XG5cdCAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIE1hbmFnZXIpKSByZXR1cm4gbmV3IE1hbmFnZXIodXJpLCBvcHRzKTtcblx0ICBpZiAodXJpICYmICdvYmplY3QnID09PSAodHlwZW9mIHVyaSA9PT0gJ3VuZGVmaW5lZCcgPyAndW5kZWZpbmVkJyA6IF90eXBlb2YodXJpKSkpIHtcblx0ICAgIG9wdHMgPSB1cmk7XG5cdCAgICB1cmkgPSB1bmRlZmluZWQ7XG5cdCAgfVxuXHQgIG9wdHMgPSBvcHRzIHx8IHt9O1xuXHRcblx0ICBvcHRzLnBhdGggPSBvcHRzLnBhdGggfHwgJy9zb2NrZXQuaW8nO1xuXHQgIHRoaXMubnNwcyA9IHt9O1xuXHQgIHRoaXMuc3VicyA9IFtdO1xuXHQgIHRoaXMub3B0cyA9IG9wdHM7XG5cdCAgdGhpcy5yZWNvbm5lY3Rpb24ob3B0cy5yZWNvbm5lY3Rpb24gIT09IGZhbHNlKTtcblx0ICB0aGlzLnJlY29ubmVjdGlvbkF0dGVtcHRzKG9wdHMucmVjb25uZWN0aW9uQXR0ZW1wdHMgfHwgSW5maW5pdHkpO1xuXHQgIHRoaXMucmVjb25uZWN0aW9uRGVsYXkob3B0cy5yZWNvbm5lY3Rpb25EZWxheSB8fCAxMDAwKTtcblx0ICB0aGlzLnJlY29ubmVjdGlvbkRlbGF5TWF4KG9wdHMucmVjb25uZWN0aW9uRGVsYXlNYXggfHwgNTAwMCk7XG5cdCAgdGhpcy5yYW5kb21pemF0aW9uRmFjdG9yKG9wdHMucmFuZG9taXphdGlvbkZhY3RvciB8fCAwLjUpO1xuXHQgIHRoaXMuYmFja29mZiA9IG5ldyBCYWNrb2ZmKHtcblx0ICAgIG1pbjogdGhpcy5yZWNvbm5lY3Rpb25EZWxheSgpLFxuXHQgICAgbWF4OiB0aGlzLnJlY29ubmVjdGlvbkRlbGF5TWF4KCksXG5cdCAgICBqaXR0ZXI6IHRoaXMucmFuZG9taXphdGlvbkZhY3RvcigpXG5cdCAgfSk7XG5cdCAgdGhpcy50aW1lb3V0KG51bGwgPT0gb3B0cy50aW1lb3V0ID8gMjAwMDAgOiBvcHRzLnRpbWVvdXQpO1xuXHQgIHRoaXMucmVhZHlTdGF0ZSA9ICdjbG9zZWQnO1xuXHQgIHRoaXMudXJpID0gdXJpO1xuXHQgIHRoaXMuY29ubmVjdGluZyA9IFtdO1xuXHQgIHRoaXMubGFzdFBpbmcgPSBudWxsO1xuXHQgIHRoaXMuZW5jb2RpbmcgPSBmYWxzZTtcblx0ICB0aGlzLnBhY2tldEJ1ZmZlciA9IFtdO1xuXHQgIHZhciBfcGFyc2VyID0gb3B0cy5wYXJzZXIgfHwgcGFyc2VyO1xuXHQgIHRoaXMuZW5jb2RlciA9IG5ldyBfcGFyc2VyLkVuY29kZXIoKTtcblx0ICB0aGlzLmRlY29kZXIgPSBuZXcgX3BhcnNlci5EZWNvZGVyKCk7XG5cdCAgdGhpcy5hdXRvQ29ubmVjdCA9IG9wdHMuYXV0b0Nvbm5lY3QgIT09IGZhbHNlO1xuXHQgIGlmICh0aGlzLmF1dG9Db25uZWN0KSB0aGlzLm9wZW4oKTtcblx0fVxuXHRcblx0LyoqXG5cdCAqIFByb3BhZ2F0ZSBnaXZlbiBldmVudCB0byBzb2NrZXRzIGFuZCBlbWl0IG9uIGB0aGlzYFxuXHQgKlxuXHQgKiBAYXBpIHByaXZhdGVcblx0ICovXG5cdFxuXHRNYW5hZ2VyLnByb3RvdHlwZS5lbWl0QWxsID0gZnVuY3Rpb24gKCkge1xuXHQgIHRoaXMuZW1pdC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuXHQgIGZvciAodmFyIG5zcCBpbiB0aGlzLm5zcHMpIHtcblx0ICAgIGlmIChoYXMuY2FsbCh0aGlzLm5zcHMsIG5zcCkpIHtcblx0ICAgICAgdGhpcy5uc3BzW25zcF0uZW1pdC5hcHBseSh0aGlzLm5zcHNbbnNwXSwgYXJndW1lbnRzKTtcblx0ICAgIH1cblx0ICB9XG5cdH07XG5cdFxuXHQvKipcblx0ICogVXBkYXRlIGBzb2NrZXQuaWRgIG9mIGFsbCBzb2NrZXRzXG5cdCAqXG5cdCAqIEBhcGkgcHJpdmF0ZVxuXHQgKi9cblx0XG5cdE1hbmFnZXIucHJvdG90eXBlLnVwZGF0ZVNvY2tldElkcyA9IGZ1bmN0aW9uICgpIHtcblx0ICBmb3IgKHZhciBuc3AgaW4gdGhpcy5uc3BzKSB7XG5cdCAgICBpZiAoaGFzLmNhbGwodGhpcy5uc3BzLCBuc3ApKSB7XG5cdCAgICAgIHRoaXMubnNwc1tuc3BdLmlkID0gdGhpcy5nZW5lcmF0ZUlkKG5zcCk7XG5cdCAgICB9XG5cdCAgfVxuXHR9O1xuXHRcblx0LyoqXG5cdCAqIGdlbmVyYXRlIGBzb2NrZXQuaWRgIGZvciB0aGUgZ2l2ZW4gYG5zcGBcblx0ICpcblx0ICogQHBhcmFtIHtTdHJpbmd9IG5zcFxuXHQgKiBAcmV0dXJuIHtTdHJpbmd9XG5cdCAqIEBhcGkgcHJpdmF0ZVxuXHQgKi9cblx0XG5cdE1hbmFnZXIucHJvdG90eXBlLmdlbmVyYXRlSWQgPSBmdW5jdGlvbiAobnNwKSB7XG5cdCAgcmV0dXJuIChuc3AgPT09ICcvJyA/ICcnIDogbnNwICsgJyMnKSArIHRoaXMuZW5naW5lLmlkO1xuXHR9O1xuXHRcblx0LyoqXG5cdCAqIE1peCBpbiBgRW1pdHRlcmAuXG5cdCAqL1xuXHRcblx0RW1pdHRlcihNYW5hZ2VyLnByb3RvdHlwZSk7XG5cdFxuXHQvKipcblx0ICogU2V0cyB0aGUgYHJlY29ubmVjdGlvbmAgY29uZmlnLlxuXHQgKlxuXHQgKiBAcGFyYW0ge0Jvb2xlYW59IHRydWUvZmFsc2UgaWYgaXQgc2hvdWxkIGF1dG9tYXRpY2FsbHkgcmVjb25uZWN0XG5cdCAqIEByZXR1cm4ge01hbmFnZXJ9IHNlbGYgb3IgdmFsdWVcblx0ICogQGFwaSBwdWJsaWNcblx0ICovXG5cdFxuXHRNYW5hZ2VyLnByb3RvdHlwZS5yZWNvbm5lY3Rpb24gPSBmdW5jdGlvbiAodikge1xuXHQgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIHRoaXMuX3JlY29ubmVjdGlvbjtcblx0ICB0aGlzLl9yZWNvbm5lY3Rpb24gPSAhIXY7XG5cdCAgcmV0dXJuIHRoaXM7XG5cdH07XG5cdFxuXHQvKipcblx0ICogU2V0cyB0aGUgcmVjb25uZWN0aW9uIGF0dGVtcHRzIGNvbmZpZy5cblx0ICpcblx0ICogQHBhcmFtIHtOdW1iZXJ9IG1heCByZWNvbm5lY3Rpb24gYXR0ZW1wdHMgYmVmb3JlIGdpdmluZyB1cFxuXHQgKiBAcmV0dXJuIHtNYW5hZ2VyfSBzZWxmIG9yIHZhbHVlXG5cdCAqIEBhcGkgcHVibGljXG5cdCAqL1xuXHRcblx0TWFuYWdlci5wcm90b3R5cGUucmVjb25uZWN0aW9uQXR0ZW1wdHMgPSBmdW5jdGlvbiAodikge1xuXHQgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIHRoaXMuX3JlY29ubmVjdGlvbkF0dGVtcHRzO1xuXHQgIHRoaXMuX3JlY29ubmVjdGlvbkF0dGVtcHRzID0gdjtcblx0ICByZXR1cm4gdGhpcztcblx0fTtcblx0XG5cdC8qKlxuXHQgKiBTZXRzIHRoZSBkZWxheSBiZXR3ZWVuIHJlY29ubmVjdGlvbnMuXG5cdCAqXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBkZWxheVxuXHQgKiBAcmV0dXJuIHtNYW5hZ2VyfSBzZWxmIG9yIHZhbHVlXG5cdCAqIEBhcGkgcHVibGljXG5cdCAqL1xuXHRcblx0TWFuYWdlci5wcm90b3R5cGUucmVjb25uZWN0aW9uRGVsYXkgPSBmdW5jdGlvbiAodikge1xuXHQgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIHRoaXMuX3JlY29ubmVjdGlvbkRlbGF5O1xuXHQgIHRoaXMuX3JlY29ubmVjdGlvbkRlbGF5ID0gdjtcblx0ICB0aGlzLmJhY2tvZmYgJiYgdGhpcy5iYWNrb2ZmLnNldE1pbih2KTtcblx0ICByZXR1cm4gdGhpcztcblx0fTtcblx0XG5cdE1hbmFnZXIucHJvdG90eXBlLnJhbmRvbWl6YXRpb25GYWN0b3IgPSBmdW5jdGlvbiAodikge1xuXHQgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIHRoaXMuX3JhbmRvbWl6YXRpb25GYWN0b3I7XG5cdCAgdGhpcy5fcmFuZG9taXphdGlvbkZhY3RvciA9IHY7XG5cdCAgdGhpcy5iYWNrb2ZmICYmIHRoaXMuYmFja29mZi5zZXRKaXR0ZXIodik7XG5cdCAgcmV0dXJuIHRoaXM7XG5cdH07XG5cdFxuXHQvKipcblx0ICogU2V0cyB0aGUgbWF4aW11bSBkZWxheSBiZXR3ZWVuIHJlY29ubmVjdGlvbnMuXG5cdCAqXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBkZWxheVxuXHQgKiBAcmV0dXJuIHtNYW5hZ2VyfSBzZWxmIG9yIHZhbHVlXG5cdCAqIEBhcGkgcHVibGljXG5cdCAqL1xuXHRcblx0TWFuYWdlci5wcm90b3R5cGUucmVjb25uZWN0aW9uRGVsYXlNYXggPSBmdW5jdGlvbiAodikge1xuXHQgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIHRoaXMuX3JlY29ubmVjdGlvbkRlbGF5TWF4O1xuXHQgIHRoaXMuX3JlY29ubmVjdGlvbkRlbGF5TWF4ID0gdjtcblx0ICB0aGlzLmJhY2tvZmYgJiYgdGhpcy5iYWNrb2ZmLnNldE1heCh2KTtcblx0ICByZXR1cm4gdGhpcztcblx0fTtcblx0XG5cdC8qKlxuXHQgKiBTZXRzIHRoZSBjb25uZWN0aW9uIHRpbWVvdXQuIGBmYWxzZWAgdG8gZGlzYWJsZVxuXHQgKlxuXHQgKiBAcmV0dXJuIHtNYW5hZ2VyfSBzZWxmIG9yIHZhbHVlXG5cdCAqIEBhcGkgcHVibGljXG5cdCAqL1xuXHRcblx0TWFuYWdlci5wcm90b3R5cGUudGltZW91dCA9IGZ1bmN0aW9uICh2KSB7XG5cdCAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gdGhpcy5fdGltZW91dDtcblx0ICB0aGlzLl90aW1lb3V0ID0gdjtcblx0ICByZXR1cm4gdGhpcztcblx0fTtcblx0XG5cdC8qKlxuXHQgKiBTdGFydHMgdHJ5aW5nIHRvIHJlY29ubmVjdCBpZiByZWNvbm5lY3Rpb24gaXMgZW5hYmxlZCBhbmQgd2UgaGF2ZSBub3Rcblx0ICogc3RhcnRlZCByZWNvbm5lY3RpbmcgeWV0XG5cdCAqXG5cdCAqIEBhcGkgcHJpdmF0ZVxuXHQgKi9cblx0XG5cdE1hbmFnZXIucHJvdG90eXBlLm1heWJlUmVjb25uZWN0T25PcGVuID0gZnVuY3Rpb24gKCkge1xuXHQgIC8vIE9ubHkgdHJ5IHRvIHJlY29ubmVjdCBpZiBpdCdzIHRoZSBmaXJzdCB0aW1lIHdlJ3JlIGNvbm5lY3Rpbmdcblx0ICBpZiAoIXRoaXMucmVjb25uZWN0aW5nICYmIHRoaXMuX3JlY29ubmVjdGlvbiAmJiB0aGlzLmJhY2tvZmYuYXR0ZW1wdHMgPT09IDApIHtcblx0ICAgIC8vIGtlZXBzIHJlY29ubmVjdGlvbiBmcm9tIGZpcmluZyB0d2ljZSBmb3IgdGhlIHNhbWUgcmVjb25uZWN0aW9uIGxvb3Bcblx0ICAgIHRoaXMucmVjb25uZWN0KCk7XG5cdCAgfVxuXHR9O1xuXHRcblx0LyoqXG5cdCAqIFNldHMgdGhlIGN1cnJlbnQgdHJhbnNwb3J0IGBzb2NrZXRgLlxuXHQgKlxuXHQgKiBAcGFyYW0ge0Z1bmN0aW9ufSBvcHRpb25hbCwgY2FsbGJhY2tcblx0ICogQHJldHVybiB7TWFuYWdlcn0gc2VsZlxuXHQgKiBAYXBpIHB1YmxpY1xuXHQgKi9cblx0XG5cdE1hbmFnZXIucHJvdG90eXBlLm9wZW4gPSBNYW5hZ2VyLnByb3RvdHlwZS5jb25uZWN0ID0gZnVuY3Rpb24gKGZuLCBvcHRzKSB7XG5cdFxuXHQgIGlmICh+dGhpcy5yZWFkeVN0YXRlLmluZGV4T2YoJ29wZW4nKSkgcmV0dXJuIHRoaXM7XG5cdFxuXHQgIHRoaXMuZW5naW5lID0gZWlvKHRoaXMudXJpLCB0aGlzLm9wdHMpO1xuXHQgIHZhciBzb2NrZXQgPSB0aGlzLmVuZ2luZTtcblx0ICB2YXIgc2VsZiA9IHRoaXM7XG5cdCAgdGhpcy5yZWFkeVN0YXRlID0gJ29wZW5pbmcnO1xuXHQgIHRoaXMuc2tpcFJlY29ubmVjdCA9IGZhbHNlO1xuXHRcblx0ICAvLyBlbWl0IGBvcGVuYFxuXHQgIHZhciBvcGVuU3ViID0gb24oc29ja2V0LCAnb3BlbicsIGZ1bmN0aW9uICgpIHtcblx0ICAgIHNlbGYub25vcGVuKCk7XG5cdCAgICBmbiAmJiBmbigpO1xuXHQgIH0pO1xuXHRcblx0ICAvLyBlbWl0IGBjb25uZWN0X2Vycm9yYFxuXHQgIHZhciBlcnJvclN1YiA9IG9uKHNvY2tldCwgJ2Vycm9yJywgZnVuY3Rpb24gKGRhdGEpIHtcblx0XG5cdCAgICBzZWxmLmNsZWFudXAoKTtcblx0ICAgIHNlbGYucmVhZHlTdGF0ZSA9ICdjbG9zZWQnO1xuXHQgICAgc2VsZi5lbWl0QWxsKCdjb25uZWN0X2Vycm9yJywgZGF0YSk7XG5cdCAgICBpZiAoZm4pIHtcblx0ICAgICAgdmFyIGVyciA9IG5ldyBFcnJvcignQ29ubmVjdGlvbiBlcnJvcicpO1xuXHQgICAgICBlcnIuZGF0YSA9IGRhdGE7XG5cdCAgICAgIGZuKGVycik7XG5cdCAgICB9IGVsc2Uge1xuXHQgICAgICAvLyBPbmx5IGRvIHRoaXMgaWYgdGhlcmUgaXMgbm8gZm4gdG8gaGFuZGxlIHRoZSBlcnJvclxuXHQgICAgICBzZWxmLm1heWJlUmVjb25uZWN0T25PcGVuKCk7XG5cdCAgICB9XG5cdCAgfSk7XG5cdFxuXHQgIC8vIGVtaXQgYGNvbm5lY3RfdGltZW91dGBcblx0ICBpZiAoZmFsc2UgIT09IHRoaXMuX3RpbWVvdXQpIHtcblx0ICAgIHZhciB0aW1lb3V0ID0gdGhpcy5fdGltZW91dDtcblx0XG5cdCAgICAvLyBzZXQgdGltZXJcblx0ICAgIHZhciB0aW1lciA9IHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuXHRcblx0ICAgICAgb3BlblN1Yi5kZXN0cm95KCk7XG5cdCAgICAgIHNvY2tldC5jbG9zZSgpO1xuXHQgICAgICBzb2NrZXQuZW1pdCgnZXJyb3InLCAndGltZW91dCcpO1xuXHQgICAgICBzZWxmLmVtaXRBbGwoJ2Nvbm5lY3RfdGltZW91dCcsIHRpbWVvdXQpO1xuXHQgICAgfSwgdGltZW91dCk7XG5cdFxuXHQgICAgdGhpcy5zdWJzLnB1c2goe1xuXHQgICAgICBkZXN0cm95OiBmdW5jdGlvbiBkZXN0cm95KCkge1xuXHQgICAgICAgIGNsZWFyVGltZW91dCh0aW1lcik7XG5cdCAgICAgIH1cblx0ICAgIH0pO1xuXHQgIH1cblx0XG5cdCAgdGhpcy5zdWJzLnB1c2gob3BlblN1Yik7XG5cdCAgdGhpcy5zdWJzLnB1c2goZXJyb3JTdWIpO1xuXHRcblx0ICByZXR1cm4gdGhpcztcblx0fTtcblx0XG5cdC8qKlxuXHQgKiBDYWxsZWQgdXBvbiB0cmFuc3BvcnQgb3Blbi5cblx0ICpcblx0ICogQGFwaSBwcml2YXRlXG5cdCAqL1xuXHRcblx0TWFuYWdlci5wcm90b3R5cGUub25vcGVuID0gZnVuY3Rpb24gKCkge1xuXHRcblx0ICAvLyBjbGVhciBvbGQgc3Vic1xuXHQgIHRoaXMuY2xlYW51cCgpO1xuXHRcblx0ICAvLyBtYXJrIGFzIG9wZW5cblx0ICB0aGlzLnJlYWR5U3RhdGUgPSAnb3Blbic7XG5cdCAgdGhpcy5lbWl0KCdvcGVuJyk7XG5cdFxuXHQgIC8vIGFkZCBuZXcgc3Vic1xuXHQgIHZhciBzb2NrZXQgPSB0aGlzLmVuZ2luZTtcblx0ICB0aGlzLnN1YnMucHVzaChvbihzb2NrZXQsICdkYXRhJywgYmluZCh0aGlzLCAnb25kYXRhJykpKTtcblx0ICB0aGlzLnN1YnMucHVzaChvbihzb2NrZXQsICdwaW5nJywgYmluZCh0aGlzLCAnb25waW5nJykpKTtcblx0ICB0aGlzLnN1YnMucHVzaChvbihzb2NrZXQsICdwb25nJywgYmluZCh0aGlzLCAnb25wb25nJykpKTtcblx0ICB0aGlzLnN1YnMucHVzaChvbihzb2NrZXQsICdlcnJvcicsIGJpbmQodGhpcywgJ29uZXJyb3InKSkpO1xuXHQgIHRoaXMuc3Vicy5wdXNoKG9uKHNvY2tldCwgJ2Nsb3NlJywgYmluZCh0aGlzLCAnb25jbG9zZScpKSk7XG5cdCAgdGhpcy5zdWJzLnB1c2gob24odGhpcy5kZWNvZGVyLCAnZGVjb2RlZCcsIGJpbmQodGhpcywgJ29uZGVjb2RlZCcpKSk7XG5cdH07XG5cdFxuXHQvKipcblx0ICogQ2FsbGVkIHVwb24gYSBwaW5nLlxuXHQgKlxuXHQgKiBAYXBpIHByaXZhdGVcblx0ICovXG5cdFxuXHRNYW5hZ2VyLnByb3RvdHlwZS5vbnBpbmcgPSBmdW5jdGlvbiAoKSB7XG5cdCAgdGhpcy5sYXN0UGluZyA9IG5ldyBEYXRlKCk7XG5cdCAgdGhpcy5lbWl0QWxsKCdwaW5nJyk7XG5cdH07XG5cdFxuXHQvKipcblx0ICogQ2FsbGVkIHVwb24gYSBwYWNrZXQuXG5cdCAqXG5cdCAqIEBhcGkgcHJpdmF0ZVxuXHQgKi9cblx0XG5cdE1hbmFnZXIucHJvdG90eXBlLm9ucG9uZyA9IGZ1bmN0aW9uICgpIHtcblx0ICB0aGlzLmVtaXRBbGwoJ3BvbmcnLCBuZXcgRGF0ZSgpIC0gdGhpcy5sYXN0UGluZyk7XG5cdH07XG5cdFxuXHQvKipcblx0ICogQ2FsbGVkIHdpdGggZGF0YS5cblx0ICpcblx0ICogQGFwaSBwcml2YXRlXG5cdCAqL1xuXHRcblx0TWFuYWdlci5wcm90b3R5cGUub25kYXRhID0gZnVuY3Rpb24gKGRhdGEpIHtcblx0ICB0aGlzLmRlY29kZXIuYWRkKGRhdGEpO1xuXHR9O1xuXHRcblx0LyoqXG5cdCAqIENhbGxlZCB3aGVuIHBhcnNlciBmdWxseSBkZWNvZGVzIGEgcGFja2V0LlxuXHQgKlxuXHQgKiBAYXBpIHByaXZhdGVcblx0ICovXG5cdFxuXHRNYW5hZ2VyLnByb3RvdHlwZS5vbmRlY29kZWQgPSBmdW5jdGlvbiAocGFja2V0KSB7XG5cdCAgdGhpcy5lbWl0KCdwYWNrZXQnLCBwYWNrZXQpO1xuXHR9O1xuXHRcblx0LyoqXG5cdCAqIENhbGxlZCB1cG9uIHNvY2tldCBlcnJvci5cblx0ICpcblx0ICogQGFwaSBwcml2YXRlXG5cdCAqL1xuXHRcblx0TWFuYWdlci5wcm90b3R5cGUub25lcnJvciA9IGZ1bmN0aW9uIChlcnIpIHtcblx0XG5cdCAgdGhpcy5lbWl0QWxsKCdlcnJvcicsIGVycik7XG5cdH07XG5cdFxuXHQvKipcblx0ICogQ3JlYXRlcyBhIG5ldyBzb2NrZXQgZm9yIHRoZSBnaXZlbiBgbnNwYC5cblx0ICpcblx0ICogQHJldHVybiB7U29ja2V0fVxuXHQgKiBAYXBpIHB1YmxpY1xuXHQgKi9cblx0XG5cdE1hbmFnZXIucHJvdG90eXBlLnNvY2tldCA9IGZ1bmN0aW9uIChuc3AsIG9wdHMpIHtcblx0ICB2YXIgc29ja2V0ID0gdGhpcy5uc3BzW25zcF07XG5cdCAgaWYgKCFzb2NrZXQpIHtcblx0ICAgIHNvY2tldCA9IG5ldyBTb2NrZXQodGhpcywgbnNwLCBvcHRzKTtcblx0ICAgIHRoaXMubnNwc1tuc3BdID0gc29ja2V0O1xuXHQgICAgdmFyIHNlbGYgPSB0aGlzO1xuXHQgICAgc29ja2V0Lm9uKCdjb25uZWN0aW5nJywgb25Db25uZWN0aW5nKTtcblx0ICAgIHNvY2tldC5vbignY29ubmVjdCcsIGZ1bmN0aW9uICgpIHtcblx0ICAgICAgc29ja2V0LmlkID0gc2VsZi5nZW5lcmF0ZUlkKG5zcCk7XG5cdCAgICB9KTtcblx0XG5cdCAgICBpZiAodGhpcy5hdXRvQ29ubmVjdCkge1xuXHQgICAgICAvLyBtYW51YWxseSBjYWxsIGhlcmUgc2luY2UgY29ubmVjdGluZyBldmVudCBpcyBmaXJlZCBiZWZvcmUgbGlzdGVuaW5nXG5cdCAgICAgIG9uQ29ubmVjdGluZygpO1xuXHQgICAgfVxuXHQgIH1cblx0XG5cdCAgZnVuY3Rpb24gb25Db25uZWN0aW5nKCkge1xuXHQgICAgaWYgKCF+aW5kZXhPZihzZWxmLmNvbm5lY3RpbmcsIHNvY2tldCkpIHtcblx0ICAgICAgc2VsZi5jb25uZWN0aW5nLnB1c2goc29ja2V0KTtcblx0ICAgIH1cblx0ICB9XG5cdFxuXHQgIHJldHVybiBzb2NrZXQ7XG5cdH07XG5cdFxuXHQvKipcblx0ICogQ2FsbGVkIHVwb24gYSBzb2NrZXQgY2xvc2UuXG5cdCAqXG5cdCAqIEBwYXJhbSB7U29ja2V0fSBzb2NrZXRcblx0ICovXG5cdFxuXHRNYW5hZ2VyLnByb3RvdHlwZS5kZXN0cm95ID0gZnVuY3Rpb24gKHNvY2tldCkge1xuXHQgIHZhciBpbmRleCA9IGluZGV4T2YodGhpcy5jb25uZWN0aW5nLCBzb2NrZXQpO1xuXHQgIGlmICh+aW5kZXgpIHRoaXMuY29ubmVjdGluZy5zcGxpY2UoaW5kZXgsIDEpO1xuXHQgIGlmICh0aGlzLmNvbm5lY3RpbmcubGVuZ3RoKSByZXR1cm47XG5cdFxuXHQgIHRoaXMuY2xvc2UoKTtcblx0fTtcblx0XG5cdC8qKlxuXHQgKiBXcml0ZXMgYSBwYWNrZXQuXG5cdCAqXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBwYWNrZXRcblx0ICogQGFwaSBwcml2YXRlXG5cdCAqL1xuXHRcblx0TWFuYWdlci5wcm90b3R5cGUucGFja2V0ID0gZnVuY3Rpb24gKHBhY2tldCkge1xuXHRcblx0ICB2YXIgc2VsZiA9IHRoaXM7XG5cdCAgaWYgKHBhY2tldC5xdWVyeSAmJiBwYWNrZXQudHlwZSA9PT0gMCkgcGFja2V0Lm5zcCArPSAnPycgKyBwYWNrZXQucXVlcnk7XG5cdFxuXHQgIGlmICghc2VsZi5lbmNvZGluZykge1xuXHQgICAgLy8gZW5jb2RlLCB0aGVuIHdyaXRlIHRvIGVuZ2luZSB3aXRoIHJlc3VsdFxuXHQgICAgc2VsZi5lbmNvZGluZyA9IHRydWU7XG5cdCAgICB0aGlzLmVuY29kZXIuZW5jb2RlKHBhY2tldCwgZnVuY3Rpb24gKGVuY29kZWRQYWNrZXRzKSB7XG5cdCAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZW5jb2RlZFBhY2tldHMubGVuZ3RoOyBpKyspIHtcblx0ICAgICAgICBzZWxmLmVuZ2luZS53cml0ZShlbmNvZGVkUGFja2V0c1tpXSwgcGFja2V0Lm9wdGlvbnMpO1xuXHQgICAgICB9XG5cdCAgICAgIHNlbGYuZW5jb2RpbmcgPSBmYWxzZTtcblx0ICAgICAgc2VsZi5wcm9jZXNzUGFja2V0UXVldWUoKTtcblx0ICAgIH0pO1xuXHQgIH0gZWxzZSB7XG5cdCAgICAvLyBhZGQgcGFja2V0IHRvIHRoZSBxdWV1ZVxuXHQgICAgc2VsZi5wYWNrZXRCdWZmZXIucHVzaChwYWNrZXQpO1xuXHQgIH1cblx0fTtcblx0XG5cdC8qKlxuXHQgKiBJZiBwYWNrZXQgYnVmZmVyIGlzIG5vbi1lbXB0eSwgYmVnaW5zIGVuY29kaW5nIHRoZVxuXHQgKiBuZXh0IHBhY2tldCBpbiBsaW5lLlxuXHQgKlxuXHQgKiBAYXBpIHByaXZhdGVcblx0ICovXG5cdFxuXHRNYW5hZ2VyLnByb3RvdHlwZS5wcm9jZXNzUGFja2V0UXVldWUgPSBmdW5jdGlvbiAoKSB7XG5cdCAgaWYgKHRoaXMucGFja2V0QnVmZmVyLmxlbmd0aCA+IDAgJiYgIXRoaXMuZW5jb2RpbmcpIHtcblx0ICAgIHZhciBwYWNrID0gdGhpcy5wYWNrZXRCdWZmZXIuc2hpZnQoKTtcblx0ICAgIHRoaXMucGFja2V0KHBhY2spO1xuXHQgIH1cblx0fTtcblx0XG5cdC8qKlxuXHQgKiBDbGVhbiB1cCB0cmFuc3BvcnQgc3Vic2NyaXB0aW9ucyBhbmQgcGFja2V0IGJ1ZmZlci5cblx0ICpcblx0ICogQGFwaSBwcml2YXRlXG5cdCAqL1xuXHRcblx0TWFuYWdlci5wcm90b3R5cGUuY2xlYW51cCA9IGZ1bmN0aW9uICgpIHtcblx0XG5cdCAgdmFyIHN1YnNMZW5ndGggPSB0aGlzLnN1YnMubGVuZ3RoO1xuXHQgIGZvciAodmFyIGkgPSAwOyBpIDwgc3Vic0xlbmd0aDsgaSsrKSB7XG5cdCAgICB2YXIgc3ViID0gdGhpcy5zdWJzLnNoaWZ0KCk7XG5cdCAgICBzdWIuZGVzdHJveSgpO1xuXHQgIH1cblx0XG5cdCAgdGhpcy5wYWNrZXRCdWZmZXIgPSBbXTtcblx0ICB0aGlzLmVuY29kaW5nID0gZmFsc2U7XG5cdCAgdGhpcy5sYXN0UGluZyA9IG51bGw7XG5cdFxuXHQgIHRoaXMuZGVjb2Rlci5kZXN0cm95KCk7XG5cdH07XG5cdFxuXHQvKipcblx0ICogQ2xvc2UgdGhlIGN1cnJlbnQgc29ja2V0LlxuXHQgKlxuXHQgKiBAYXBpIHByaXZhdGVcblx0ICovXG5cdFxuXHRNYW5hZ2VyLnByb3RvdHlwZS5jbG9zZSA9IE1hbmFnZXIucHJvdG90eXBlLmRpc2Nvbm5lY3QgPSBmdW5jdGlvbiAoKSB7XG5cdFxuXHQgIHRoaXMuc2tpcFJlY29ubmVjdCA9IHRydWU7XG5cdCAgdGhpcy5yZWNvbm5lY3RpbmcgPSBmYWxzZTtcblx0ICBpZiAoJ29wZW5pbmcnID09PSB0aGlzLnJlYWR5U3RhdGUpIHtcblx0ICAgIC8vIGBvbmNsb3NlYCB3aWxsIG5vdCBmaXJlIGJlY2F1c2Vcblx0ICAgIC8vIGFuIG9wZW4gZXZlbnQgbmV2ZXIgaGFwcGVuZWRcblx0ICAgIHRoaXMuY2xlYW51cCgpO1xuXHQgIH1cblx0ICB0aGlzLmJhY2tvZmYucmVzZXQoKTtcblx0ICB0aGlzLnJlYWR5U3RhdGUgPSAnY2xvc2VkJztcblx0ICBpZiAodGhpcy5lbmdpbmUpIHRoaXMuZW5naW5lLmNsb3NlKCk7XG5cdH07XG5cdFxuXHQvKipcblx0ICogQ2FsbGVkIHVwb24gZW5naW5lIGNsb3NlLlxuXHQgKlxuXHQgKiBAYXBpIHByaXZhdGVcblx0ICovXG5cdFxuXHRNYW5hZ2VyLnByb3RvdHlwZS5vbmNsb3NlID0gZnVuY3Rpb24gKHJlYXNvbikge1xuXHRcblx0ICB0aGlzLmNsZWFudXAoKTtcblx0ICB0aGlzLmJhY2tvZmYucmVzZXQoKTtcblx0ICB0aGlzLnJlYWR5U3RhdGUgPSAnY2xvc2VkJztcblx0ICB0aGlzLmVtaXQoJ2Nsb3NlJywgcmVhc29uKTtcblx0XG5cdCAgaWYgKHRoaXMuX3JlY29ubmVjdGlvbiAmJiAhdGhpcy5za2lwUmVjb25uZWN0KSB7XG5cdCAgICB0aGlzLnJlY29ubmVjdCgpO1xuXHQgIH1cblx0fTtcblx0XG5cdC8qKlxuXHQgKiBBdHRlbXB0IGEgcmVjb25uZWN0aW9uLlxuXHQgKlxuXHQgKiBAYXBpIHByaXZhdGVcblx0ICovXG5cdFxuXHRNYW5hZ2VyLnByb3RvdHlwZS5yZWNvbm5lY3QgPSBmdW5jdGlvbiAoKSB7XG5cdCAgaWYgKHRoaXMucmVjb25uZWN0aW5nIHx8IHRoaXMuc2tpcFJlY29ubmVjdCkgcmV0dXJuIHRoaXM7XG5cdFxuXHQgIHZhciBzZWxmID0gdGhpcztcblx0XG5cdCAgaWYgKHRoaXMuYmFja29mZi5hdHRlbXB0cyA+PSB0aGlzLl9yZWNvbm5lY3Rpb25BdHRlbXB0cykge1xuXHRcblx0ICAgIHRoaXMuYmFja29mZi5yZXNldCgpO1xuXHQgICAgdGhpcy5lbWl0QWxsKCdyZWNvbm5lY3RfZmFpbGVkJyk7XG5cdCAgICB0aGlzLnJlY29ubmVjdGluZyA9IGZhbHNlO1xuXHQgIH0gZWxzZSB7XG5cdCAgICB2YXIgZGVsYXkgPSB0aGlzLmJhY2tvZmYuZHVyYXRpb24oKTtcblx0XG5cdCAgICB0aGlzLnJlY29ubmVjdGluZyA9IHRydWU7XG5cdCAgICB2YXIgdGltZXIgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcblx0ICAgICAgaWYgKHNlbGYuc2tpcFJlY29ubmVjdCkgcmV0dXJuO1xuXHRcblx0ICAgICAgc2VsZi5lbWl0QWxsKCdyZWNvbm5lY3RfYXR0ZW1wdCcsIHNlbGYuYmFja29mZi5hdHRlbXB0cyk7XG5cdCAgICAgIHNlbGYuZW1pdEFsbCgncmVjb25uZWN0aW5nJywgc2VsZi5iYWNrb2ZmLmF0dGVtcHRzKTtcblx0XG5cdCAgICAgIC8vIGNoZWNrIGFnYWluIGZvciB0aGUgY2FzZSBzb2NrZXQgY2xvc2VkIGluIGFib3ZlIGV2ZW50c1xuXHQgICAgICBpZiAoc2VsZi5za2lwUmVjb25uZWN0KSByZXR1cm47XG5cdFxuXHQgICAgICBzZWxmLm9wZW4oZnVuY3Rpb24gKGVycikge1xuXHQgICAgICAgIGlmIChlcnIpIHtcblx0XG5cdCAgICAgICAgICBzZWxmLnJlY29ubmVjdGluZyA9IGZhbHNlO1xuXHQgICAgICAgICAgc2VsZi5yZWNvbm5lY3QoKTtcblx0ICAgICAgICAgIHNlbGYuZW1pdEFsbCgncmVjb25uZWN0X2Vycm9yJywgZXJyLmRhdGEpO1xuXHQgICAgICAgIH0gZWxzZSB7XG5cdFxuXHQgICAgICAgICAgc2VsZi5vbnJlY29ubmVjdCgpO1xuXHQgICAgICAgIH1cblx0ICAgICAgfSk7XG5cdCAgICB9LCBkZWxheSk7XG5cdFxuXHQgICAgdGhpcy5zdWJzLnB1c2goe1xuXHQgICAgICBkZXN0cm95OiBmdW5jdGlvbiBkZXN0cm95KCkge1xuXHQgICAgICAgIGNsZWFyVGltZW91dCh0aW1lcik7XG5cdCAgICAgIH1cblx0ICAgIH0pO1xuXHQgIH1cblx0fTtcblx0XG5cdC8qKlxuXHQgKiBDYWxsZWQgdXBvbiBzdWNjZXNzZnVsIHJlY29ubmVjdC5cblx0ICpcblx0ICogQGFwaSBwcml2YXRlXG5cdCAqL1xuXHRcblx0TWFuYWdlci5wcm90b3R5cGUub25yZWNvbm5lY3QgPSBmdW5jdGlvbiAoKSB7XG5cdCAgdmFyIGF0dGVtcHQgPSB0aGlzLmJhY2tvZmYuYXR0ZW1wdHM7XG5cdCAgdGhpcy5yZWNvbm5lY3RpbmcgPSBmYWxzZTtcblx0ICB0aGlzLmJhY2tvZmYucmVzZXQoKTtcblx0ICB0aGlzLnVwZGF0ZVNvY2tldElkcygpO1xuXHQgIHRoaXMuZW1pdEFsbCgncmVjb25uZWN0JywgYXR0ZW1wdCk7XG5cdH07XG5cbi8qKiovIH0pLFxuLyogMTEgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXHRcblx0bW9kdWxlLmV4cG9ydHMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEyKTtcblxuXG4vKioqLyB9KSxcbi8qIDEyICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblx0XG5cdG1vZHVsZS5leHBvcnRzID0gX193ZWJwYWNrX3JlcXVpcmVfXygxMyk7XG5cdFxuXHQvKipcblx0ICogRXhwb3J0cyBwYXJzZXJcblx0ICpcblx0ICogQGFwaSBwdWJsaWNcblx0ICpcblx0ICovXG5cdG1vZHVsZS5leHBvcnRzLnBhcnNlciA9IF9fd2VicGFja19yZXF1aXJlX18oMjApO1xuXG5cbi8qKiovIH0pLFxuLyogMTMgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXHQvKiBXRUJQQUNLIFZBUiBJTkpFQ1RJT04gKi8oZnVuY3Rpb24oZ2xvYmFsKSB7LyoqXG5cdCAqIE1vZHVsZSBkZXBlbmRlbmNpZXMuXG5cdCAqL1xuXHRcblx0dmFyIHRyYW5zcG9ydHMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDE0KTtcblx0dmFyIEVtaXR0ZXIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDUpO1xuXHR2YXIgZGVidWcgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDMpKCdlbmdpbmUuaW8tY2xpZW50OnNvY2tldCcpO1xuXHR2YXIgaW5kZXggPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDM0KTtcblx0dmFyIHBhcnNlciA9IF9fd2VicGFja19yZXF1aXJlX18oMjApO1xuXHR2YXIgcGFyc2V1cmkgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIpO1xuXHR2YXIgcGFyc2Vqc29uID0gX193ZWJwYWNrX3JlcXVpcmVfXygzNSk7XG5cdHZhciBwYXJzZXFzID0gX193ZWJwYWNrX3JlcXVpcmVfXygyOCk7XG5cdFxuXHQvKipcblx0ICogTW9kdWxlIGV4cG9ydHMuXG5cdCAqL1xuXHRcblx0bW9kdWxlLmV4cG9ydHMgPSBTb2NrZXQ7XG5cdFxuXHQvKipcblx0ICogU29ja2V0IGNvbnN0cnVjdG9yLlxuXHQgKlxuXHQgKiBAcGFyYW0ge1N0cmluZ3xPYmplY3R9IHVyaSBvciBvcHRpb25zXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG5cdCAqIEBhcGkgcHVibGljXG5cdCAqL1xuXHRcblx0ZnVuY3Rpb24gU29ja2V0ICh1cmksIG9wdHMpIHtcblx0ICBpZiAoISh0aGlzIGluc3RhbmNlb2YgU29ja2V0KSkgcmV0dXJuIG5ldyBTb2NrZXQodXJpLCBvcHRzKTtcblx0XG5cdCAgb3B0cyA9IG9wdHMgfHwge307XG5cdFxuXHQgIGlmICh1cmkgJiYgJ29iamVjdCcgPT09IHR5cGVvZiB1cmkpIHtcblx0ICAgIG9wdHMgPSB1cmk7XG5cdCAgICB1cmkgPSBudWxsO1xuXHQgIH1cblx0XG5cdCAgaWYgKHVyaSkge1xuXHQgICAgdXJpID0gcGFyc2V1cmkodXJpKTtcblx0ICAgIG9wdHMuaG9zdG5hbWUgPSB1cmkuaG9zdDtcblx0ICAgIG9wdHMuc2VjdXJlID0gdXJpLnByb3RvY29sID09PSAnaHR0cHMnIHx8IHVyaS5wcm90b2NvbCA9PT0gJ3dzcyc7XG5cdCAgICBvcHRzLnBvcnQgPSB1cmkucG9ydDtcblx0ICAgIGlmICh1cmkucXVlcnkpIG9wdHMucXVlcnkgPSB1cmkucXVlcnk7XG5cdCAgfSBlbHNlIGlmIChvcHRzLmhvc3QpIHtcblx0ICAgIG9wdHMuaG9zdG5hbWUgPSBwYXJzZXVyaShvcHRzLmhvc3QpLmhvc3Q7XG5cdCAgfVxuXHRcblx0ICB0aGlzLnNlY3VyZSA9IG51bGwgIT0gb3B0cy5zZWN1cmUgPyBvcHRzLnNlY3VyZVxuXHQgICAgOiAoZ2xvYmFsLmxvY2F0aW9uICYmICdodHRwczonID09PSBsb2NhdGlvbi5wcm90b2NvbCk7XG5cdFxuXHQgIGlmIChvcHRzLmhvc3RuYW1lICYmICFvcHRzLnBvcnQpIHtcblx0ICAgIC8vIGlmIG5vIHBvcnQgaXMgc3BlY2lmaWVkIG1hbnVhbGx5LCB1c2UgdGhlIHByb3RvY29sIGRlZmF1bHRcblx0ICAgIG9wdHMucG9ydCA9IHRoaXMuc2VjdXJlID8gJzQ0MycgOiAnODAnO1xuXHQgIH1cblx0XG5cdCAgdGhpcy5hZ2VudCA9IG9wdHMuYWdlbnQgfHwgZmFsc2U7XG5cdCAgdGhpcy5ob3N0bmFtZSA9IG9wdHMuaG9zdG5hbWUgfHxcblx0ICAgIChnbG9iYWwubG9jYXRpb24gPyBsb2NhdGlvbi5ob3N0bmFtZSA6ICdsb2NhbGhvc3QnKTtcblx0ICB0aGlzLnBvcnQgPSBvcHRzLnBvcnQgfHwgKGdsb2JhbC5sb2NhdGlvbiAmJiBsb2NhdGlvbi5wb3J0XG5cdCAgICAgID8gbG9jYXRpb24ucG9ydFxuXHQgICAgICA6ICh0aGlzLnNlY3VyZSA/IDQ0MyA6IDgwKSk7XG5cdCAgdGhpcy5xdWVyeSA9IG9wdHMucXVlcnkgfHwge307XG5cdCAgaWYgKCdzdHJpbmcnID09PSB0eXBlb2YgdGhpcy5xdWVyeSkgdGhpcy5xdWVyeSA9IHBhcnNlcXMuZGVjb2RlKHRoaXMucXVlcnkpO1xuXHQgIHRoaXMudXBncmFkZSA9IGZhbHNlICE9PSBvcHRzLnVwZ3JhZGU7XG5cdCAgdGhpcy5wYXRoID0gKG9wdHMucGF0aCB8fCAnL2VuZ2luZS5pbycpLnJlcGxhY2UoL1xcLyQvLCAnJykgKyAnLyc7XG5cdCAgdGhpcy5mb3JjZUpTT05QID0gISFvcHRzLmZvcmNlSlNPTlA7XG5cdCAgdGhpcy5qc29ucCA9IGZhbHNlICE9PSBvcHRzLmpzb25wO1xuXHQgIHRoaXMuZm9yY2VCYXNlNjQgPSAhIW9wdHMuZm9yY2VCYXNlNjQ7XG5cdCAgdGhpcy5lbmFibGVzWERSID0gISFvcHRzLmVuYWJsZXNYRFI7XG5cdCAgdGhpcy50aW1lc3RhbXBQYXJhbSA9IG9wdHMudGltZXN0YW1wUGFyYW0gfHwgJ3QnO1xuXHQgIHRoaXMudGltZXN0YW1wUmVxdWVzdHMgPSBvcHRzLnRpbWVzdGFtcFJlcXVlc3RzO1xuXHQgIHRoaXMudHJhbnNwb3J0cyA9IG9wdHMudHJhbnNwb3J0cyB8fCBbJ3BvbGxpbmcnLCAnd2Vic29ja2V0J107XG5cdCAgdGhpcy50cmFuc3BvcnRPcHRpb25zID0gb3B0cy50cmFuc3BvcnRPcHRpb25zIHx8IHt9O1xuXHQgIHRoaXMucmVhZHlTdGF0ZSA9ICcnO1xuXHQgIHRoaXMud3JpdGVCdWZmZXIgPSBbXTtcblx0ICB0aGlzLnByZXZCdWZmZXJMZW4gPSAwO1xuXHQgIHRoaXMucG9saWN5UG9ydCA9IG9wdHMucG9saWN5UG9ydCB8fCA4NDM7XG5cdCAgdGhpcy5yZW1lbWJlclVwZ3JhZGUgPSBvcHRzLnJlbWVtYmVyVXBncmFkZSB8fCBmYWxzZTtcblx0ICB0aGlzLmJpbmFyeVR5cGUgPSBudWxsO1xuXHQgIHRoaXMub25seUJpbmFyeVVwZ3JhZGVzID0gb3B0cy5vbmx5QmluYXJ5VXBncmFkZXM7XG5cdCAgdGhpcy5wZXJNZXNzYWdlRGVmbGF0ZSA9IGZhbHNlICE9PSBvcHRzLnBlck1lc3NhZ2VEZWZsYXRlID8gKG9wdHMucGVyTWVzc2FnZURlZmxhdGUgfHwge30pIDogZmFsc2U7XG5cdFxuXHQgIGlmICh0cnVlID09PSB0aGlzLnBlck1lc3NhZ2VEZWZsYXRlKSB0aGlzLnBlck1lc3NhZ2VEZWZsYXRlID0ge307XG5cdCAgaWYgKHRoaXMucGVyTWVzc2FnZURlZmxhdGUgJiYgbnVsbCA9PSB0aGlzLnBlck1lc3NhZ2VEZWZsYXRlLnRocmVzaG9sZCkge1xuXHQgICAgdGhpcy5wZXJNZXNzYWdlRGVmbGF0ZS50aHJlc2hvbGQgPSAxMDI0O1xuXHQgIH1cblx0XG5cdCAgLy8gU1NMIG9wdGlvbnMgZm9yIE5vZGUuanMgY2xpZW50XG5cdCAgdGhpcy5wZnggPSBvcHRzLnBmeCB8fCBudWxsO1xuXHQgIHRoaXMua2V5ID0gb3B0cy5rZXkgfHwgbnVsbDtcblx0ICB0aGlzLnBhc3NwaHJhc2UgPSBvcHRzLnBhc3NwaHJhc2UgfHwgbnVsbDtcblx0ICB0aGlzLmNlcnQgPSBvcHRzLmNlcnQgfHwgbnVsbDtcblx0ICB0aGlzLmNhID0gb3B0cy5jYSB8fCBudWxsO1xuXHQgIHRoaXMuY2lwaGVycyA9IG9wdHMuY2lwaGVycyB8fCBudWxsO1xuXHQgIHRoaXMucmVqZWN0VW5hdXRob3JpemVkID0gb3B0cy5yZWplY3RVbmF1dGhvcml6ZWQgPT09IHVuZGVmaW5lZCA/IHRydWUgOiBvcHRzLnJlamVjdFVuYXV0aG9yaXplZDtcblx0ICB0aGlzLmZvcmNlTm9kZSA9ICEhb3B0cy5mb3JjZU5vZGU7XG5cdFxuXHQgIC8vIG90aGVyIG9wdGlvbnMgZm9yIE5vZGUuanMgY2xpZW50XG5cdCAgdmFyIGZyZWVHbG9iYWwgPSB0eXBlb2YgZ2xvYmFsID09PSAnb2JqZWN0JyAmJiBnbG9iYWw7XG5cdCAgaWYgKGZyZWVHbG9iYWwuZ2xvYmFsID09PSBmcmVlR2xvYmFsKSB7XG5cdCAgICBpZiAob3B0cy5leHRyYUhlYWRlcnMgJiYgT2JqZWN0LmtleXMob3B0cy5leHRyYUhlYWRlcnMpLmxlbmd0aCA+IDApIHtcblx0ICAgICAgdGhpcy5leHRyYUhlYWRlcnMgPSBvcHRzLmV4dHJhSGVhZGVycztcblx0ICAgIH1cblx0XG5cdCAgICBpZiAob3B0cy5sb2NhbEFkZHJlc3MpIHtcblx0ICAgICAgdGhpcy5sb2NhbEFkZHJlc3MgPSBvcHRzLmxvY2FsQWRkcmVzcztcblx0ICAgIH1cblx0ICB9XG5cdFxuXHQgIC8vIHNldCBvbiBoYW5kc2hha2Vcblx0ICB0aGlzLmlkID0gbnVsbDtcblx0ICB0aGlzLnVwZ3JhZGVzID0gbnVsbDtcblx0ICB0aGlzLnBpbmdJbnRlcnZhbCA9IG51bGw7XG5cdCAgdGhpcy5waW5nVGltZW91dCA9IG51bGw7XG5cdFxuXHQgIC8vIHNldCBvbiBoZWFydGJlYXRcblx0ICB0aGlzLnBpbmdJbnRlcnZhbFRpbWVyID0gbnVsbDtcblx0ICB0aGlzLnBpbmdUaW1lb3V0VGltZXIgPSBudWxsO1xuXHRcblx0ICB0aGlzLm9wZW4oKTtcblx0fVxuXHRcblx0U29ja2V0LnByaW9yV2Vic29ja2V0U3VjY2VzcyA9IGZhbHNlO1xuXHRcblx0LyoqXG5cdCAqIE1peCBpbiBgRW1pdHRlcmAuXG5cdCAqL1xuXHRcblx0RW1pdHRlcihTb2NrZXQucHJvdG90eXBlKTtcblx0XG5cdC8qKlxuXHQgKiBQcm90b2NvbCB2ZXJzaW9uLlxuXHQgKlxuXHQgKiBAYXBpIHB1YmxpY1xuXHQgKi9cblx0XG5cdFNvY2tldC5wcm90b2NvbCA9IHBhcnNlci5wcm90b2NvbDsgLy8gdGhpcyBpcyBhbiBpbnRcblx0XG5cdC8qKlxuXHQgKiBFeHBvc2UgZGVwcyBmb3IgbGVnYWN5IGNvbXBhdGliaWxpdHlcblx0ICogYW5kIHN0YW5kYWxvbmUgYnJvd3NlciBhY2Nlc3MuXG5cdCAqL1xuXHRcblx0U29ja2V0LlNvY2tldCA9IFNvY2tldDtcblx0U29ja2V0LlRyYW5zcG9ydCA9IF9fd2VicGFja19yZXF1aXJlX18oMTkpO1xuXHRTb2NrZXQudHJhbnNwb3J0cyA9IF9fd2VicGFja19yZXF1aXJlX18oMTQpO1xuXHRTb2NrZXQucGFyc2VyID0gX193ZWJwYWNrX3JlcXVpcmVfXygyMCk7XG5cdFxuXHQvKipcblx0ICogQ3JlYXRlcyB0cmFuc3BvcnQgb2YgdGhlIGdpdmVuIHR5cGUuXG5cdCAqXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSB0cmFuc3BvcnQgbmFtZVxuXHQgKiBAcmV0dXJuIHtUcmFuc3BvcnR9XG5cdCAqIEBhcGkgcHJpdmF0ZVxuXHQgKi9cblx0XG5cdFNvY2tldC5wcm90b3R5cGUuY3JlYXRlVHJhbnNwb3J0ID0gZnVuY3Rpb24gKG5hbWUpIHtcblx0XG5cdCAgdmFyIHF1ZXJ5ID0gY2xvbmUodGhpcy5xdWVyeSk7XG5cdFxuXHQgIC8vIGFwcGVuZCBlbmdpbmUuaW8gcHJvdG9jb2wgaWRlbnRpZmllclxuXHQgIHF1ZXJ5LkVJTyA9IHBhcnNlci5wcm90b2NvbDtcblx0XG5cdCAgLy8gdHJhbnNwb3J0IG5hbWVcblx0ICBxdWVyeS50cmFuc3BvcnQgPSBuYW1lO1xuXHRcblx0ICAvLyBwZXItdHJhbnNwb3J0IG9wdGlvbnNcblx0ICB2YXIgb3B0aW9ucyA9IHRoaXMudHJhbnNwb3J0T3B0aW9uc1tuYW1lXSB8fCB7fTtcblx0XG5cdCAgLy8gc2Vzc2lvbiBpZCBpZiB3ZSBhbHJlYWR5IGhhdmUgb25lXG5cdCAgaWYgKHRoaXMuaWQpIHF1ZXJ5LnNpZCA9IHRoaXMuaWQ7XG5cdFxuXHQgIHZhciB0cmFuc3BvcnQgPSBuZXcgdHJhbnNwb3J0c1tuYW1lXSh7XG5cdCAgICBxdWVyeTogcXVlcnksXG5cdCAgICBzb2NrZXQ6IHRoaXMsXG5cdCAgICBhZ2VudDogb3B0aW9ucy5hZ2VudCB8fCB0aGlzLmFnZW50LFxuXHQgICAgaG9zdG5hbWU6IG9wdGlvbnMuaG9zdG5hbWUgfHwgdGhpcy5ob3N0bmFtZSxcblx0ICAgIHBvcnQ6IG9wdGlvbnMucG9ydCB8fCB0aGlzLnBvcnQsXG5cdCAgICBzZWN1cmU6IG9wdGlvbnMuc2VjdXJlIHx8IHRoaXMuc2VjdXJlLFxuXHQgICAgcGF0aDogb3B0aW9ucy5wYXRoIHx8IHRoaXMucGF0aCxcblx0ICAgIGZvcmNlSlNPTlA6IG9wdGlvbnMuZm9yY2VKU09OUCB8fCB0aGlzLmZvcmNlSlNPTlAsXG5cdCAgICBqc29ucDogb3B0aW9ucy5qc29ucCB8fCB0aGlzLmpzb25wLFxuXHQgICAgZm9yY2VCYXNlNjQ6IG9wdGlvbnMuZm9yY2VCYXNlNjQgfHwgdGhpcy5mb3JjZUJhc2U2NCxcblx0ICAgIGVuYWJsZXNYRFI6IG9wdGlvbnMuZW5hYmxlc1hEUiB8fCB0aGlzLmVuYWJsZXNYRFIsXG5cdCAgICB0aW1lc3RhbXBSZXF1ZXN0czogb3B0aW9ucy50aW1lc3RhbXBSZXF1ZXN0cyB8fCB0aGlzLnRpbWVzdGFtcFJlcXVlc3RzLFxuXHQgICAgdGltZXN0YW1wUGFyYW06IG9wdGlvbnMudGltZXN0YW1wUGFyYW0gfHwgdGhpcy50aW1lc3RhbXBQYXJhbSxcblx0ICAgIHBvbGljeVBvcnQ6IG9wdGlvbnMucG9saWN5UG9ydCB8fCB0aGlzLnBvbGljeVBvcnQsXG5cdCAgICBwZng6IG9wdGlvbnMucGZ4IHx8IHRoaXMucGZ4LFxuXHQgICAga2V5OiBvcHRpb25zLmtleSB8fCB0aGlzLmtleSxcblx0ICAgIHBhc3NwaHJhc2U6IG9wdGlvbnMucGFzc3BocmFzZSB8fCB0aGlzLnBhc3NwaHJhc2UsXG5cdCAgICBjZXJ0OiBvcHRpb25zLmNlcnQgfHwgdGhpcy5jZXJ0LFxuXHQgICAgY2E6IG9wdGlvbnMuY2EgfHwgdGhpcy5jYSxcblx0ICAgIGNpcGhlcnM6IG9wdGlvbnMuY2lwaGVycyB8fCB0aGlzLmNpcGhlcnMsXG5cdCAgICByZWplY3RVbmF1dGhvcml6ZWQ6IG9wdGlvbnMucmVqZWN0VW5hdXRob3JpemVkIHx8IHRoaXMucmVqZWN0VW5hdXRob3JpemVkLFxuXHQgICAgcGVyTWVzc2FnZURlZmxhdGU6IG9wdGlvbnMucGVyTWVzc2FnZURlZmxhdGUgfHwgdGhpcy5wZXJNZXNzYWdlRGVmbGF0ZSxcblx0ICAgIGV4dHJhSGVhZGVyczogb3B0aW9ucy5leHRyYUhlYWRlcnMgfHwgdGhpcy5leHRyYUhlYWRlcnMsXG5cdCAgICBmb3JjZU5vZGU6IG9wdGlvbnMuZm9yY2VOb2RlIHx8IHRoaXMuZm9yY2VOb2RlLFxuXHQgICAgbG9jYWxBZGRyZXNzOiBvcHRpb25zLmxvY2FsQWRkcmVzcyB8fCB0aGlzLmxvY2FsQWRkcmVzcyxcblx0ICAgIHJlcXVlc3RUaW1lb3V0OiBvcHRpb25zLnJlcXVlc3RUaW1lb3V0IHx8IHRoaXMucmVxdWVzdFRpbWVvdXQsXG5cdCAgICBwcm90b2NvbHM6IG9wdGlvbnMucHJvdG9jb2xzIHx8IHZvaWQgKDApXG5cdCAgfSk7XG5cdFxuXHQgIHJldHVybiB0cmFuc3BvcnQ7XG5cdH07XG5cdFxuXHRmdW5jdGlvbiBjbG9uZSAob2JqKSB7XG5cdCAgdmFyIG8gPSB7fTtcblx0ICBmb3IgKHZhciBpIGluIG9iaikge1xuXHQgICAgaWYgKG9iai5oYXNPd25Qcm9wZXJ0eShpKSkge1xuXHQgICAgICBvW2ldID0gb2JqW2ldO1xuXHQgICAgfVxuXHQgIH1cblx0ICByZXR1cm4gbztcblx0fVxuXHRcblx0LyoqXG5cdCAqIEluaXRpYWxpemVzIHRyYW5zcG9ydCB0byB1c2UgYW5kIHN0YXJ0cyBwcm9iZS5cblx0ICpcblx0ICogQGFwaSBwcml2YXRlXG5cdCAqL1xuXHRTb2NrZXQucHJvdG90eXBlLm9wZW4gPSBmdW5jdGlvbiAoKSB7XG5cdCAgdmFyIHRyYW5zcG9ydDtcblx0ICBpZiAodGhpcy5yZW1lbWJlclVwZ3JhZGUgJiYgU29ja2V0LnByaW9yV2Vic29ja2V0U3VjY2VzcyAmJiB0aGlzLnRyYW5zcG9ydHMuaW5kZXhPZignd2Vic29ja2V0JykgIT09IC0xKSB7XG5cdCAgICB0cmFuc3BvcnQgPSAnd2Vic29ja2V0Jztcblx0ICB9IGVsc2UgaWYgKDAgPT09IHRoaXMudHJhbnNwb3J0cy5sZW5ndGgpIHtcblx0ICAgIC8vIEVtaXQgZXJyb3Igb24gbmV4dCB0aWNrIHNvIGl0IGNhbiBiZSBsaXN0ZW5lZCB0b1xuXHQgICAgdmFyIHNlbGYgPSB0aGlzO1xuXHQgICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG5cdCAgICAgIHNlbGYuZW1pdCgnZXJyb3InLCAnTm8gdHJhbnNwb3J0cyBhdmFpbGFibGUnKTtcblx0ICAgIH0sIDApO1xuXHQgICAgcmV0dXJuO1xuXHQgIH0gZWxzZSB7XG5cdCAgICB0cmFuc3BvcnQgPSB0aGlzLnRyYW5zcG9ydHNbMF07XG5cdCAgfVxuXHQgIHRoaXMucmVhZHlTdGF0ZSA9ICdvcGVuaW5nJztcblx0XG5cdCAgLy8gUmV0cnkgd2l0aCB0aGUgbmV4dCB0cmFuc3BvcnQgaWYgdGhlIHRyYW5zcG9ydCBpcyBkaXNhYmxlZCAoanNvbnA6IGZhbHNlKVxuXHQgIHRyeSB7XG5cdCAgICB0cmFuc3BvcnQgPSB0aGlzLmNyZWF0ZVRyYW5zcG9ydCh0cmFuc3BvcnQpO1xuXHQgIH0gY2F0Y2ggKGUpIHtcblx0ICAgIHRoaXMudHJhbnNwb3J0cy5zaGlmdCgpO1xuXHQgICAgdGhpcy5vcGVuKCk7XG5cdCAgICByZXR1cm47XG5cdCAgfVxuXHRcblx0ICB0cmFuc3BvcnQub3BlbigpO1xuXHQgIHRoaXMuc2V0VHJhbnNwb3J0KHRyYW5zcG9ydCk7XG5cdH07XG5cdFxuXHQvKipcblx0ICogU2V0cyB0aGUgY3VycmVudCB0cmFuc3BvcnQuIERpc2FibGVzIHRoZSBleGlzdGluZyBvbmUgKGlmIGFueSkuXG5cdCAqXG5cdCAqIEBhcGkgcHJpdmF0ZVxuXHQgKi9cblx0XG5cdFNvY2tldC5wcm90b3R5cGUuc2V0VHJhbnNwb3J0ID0gZnVuY3Rpb24gKHRyYW5zcG9ydCkge1xuXHRcblx0ICB2YXIgc2VsZiA9IHRoaXM7XG5cdFxuXHQgIGlmICh0aGlzLnRyYW5zcG9ydCkge1xuXHRcblx0ICAgIHRoaXMudHJhbnNwb3J0LnJlbW92ZUFsbExpc3RlbmVycygpO1xuXHQgIH1cblx0XG5cdCAgLy8gc2V0IHVwIHRyYW5zcG9ydFxuXHQgIHRoaXMudHJhbnNwb3J0ID0gdHJhbnNwb3J0O1xuXHRcblx0ICAvLyBzZXQgdXAgdHJhbnNwb3J0IGxpc3RlbmVyc1xuXHQgIHRyYW5zcG9ydFxuXHQgIC5vbignZHJhaW4nLCBmdW5jdGlvbiAoKSB7XG5cdCAgICBzZWxmLm9uRHJhaW4oKTtcblx0ICB9KVxuXHQgIC5vbigncGFja2V0JywgZnVuY3Rpb24gKHBhY2tldCkge1xuXHQgICAgc2VsZi5vblBhY2tldChwYWNrZXQpO1xuXHQgIH0pXG5cdCAgLm9uKCdlcnJvcicsIGZ1bmN0aW9uIChlKSB7XG5cdCAgICBzZWxmLm9uRXJyb3IoZSk7XG5cdCAgfSlcblx0ICAub24oJ2Nsb3NlJywgZnVuY3Rpb24gKCkge1xuXHQgICAgc2VsZi5vbkNsb3NlKCd0cmFuc3BvcnQgY2xvc2UnKTtcblx0ICB9KTtcblx0fTtcblx0XG5cdC8qKlxuXHQgKiBQcm9iZXMgYSB0cmFuc3BvcnQuXG5cdCAqXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSB0cmFuc3BvcnQgbmFtZVxuXHQgKiBAYXBpIHByaXZhdGVcblx0ICovXG5cdFxuXHRTb2NrZXQucHJvdG90eXBlLnByb2JlID0gZnVuY3Rpb24gKG5hbWUpIHtcblx0XG5cdCAgdmFyIHRyYW5zcG9ydCA9IHRoaXMuY3JlYXRlVHJhbnNwb3J0KG5hbWUsIHsgcHJvYmU6IDEgfSk7XG5cdCAgdmFyIGZhaWxlZCA9IGZhbHNlO1xuXHQgIHZhciBzZWxmID0gdGhpcztcblx0XG5cdCAgU29ja2V0LnByaW9yV2Vic29ja2V0U3VjY2VzcyA9IGZhbHNlO1xuXHRcblx0ICBmdW5jdGlvbiBvblRyYW5zcG9ydE9wZW4gKCkge1xuXHQgICAgaWYgKHNlbGYub25seUJpbmFyeVVwZ3JhZGVzKSB7XG5cdCAgICAgIHZhciB1cGdyYWRlTG9zZXNCaW5hcnkgPSAhdGhpcy5zdXBwb3J0c0JpbmFyeSAmJiBzZWxmLnRyYW5zcG9ydC5zdXBwb3J0c0JpbmFyeTtcblx0ICAgICAgZmFpbGVkID0gZmFpbGVkIHx8IHVwZ3JhZGVMb3Nlc0JpbmFyeTtcblx0ICAgIH1cblx0ICAgIGlmIChmYWlsZWQpIHJldHVybjtcblx0XG5cdFxuXHQgICAgdHJhbnNwb3J0LnNlbmQoW3sgdHlwZTogJ3BpbmcnLCBkYXRhOiAncHJvYmUnIH1dKTtcblx0ICAgIHRyYW5zcG9ydC5vbmNlKCdwYWNrZXQnLCBmdW5jdGlvbiAobXNnKSB7XG5cdCAgICAgIGlmIChmYWlsZWQpIHJldHVybjtcblx0ICAgICAgaWYgKCdwb25nJyA9PT0gbXNnLnR5cGUgJiYgJ3Byb2JlJyA9PT0gbXNnLmRhdGEpIHtcblx0XG5cdCAgICAgICAgc2VsZi51cGdyYWRpbmcgPSB0cnVlO1xuXHQgICAgICAgIHNlbGYuZW1pdCgndXBncmFkaW5nJywgdHJhbnNwb3J0KTtcblx0ICAgICAgICBpZiAoIXRyYW5zcG9ydCkgcmV0dXJuO1xuXHQgICAgICAgIFNvY2tldC5wcmlvcldlYnNvY2tldFN1Y2Nlc3MgPSAnd2Vic29ja2V0JyA9PT0gdHJhbnNwb3J0Lm5hbWU7XG5cdFxuXHRcblx0ICAgICAgICBzZWxmLnRyYW5zcG9ydC5wYXVzZShmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICBpZiAoZmFpbGVkKSByZXR1cm47XG5cdCAgICAgICAgICBpZiAoJ2Nsb3NlZCcgPT09IHNlbGYucmVhZHlTdGF0ZSkgcmV0dXJuO1xuXHRcblx0XG5cdCAgICAgICAgICBjbGVhbnVwKCk7XG5cdFxuXHQgICAgICAgICAgc2VsZi5zZXRUcmFuc3BvcnQodHJhbnNwb3J0KTtcblx0ICAgICAgICAgIHRyYW5zcG9ydC5zZW5kKFt7IHR5cGU6ICd1cGdyYWRlJyB9XSk7XG5cdCAgICAgICAgICBzZWxmLmVtaXQoJ3VwZ3JhZGUnLCB0cmFuc3BvcnQpO1xuXHQgICAgICAgICAgdHJhbnNwb3J0ID0gbnVsbDtcblx0ICAgICAgICAgIHNlbGYudXBncmFkaW5nID0gZmFsc2U7XG5cdCAgICAgICAgICBzZWxmLmZsdXNoKCk7XG5cdCAgICAgICAgfSk7XG5cdCAgICAgIH0gZWxzZSB7XG5cdFxuXHQgICAgICAgIHZhciBlcnIgPSBuZXcgRXJyb3IoJ3Byb2JlIGVycm9yJyk7XG5cdCAgICAgICAgZXJyLnRyYW5zcG9ydCA9IHRyYW5zcG9ydC5uYW1lO1xuXHQgICAgICAgIHNlbGYuZW1pdCgndXBncmFkZUVycm9yJywgZXJyKTtcblx0ICAgICAgfVxuXHQgICAgfSk7XG5cdCAgfVxuXHRcblx0ICBmdW5jdGlvbiBmcmVlemVUcmFuc3BvcnQgKCkge1xuXHQgICAgaWYgKGZhaWxlZCkgcmV0dXJuO1xuXHRcblx0ICAgIC8vIEFueSBjYWxsYmFjayBjYWxsZWQgYnkgdHJhbnNwb3J0IHNob3VsZCBiZSBpZ25vcmVkIHNpbmNlIG5vd1xuXHQgICAgZmFpbGVkID0gdHJ1ZTtcblx0XG5cdCAgICBjbGVhbnVwKCk7XG5cdFxuXHQgICAgdHJhbnNwb3J0LmNsb3NlKCk7XG5cdCAgICB0cmFuc3BvcnQgPSBudWxsO1xuXHQgIH1cblx0XG5cdCAgLy8gSGFuZGxlIGFueSBlcnJvciB0aGF0IGhhcHBlbnMgd2hpbGUgcHJvYmluZ1xuXHQgIGZ1bmN0aW9uIG9uZXJyb3IgKGVycikge1xuXHQgICAgdmFyIGVycm9yID0gbmV3IEVycm9yKCdwcm9iZSBlcnJvcjogJyArIGVycik7XG5cdCAgICBlcnJvci50cmFuc3BvcnQgPSB0cmFuc3BvcnQubmFtZTtcblx0XG5cdCAgICBmcmVlemVUcmFuc3BvcnQoKTtcblx0XG5cdFxuXHRcblx0ICAgIHNlbGYuZW1pdCgndXBncmFkZUVycm9yJywgZXJyb3IpO1xuXHQgIH1cblx0XG5cdCAgZnVuY3Rpb24gb25UcmFuc3BvcnRDbG9zZSAoKSB7XG5cdCAgICBvbmVycm9yKCd0cmFuc3BvcnQgY2xvc2VkJyk7XG5cdCAgfVxuXHRcblx0ICAvLyBXaGVuIHRoZSBzb2NrZXQgaXMgY2xvc2VkIHdoaWxlIHdlJ3JlIHByb2Jpbmdcblx0ICBmdW5jdGlvbiBvbmNsb3NlICgpIHtcblx0ICAgIG9uZXJyb3IoJ3NvY2tldCBjbG9zZWQnKTtcblx0ICB9XG5cdFxuXHQgIC8vIFdoZW4gdGhlIHNvY2tldCBpcyB1cGdyYWRlZCB3aGlsZSB3ZSdyZSBwcm9iaW5nXG5cdCAgZnVuY3Rpb24gb251cGdyYWRlICh0bykge1xuXHQgICAgaWYgKHRyYW5zcG9ydCAmJiB0by5uYW1lICE9PSB0cmFuc3BvcnQubmFtZSkge1xuXHRcblx0ICAgICAgZnJlZXplVHJhbnNwb3J0KCk7XG5cdCAgICB9XG5cdCAgfVxuXHRcblx0ICAvLyBSZW1vdmUgYWxsIGxpc3RlbmVycyBvbiB0aGUgdHJhbnNwb3J0IGFuZCBvbiBzZWxmXG5cdCAgZnVuY3Rpb24gY2xlYW51cCAoKSB7XG5cdCAgICB0cmFuc3BvcnQucmVtb3ZlTGlzdGVuZXIoJ29wZW4nLCBvblRyYW5zcG9ydE9wZW4pO1xuXHQgICAgdHJhbnNwb3J0LnJlbW92ZUxpc3RlbmVyKCdlcnJvcicsIG9uZXJyb3IpO1xuXHQgICAgdHJhbnNwb3J0LnJlbW92ZUxpc3RlbmVyKCdjbG9zZScsIG9uVHJhbnNwb3J0Q2xvc2UpO1xuXHQgICAgc2VsZi5yZW1vdmVMaXN0ZW5lcignY2xvc2UnLCBvbmNsb3NlKTtcblx0ICAgIHNlbGYucmVtb3ZlTGlzdGVuZXIoJ3VwZ3JhZGluZycsIG9udXBncmFkZSk7XG5cdCAgfVxuXHRcblx0ICB0cmFuc3BvcnQub25jZSgnb3BlbicsIG9uVHJhbnNwb3J0T3Blbik7XG5cdCAgdHJhbnNwb3J0Lm9uY2UoJ2Vycm9yJywgb25lcnJvcik7XG5cdCAgdHJhbnNwb3J0Lm9uY2UoJ2Nsb3NlJywgb25UcmFuc3BvcnRDbG9zZSk7XG5cdFxuXHQgIHRoaXMub25jZSgnY2xvc2UnLCBvbmNsb3NlKTtcblx0ICB0aGlzLm9uY2UoJ3VwZ3JhZGluZycsIG9udXBncmFkZSk7XG5cdFxuXHQgIHRyYW5zcG9ydC5vcGVuKCk7XG5cdH07XG5cdFxuXHQvKipcblx0ICogQ2FsbGVkIHdoZW4gY29ubmVjdGlvbiBpcyBkZWVtZWQgb3Blbi5cblx0ICpcblx0ICogQGFwaSBwdWJsaWNcblx0ICovXG5cdFxuXHRTb2NrZXQucHJvdG90eXBlLm9uT3BlbiA9IGZ1bmN0aW9uICgpIHtcblx0XG5cdCAgdGhpcy5yZWFkeVN0YXRlID0gJ29wZW4nO1xuXHQgIFNvY2tldC5wcmlvcldlYnNvY2tldFN1Y2Nlc3MgPSAnd2Vic29ja2V0JyA9PT0gdGhpcy50cmFuc3BvcnQubmFtZTtcblx0ICB0aGlzLmVtaXQoJ29wZW4nKTtcblx0ICB0aGlzLmZsdXNoKCk7XG5cdFxuXHQgIC8vIHdlIGNoZWNrIGZvciBgcmVhZHlTdGF0ZWAgaW4gY2FzZSBhbiBgb3BlbmBcblx0ICAvLyBsaXN0ZW5lciBhbHJlYWR5IGNsb3NlZCB0aGUgc29ja2V0XG5cdCAgaWYgKCdvcGVuJyA9PT0gdGhpcy5yZWFkeVN0YXRlICYmIHRoaXMudXBncmFkZSAmJiB0aGlzLnRyYW5zcG9ydC5wYXVzZSkge1xuXHRcblx0ICAgIGZvciAodmFyIGkgPSAwLCBsID0gdGhpcy51cGdyYWRlcy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcblx0ICAgICAgdGhpcy5wcm9iZSh0aGlzLnVwZ3JhZGVzW2ldKTtcblx0ICAgIH1cblx0ICB9XG5cdH07XG5cdFxuXHQvKipcblx0ICogSGFuZGxlcyBhIHBhY2tldC5cblx0ICpcblx0ICogQGFwaSBwcml2YXRlXG5cdCAqL1xuXHRcblx0U29ja2V0LnByb3RvdHlwZS5vblBhY2tldCA9IGZ1bmN0aW9uIChwYWNrZXQpIHtcblx0ICBpZiAoJ29wZW5pbmcnID09PSB0aGlzLnJlYWR5U3RhdGUgfHwgJ29wZW4nID09PSB0aGlzLnJlYWR5U3RhdGUgfHxcblx0ICAgICAgJ2Nsb3NpbmcnID09PSB0aGlzLnJlYWR5U3RhdGUpIHtcblx0XG5cdFxuXHQgICAgdGhpcy5lbWl0KCdwYWNrZXQnLCBwYWNrZXQpO1xuXHRcblx0ICAgIC8vIFNvY2tldCBpcyBsaXZlIC0gYW55IHBhY2tldCBjb3VudHNcblx0ICAgIHRoaXMuZW1pdCgnaGVhcnRiZWF0Jyk7XG5cdFxuXHQgICAgc3dpdGNoIChwYWNrZXQudHlwZSkge1xuXHQgICAgICBjYXNlICdvcGVuJzpcblx0ICAgICAgICB0aGlzLm9uSGFuZHNoYWtlKHBhcnNlanNvbihwYWNrZXQuZGF0YSkpO1xuXHQgICAgICAgIGJyZWFrO1xuXHRcblx0ICAgICAgY2FzZSAncG9uZyc6XG5cdCAgICAgICAgdGhpcy5zZXRQaW5nKCk7XG5cdCAgICAgICAgdGhpcy5lbWl0KCdwb25nJyk7XG5cdCAgICAgICAgYnJlYWs7XG5cdFxuXHQgICAgICBjYXNlICdlcnJvcic6XG5cdCAgICAgICAgdmFyIGVyciA9IG5ldyBFcnJvcignc2VydmVyIGVycm9yJyk7XG5cdCAgICAgICAgZXJyLmNvZGUgPSBwYWNrZXQuZGF0YTtcblx0ICAgICAgICB0aGlzLm9uRXJyb3IoZXJyKTtcblx0ICAgICAgICBicmVhaztcblx0XG5cdCAgICAgIGNhc2UgJ21lc3NhZ2UnOlxuXHQgICAgICAgIHRoaXMuZW1pdCgnZGF0YScsIHBhY2tldC5kYXRhKTtcblx0ICAgICAgICB0aGlzLmVtaXQoJ21lc3NhZ2UnLCBwYWNrZXQuZGF0YSk7XG5cdCAgICAgICAgYnJlYWs7XG5cdCAgICB9XG5cdCAgfSBlbHNlIHtcblx0XG5cdCAgfVxuXHR9O1xuXHRcblx0LyoqXG5cdCAqIENhbGxlZCB1cG9uIGhhbmRzaGFrZSBjb21wbGV0aW9uLlxuXHQgKlxuXHQgKiBAcGFyYW0ge09iamVjdH0gaGFuZHNoYWtlIG9ialxuXHQgKiBAYXBpIHByaXZhdGVcblx0ICovXG5cdFxuXHRTb2NrZXQucHJvdG90eXBlLm9uSGFuZHNoYWtlID0gZnVuY3Rpb24gKGRhdGEpIHtcblx0ICB0aGlzLmVtaXQoJ2hhbmRzaGFrZScsIGRhdGEpO1xuXHQgIHRoaXMuaWQgPSBkYXRhLnNpZDtcblx0ICB0aGlzLnRyYW5zcG9ydC5xdWVyeS5zaWQgPSBkYXRhLnNpZDtcblx0ICB0aGlzLnVwZ3JhZGVzID0gdGhpcy5maWx0ZXJVcGdyYWRlcyhkYXRhLnVwZ3JhZGVzKTtcblx0ICB0aGlzLnBpbmdJbnRlcnZhbCA9IGRhdGEucGluZ0ludGVydmFsO1xuXHQgIHRoaXMucGluZ1RpbWVvdXQgPSBkYXRhLnBpbmdUaW1lb3V0O1xuXHQgIHRoaXMub25PcGVuKCk7XG5cdCAgLy8gSW4gY2FzZSBvcGVuIGhhbmRsZXIgY2xvc2VzIHNvY2tldFxuXHQgIGlmICgnY2xvc2VkJyA9PT0gdGhpcy5yZWFkeVN0YXRlKSByZXR1cm47XG5cdCAgdGhpcy5zZXRQaW5nKCk7XG5cdFxuXHQgIC8vIFByb2xvbmcgbGl2ZW5lc3Mgb2Ygc29ja2V0IG9uIGhlYXJ0YmVhdFxuXHQgIHRoaXMucmVtb3ZlTGlzdGVuZXIoJ2hlYXJ0YmVhdCcsIHRoaXMub25IZWFydGJlYXQpO1xuXHQgIHRoaXMub24oJ2hlYXJ0YmVhdCcsIHRoaXMub25IZWFydGJlYXQpO1xuXHR9O1xuXHRcblx0LyoqXG5cdCAqIFJlc2V0cyBwaW5nIHRpbWVvdXQuXG5cdCAqXG5cdCAqIEBhcGkgcHJpdmF0ZVxuXHQgKi9cblx0XG5cdFNvY2tldC5wcm90b3R5cGUub25IZWFydGJlYXQgPSBmdW5jdGlvbiAodGltZW91dCkge1xuXHQgIGNsZWFyVGltZW91dCh0aGlzLnBpbmdUaW1lb3V0VGltZXIpO1xuXHQgIHZhciBzZWxmID0gdGhpcztcblx0ICBzZWxmLnBpbmdUaW1lb3V0VGltZXIgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcblx0ICAgIGlmICgnY2xvc2VkJyA9PT0gc2VsZi5yZWFkeVN0YXRlKSByZXR1cm47XG5cdCAgICBzZWxmLm9uQ2xvc2UoJ3BpbmcgdGltZW91dCcpO1xuXHQgIH0sIHRpbWVvdXQgfHwgKHNlbGYucGluZ0ludGVydmFsICsgc2VsZi5waW5nVGltZW91dCkpO1xuXHR9O1xuXHRcblx0LyoqXG5cdCAqIFBpbmdzIHNlcnZlciBldmVyeSBgdGhpcy5waW5nSW50ZXJ2YWxgIGFuZCBleHBlY3RzIHJlc3BvbnNlXG5cdCAqIHdpdGhpbiBgdGhpcy5waW5nVGltZW91dGAgb3IgY2xvc2VzIGNvbm5lY3Rpb24uXG5cdCAqXG5cdCAqIEBhcGkgcHJpdmF0ZVxuXHQgKi9cblx0XG5cdFNvY2tldC5wcm90b3R5cGUuc2V0UGluZyA9IGZ1bmN0aW9uICgpIHtcblx0ICB2YXIgc2VsZiA9IHRoaXM7XG5cdCAgY2xlYXJUaW1lb3V0KHNlbGYucGluZ0ludGVydmFsVGltZXIpO1xuXHQgIHNlbGYucGluZ0ludGVydmFsVGltZXIgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcblx0XG5cdCAgICBzZWxmLnBpbmcoKTtcblx0ICAgIHNlbGYub25IZWFydGJlYXQoc2VsZi5waW5nVGltZW91dCk7XG5cdCAgfSwgc2VsZi5waW5nSW50ZXJ2YWwpO1xuXHR9O1xuXHRcblx0LyoqXG5cdCogU2VuZHMgYSBwaW5nIHBhY2tldC5cblx0KlxuXHQqIEBhcGkgcHJpdmF0ZVxuXHQqL1xuXHRcblx0U29ja2V0LnByb3RvdHlwZS5waW5nID0gZnVuY3Rpb24gKCkge1xuXHQgIHZhciBzZWxmID0gdGhpcztcblx0ICB0aGlzLnNlbmRQYWNrZXQoJ3BpbmcnLCBmdW5jdGlvbiAoKSB7XG5cdCAgICBzZWxmLmVtaXQoJ3BpbmcnKTtcblx0ICB9KTtcblx0fTtcblx0XG5cdC8qKlxuXHQgKiBDYWxsZWQgb24gYGRyYWluYCBldmVudFxuXHQgKlxuXHQgKiBAYXBpIHByaXZhdGVcblx0ICovXG5cdFxuXHRTb2NrZXQucHJvdG90eXBlLm9uRHJhaW4gPSBmdW5jdGlvbiAoKSB7XG5cdCAgdGhpcy53cml0ZUJ1ZmZlci5zcGxpY2UoMCwgdGhpcy5wcmV2QnVmZmVyTGVuKTtcblx0XG5cdCAgLy8gc2V0dGluZyBwcmV2QnVmZmVyTGVuID0gMCBpcyB2ZXJ5IGltcG9ydGFudFxuXHQgIC8vIGZvciBleGFtcGxlLCB3aGVuIHVwZ3JhZGluZywgdXBncmFkZSBwYWNrZXQgaXMgc2VudCBvdmVyLFxuXHQgIC8vIGFuZCBhIG5vbnplcm8gcHJldkJ1ZmZlckxlbiBjb3VsZCBjYXVzZSBwcm9ibGVtcyBvbiBgZHJhaW5gXG5cdCAgdGhpcy5wcmV2QnVmZmVyTGVuID0gMDtcblx0XG5cdCAgaWYgKDAgPT09IHRoaXMud3JpdGVCdWZmZXIubGVuZ3RoKSB7XG5cdCAgICB0aGlzLmVtaXQoJ2RyYWluJyk7XG5cdCAgfSBlbHNlIHtcblx0ICAgIHRoaXMuZmx1c2goKTtcblx0ICB9XG5cdH07XG5cdFxuXHQvKipcblx0ICogRmx1c2ggd3JpdGUgYnVmZmVycy5cblx0ICpcblx0ICogQGFwaSBwcml2YXRlXG5cdCAqL1xuXHRcblx0U29ja2V0LnByb3RvdHlwZS5mbHVzaCA9IGZ1bmN0aW9uICgpIHtcblx0ICBpZiAoJ2Nsb3NlZCcgIT09IHRoaXMucmVhZHlTdGF0ZSAmJiB0aGlzLnRyYW5zcG9ydC53cml0YWJsZSAmJlxuXHQgICAgIXRoaXMudXBncmFkaW5nICYmIHRoaXMud3JpdGVCdWZmZXIubGVuZ3RoKSB7XG5cdFxuXHQgICAgdGhpcy50cmFuc3BvcnQuc2VuZCh0aGlzLndyaXRlQnVmZmVyKTtcblx0ICAgIC8vIGtlZXAgdHJhY2sgb2YgY3VycmVudCBsZW5ndGggb2Ygd3JpdGVCdWZmZXJcblx0ICAgIC8vIHNwbGljZSB3cml0ZUJ1ZmZlciBhbmQgY2FsbGJhY2tCdWZmZXIgb24gYGRyYWluYFxuXHQgICAgdGhpcy5wcmV2QnVmZmVyTGVuID0gdGhpcy53cml0ZUJ1ZmZlci5sZW5ndGg7XG5cdCAgICB0aGlzLmVtaXQoJ2ZsdXNoJyk7XG5cdCAgfVxuXHR9O1xuXHRcblx0LyoqXG5cdCAqIFNlbmRzIGEgbWVzc2FnZS5cblx0ICpcblx0ICogQHBhcmFtIHtTdHJpbmd9IG1lc3NhZ2UuXG5cdCAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrIGZ1bmN0aW9uLlxuXHQgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucy5cblx0ICogQHJldHVybiB7U29ja2V0fSBmb3IgY2hhaW5pbmcuXG5cdCAqIEBhcGkgcHVibGljXG5cdCAqL1xuXHRcblx0U29ja2V0LnByb3RvdHlwZS53cml0ZSA9XG5cdFNvY2tldC5wcm90b3R5cGUuc2VuZCA9IGZ1bmN0aW9uIChtc2csIG9wdGlvbnMsIGZuKSB7XG5cdCAgdGhpcy5zZW5kUGFja2V0KCdtZXNzYWdlJywgbXNnLCBvcHRpb25zLCBmbik7XG5cdCAgcmV0dXJuIHRoaXM7XG5cdH07XG5cdFxuXHQvKipcblx0ICogU2VuZHMgYSBwYWNrZXQuXG5cdCAqXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBwYWNrZXQgdHlwZS5cblx0ICogQHBhcmFtIHtTdHJpbmd9IGRhdGEuXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zLlxuXHQgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFjayBmdW5jdGlvbi5cblx0ICogQGFwaSBwcml2YXRlXG5cdCAqL1xuXHRcblx0U29ja2V0LnByb3RvdHlwZS5zZW5kUGFja2V0ID0gZnVuY3Rpb24gKHR5cGUsIGRhdGEsIG9wdGlvbnMsIGZuKSB7XG5cdCAgaWYgKCdmdW5jdGlvbicgPT09IHR5cGVvZiBkYXRhKSB7XG5cdCAgICBmbiA9IGRhdGE7XG5cdCAgICBkYXRhID0gdW5kZWZpbmVkO1xuXHQgIH1cblx0XG5cdCAgaWYgKCdmdW5jdGlvbicgPT09IHR5cGVvZiBvcHRpb25zKSB7XG5cdCAgICBmbiA9IG9wdGlvbnM7XG5cdCAgICBvcHRpb25zID0gbnVsbDtcblx0ICB9XG5cdFxuXHQgIGlmICgnY2xvc2luZycgPT09IHRoaXMucmVhZHlTdGF0ZSB8fCAnY2xvc2VkJyA9PT0gdGhpcy5yZWFkeVN0YXRlKSB7XG5cdCAgICByZXR1cm47XG5cdCAgfVxuXHRcblx0ICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblx0ICBvcHRpb25zLmNvbXByZXNzID0gZmFsc2UgIT09IG9wdGlvbnMuY29tcHJlc3M7XG5cdFxuXHQgIHZhciBwYWNrZXQgPSB7XG5cdCAgICB0eXBlOiB0eXBlLFxuXHQgICAgZGF0YTogZGF0YSxcblx0ICAgIG9wdGlvbnM6IG9wdGlvbnNcblx0ICB9O1xuXHQgIHRoaXMuZW1pdCgncGFja2V0Q3JlYXRlJywgcGFja2V0KTtcblx0ICB0aGlzLndyaXRlQnVmZmVyLnB1c2gocGFja2V0KTtcblx0ICBpZiAoZm4pIHRoaXMub25jZSgnZmx1c2gnLCBmbik7XG5cdCAgdGhpcy5mbHVzaCgpO1xuXHR9O1xuXHRcblx0LyoqXG5cdCAqIENsb3NlcyB0aGUgY29ubmVjdGlvbi5cblx0ICpcblx0ICogQGFwaSBwcml2YXRlXG5cdCAqL1xuXHRcblx0U29ja2V0LnByb3RvdHlwZS5jbG9zZSA9IGZ1bmN0aW9uICgpIHtcblx0ICBpZiAoJ29wZW5pbmcnID09PSB0aGlzLnJlYWR5U3RhdGUgfHwgJ29wZW4nID09PSB0aGlzLnJlYWR5U3RhdGUpIHtcblx0ICAgIHRoaXMucmVhZHlTdGF0ZSA9ICdjbG9zaW5nJztcblx0XG5cdCAgICB2YXIgc2VsZiA9IHRoaXM7XG5cdFxuXHQgICAgaWYgKHRoaXMud3JpdGVCdWZmZXIubGVuZ3RoKSB7XG5cdCAgICAgIHRoaXMub25jZSgnZHJhaW4nLCBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgaWYgKHRoaXMudXBncmFkaW5nKSB7XG5cdCAgICAgICAgICB3YWl0Rm9yVXBncmFkZSgpO1xuXHQgICAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgICBjbG9zZSgpO1xuXHQgICAgICAgIH1cblx0ICAgICAgfSk7XG5cdCAgICB9IGVsc2UgaWYgKHRoaXMudXBncmFkaW5nKSB7XG5cdCAgICAgIHdhaXRGb3JVcGdyYWRlKCk7XG5cdCAgICB9IGVsc2Uge1xuXHQgICAgICBjbG9zZSgpO1xuXHQgICAgfVxuXHQgIH1cblx0XG5cdCAgZnVuY3Rpb24gY2xvc2UgKCkge1xuXHQgICAgc2VsZi5vbkNsb3NlKCdmb3JjZWQgY2xvc2UnKTtcblx0XG5cdCAgICBzZWxmLnRyYW5zcG9ydC5jbG9zZSgpO1xuXHQgIH1cblx0XG5cdCAgZnVuY3Rpb24gY2xlYW51cEFuZENsb3NlICgpIHtcblx0ICAgIHNlbGYucmVtb3ZlTGlzdGVuZXIoJ3VwZ3JhZGUnLCBjbGVhbnVwQW5kQ2xvc2UpO1xuXHQgICAgc2VsZi5yZW1vdmVMaXN0ZW5lcigndXBncmFkZUVycm9yJywgY2xlYW51cEFuZENsb3NlKTtcblx0ICAgIGNsb3NlKCk7XG5cdCAgfVxuXHRcblx0ICBmdW5jdGlvbiB3YWl0Rm9yVXBncmFkZSAoKSB7XG5cdCAgICAvLyB3YWl0IGZvciB1cGdyYWRlIHRvIGZpbmlzaCBzaW5jZSB3ZSBjYW4ndCBzZW5kIHBhY2tldHMgd2hpbGUgcGF1c2luZyBhIHRyYW5zcG9ydFxuXHQgICAgc2VsZi5vbmNlKCd1cGdyYWRlJywgY2xlYW51cEFuZENsb3NlKTtcblx0ICAgIHNlbGYub25jZSgndXBncmFkZUVycm9yJywgY2xlYW51cEFuZENsb3NlKTtcblx0ICB9XG5cdFxuXHQgIHJldHVybiB0aGlzO1xuXHR9O1xuXHRcblx0LyoqXG5cdCAqIENhbGxlZCB1cG9uIHRyYW5zcG9ydCBlcnJvclxuXHQgKlxuXHQgKiBAYXBpIHByaXZhdGVcblx0ICovXG5cdFxuXHRTb2NrZXQucHJvdG90eXBlLm9uRXJyb3IgPSBmdW5jdGlvbiAoZXJyKSB7XG5cdFxuXHQgIFNvY2tldC5wcmlvcldlYnNvY2tldFN1Y2Nlc3MgPSBmYWxzZTtcblx0ICB0aGlzLmVtaXQoJ2Vycm9yJywgZXJyKTtcblx0ICB0aGlzLm9uQ2xvc2UoJ3RyYW5zcG9ydCBlcnJvcicsIGVycik7XG5cdH07XG5cdFxuXHQvKipcblx0ICogQ2FsbGVkIHVwb24gdHJhbnNwb3J0IGNsb3NlLlxuXHQgKlxuXHQgKiBAYXBpIHByaXZhdGVcblx0ICovXG5cdFxuXHRTb2NrZXQucHJvdG90eXBlLm9uQ2xvc2UgPSBmdW5jdGlvbiAocmVhc29uLCBkZXNjKSB7XG5cdCAgaWYgKCdvcGVuaW5nJyA9PT0gdGhpcy5yZWFkeVN0YXRlIHx8ICdvcGVuJyA9PT0gdGhpcy5yZWFkeVN0YXRlIHx8ICdjbG9zaW5nJyA9PT0gdGhpcy5yZWFkeVN0YXRlKSB7XG5cdFxuXHQgICAgdmFyIHNlbGYgPSB0aGlzO1xuXHRcblx0ICAgIC8vIGNsZWFyIHRpbWVyc1xuXHQgICAgY2xlYXJUaW1lb3V0KHRoaXMucGluZ0ludGVydmFsVGltZXIpO1xuXHQgICAgY2xlYXJUaW1lb3V0KHRoaXMucGluZ1RpbWVvdXRUaW1lcik7XG5cdFxuXHQgICAgLy8gc3RvcCBldmVudCBmcm9tIGZpcmluZyBhZ2FpbiBmb3IgdHJhbnNwb3J0XG5cdCAgICB0aGlzLnRyYW5zcG9ydC5yZW1vdmVBbGxMaXN0ZW5lcnMoJ2Nsb3NlJyk7XG5cdFxuXHQgICAgLy8gZW5zdXJlIHRyYW5zcG9ydCB3b24ndCBzdGF5IG9wZW5cblx0ICAgIHRoaXMudHJhbnNwb3J0LmNsb3NlKCk7XG5cdFxuXHQgICAgLy8gaWdub3JlIGZ1cnRoZXIgdHJhbnNwb3J0IGNvbW11bmljYXRpb25cblx0ICAgIHRoaXMudHJhbnNwb3J0LnJlbW92ZUFsbExpc3RlbmVycygpO1xuXHRcblx0ICAgIC8vIHNldCByZWFkeSBzdGF0ZVxuXHQgICAgdGhpcy5yZWFkeVN0YXRlID0gJ2Nsb3NlZCc7XG5cdFxuXHQgICAgLy8gY2xlYXIgc2Vzc2lvbiBpZFxuXHQgICAgdGhpcy5pZCA9IG51bGw7XG5cdFxuXHQgICAgLy8gZW1pdCBjbG9zZSBldmVudFxuXHQgICAgdGhpcy5lbWl0KCdjbG9zZScsIHJlYXNvbiwgZGVzYyk7XG5cdFxuXHQgICAgLy8gY2xlYW4gYnVmZmVycyBhZnRlciwgc28gdXNlcnMgY2FuIHN0aWxsXG5cdCAgICAvLyBncmFiIHRoZSBidWZmZXJzIG9uIGBjbG9zZWAgZXZlbnRcblx0ICAgIHNlbGYud3JpdGVCdWZmZXIgPSBbXTtcblx0ICAgIHNlbGYucHJldkJ1ZmZlckxlbiA9IDA7XG5cdCAgfVxuXHR9O1xuXHRcblx0LyoqXG5cdCAqIEZpbHRlcnMgdXBncmFkZXMsIHJldHVybmluZyBvbmx5IHRob3NlIG1hdGNoaW5nIGNsaWVudCB0cmFuc3BvcnRzLlxuXHQgKlxuXHQgKiBAcGFyYW0ge0FycmF5fSBzZXJ2ZXIgdXBncmFkZXNcblx0ICogQGFwaSBwcml2YXRlXG5cdCAqXG5cdCAqL1xuXHRcblx0U29ja2V0LnByb3RvdHlwZS5maWx0ZXJVcGdyYWRlcyA9IGZ1bmN0aW9uICh1cGdyYWRlcykge1xuXHQgIHZhciBmaWx0ZXJlZFVwZ3JhZGVzID0gW107XG5cdCAgZm9yICh2YXIgaSA9IDAsIGogPSB1cGdyYWRlcy5sZW5ndGg7IGkgPCBqOyBpKyspIHtcblx0ICAgIGlmICh+aW5kZXgodGhpcy50cmFuc3BvcnRzLCB1cGdyYWRlc1tpXSkpIGZpbHRlcmVkVXBncmFkZXMucHVzaCh1cGdyYWRlc1tpXSk7XG5cdCAgfVxuXHQgIHJldHVybiBmaWx0ZXJlZFVwZ3JhZGVzO1xuXHR9O1xuXHRcblx0LyogV0VCUEFDSyBWQVIgSU5KRUNUSU9OICovfS5jYWxsKGV4cG9ydHMsIChmdW5jdGlvbigpIHsgcmV0dXJuIHRoaXM7IH0oKSkpKVxuXG4vKioqLyB9KSxcbi8qIDE0ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblx0LyogV0VCUEFDSyBWQVIgSU5KRUNUSU9OICovKGZ1bmN0aW9uKGdsb2JhbCkgey8qKlxuXHQgKiBNb2R1bGUgZGVwZW5kZW5jaWVzXG5cdCAqL1xuXHRcblx0dmFyIFhNTEh0dHBSZXF1ZXN0ID0gX193ZWJwYWNrX3JlcXVpcmVfXygxNSk7XG5cdHZhciBYSFIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDE3KTtcblx0dmFyIEpTT05QID0gX193ZWJwYWNrX3JlcXVpcmVfXygzMSk7XG5cdHZhciB3ZWJzb2NrZXQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDMyKTtcblx0XG5cdC8qKlxuXHQgKiBFeHBvcnQgdHJhbnNwb3J0cy5cblx0ICovXG5cdFxuXHRleHBvcnRzLnBvbGxpbmcgPSBwb2xsaW5nO1xuXHRleHBvcnRzLndlYnNvY2tldCA9IHdlYnNvY2tldDtcblx0XG5cdC8qKlxuXHQgKiBQb2xsaW5nIHRyYW5zcG9ydCBwb2x5bW9ycGhpYyBjb25zdHJ1Y3Rvci5cblx0ICogRGVjaWRlcyBvbiB4aHIgdnMganNvbnAgYmFzZWQgb24gZmVhdHVyZSBkZXRlY3Rpb24uXG5cdCAqXG5cdCAqIEBhcGkgcHJpdmF0ZVxuXHQgKi9cblx0XG5cdGZ1bmN0aW9uIHBvbGxpbmcgKG9wdHMpIHtcblx0ICB2YXIgeGhyO1xuXHQgIHZhciB4ZCA9IGZhbHNlO1xuXHQgIHZhciB4cyA9IGZhbHNlO1xuXHQgIHZhciBqc29ucCA9IGZhbHNlICE9PSBvcHRzLmpzb25wO1xuXHRcblx0ICBpZiAoZ2xvYmFsLmxvY2F0aW9uKSB7XG5cdCAgICB2YXIgaXNTU0wgPSAnaHR0cHM6JyA9PT0gbG9jYXRpb24ucHJvdG9jb2w7XG5cdCAgICB2YXIgcG9ydCA9IGxvY2F0aW9uLnBvcnQ7XG5cdFxuXHQgICAgLy8gc29tZSB1c2VyIGFnZW50cyBoYXZlIGVtcHR5IGBsb2NhdGlvbi5wb3J0YFxuXHQgICAgaWYgKCFwb3J0KSB7XG5cdCAgICAgIHBvcnQgPSBpc1NTTCA/IDQ0MyA6IDgwO1xuXHQgICAgfVxuXHRcblx0ICAgIHhkID0gb3B0cy5ob3N0bmFtZSAhPT0gbG9jYXRpb24uaG9zdG5hbWUgfHwgcG9ydCAhPT0gb3B0cy5wb3J0O1xuXHQgICAgeHMgPSBvcHRzLnNlY3VyZSAhPT0gaXNTU0w7XG5cdCAgfVxuXHRcblx0ICBvcHRzLnhkb21haW4gPSB4ZDtcblx0ICBvcHRzLnhzY2hlbWUgPSB4cztcblx0ICB4aHIgPSBuZXcgWE1MSHR0cFJlcXVlc3Qob3B0cyk7XG5cdFxuXHQgIGlmICgnb3BlbicgaW4geGhyICYmICFvcHRzLmZvcmNlSlNPTlApIHtcblx0ICAgIHJldHVybiBuZXcgWEhSKG9wdHMpO1xuXHQgIH0gZWxzZSB7XG5cdCAgICBpZiAoIWpzb25wKSB0aHJvdyBuZXcgRXJyb3IoJ0pTT05QIGRpc2FibGVkJyk7XG5cdCAgICByZXR1cm4gbmV3IEpTT05QKG9wdHMpO1xuXHQgIH1cblx0fVxuXHRcblx0LyogV0VCUEFDSyBWQVIgSU5KRUNUSU9OICovfS5jYWxsKGV4cG9ydHMsIChmdW5jdGlvbigpIHsgcmV0dXJuIHRoaXM7IH0oKSkpKVxuXG4vKioqLyB9KSxcbi8qIDE1ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblx0LyogV0VCUEFDSyBWQVIgSU5KRUNUSU9OICovKGZ1bmN0aW9uKGdsb2JhbCkgey8vIGJyb3dzZXIgc2hpbSBmb3IgeG1saHR0cHJlcXVlc3QgbW9kdWxlXG5cdFxuXHR2YXIgaGFzQ09SUyA9IF9fd2VicGFja19yZXF1aXJlX18oMTYpO1xuXHRcblx0bW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAob3B0cykge1xuXHQgIHZhciB4ZG9tYWluID0gb3B0cy54ZG9tYWluO1xuXHRcblx0ICAvLyBzY2hlbWUgbXVzdCBiZSBzYW1lIHdoZW4gdXNpZ24gWERvbWFpblJlcXVlc3Rcblx0ICAvLyBodHRwOi8vYmxvZ3MubXNkbi5jb20vYi9pZWludGVybmFscy9hcmNoaXZlLzIwMTAvMDUvMTMveGRvbWFpbnJlcXVlc3QtcmVzdHJpY3Rpb25zLWxpbWl0YXRpb25zLWFuZC13b3JrYXJvdW5kcy5hc3B4XG5cdCAgdmFyIHhzY2hlbWUgPSBvcHRzLnhzY2hlbWU7XG5cdFxuXHQgIC8vIFhEb21haW5SZXF1ZXN0IGhhcyBhIGZsb3cgb2Ygbm90IHNlbmRpbmcgY29va2llLCB0aGVyZWZvcmUgaXQgc2hvdWxkIGJlIGRpc2FibGVkIGFzIGEgZGVmYXVsdC5cblx0ICAvLyBodHRwczovL2dpdGh1Yi5jb20vQXV0b21hdHRpYy9lbmdpbmUuaW8tY2xpZW50L3B1bGwvMjE3XG5cdCAgdmFyIGVuYWJsZXNYRFIgPSBvcHRzLmVuYWJsZXNYRFI7XG5cdFxuXHQgIC8vIFhNTEh0dHBSZXF1ZXN0IGNhbiBiZSBkaXNhYmxlZCBvbiBJRVxuXHQgIHRyeSB7XG5cdCAgICBpZiAoJ3VuZGVmaW5lZCcgIT09IHR5cGVvZiBYTUxIdHRwUmVxdWVzdCAmJiAoIXhkb21haW4gfHwgaGFzQ09SUykpIHtcblx0ICAgICAgcmV0dXJuIG5ldyBYTUxIdHRwUmVxdWVzdCgpO1xuXHQgICAgfVxuXHQgIH0gY2F0Y2ggKGUpIHsgfVxuXHRcblx0ICAvLyBVc2UgWERvbWFpblJlcXVlc3QgZm9yIElFOCBpZiBlbmFibGVzWERSIGlzIHRydWVcblx0ICAvLyBiZWNhdXNlIGxvYWRpbmcgYmFyIGtlZXBzIGZsYXNoaW5nIHdoZW4gdXNpbmcganNvbnAtcG9sbGluZ1xuXHQgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS95dWppb3Nha2Evc29ja2UuaW8taWU4LWxvYWRpbmctZXhhbXBsZVxuXHQgIHRyeSB7XG5cdCAgICBpZiAoJ3VuZGVmaW5lZCcgIT09IHR5cGVvZiBYRG9tYWluUmVxdWVzdCAmJiAheHNjaGVtZSAmJiBlbmFibGVzWERSKSB7XG5cdCAgICAgIHJldHVybiBuZXcgWERvbWFpblJlcXVlc3QoKTtcblx0ICAgIH1cblx0ICB9IGNhdGNoIChlKSB7IH1cblx0XG5cdCAgaWYgKCF4ZG9tYWluKSB7XG5cdCAgICB0cnkge1xuXHQgICAgICByZXR1cm4gbmV3IGdsb2JhbFtbJ0FjdGl2ZSddLmNvbmNhdCgnT2JqZWN0Jykuam9pbignWCcpXSgnTWljcm9zb2Z0LlhNTEhUVFAnKTtcblx0ICAgIH0gY2F0Y2ggKGUpIHsgfVxuXHQgIH1cblx0fTtcblx0XG5cdC8qIFdFQlBBQ0sgVkFSIElOSkVDVElPTiAqL30uY2FsbChleHBvcnRzLCAoZnVuY3Rpb24oKSB7IHJldHVybiB0aGlzOyB9KCkpKSlcblxuLyoqKi8gfSksXG4vKiAxNiAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xuXG5cdFxuXHQvKipcblx0ICogTW9kdWxlIGV4cG9ydHMuXG5cdCAqXG5cdCAqIExvZ2ljIGJvcnJvd2VkIGZyb20gTW9kZXJuaXpyOlxuXHQgKlxuXHQgKiAgIC0gaHR0cHM6Ly9naXRodWIuY29tL01vZGVybml6ci9Nb2Rlcm5penIvYmxvYi9tYXN0ZXIvZmVhdHVyZS1kZXRlY3RzL2NvcnMuanNcblx0ICovXG5cdFxuXHR0cnkge1xuXHQgIG1vZHVsZS5leHBvcnRzID0gdHlwZW9mIFhNTEh0dHBSZXF1ZXN0ICE9PSAndW5kZWZpbmVkJyAmJlxuXHQgICAgJ3dpdGhDcmVkZW50aWFscycgaW4gbmV3IFhNTEh0dHBSZXF1ZXN0KCk7XG5cdH0gY2F0Y2ggKGVycikge1xuXHQgIC8vIGlmIFhNTEh0dHAgc3VwcG9ydCBpcyBkaXNhYmxlZCBpbiBJRSB0aGVuIGl0IHdpbGwgdGhyb3dcblx0ICAvLyB3aGVuIHRyeWluZyB0byBjcmVhdGVcblx0ICBtb2R1bGUuZXhwb3J0cyA9IGZhbHNlO1xuXHR9XG5cblxuLyoqKi8gfSksXG4vKiAxNyAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cdC8qIFdFQlBBQ0sgVkFSIElOSkVDVElPTiAqLyhmdW5jdGlvbihnbG9iYWwpIHsvKipcblx0ICogTW9kdWxlIHJlcXVpcmVtZW50cy5cblx0ICovXG5cdFxuXHR2YXIgWE1MSHR0cFJlcXVlc3QgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDE1KTtcblx0dmFyIFBvbGxpbmcgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDE4KTtcblx0dmFyIEVtaXR0ZXIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDUpO1xuXHR2YXIgaW5oZXJpdCA9IF9fd2VicGFja19yZXF1aXJlX18oMjkpO1xuXHR2YXIgZGVidWcgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDMpKCdlbmdpbmUuaW8tY2xpZW50OnBvbGxpbmcteGhyJyk7XG5cdFxuXHQvKipcblx0ICogTW9kdWxlIGV4cG9ydHMuXG5cdCAqL1xuXHRcblx0bW9kdWxlLmV4cG9ydHMgPSBYSFI7XG5cdG1vZHVsZS5leHBvcnRzLlJlcXVlc3QgPSBSZXF1ZXN0O1xuXHRcblx0LyoqXG5cdCAqIEVtcHR5IGZ1bmN0aW9uXG5cdCAqL1xuXHRcblx0ZnVuY3Rpb24gZW1wdHkgKCkge31cblx0XG5cdC8qKlxuXHQgKiBYSFIgUG9sbGluZyBjb25zdHJ1Y3Rvci5cblx0ICpcblx0ICogQHBhcmFtIHtPYmplY3R9IG9wdHNcblx0ICogQGFwaSBwdWJsaWNcblx0ICovXG5cdFxuXHRmdW5jdGlvbiBYSFIgKG9wdHMpIHtcblx0ICBQb2xsaW5nLmNhbGwodGhpcywgb3B0cyk7XG5cdCAgdGhpcy5yZXF1ZXN0VGltZW91dCA9IG9wdHMucmVxdWVzdFRpbWVvdXQ7XG5cdCAgdGhpcy5leHRyYUhlYWRlcnMgPSBvcHRzLmV4dHJhSGVhZGVycztcblx0XG5cdCAgaWYgKGdsb2JhbC5sb2NhdGlvbikge1xuXHQgICAgdmFyIGlzU1NMID0gJ2h0dHBzOicgPT09IGxvY2F0aW9uLnByb3RvY29sO1xuXHQgICAgdmFyIHBvcnQgPSBsb2NhdGlvbi5wb3J0O1xuXHRcblx0ICAgIC8vIHNvbWUgdXNlciBhZ2VudHMgaGF2ZSBlbXB0eSBgbG9jYXRpb24ucG9ydGBcblx0ICAgIGlmICghcG9ydCkge1xuXHQgICAgICBwb3J0ID0gaXNTU0wgPyA0NDMgOiA4MDtcblx0ICAgIH1cblx0XG5cdCAgICB0aGlzLnhkID0gb3B0cy5ob3N0bmFtZSAhPT0gZ2xvYmFsLmxvY2F0aW9uLmhvc3RuYW1lIHx8XG5cdCAgICAgIHBvcnQgIT09IG9wdHMucG9ydDtcblx0ICAgIHRoaXMueHMgPSBvcHRzLnNlY3VyZSAhPT0gaXNTU0w7XG5cdCAgfVxuXHR9XG5cdFxuXHQvKipcblx0ICogSW5oZXJpdHMgZnJvbSBQb2xsaW5nLlxuXHQgKi9cblx0XG5cdGluaGVyaXQoWEhSLCBQb2xsaW5nKTtcblx0XG5cdC8qKlxuXHQgKiBYSFIgc3VwcG9ydHMgYmluYXJ5XG5cdCAqL1xuXHRcblx0WEhSLnByb3RvdHlwZS5zdXBwb3J0c0JpbmFyeSA9IHRydWU7XG5cdFxuXHQvKipcblx0ICogQ3JlYXRlcyBhIHJlcXVlc3QuXG5cdCAqXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBtZXRob2Rcblx0ICogQGFwaSBwcml2YXRlXG5cdCAqL1xuXHRcblx0WEhSLnByb3RvdHlwZS5yZXF1ZXN0ID0gZnVuY3Rpb24gKG9wdHMpIHtcblx0ICBvcHRzID0gb3B0cyB8fCB7fTtcblx0ICBvcHRzLnVyaSA9IHRoaXMudXJpKCk7XG5cdCAgb3B0cy54ZCA9IHRoaXMueGQ7XG5cdCAgb3B0cy54cyA9IHRoaXMueHM7XG5cdCAgb3B0cy5hZ2VudCA9IHRoaXMuYWdlbnQgfHwgZmFsc2U7XG5cdCAgb3B0cy5zdXBwb3J0c0JpbmFyeSA9IHRoaXMuc3VwcG9ydHNCaW5hcnk7XG5cdCAgb3B0cy5lbmFibGVzWERSID0gdGhpcy5lbmFibGVzWERSO1xuXHRcblx0ICAvLyBTU0wgb3B0aW9ucyBmb3IgTm9kZS5qcyBjbGllbnRcblx0ICBvcHRzLnBmeCA9IHRoaXMucGZ4O1xuXHQgIG9wdHMua2V5ID0gdGhpcy5rZXk7XG5cdCAgb3B0cy5wYXNzcGhyYXNlID0gdGhpcy5wYXNzcGhyYXNlO1xuXHQgIG9wdHMuY2VydCA9IHRoaXMuY2VydDtcblx0ICBvcHRzLmNhID0gdGhpcy5jYTtcblx0ICBvcHRzLmNpcGhlcnMgPSB0aGlzLmNpcGhlcnM7XG5cdCAgb3B0cy5yZWplY3RVbmF1dGhvcml6ZWQgPSB0aGlzLnJlamVjdFVuYXV0aG9yaXplZDtcblx0ICBvcHRzLnJlcXVlc3RUaW1lb3V0ID0gdGhpcy5yZXF1ZXN0VGltZW91dDtcblx0XG5cdCAgLy8gb3RoZXIgb3B0aW9ucyBmb3IgTm9kZS5qcyBjbGllbnRcblx0ICBvcHRzLmV4dHJhSGVhZGVycyA9IHRoaXMuZXh0cmFIZWFkZXJzO1xuXHRcblx0ICByZXR1cm4gbmV3IFJlcXVlc3Qob3B0cyk7XG5cdH07XG5cdFxuXHQvKipcblx0ICogU2VuZHMgZGF0YS5cblx0ICpcblx0ICogQHBhcmFtIHtTdHJpbmd9IGRhdGEgdG8gc2VuZC5cblx0ICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGVkIHVwb24gZmx1c2guXG5cdCAqIEBhcGkgcHJpdmF0ZVxuXHQgKi9cblx0XG5cdFhIUi5wcm90b3R5cGUuZG9Xcml0ZSA9IGZ1bmN0aW9uIChkYXRhLCBmbikge1xuXHQgIHZhciBpc0JpbmFyeSA9IHR5cGVvZiBkYXRhICE9PSAnc3RyaW5nJyAmJiBkYXRhICE9PSB1bmRlZmluZWQ7XG5cdCAgdmFyIHJlcSA9IHRoaXMucmVxdWVzdCh7IG1ldGhvZDogJ1BPU1QnLCBkYXRhOiBkYXRhLCBpc0JpbmFyeTogaXNCaW5hcnkgfSk7XG5cdCAgdmFyIHNlbGYgPSB0aGlzO1xuXHQgIHJlcS5vbignc3VjY2VzcycsIGZuKTtcblx0ICByZXEub24oJ2Vycm9yJywgZnVuY3Rpb24gKGVycikge1xuXHQgICAgc2VsZi5vbkVycm9yKCd4aHIgcG9zdCBlcnJvcicsIGVycik7XG5cdCAgfSk7XG5cdCAgdGhpcy5zZW5kWGhyID0gcmVxO1xuXHR9O1xuXHRcblx0LyoqXG5cdCAqIFN0YXJ0cyBhIHBvbGwgY3ljbGUuXG5cdCAqXG5cdCAqIEBhcGkgcHJpdmF0ZVxuXHQgKi9cblx0XG5cdFhIUi5wcm90b3R5cGUuZG9Qb2xsID0gZnVuY3Rpb24gKCkge1xuXHRcblx0ICB2YXIgcmVxID0gdGhpcy5yZXF1ZXN0KCk7XG5cdCAgdmFyIHNlbGYgPSB0aGlzO1xuXHQgIHJlcS5vbignZGF0YScsIGZ1bmN0aW9uIChkYXRhKSB7XG5cdCAgICBzZWxmLm9uRGF0YShkYXRhKTtcblx0ICB9KTtcblx0ICByZXEub24oJ2Vycm9yJywgZnVuY3Rpb24gKGVycikge1xuXHQgICAgc2VsZi5vbkVycm9yKCd4aHIgcG9sbCBlcnJvcicsIGVycik7XG5cdCAgfSk7XG5cdCAgdGhpcy5wb2xsWGhyID0gcmVxO1xuXHR9O1xuXHRcblx0LyoqXG5cdCAqIFJlcXVlc3QgY29uc3RydWN0b3Jcblx0ICpcblx0ICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcblx0ICogQGFwaSBwdWJsaWNcblx0ICovXG5cdFxuXHRmdW5jdGlvbiBSZXF1ZXN0IChvcHRzKSB7XG5cdCAgdGhpcy5tZXRob2QgPSBvcHRzLm1ldGhvZCB8fCAnR0VUJztcblx0ICB0aGlzLnVyaSA9IG9wdHMudXJpO1xuXHQgIHRoaXMueGQgPSAhIW9wdHMueGQ7XG5cdCAgdGhpcy54cyA9ICEhb3B0cy54cztcblx0ICB0aGlzLmFzeW5jID0gZmFsc2UgIT09IG9wdHMuYXN5bmM7XG5cdCAgdGhpcy5kYXRhID0gdW5kZWZpbmVkICE9PSBvcHRzLmRhdGEgPyBvcHRzLmRhdGEgOiBudWxsO1xuXHQgIHRoaXMuYWdlbnQgPSBvcHRzLmFnZW50O1xuXHQgIHRoaXMuaXNCaW5hcnkgPSBvcHRzLmlzQmluYXJ5O1xuXHQgIHRoaXMuc3VwcG9ydHNCaW5hcnkgPSBvcHRzLnN1cHBvcnRzQmluYXJ5O1xuXHQgIHRoaXMuZW5hYmxlc1hEUiA9IG9wdHMuZW5hYmxlc1hEUjtcblx0ICB0aGlzLnJlcXVlc3RUaW1lb3V0ID0gb3B0cy5yZXF1ZXN0VGltZW91dDtcblx0XG5cdCAgLy8gU1NMIG9wdGlvbnMgZm9yIE5vZGUuanMgY2xpZW50XG5cdCAgdGhpcy5wZnggPSBvcHRzLnBmeDtcblx0ICB0aGlzLmtleSA9IG9wdHMua2V5O1xuXHQgIHRoaXMucGFzc3BocmFzZSA9IG9wdHMucGFzc3BocmFzZTtcblx0ICB0aGlzLmNlcnQgPSBvcHRzLmNlcnQ7XG5cdCAgdGhpcy5jYSA9IG9wdHMuY2E7XG5cdCAgdGhpcy5jaXBoZXJzID0gb3B0cy5jaXBoZXJzO1xuXHQgIHRoaXMucmVqZWN0VW5hdXRob3JpemVkID0gb3B0cy5yZWplY3RVbmF1dGhvcml6ZWQ7XG5cdFxuXHQgIC8vIG90aGVyIG9wdGlvbnMgZm9yIE5vZGUuanMgY2xpZW50XG5cdCAgdGhpcy5leHRyYUhlYWRlcnMgPSBvcHRzLmV4dHJhSGVhZGVycztcblx0XG5cdCAgdGhpcy5jcmVhdGUoKTtcblx0fVxuXHRcblx0LyoqXG5cdCAqIE1peCBpbiBgRW1pdHRlcmAuXG5cdCAqL1xuXHRcblx0RW1pdHRlcihSZXF1ZXN0LnByb3RvdHlwZSk7XG5cdFxuXHQvKipcblx0ICogQ3JlYXRlcyB0aGUgWEhSIG9iamVjdCBhbmQgc2VuZHMgdGhlIHJlcXVlc3QuXG5cdCAqXG5cdCAqIEBhcGkgcHJpdmF0ZVxuXHQgKi9cblx0XG5cdFJlcXVlc3QucHJvdG90eXBlLmNyZWF0ZSA9IGZ1bmN0aW9uICgpIHtcblx0ICB2YXIgb3B0cyA9IHsgYWdlbnQ6IHRoaXMuYWdlbnQsIHhkb21haW46IHRoaXMueGQsIHhzY2hlbWU6IHRoaXMueHMsIGVuYWJsZXNYRFI6IHRoaXMuZW5hYmxlc1hEUiB9O1xuXHRcblx0ICAvLyBTU0wgb3B0aW9ucyBmb3IgTm9kZS5qcyBjbGllbnRcblx0ICBvcHRzLnBmeCA9IHRoaXMucGZ4O1xuXHQgIG9wdHMua2V5ID0gdGhpcy5rZXk7XG5cdCAgb3B0cy5wYXNzcGhyYXNlID0gdGhpcy5wYXNzcGhyYXNlO1xuXHQgIG9wdHMuY2VydCA9IHRoaXMuY2VydDtcblx0ICBvcHRzLmNhID0gdGhpcy5jYTtcblx0ICBvcHRzLmNpcGhlcnMgPSB0aGlzLmNpcGhlcnM7XG5cdCAgb3B0cy5yZWplY3RVbmF1dGhvcml6ZWQgPSB0aGlzLnJlamVjdFVuYXV0aG9yaXplZDtcblx0XG5cdCAgdmFyIHhociA9IHRoaXMueGhyID0gbmV3IFhNTEh0dHBSZXF1ZXN0KG9wdHMpO1xuXHQgIHZhciBzZWxmID0gdGhpcztcblx0XG5cdCAgdHJ5IHtcblx0XG5cdCAgICB4aHIub3Blbih0aGlzLm1ldGhvZCwgdGhpcy51cmksIHRoaXMuYXN5bmMpO1xuXHQgICAgdHJ5IHtcblx0ICAgICAgaWYgKHRoaXMuZXh0cmFIZWFkZXJzKSB7XG5cdCAgICAgICAgeGhyLnNldERpc2FibGVIZWFkZXJDaGVjayAmJiB4aHIuc2V0RGlzYWJsZUhlYWRlckNoZWNrKHRydWUpO1xuXHQgICAgICAgIGZvciAodmFyIGkgaW4gdGhpcy5leHRyYUhlYWRlcnMpIHtcblx0ICAgICAgICAgIGlmICh0aGlzLmV4dHJhSGVhZGVycy5oYXNPd25Qcm9wZXJ0eShpKSkge1xuXHQgICAgICAgICAgICB4aHIuc2V0UmVxdWVzdEhlYWRlcihpLCB0aGlzLmV4dHJhSGVhZGVyc1tpXSk7XG5cdCAgICAgICAgICB9XG5cdCAgICAgICAgfVxuXHQgICAgICB9XG5cdCAgICB9IGNhdGNoIChlKSB7fVxuXHRcblx0ICAgIGlmICgnUE9TVCcgPT09IHRoaXMubWV0aG9kKSB7XG5cdCAgICAgIHRyeSB7XG5cdCAgICAgICAgaWYgKHRoaXMuaXNCaW5hcnkpIHtcblx0ICAgICAgICAgIHhoci5zZXRSZXF1ZXN0SGVhZGVyKCdDb250ZW50LXR5cGUnLCAnYXBwbGljYXRpb24vb2N0ZXQtc3RyZWFtJyk7XG5cdCAgICAgICAgfSBlbHNlIHtcblx0ICAgICAgICAgIHhoci5zZXRSZXF1ZXN0SGVhZGVyKCdDb250ZW50LXR5cGUnLCAndGV4dC9wbGFpbjtjaGFyc2V0PVVURi04Jyk7XG5cdCAgICAgICAgfVxuXHQgICAgICB9IGNhdGNoIChlKSB7fVxuXHQgICAgfVxuXHRcblx0ICAgIHRyeSB7XG5cdCAgICAgIHhoci5zZXRSZXF1ZXN0SGVhZGVyKCdBY2NlcHQnLCAnKi8qJyk7XG5cdCAgICB9IGNhdGNoIChlKSB7fVxuXHRcblx0ICAgIC8vIGllNiBjaGVja1xuXHQgICAgaWYgKCd3aXRoQ3JlZGVudGlhbHMnIGluIHhocikge1xuXHQgICAgICB4aHIud2l0aENyZWRlbnRpYWxzID0gdHJ1ZTtcblx0ICAgIH1cblx0XG5cdCAgICBpZiAodGhpcy5yZXF1ZXN0VGltZW91dCkge1xuXHQgICAgICB4aHIudGltZW91dCA9IHRoaXMucmVxdWVzdFRpbWVvdXQ7XG5cdCAgICB9XG5cdFxuXHQgICAgaWYgKHRoaXMuaGFzWERSKCkpIHtcblx0ICAgICAgeGhyLm9ubG9hZCA9IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICBzZWxmLm9uTG9hZCgpO1xuXHQgICAgICB9O1xuXHQgICAgICB4aHIub25lcnJvciA9IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICBzZWxmLm9uRXJyb3IoeGhyLnJlc3BvbnNlVGV4dCk7XG5cdCAgICAgIH07XG5cdCAgICB9IGVsc2Uge1xuXHQgICAgICB4aHIub25yZWFkeXN0YXRlY2hhbmdlID0gZnVuY3Rpb24gKCkge1xuXHQgICAgICAgIGlmICh4aHIucmVhZHlTdGF0ZSA9PT0gMikge1xuXHQgICAgICAgICAgdmFyIGNvbnRlbnRUeXBlO1xuXHQgICAgICAgICAgdHJ5IHtcblx0ICAgICAgICAgICAgY29udGVudFR5cGUgPSB4aHIuZ2V0UmVzcG9uc2VIZWFkZXIoJ0NvbnRlbnQtVHlwZScpO1xuXHQgICAgICAgICAgfSBjYXRjaCAoZSkge31cblx0ICAgICAgICAgIGlmIChjb250ZW50VHlwZSA9PT0gJ2FwcGxpY2F0aW9uL29jdGV0LXN0cmVhbScpIHtcblx0ICAgICAgICAgICAgeGhyLnJlc3BvbnNlVHlwZSA9ICdhcnJheWJ1ZmZlcic7XG5cdCAgICAgICAgICB9XG5cdCAgICAgICAgfVxuXHQgICAgICAgIGlmICg0ICE9PSB4aHIucmVhZHlTdGF0ZSkgcmV0dXJuO1xuXHQgICAgICAgIGlmICgyMDAgPT09IHhoci5zdGF0dXMgfHwgMTIyMyA9PT0geGhyLnN0YXR1cykge1xuXHQgICAgICAgICAgc2VsZi5vbkxvYWQoKTtcblx0ICAgICAgICB9IGVsc2Uge1xuXHQgICAgICAgICAgLy8gbWFrZSBzdXJlIHRoZSBgZXJyb3JgIGV2ZW50IGhhbmRsZXIgdGhhdCdzIHVzZXItc2V0XG5cdCAgICAgICAgICAvLyBkb2VzIG5vdCB0aHJvdyBpbiB0aGUgc2FtZSB0aWNrIGFuZCBnZXRzIGNhdWdodCBoZXJlXG5cdCAgICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgc2VsZi5vbkVycm9yKHhoci5zdGF0dXMpO1xuXHQgICAgICAgICAgfSwgMCk7XG5cdCAgICAgICAgfVxuXHQgICAgICB9O1xuXHQgICAgfVxuXHRcblx0XG5cdCAgICB4aHIuc2VuZCh0aGlzLmRhdGEpO1xuXHQgIH0gY2F0Y2ggKGUpIHtcblx0ICAgIC8vIE5lZWQgdG8gZGVmZXIgc2luY2UgLmNyZWF0ZSgpIGlzIGNhbGxlZCBkaXJlY3RseSBmaHJvbSB0aGUgY29uc3RydWN0b3Jcblx0ICAgIC8vIGFuZCB0aHVzIHRoZSAnZXJyb3InIGV2ZW50IGNhbiBvbmx5IGJlIG9ubHkgYm91bmQgKmFmdGVyKiB0aGlzIGV4Y2VwdGlvblxuXHQgICAgLy8gb2NjdXJzLiAgVGhlcmVmb3JlLCBhbHNvLCB3ZSBjYW5ub3QgdGhyb3cgaGVyZSBhdCBhbGwuXG5cdCAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcblx0ICAgICAgc2VsZi5vbkVycm9yKGUpO1xuXHQgICAgfSwgMCk7XG5cdCAgICByZXR1cm47XG5cdCAgfVxuXHRcblx0ICBpZiAoZ2xvYmFsLmRvY3VtZW50KSB7XG5cdCAgICB0aGlzLmluZGV4ID0gUmVxdWVzdC5yZXF1ZXN0c0NvdW50Kys7XG5cdCAgICBSZXF1ZXN0LnJlcXVlc3RzW3RoaXMuaW5kZXhdID0gdGhpcztcblx0ICB9XG5cdH07XG5cdFxuXHQvKipcblx0ICogQ2FsbGVkIHVwb24gc3VjY2Vzc2Z1bCByZXNwb25zZS5cblx0ICpcblx0ICogQGFwaSBwcml2YXRlXG5cdCAqL1xuXHRcblx0UmVxdWVzdC5wcm90b3R5cGUub25TdWNjZXNzID0gZnVuY3Rpb24gKCkge1xuXHQgIHRoaXMuZW1pdCgnc3VjY2VzcycpO1xuXHQgIHRoaXMuY2xlYW51cCgpO1xuXHR9O1xuXHRcblx0LyoqXG5cdCAqIENhbGxlZCBpZiB3ZSBoYXZlIGRhdGEuXG5cdCAqXG5cdCAqIEBhcGkgcHJpdmF0ZVxuXHQgKi9cblx0XG5cdFJlcXVlc3QucHJvdG90eXBlLm9uRGF0YSA9IGZ1bmN0aW9uIChkYXRhKSB7XG5cdCAgdGhpcy5lbWl0KCdkYXRhJywgZGF0YSk7XG5cdCAgdGhpcy5vblN1Y2Nlc3MoKTtcblx0fTtcblx0XG5cdC8qKlxuXHQgKiBDYWxsZWQgdXBvbiBlcnJvci5cblx0ICpcblx0ICogQGFwaSBwcml2YXRlXG5cdCAqL1xuXHRcblx0UmVxdWVzdC5wcm90b3R5cGUub25FcnJvciA9IGZ1bmN0aW9uIChlcnIpIHtcblx0ICB0aGlzLmVtaXQoJ2Vycm9yJywgZXJyKTtcblx0ICB0aGlzLmNsZWFudXAodHJ1ZSk7XG5cdH07XG5cdFxuXHQvKipcblx0ICogQ2xlYW5zIHVwIGhvdXNlLlxuXHQgKlxuXHQgKiBAYXBpIHByaXZhdGVcblx0ICovXG5cdFxuXHRSZXF1ZXN0LnByb3RvdHlwZS5jbGVhbnVwID0gZnVuY3Rpb24gKGZyb21FcnJvcikge1xuXHQgIGlmICgndW5kZWZpbmVkJyA9PT0gdHlwZW9mIHRoaXMueGhyIHx8IG51bGwgPT09IHRoaXMueGhyKSB7XG5cdCAgICByZXR1cm47XG5cdCAgfVxuXHQgIC8vIHhtbGh0dHByZXF1ZXN0XG5cdCAgaWYgKHRoaXMuaGFzWERSKCkpIHtcblx0ICAgIHRoaXMueGhyLm9ubG9hZCA9IHRoaXMueGhyLm9uZXJyb3IgPSBlbXB0eTtcblx0ICB9IGVsc2Uge1xuXHQgICAgdGhpcy54aHIub25yZWFkeXN0YXRlY2hhbmdlID0gZW1wdHk7XG5cdCAgfVxuXHRcblx0ICBpZiAoZnJvbUVycm9yKSB7XG5cdCAgICB0cnkge1xuXHQgICAgICB0aGlzLnhoci5hYm9ydCgpO1xuXHQgICAgfSBjYXRjaCAoZSkge31cblx0ICB9XG5cdFxuXHQgIGlmIChnbG9iYWwuZG9jdW1lbnQpIHtcblx0ICAgIGRlbGV0ZSBSZXF1ZXN0LnJlcXVlc3RzW3RoaXMuaW5kZXhdO1xuXHQgIH1cblx0XG5cdCAgdGhpcy54aHIgPSBudWxsO1xuXHR9O1xuXHRcblx0LyoqXG5cdCAqIENhbGxlZCB1cG9uIGxvYWQuXG5cdCAqXG5cdCAqIEBhcGkgcHJpdmF0ZVxuXHQgKi9cblx0XG5cdFJlcXVlc3QucHJvdG90eXBlLm9uTG9hZCA9IGZ1bmN0aW9uICgpIHtcblx0ICB2YXIgZGF0YTtcblx0ICB0cnkge1xuXHQgICAgdmFyIGNvbnRlbnRUeXBlO1xuXHQgICAgdHJ5IHtcblx0ICAgICAgY29udGVudFR5cGUgPSB0aGlzLnhoci5nZXRSZXNwb25zZUhlYWRlcignQ29udGVudC1UeXBlJyk7XG5cdCAgICB9IGNhdGNoIChlKSB7fVxuXHQgICAgaWYgKGNvbnRlbnRUeXBlID09PSAnYXBwbGljYXRpb24vb2N0ZXQtc3RyZWFtJykge1xuXHQgICAgICBkYXRhID0gdGhpcy54aHIucmVzcG9uc2UgfHwgdGhpcy54aHIucmVzcG9uc2VUZXh0O1xuXHQgICAgfSBlbHNlIHtcblx0ICAgICAgZGF0YSA9IHRoaXMueGhyLnJlc3BvbnNlVGV4dDtcblx0ICAgIH1cblx0ICB9IGNhdGNoIChlKSB7XG5cdCAgICB0aGlzLm9uRXJyb3IoZSk7XG5cdCAgfVxuXHQgIGlmIChudWxsICE9IGRhdGEpIHtcblx0ICAgIHRoaXMub25EYXRhKGRhdGEpO1xuXHQgIH1cblx0fTtcblx0XG5cdC8qKlxuXHQgKiBDaGVjayBpZiBpdCBoYXMgWERvbWFpblJlcXVlc3QuXG5cdCAqXG5cdCAqIEBhcGkgcHJpdmF0ZVxuXHQgKi9cblx0XG5cdFJlcXVlc3QucHJvdG90eXBlLmhhc1hEUiA9IGZ1bmN0aW9uICgpIHtcblx0ICByZXR1cm4gJ3VuZGVmaW5lZCcgIT09IHR5cGVvZiBnbG9iYWwuWERvbWFpblJlcXVlc3QgJiYgIXRoaXMueHMgJiYgdGhpcy5lbmFibGVzWERSO1xuXHR9O1xuXHRcblx0LyoqXG5cdCAqIEFib3J0cyB0aGUgcmVxdWVzdC5cblx0ICpcblx0ICogQGFwaSBwdWJsaWNcblx0ICovXG5cdFxuXHRSZXF1ZXN0LnByb3RvdHlwZS5hYm9ydCA9IGZ1bmN0aW9uICgpIHtcblx0ICB0aGlzLmNsZWFudXAoKTtcblx0fTtcblx0XG5cdC8qKlxuXHQgKiBBYm9ydHMgcGVuZGluZyByZXF1ZXN0cyB3aGVuIHVubG9hZGluZyB0aGUgd2luZG93LiBUaGlzIGlzIG5lZWRlZCB0byBwcmV2ZW50XG5cdCAqIG1lbW9yeSBsZWFrcyAoZS5nLiB3aGVuIHVzaW5nIElFKSBhbmQgdG8gZW5zdXJlIHRoYXQgbm8gc3B1cmlvdXMgZXJyb3IgaXNcblx0ICogZW1pdHRlZC5cblx0ICovXG5cdFxuXHRSZXF1ZXN0LnJlcXVlc3RzQ291bnQgPSAwO1xuXHRSZXF1ZXN0LnJlcXVlc3RzID0ge307XG5cdFxuXHRpZiAoZ2xvYmFsLmRvY3VtZW50KSB7XG5cdCAgaWYgKGdsb2JhbC5hdHRhY2hFdmVudCkge1xuXHQgICAgZ2xvYmFsLmF0dGFjaEV2ZW50KCdvbnVubG9hZCcsIHVubG9hZEhhbmRsZXIpO1xuXHQgIH0gZWxzZSBpZiAoZ2xvYmFsLmFkZEV2ZW50TGlzdGVuZXIpIHtcblx0ICAgIGdsb2JhbC5hZGRFdmVudExpc3RlbmVyKCdiZWZvcmV1bmxvYWQnLCB1bmxvYWRIYW5kbGVyLCBmYWxzZSk7XG5cdCAgfVxuXHR9XG5cdFxuXHRmdW5jdGlvbiB1bmxvYWRIYW5kbGVyICgpIHtcblx0ICBmb3IgKHZhciBpIGluIFJlcXVlc3QucmVxdWVzdHMpIHtcblx0ICAgIGlmIChSZXF1ZXN0LnJlcXVlc3RzLmhhc093blByb3BlcnR5KGkpKSB7XG5cdCAgICAgIFJlcXVlc3QucmVxdWVzdHNbaV0uYWJvcnQoKTtcblx0ICAgIH1cblx0ICB9XG5cdH1cblx0XG5cdC8qIFdFQlBBQ0sgVkFSIElOSkVDVElPTiAqL30uY2FsbChleHBvcnRzLCAoZnVuY3Rpb24oKSB7IHJldHVybiB0aGlzOyB9KCkpKSlcblxuLyoqKi8gfSksXG4vKiAxOCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cdC8qKlxuXHQgKiBNb2R1bGUgZGVwZW5kZW5jaWVzLlxuXHQgKi9cblx0XG5cdHZhciBUcmFuc3BvcnQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDE5KTtcblx0dmFyIHBhcnNlcXMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDI4KTtcblx0dmFyIHBhcnNlciA9IF9fd2VicGFja19yZXF1aXJlX18oMjApO1xuXHR2YXIgaW5oZXJpdCA9IF9fd2VicGFja19yZXF1aXJlX18oMjkpO1xuXHR2YXIgeWVhc3QgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDMwKTtcblx0dmFyIGRlYnVnID0gX193ZWJwYWNrX3JlcXVpcmVfXygzKSgnZW5naW5lLmlvLWNsaWVudDpwb2xsaW5nJyk7XG5cdFxuXHQvKipcblx0ICogTW9kdWxlIGV4cG9ydHMuXG5cdCAqL1xuXHRcblx0bW9kdWxlLmV4cG9ydHMgPSBQb2xsaW5nO1xuXHRcblx0LyoqXG5cdCAqIElzIFhIUjIgc3VwcG9ydGVkP1xuXHQgKi9cblx0XG5cdHZhciBoYXNYSFIyID0gKGZ1bmN0aW9uICgpIHtcblx0ICB2YXIgWE1MSHR0cFJlcXVlc3QgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDE1KTtcblx0ICB2YXIgeGhyID0gbmV3IFhNTEh0dHBSZXF1ZXN0KHsgeGRvbWFpbjogZmFsc2UgfSk7XG5cdCAgcmV0dXJuIG51bGwgIT0geGhyLnJlc3BvbnNlVHlwZTtcblx0fSkoKTtcblx0XG5cdC8qKlxuXHQgKiBQb2xsaW5nIGludGVyZmFjZS5cblx0ICpcblx0ICogQHBhcmFtIHtPYmplY3R9IG9wdHNcblx0ICogQGFwaSBwcml2YXRlXG5cdCAqL1xuXHRcblx0ZnVuY3Rpb24gUG9sbGluZyAob3B0cykge1xuXHQgIHZhciBmb3JjZUJhc2U2NCA9IChvcHRzICYmIG9wdHMuZm9yY2VCYXNlNjQpO1xuXHQgIGlmICghaGFzWEhSMiB8fCBmb3JjZUJhc2U2NCkge1xuXHQgICAgdGhpcy5zdXBwb3J0c0JpbmFyeSA9IGZhbHNlO1xuXHQgIH1cblx0ICBUcmFuc3BvcnQuY2FsbCh0aGlzLCBvcHRzKTtcblx0fVxuXHRcblx0LyoqXG5cdCAqIEluaGVyaXRzIGZyb20gVHJhbnNwb3J0LlxuXHQgKi9cblx0XG5cdGluaGVyaXQoUG9sbGluZywgVHJhbnNwb3J0KTtcblx0XG5cdC8qKlxuXHQgKiBUcmFuc3BvcnQgbmFtZS5cblx0ICovXG5cdFxuXHRQb2xsaW5nLnByb3RvdHlwZS5uYW1lID0gJ3BvbGxpbmcnO1xuXHRcblx0LyoqXG5cdCAqIE9wZW5zIHRoZSBzb2NrZXQgKHRyaWdnZXJzIHBvbGxpbmcpLiBXZSB3cml0ZSBhIFBJTkcgbWVzc2FnZSB0byBkZXRlcm1pbmVcblx0ICogd2hlbiB0aGUgdHJhbnNwb3J0IGlzIG9wZW4uXG5cdCAqXG5cdCAqIEBhcGkgcHJpdmF0ZVxuXHQgKi9cblx0XG5cdFBvbGxpbmcucHJvdG90eXBlLmRvT3BlbiA9IGZ1bmN0aW9uICgpIHtcblx0ICB0aGlzLnBvbGwoKTtcblx0fTtcblx0XG5cdC8qKlxuXHQgKiBQYXVzZXMgcG9sbGluZy5cblx0ICpcblx0ICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2sgdXBvbiBidWZmZXJzIGFyZSBmbHVzaGVkIGFuZCB0cmFuc3BvcnQgaXMgcGF1c2VkXG5cdCAqIEBhcGkgcHJpdmF0ZVxuXHQgKi9cblx0XG5cdFBvbGxpbmcucHJvdG90eXBlLnBhdXNlID0gZnVuY3Rpb24gKG9uUGF1c2UpIHtcblx0ICB2YXIgc2VsZiA9IHRoaXM7XG5cdFxuXHQgIHRoaXMucmVhZHlTdGF0ZSA9ICdwYXVzaW5nJztcblx0XG5cdCAgZnVuY3Rpb24gcGF1c2UgKCkge1xuXHRcblx0ICAgIHNlbGYucmVhZHlTdGF0ZSA9ICdwYXVzZWQnO1xuXHQgICAgb25QYXVzZSgpO1xuXHQgIH1cblx0XG5cdCAgaWYgKHRoaXMucG9sbGluZyB8fCAhdGhpcy53cml0YWJsZSkge1xuXHQgICAgdmFyIHRvdGFsID0gMDtcblx0XG5cdCAgICBpZiAodGhpcy5wb2xsaW5nKSB7XG5cdFxuXHQgICAgICB0b3RhbCsrO1xuXHQgICAgICB0aGlzLm9uY2UoJ3BvbGxDb21wbGV0ZScsIGZ1bmN0aW9uICgpIHtcblx0XG5cdCAgICAgICAgLS10b3RhbCB8fCBwYXVzZSgpO1xuXHQgICAgICB9KTtcblx0ICAgIH1cblx0XG5cdCAgICBpZiAoIXRoaXMud3JpdGFibGUpIHtcblx0XG5cdCAgICAgIHRvdGFsKys7XG5cdCAgICAgIHRoaXMub25jZSgnZHJhaW4nLCBmdW5jdGlvbiAoKSB7XG5cdFxuXHQgICAgICAgIC0tdG90YWwgfHwgcGF1c2UoKTtcblx0ICAgICAgfSk7XG5cdCAgICB9XG5cdCAgfSBlbHNlIHtcblx0ICAgIHBhdXNlKCk7XG5cdCAgfVxuXHR9O1xuXHRcblx0LyoqXG5cdCAqIFN0YXJ0cyBwb2xsaW5nIGN5Y2xlLlxuXHQgKlxuXHQgKiBAYXBpIHB1YmxpY1xuXHQgKi9cblx0XG5cdFBvbGxpbmcucHJvdG90eXBlLnBvbGwgPSBmdW5jdGlvbiAoKSB7XG5cdFxuXHQgIHRoaXMucG9sbGluZyA9IHRydWU7XG5cdCAgdGhpcy5kb1BvbGwoKTtcblx0ICB0aGlzLmVtaXQoJ3BvbGwnKTtcblx0fTtcblx0XG5cdC8qKlxuXHQgKiBPdmVybG9hZHMgb25EYXRhIHRvIGRldGVjdCBwYXlsb2Fkcy5cblx0ICpcblx0ICogQGFwaSBwcml2YXRlXG5cdCAqL1xuXHRcblx0UG9sbGluZy5wcm90b3R5cGUub25EYXRhID0gZnVuY3Rpb24gKGRhdGEpIHtcblx0ICB2YXIgc2VsZiA9IHRoaXM7XG5cdFxuXHQgIHZhciBjYWxsYmFjayA9IGZ1bmN0aW9uIChwYWNrZXQsIGluZGV4LCB0b3RhbCkge1xuXHQgICAgLy8gaWYgaXRzIHRoZSBmaXJzdCBtZXNzYWdlIHdlIGNvbnNpZGVyIHRoZSB0cmFuc3BvcnQgb3BlblxuXHQgICAgaWYgKCdvcGVuaW5nJyA9PT0gc2VsZi5yZWFkeVN0YXRlKSB7XG5cdCAgICAgIHNlbGYub25PcGVuKCk7XG5cdCAgICB9XG5cdFxuXHQgICAgLy8gaWYgaXRzIGEgY2xvc2UgcGFja2V0LCB3ZSBjbG9zZSB0aGUgb25nb2luZyByZXF1ZXN0c1xuXHQgICAgaWYgKCdjbG9zZScgPT09IHBhY2tldC50eXBlKSB7XG5cdCAgICAgIHNlbGYub25DbG9zZSgpO1xuXHQgICAgICByZXR1cm4gZmFsc2U7XG5cdCAgICB9XG5cdFxuXHQgICAgLy8gb3RoZXJ3aXNlIGJ5cGFzcyBvbkRhdGEgYW5kIGhhbmRsZSB0aGUgbWVzc2FnZVxuXHQgICAgc2VsZi5vblBhY2tldChwYWNrZXQpO1xuXHQgIH07XG5cdFxuXHQgIC8vIGRlY29kZSBwYXlsb2FkXG5cdCAgcGFyc2VyLmRlY29kZVBheWxvYWQoZGF0YSwgdGhpcy5zb2NrZXQuYmluYXJ5VHlwZSwgY2FsbGJhY2spO1xuXHRcblx0ICAvLyBpZiBhbiBldmVudCBkaWQgbm90IHRyaWdnZXIgY2xvc2luZ1xuXHQgIGlmICgnY2xvc2VkJyAhPT0gdGhpcy5yZWFkeVN0YXRlKSB7XG5cdCAgICAvLyBpZiB3ZSBnb3QgZGF0YSB3ZSdyZSBub3QgcG9sbGluZ1xuXHQgICAgdGhpcy5wb2xsaW5nID0gZmFsc2U7XG5cdCAgICB0aGlzLmVtaXQoJ3BvbGxDb21wbGV0ZScpO1xuXHRcblx0ICAgIGlmICgnb3BlbicgPT09IHRoaXMucmVhZHlTdGF0ZSkge1xuXHQgICAgICB0aGlzLnBvbGwoKTtcblx0ICAgIH0gZWxzZSB7XG5cdFxuXHQgICAgfVxuXHQgIH1cblx0fTtcblx0XG5cdC8qKlxuXHQgKiBGb3IgcG9sbGluZywgc2VuZCBhIGNsb3NlIHBhY2tldC5cblx0ICpcblx0ICogQGFwaSBwcml2YXRlXG5cdCAqL1xuXHRcblx0UG9sbGluZy5wcm90b3R5cGUuZG9DbG9zZSA9IGZ1bmN0aW9uICgpIHtcblx0ICB2YXIgc2VsZiA9IHRoaXM7XG5cdFxuXHQgIGZ1bmN0aW9uIGNsb3NlICgpIHtcblx0XG5cdCAgICBzZWxmLndyaXRlKFt7IHR5cGU6ICdjbG9zZScgfV0pO1xuXHQgIH1cblx0XG5cdCAgaWYgKCdvcGVuJyA9PT0gdGhpcy5yZWFkeVN0YXRlKSB7XG5cdFxuXHQgICAgY2xvc2UoKTtcblx0ICB9IGVsc2Uge1xuXHQgICAgLy8gaW4gY2FzZSB3ZSdyZSB0cnlpbmcgdG8gY2xvc2Ugd2hpbGVcblx0ICAgIC8vIGhhbmRzaGFraW5nIGlzIGluIHByb2dyZXNzIChHSC0xNjQpXG5cdFxuXHQgICAgdGhpcy5vbmNlKCdvcGVuJywgY2xvc2UpO1xuXHQgIH1cblx0fTtcblx0XG5cdC8qKlxuXHQgKiBXcml0ZXMgYSBwYWNrZXRzIHBheWxvYWQuXG5cdCAqXG5cdCAqIEBwYXJhbSB7QXJyYXl9IGRhdGEgcGFja2V0c1xuXHQgKiBAcGFyYW0ge0Z1bmN0aW9ufSBkcmFpbiBjYWxsYmFja1xuXHQgKiBAYXBpIHByaXZhdGVcblx0ICovXG5cdFxuXHRQb2xsaW5nLnByb3RvdHlwZS53cml0ZSA9IGZ1bmN0aW9uIChwYWNrZXRzKSB7XG5cdCAgdmFyIHNlbGYgPSB0aGlzO1xuXHQgIHRoaXMud3JpdGFibGUgPSBmYWxzZTtcblx0ICB2YXIgY2FsbGJhY2tmbiA9IGZ1bmN0aW9uICgpIHtcblx0ICAgIHNlbGYud3JpdGFibGUgPSB0cnVlO1xuXHQgICAgc2VsZi5lbWl0KCdkcmFpbicpO1xuXHQgIH07XG5cdFxuXHQgIHBhcnNlci5lbmNvZGVQYXlsb2FkKHBhY2tldHMsIHRoaXMuc3VwcG9ydHNCaW5hcnksIGZ1bmN0aW9uIChkYXRhKSB7XG5cdCAgICBzZWxmLmRvV3JpdGUoZGF0YSwgY2FsbGJhY2tmbik7XG5cdCAgfSk7XG5cdH07XG5cdFxuXHQvKipcblx0ICogR2VuZXJhdGVzIHVyaSBmb3IgY29ubmVjdGlvbi5cblx0ICpcblx0ICogQGFwaSBwcml2YXRlXG5cdCAqL1xuXHRcblx0UG9sbGluZy5wcm90b3R5cGUudXJpID0gZnVuY3Rpb24gKCkge1xuXHQgIHZhciBxdWVyeSA9IHRoaXMucXVlcnkgfHwge307XG5cdCAgdmFyIHNjaGVtYSA9IHRoaXMuc2VjdXJlID8gJ2h0dHBzJyA6ICdodHRwJztcblx0ICB2YXIgcG9ydCA9ICcnO1xuXHRcblx0ICAvLyBjYWNoZSBidXN0aW5nIGlzIGZvcmNlZFxuXHQgIGlmIChmYWxzZSAhPT0gdGhpcy50aW1lc3RhbXBSZXF1ZXN0cykge1xuXHQgICAgcXVlcnlbdGhpcy50aW1lc3RhbXBQYXJhbV0gPSB5ZWFzdCgpO1xuXHQgIH1cblx0XG5cdCAgaWYgKCF0aGlzLnN1cHBvcnRzQmluYXJ5ICYmICFxdWVyeS5zaWQpIHtcblx0ICAgIHF1ZXJ5LmI2NCA9IDE7XG5cdCAgfVxuXHRcblx0ICBxdWVyeSA9IHBhcnNlcXMuZW5jb2RlKHF1ZXJ5KTtcblx0XG5cdCAgLy8gYXZvaWQgcG9ydCBpZiBkZWZhdWx0IGZvciBzY2hlbWFcblx0ICBpZiAodGhpcy5wb3J0ICYmICgoJ2h0dHBzJyA9PT0gc2NoZW1hICYmIE51bWJlcih0aGlzLnBvcnQpICE9PSA0NDMpIHx8XG5cdCAgICAgKCdodHRwJyA9PT0gc2NoZW1hICYmIE51bWJlcih0aGlzLnBvcnQpICE9PSA4MCkpKSB7XG5cdCAgICBwb3J0ID0gJzonICsgdGhpcy5wb3J0O1xuXHQgIH1cblx0XG5cdCAgLy8gcHJlcGVuZCA/IHRvIHF1ZXJ5XG5cdCAgaWYgKHF1ZXJ5Lmxlbmd0aCkge1xuXHQgICAgcXVlcnkgPSAnPycgKyBxdWVyeTtcblx0ICB9XG5cdFxuXHQgIHZhciBpcHY2ID0gdGhpcy5ob3N0bmFtZS5pbmRleE9mKCc6JykgIT09IC0xO1xuXHQgIHJldHVybiBzY2hlbWEgKyAnOi8vJyArIChpcHY2ID8gJ1snICsgdGhpcy5ob3N0bmFtZSArICddJyA6IHRoaXMuaG9zdG5hbWUpICsgcG9ydCArIHRoaXMucGF0aCArIHF1ZXJ5O1xuXHR9O1xuXG5cbi8qKiovIH0pLFxuLyogMTkgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXHQvKipcblx0ICogTW9kdWxlIGRlcGVuZGVuY2llcy5cblx0ICovXG5cdFxuXHR2YXIgcGFyc2VyID0gX193ZWJwYWNrX3JlcXVpcmVfXygyMCk7XG5cdHZhciBFbWl0dGVyID0gX193ZWJwYWNrX3JlcXVpcmVfXyg1KTtcblx0XG5cdC8qKlxuXHQgKiBNb2R1bGUgZXhwb3J0cy5cblx0ICovXG5cdFxuXHRtb2R1bGUuZXhwb3J0cyA9IFRyYW5zcG9ydDtcblx0XG5cdC8qKlxuXHQgKiBUcmFuc3BvcnQgYWJzdHJhY3QgY29uc3RydWN0b3IuXG5cdCAqXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zLlxuXHQgKiBAYXBpIHByaXZhdGVcblx0ICovXG5cdFxuXHRmdW5jdGlvbiBUcmFuc3BvcnQgKG9wdHMpIHtcblx0ICB0aGlzLnBhdGggPSBvcHRzLnBhdGg7XG5cdCAgdGhpcy5ob3N0bmFtZSA9IG9wdHMuaG9zdG5hbWU7XG5cdCAgdGhpcy5wb3J0ID0gb3B0cy5wb3J0O1xuXHQgIHRoaXMuc2VjdXJlID0gb3B0cy5zZWN1cmU7XG5cdCAgdGhpcy5xdWVyeSA9IG9wdHMucXVlcnk7XG5cdCAgdGhpcy50aW1lc3RhbXBQYXJhbSA9IG9wdHMudGltZXN0YW1wUGFyYW07XG5cdCAgdGhpcy50aW1lc3RhbXBSZXF1ZXN0cyA9IG9wdHMudGltZXN0YW1wUmVxdWVzdHM7XG5cdCAgdGhpcy5yZWFkeVN0YXRlID0gJyc7XG5cdCAgdGhpcy5hZ2VudCA9IG9wdHMuYWdlbnQgfHwgZmFsc2U7XG5cdCAgdGhpcy5zb2NrZXQgPSBvcHRzLnNvY2tldDtcblx0ICB0aGlzLmVuYWJsZXNYRFIgPSBvcHRzLmVuYWJsZXNYRFI7XG5cdFxuXHQgIC8vIFNTTCBvcHRpb25zIGZvciBOb2RlLmpzIGNsaWVudFxuXHQgIHRoaXMucGZ4ID0gb3B0cy5wZng7XG5cdCAgdGhpcy5rZXkgPSBvcHRzLmtleTtcblx0ICB0aGlzLnBhc3NwaHJhc2UgPSBvcHRzLnBhc3NwaHJhc2U7XG5cdCAgdGhpcy5jZXJ0ID0gb3B0cy5jZXJ0O1xuXHQgIHRoaXMuY2EgPSBvcHRzLmNhO1xuXHQgIHRoaXMuY2lwaGVycyA9IG9wdHMuY2lwaGVycztcblx0ICB0aGlzLnJlamVjdFVuYXV0aG9yaXplZCA9IG9wdHMucmVqZWN0VW5hdXRob3JpemVkO1xuXHQgIHRoaXMuZm9yY2VOb2RlID0gb3B0cy5mb3JjZU5vZGU7XG5cdFxuXHQgIC8vIG90aGVyIG9wdGlvbnMgZm9yIE5vZGUuanMgY2xpZW50XG5cdCAgdGhpcy5leHRyYUhlYWRlcnMgPSBvcHRzLmV4dHJhSGVhZGVycztcblx0ICB0aGlzLmxvY2FsQWRkcmVzcyA9IG9wdHMubG9jYWxBZGRyZXNzO1xuXHR9XG5cdFxuXHQvKipcblx0ICogTWl4IGluIGBFbWl0dGVyYC5cblx0ICovXG5cdFxuXHRFbWl0dGVyKFRyYW5zcG9ydC5wcm90b3R5cGUpO1xuXHRcblx0LyoqXG5cdCAqIEVtaXRzIGFuIGVycm9yLlxuXHQgKlxuXHQgKiBAcGFyYW0ge1N0cmluZ30gc3RyXG5cdCAqIEByZXR1cm4ge1RyYW5zcG9ydH0gZm9yIGNoYWluaW5nXG5cdCAqIEBhcGkgcHVibGljXG5cdCAqL1xuXHRcblx0VHJhbnNwb3J0LnByb3RvdHlwZS5vbkVycm9yID0gZnVuY3Rpb24gKG1zZywgZGVzYykge1xuXHQgIHZhciBlcnIgPSBuZXcgRXJyb3IobXNnKTtcblx0ICBlcnIudHlwZSA9ICdUcmFuc3BvcnRFcnJvcic7XG5cdCAgZXJyLmRlc2NyaXB0aW9uID0gZGVzYztcblx0ICB0aGlzLmVtaXQoJ2Vycm9yJywgZXJyKTtcblx0ICByZXR1cm4gdGhpcztcblx0fTtcblx0XG5cdC8qKlxuXHQgKiBPcGVucyB0aGUgdHJhbnNwb3J0LlxuXHQgKlxuXHQgKiBAYXBpIHB1YmxpY1xuXHQgKi9cblx0XG5cdFRyYW5zcG9ydC5wcm90b3R5cGUub3BlbiA9IGZ1bmN0aW9uICgpIHtcblx0ICBpZiAoJ2Nsb3NlZCcgPT09IHRoaXMucmVhZHlTdGF0ZSB8fCAnJyA9PT0gdGhpcy5yZWFkeVN0YXRlKSB7XG5cdCAgICB0aGlzLnJlYWR5U3RhdGUgPSAnb3BlbmluZyc7XG5cdCAgICB0aGlzLmRvT3BlbigpO1xuXHQgIH1cblx0XG5cdCAgcmV0dXJuIHRoaXM7XG5cdH07XG5cdFxuXHQvKipcblx0ICogQ2xvc2VzIHRoZSB0cmFuc3BvcnQuXG5cdCAqXG5cdCAqIEBhcGkgcHJpdmF0ZVxuXHQgKi9cblx0XG5cdFRyYW5zcG9ydC5wcm90b3R5cGUuY2xvc2UgPSBmdW5jdGlvbiAoKSB7XG5cdCAgaWYgKCdvcGVuaW5nJyA9PT0gdGhpcy5yZWFkeVN0YXRlIHx8ICdvcGVuJyA9PT0gdGhpcy5yZWFkeVN0YXRlKSB7XG5cdCAgICB0aGlzLmRvQ2xvc2UoKTtcblx0ICAgIHRoaXMub25DbG9zZSgpO1xuXHQgIH1cblx0XG5cdCAgcmV0dXJuIHRoaXM7XG5cdH07XG5cdFxuXHQvKipcblx0ICogU2VuZHMgbXVsdGlwbGUgcGFja2V0cy5cblx0ICpcblx0ICogQHBhcmFtIHtBcnJheX0gcGFja2V0c1xuXHQgKiBAYXBpIHByaXZhdGVcblx0ICovXG5cdFxuXHRUcmFuc3BvcnQucHJvdG90eXBlLnNlbmQgPSBmdW5jdGlvbiAocGFja2V0cykge1xuXHQgIGlmICgnb3BlbicgPT09IHRoaXMucmVhZHlTdGF0ZSkge1xuXHQgICAgdGhpcy53cml0ZShwYWNrZXRzKTtcblx0ICB9IGVsc2Uge1xuXHQgICAgdGhyb3cgbmV3IEVycm9yKCdUcmFuc3BvcnQgbm90IG9wZW4nKTtcblx0ICB9XG5cdH07XG5cdFxuXHQvKipcblx0ICogQ2FsbGVkIHVwb24gb3BlblxuXHQgKlxuXHQgKiBAYXBpIHByaXZhdGVcblx0ICovXG5cdFxuXHRUcmFuc3BvcnQucHJvdG90eXBlLm9uT3BlbiA9IGZ1bmN0aW9uICgpIHtcblx0ICB0aGlzLnJlYWR5U3RhdGUgPSAnb3Blbic7XG5cdCAgdGhpcy53cml0YWJsZSA9IHRydWU7XG5cdCAgdGhpcy5lbWl0KCdvcGVuJyk7XG5cdH07XG5cdFxuXHQvKipcblx0ICogQ2FsbGVkIHdpdGggZGF0YS5cblx0ICpcblx0ICogQHBhcmFtIHtTdHJpbmd9IGRhdGFcblx0ICogQGFwaSBwcml2YXRlXG5cdCAqL1xuXHRcblx0VHJhbnNwb3J0LnByb3RvdHlwZS5vbkRhdGEgPSBmdW5jdGlvbiAoZGF0YSkge1xuXHQgIHZhciBwYWNrZXQgPSBwYXJzZXIuZGVjb2RlUGFja2V0KGRhdGEsIHRoaXMuc29ja2V0LmJpbmFyeVR5cGUpO1xuXHQgIHRoaXMub25QYWNrZXQocGFja2V0KTtcblx0fTtcblx0XG5cdC8qKlxuXHQgKiBDYWxsZWQgd2l0aCBhIGRlY29kZWQgcGFja2V0LlxuXHQgKi9cblx0XG5cdFRyYW5zcG9ydC5wcm90b3R5cGUub25QYWNrZXQgPSBmdW5jdGlvbiAocGFja2V0KSB7XG5cdCAgdGhpcy5lbWl0KCdwYWNrZXQnLCBwYWNrZXQpO1xuXHR9O1xuXHRcblx0LyoqXG5cdCAqIENhbGxlZCB1cG9uIGNsb3NlLlxuXHQgKlxuXHQgKiBAYXBpIHByaXZhdGVcblx0ICovXG5cdFxuXHRUcmFuc3BvcnQucHJvdG90eXBlLm9uQ2xvc2UgPSBmdW5jdGlvbiAoKSB7XG5cdCAgdGhpcy5yZWFkeVN0YXRlID0gJ2Nsb3NlZCc7XG5cdCAgdGhpcy5lbWl0KCdjbG9zZScpO1xuXHR9O1xuXG5cbi8qKiovIH0pLFxuLyogMjAgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXHQvKiBXRUJQQUNLIFZBUiBJTkpFQ1RJT04gKi8oZnVuY3Rpb24oZ2xvYmFsKSB7LyoqXG5cdCAqIE1vZHVsZSBkZXBlbmRlbmNpZXMuXG5cdCAqL1xuXHRcblx0dmFyIGtleXMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIxKTtcblx0dmFyIGhhc0JpbmFyeSA9IF9fd2VicGFja19yZXF1aXJlX18oNik7XG5cdHZhciBzbGljZUJ1ZmZlciA9IF9fd2VicGFja19yZXF1aXJlX18oMjIpO1xuXHR2YXIgYWZ0ZXIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIzKTtcblx0dmFyIHV0ZjggPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDI0KTtcblx0XG5cdHZhciBiYXNlNjRlbmNvZGVyO1xuXHRpZiAoZ2xvYmFsICYmIGdsb2JhbC5BcnJheUJ1ZmZlcikge1xuXHQgIGJhc2U2NGVuY29kZXIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDI2KTtcblx0fVxuXHRcblx0LyoqXG5cdCAqIENoZWNrIGlmIHdlIGFyZSBydW5uaW5nIGFuIGFuZHJvaWQgYnJvd3Nlci4gVGhhdCByZXF1aXJlcyB1cyB0byB1c2Vcblx0ICogQXJyYXlCdWZmZXIgd2l0aCBwb2xsaW5nIHRyYW5zcG9ydHMuLi5cblx0ICpcblx0ICogaHR0cDovL2doaW5kYS5uZXQvanBlZy1ibG9iLWFqYXgtYW5kcm9pZC9cblx0ICovXG5cdFxuXHR2YXIgaXNBbmRyb2lkID0gdHlwZW9mIG5hdmlnYXRvciAhPT0gJ3VuZGVmaW5lZCcgJiYgL0FuZHJvaWQvaS50ZXN0KG5hdmlnYXRvci51c2VyQWdlbnQpO1xuXHRcblx0LyoqXG5cdCAqIENoZWNrIGlmIHdlIGFyZSBydW5uaW5nIGluIFBoYW50b21KUy5cblx0ICogVXBsb2FkaW5nIGEgQmxvYiB3aXRoIFBoYW50b21KUyBkb2VzIG5vdCB3b3JrIGNvcnJlY3RseSwgYXMgcmVwb3J0ZWQgaGVyZTpcblx0ICogaHR0cHM6Ly9naXRodWIuY29tL2FyaXlhL3BoYW50b21qcy9pc3N1ZXMvMTEzOTVcblx0ICogQHR5cGUgYm9vbGVhblxuXHQgKi9cblx0dmFyIGlzUGhhbnRvbUpTID0gdHlwZW9mIG5hdmlnYXRvciAhPT0gJ3VuZGVmaW5lZCcgJiYgL1BoYW50b21KUy9pLnRlc3QobmF2aWdhdG9yLnVzZXJBZ2VudCk7XG5cdFxuXHQvKipcblx0ICogV2hlbiB0cnVlLCBhdm9pZHMgdXNpbmcgQmxvYnMgdG8gZW5jb2RlIHBheWxvYWRzLlxuXHQgKiBAdHlwZSBib29sZWFuXG5cdCAqL1xuXHR2YXIgZG9udFNlbmRCbG9icyA9IGlzQW5kcm9pZCB8fCBpc1BoYW50b21KUztcblx0XG5cdC8qKlxuXHQgKiBDdXJyZW50IHByb3RvY29sIHZlcnNpb24uXG5cdCAqL1xuXHRcblx0ZXhwb3J0cy5wcm90b2NvbCA9IDM7XG5cdFxuXHQvKipcblx0ICogUGFja2V0IHR5cGVzLlxuXHQgKi9cblx0XG5cdHZhciBwYWNrZXRzID0gZXhwb3J0cy5wYWNrZXRzID0ge1xuXHQgICAgb3BlbjogICAgIDAgICAgLy8gbm9uLXdzXG5cdCAgLCBjbG9zZTogICAgMSAgICAvLyBub24td3Ncblx0ICAsIHBpbmc6ICAgICAyXG5cdCAgLCBwb25nOiAgICAgM1xuXHQgICwgbWVzc2FnZTogIDRcblx0ICAsIHVwZ3JhZGU6ICA1XG5cdCAgLCBub29wOiAgICAgNlxuXHR9O1xuXHRcblx0dmFyIHBhY2tldHNsaXN0ID0ga2V5cyhwYWNrZXRzKTtcblx0XG5cdC8qKlxuXHQgKiBQcmVtYWRlIGVycm9yIHBhY2tldC5cblx0ICovXG5cdFxuXHR2YXIgZXJyID0geyB0eXBlOiAnZXJyb3InLCBkYXRhOiAncGFyc2VyIGVycm9yJyB9O1xuXHRcblx0LyoqXG5cdCAqIENyZWF0ZSBhIGJsb2IgYXBpIGV2ZW4gZm9yIGJsb2IgYnVpbGRlciB3aGVuIHZlbmRvciBwcmVmaXhlcyBleGlzdFxuXHQgKi9cblx0XG5cdHZhciBCbG9iID0gX193ZWJwYWNrX3JlcXVpcmVfXygyNyk7XG5cdFxuXHQvKipcblx0ICogRW5jb2RlcyBhIHBhY2tldC5cblx0ICpcblx0ICogICAgIDxwYWNrZXQgdHlwZSBpZD4gWyA8ZGF0YT4gXVxuXHQgKlxuXHQgKiBFeGFtcGxlOlxuXHQgKlxuXHQgKiAgICAgNWhlbGxvIHdvcmxkXG5cdCAqICAgICAzXG5cdCAqICAgICA0XG5cdCAqXG5cdCAqIEJpbmFyeSBpcyBlbmNvZGVkIGluIGFuIGlkZW50aWNhbCBwcmluY2lwbGVcblx0ICpcblx0ICogQGFwaSBwcml2YXRlXG5cdCAqL1xuXHRcblx0ZXhwb3J0cy5lbmNvZGVQYWNrZXQgPSBmdW5jdGlvbiAocGFja2V0LCBzdXBwb3J0c0JpbmFyeSwgdXRmOGVuY29kZSwgY2FsbGJhY2spIHtcblx0ICBpZiAodHlwZW9mIHN1cHBvcnRzQmluYXJ5ID09PSAnZnVuY3Rpb24nKSB7XG5cdCAgICBjYWxsYmFjayA9IHN1cHBvcnRzQmluYXJ5O1xuXHQgICAgc3VwcG9ydHNCaW5hcnkgPSBmYWxzZTtcblx0ICB9XG5cdFxuXHQgIGlmICh0eXBlb2YgdXRmOGVuY29kZSA9PT0gJ2Z1bmN0aW9uJykge1xuXHQgICAgY2FsbGJhY2sgPSB1dGY4ZW5jb2RlO1xuXHQgICAgdXRmOGVuY29kZSA9IG51bGw7XG5cdCAgfVxuXHRcblx0ICB2YXIgZGF0YSA9IChwYWNrZXQuZGF0YSA9PT0gdW5kZWZpbmVkKVxuXHQgICAgPyB1bmRlZmluZWRcblx0ICAgIDogcGFja2V0LmRhdGEuYnVmZmVyIHx8IHBhY2tldC5kYXRhO1xuXHRcblx0ICBpZiAoZ2xvYmFsLkFycmF5QnVmZmVyICYmIGRhdGEgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlcikge1xuXHQgICAgcmV0dXJuIGVuY29kZUFycmF5QnVmZmVyKHBhY2tldCwgc3VwcG9ydHNCaW5hcnksIGNhbGxiYWNrKTtcblx0ICB9IGVsc2UgaWYgKEJsb2IgJiYgZGF0YSBpbnN0YW5jZW9mIGdsb2JhbC5CbG9iKSB7XG5cdCAgICByZXR1cm4gZW5jb2RlQmxvYihwYWNrZXQsIHN1cHBvcnRzQmluYXJ5LCBjYWxsYmFjayk7XG5cdCAgfVxuXHRcblx0ICAvLyBtaWdodCBiZSBhbiBvYmplY3Qgd2l0aCB7IGJhc2U2NDogdHJ1ZSwgZGF0YTogZGF0YUFzQmFzZTY0U3RyaW5nIH1cblx0ICBpZiAoZGF0YSAmJiBkYXRhLmJhc2U2NCkge1xuXHQgICAgcmV0dXJuIGVuY29kZUJhc2U2NE9iamVjdChwYWNrZXQsIGNhbGxiYWNrKTtcblx0ICB9XG5cdFxuXHQgIC8vIFNlbmRpbmcgZGF0YSBhcyBhIHV0Zi04IHN0cmluZ1xuXHQgIHZhciBlbmNvZGVkID0gcGFja2V0c1twYWNrZXQudHlwZV07XG5cdFxuXHQgIC8vIGRhdGEgZnJhZ21lbnQgaXMgb3B0aW9uYWxcblx0ICBpZiAodW5kZWZpbmVkICE9PSBwYWNrZXQuZGF0YSkge1xuXHQgICAgZW5jb2RlZCArPSB1dGY4ZW5jb2RlID8gdXRmOC5lbmNvZGUoU3RyaW5nKHBhY2tldC5kYXRhKSwgeyBzdHJpY3Q6IGZhbHNlIH0pIDogU3RyaW5nKHBhY2tldC5kYXRhKTtcblx0ICB9XG5cdFxuXHQgIHJldHVybiBjYWxsYmFjaygnJyArIGVuY29kZWQpO1xuXHRcblx0fTtcblx0XG5cdGZ1bmN0aW9uIGVuY29kZUJhc2U2NE9iamVjdChwYWNrZXQsIGNhbGxiYWNrKSB7XG5cdCAgLy8gcGFja2V0IGRhdGEgaXMgYW4gb2JqZWN0IHsgYmFzZTY0OiB0cnVlLCBkYXRhOiBkYXRhQXNCYXNlNjRTdHJpbmcgfVxuXHQgIHZhciBtZXNzYWdlID0gJ2InICsgZXhwb3J0cy5wYWNrZXRzW3BhY2tldC50eXBlXSArIHBhY2tldC5kYXRhLmRhdGE7XG5cdCAgcmV0dXJuIGNhbGxiYWNrKG1lc3NhZ2UpO1xuXHR9XG5cdFxuXHQvKipcblx0ICogRW5jb2RlIHBhY2tldCBoZWxwZXJzIGZvciBiaW5hcnkgdHlwZXNcblx0ICovXG5cdFxuXHRmdW5jdGlvbiBlbmNvZGVBcnJheUJ1ZmZlcihwYWNrZXQsIHN1cHBvcnRzQmluYXJ5LCBjYWxsYmFjaykge1xuXHQgIGlmICghc3VwcG9ydHNCaW5hcnkpIHtcblx0ICAgIHJldHVybiBleHBvcnRzLmVuY29kZUJhc2U2NFBhY2tldChwYWNrZXQsIGNhbGxiYWNrKTtcblx0ICB9XG5cdFxuXHQgIHZhciBkYXRhID0gcGFja2V0LmRhdGE7XG5cdCAgdmFyIGNvbnRlbnRBcnJheSA9IG5ldyBVaW50OEFycmF5KGRhdGEpO1xuXHQgIHZhciByZXN1bHRCdWZmZXIgPSBuZXcgVWludDhBcnJheSgxICsgZGF0YS5ieXRlTGVuZ3RoKTtcblx0XG5cdCAgcmVzdWx0QnVmZmVyWzBdID0gcGFja2V0c1twYWNrZXQudHlwZV07XG5cdCAgZm9yICh2YXIgaSA9IDA7IGkgPCBjb250ZW50QXJyYXkubGVuZ3RoOyBpKyspIHtcblx0ICAgIHJlc3VsdEJ1ZmZlcltpKzFdID0gY29udGVudEFycmF5W2ldO1xuXHQgIH1cblx0XG5cdCAgcmV0dXJuIGNhbGxiYWNrKHJlc3VsdEJ1ZmZlci5idWZmZXIpO1xuXHR9XG5cdFxuXHRmdW5jdGlvbiBlbmNvZGVCbG9iQXNBcnJheUJ1ZmZlcihwYWNrZXQsIHN1cHBvcnRzQmluYXJ5LCBjYWxsYmFjaykge1xuXHQgIGlmICghc3VwcG9ydHNCaW5hcnkpIHtcblx0ICAgIHJldHVybiBleHBvcnRzLmVuY29kZUJhc2U2NFBhY2tldChwYWNrZXQsIGNhbGxiYWNrKTtcblx0ICB9XG5cdFxuXHQgIHZhciBmciA9IG5ldyBGaWxlUmVhZGVyKCk7XG5cdCAgZnIub25sb2FkID0gZnVuY3Rpb24oKSB7XG5cdCAgICBwYWNrZXQuZGF0YSA9IGZyLnJlc3VsdDtcblx0ICAgIGV4cG9ydHMuZW5jb2RlUGFja2V0KHBhY2tldCwgc3VwcG9ydHNCaW5hcnksIHRydWUsIGNhbGxiYWNrKTtcblx0ICB9O1xuXHQgIHJldHVybiBmci5yZWFkQXNBcnJheUJ1ZmZlcihwYWNrZXQuZGF0YSk7XG5cdH1cblx0XG5cdGZ1bmN0aW9uIGVuY29kZUJsb2IocGFja2V0LCBzdXBwb3J0c0JpbmFyeSwgY2FsbGJhY2spIHtcblx0ICBpZiAoIXN1cHBvcnRzQmluYXJ5KSB7XG5cdCAgICByZXR1cm4gZXhwb3J0cy5lbmNvZGVCYXNlNjRQYWNrZXQocGFja2V0LCBjYWxsYmFjayk7XG5cdCAgfVxuXHRcblx0ICBpZiAoZG9udFNlbmRCbG9icykge1xuXHQgICAgcmV0dXJuIGVuY29kZUJsb2JBc0FycmF5QnVmZmVyKHBhY2tldCwgc3VwcG9ydHNCaW5hcnksIGNhbGxiYWNrKTtcblx0ICB9XG5cdFxuXHQgIHZhciBsZW5ndGggPSBuZXcgVWludDhBcnJheSgxKTtcblx0ICBsZW5ndGhbMF0gPSBwYWNrZXRzW3BhY2tldC50eXBlXTtcblx0ICB2YXIgYmxvYiA9IG5ldyBCbG9iKFtsZW5ndGguYnVmZmVyLCBwYWNrZXQuZGF0YV0pO1xuXHRcblx0ICByZXR1cm4gY2FsbGJhY2soYmxvYik7XG5cdH1cblx0XG5cdC8qKlxuXHQgKiBFbmNvZGVzIGEgcGFja2V0IHdpdGggYmluYXJ5IGRhdGEgaW4gYSBiYXNlNjQgc3RyaW5nXG5cdCAqXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBwYWNrZXQsIGhhcyBgdHlwZWAgYW5kIGBkYXRhYFxuXHQgKiBAcmV0dXJuIHtTdHJpbmd9IGJhc2U2NCBlbmNvZGVkIG1lc3NhZ2Vcblx0ICovXG5cdFxuXHRleHBvcnRzLmVuY29kZUJhc2U2NFBhY2tldCA9IGZ1bmN0aW9uKHBhY2tldCwgY2FsbGJhY2spIHtcblx0ICB2YXIgbWVzc2FnZSA9ICdiJyArIGV4cG9ydHMucGFja2V0c1twYWNrZXQudHlwZV07XG5cdCAgaWYgKEJsb2IgJiYgcGFja2V0LmRhdGEgaW5zdGFuY2VvZiBnbG9iYWwuQmxvYikge1xuXHQgICAgdmFyIGZyID0gbmV3IEZpbGVSZWFkZXIoKTtcblx0ICAgIGZyLm9ubG9hZCA9IGZ1bmN0aW9uKCkge1xuXHQgICAgICB2YXIgYjY0ID0gZnIucmVzdWx0LnNwbGl0KCcsJylbMV07XG5cdCAgICAgIGNhbGxiYWNrKG1lc3NhZ2UgKyBiNjQpO1xuXHQgICAgfTtcblx0ICAgIHJldHVybiBmci5yZWFkQXNEYXRhVVJMKHBhY2tldC5kYXRhKTtcblx0ICB9XG5cdFxuXHQgIHZhciBiNjRkYXRhO1xuXHQgIHRyeSB7XG5cdCAgICBiNjRkYXRhID0gU3RyaW5nLmZyb21DaGFyQ29kZS5hcHBseShudWxsLCBuZXcgVWludDhBcnJheShwYWNrZXQuZGF0YSkpO1xuXHQgIH0gY2F0Y2ggKGUpIHtcblx0ICAgIC8vIGlQaG9uZSBTYWZhcmkgZG9lc24ndCBsZXQgeW91IGFwcGx5IHdpdGggdHlwZWQgYXJyYXlzXG5cdCAgICB2YXIgdHlwZWQgPSBuZXcgVWludDhBcnJheShwYWNrZXQuZGF0YSk7XG5cdCAgICB2YXIgYmFzaWMgPSBuZXcgQXJyYXkodHlwZWQubGVuZ3RoKTtcblx0ICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdHlwZWQubGVuZ3RoOyBpKyspIHtcblx0ICAgICAgYmFzaWNbaV0gPSB0eXBlZFtpXTtcblx0ICAgIH1cblx0ICAgIGI2NGRhdGEgPSBTdHJpbmcuZnJvbUNoYXJDb2RlLmFwcGx5KG51bGwsIGJhc2ljKTtcblx0ICB9XG5cdCAgbWVzc2FnZSArPSBnbG9iYWwuYnRvYShiNjRkYXRhKTtcblx0ICByZXR1cm4gY2FsbGJhY2sobWVzc2FnZSk7XG5cdH07XG5cdFxuXHQvKipcblx0ICogRGVjb2RlcyBhIHBhY2tldC4gQ2hhbmdlcyBmb3JtYXQgdG8gQmxvYiBpZiByZXF1ZXN0ZWQuXG5cdCAqXG5cdCAqIEByZXR1cm4ge09iamVjdH0gd2l0aCBgdHlwZWAgYW5kIGBkYXRhYCAoaWYgYW55KVxuXHQgKiBAYXBpIHByaXZhdGVcblx0ICovXG5cdFxuXHRleHBvcnRzLmRlY29kZVBhY2tldCA9IGZ1bmN0aW9uIChkYXRhLCBiaW5hcnlUeXBlLCB1dGY4ZGVjb2RlKSB7XG5cdCAgaWYgKGRhdGEgPT09IHVuZGVmaW5lZCkge1xuXHQgICAgcmV0dXJuIGVycjtcblx0ICB9XG5cdCAgLy8gU3RyaW5nIGRhdGFcblx0ICBpZiAodHlwZW9mIGRhdGEgPT09ICdzdHJpbmcnKSB7XG5cdCAgICBpZiAoZGF0YS5jaGFyQXQoMCkgPT09ICdiJykge1xuXHQgICAgICByZXR1cm4gZXhwb3J0cy5kZWNvZGVCYXNlNjRQYWNrZXQoZGF0YS5zdWJzdHIoMSksIGJpbmFyeVR5cGUpO1xuXHQgICAgfVxuXHRcblx0ICAgIGlmICh1dGY4ZGVjb2RlKSB7XG5cdCAgICAgIGRhdGEgPSB0cnlEZWNvZGUoZGF0YSk7XG5cdCAgICAgIGlmIChkYXRhID09PSBmYWxzZSkge1xuXHQgICAgICAgIHJldHVybiBlcnI7XG5cdCAgICAgIH1cblx0ICAgIH1cblx0ICAgIHZhciB0eXBlID0gZGF0YS5jaGFyQXQoMCk7XG5cdFxuXHQgICAgaWYgKE51bWJlcih0eXBlKSAhPSB0eXBlIHx8ICFwYWNrZXRzbGlzdFt0eXBlXSkge1xuXHQgICAgICByZXR1cm4gZXJyO1xuXHQgICAgfVxuXHRcblx0ICAgIGlmIChkYXRhLmxlbmd0aCA+IDEpIHtcblx0ICAgICAgcmV0dXJuIHsgdHlwZTogcGFja2V0c2xpc3RbdHlwZV0sIGRhdGE6IGRhdGEuc3Vic3RyaW5nKDEpIH07XG5cdCAgICB9IGVsc2Uge1xuXHQgICAgICByZXR1cm4geyB0eXBlOiBwYWNrZXRzbGlzdFt0eXBlXSB9O1xuXHQgICAgfVxuXHQgIH1cblx0XG5cdCAgdmFyIGFzQXJyYXkgPSBuZXcgVWludDhBcnJheShkYXRhKTtcblx0ICB2YXIgdHlwZSA9IGFzQXJyYXlbMF07XG5cdCAgdmFyIHJlc3QgPSBzbGljZUJ1ZmZlcihkYXRhLCAxKTtcblx0ICBpZiAoQmxvYiAmJiBiaW5hcnlUeXBlID09PSAnYmxvYicpIHtcblx0ICAgIHJlc3QgPSBuZXcgQmxvYihbcmVzdF0pO1xuXHQgIH1cblx0ICByZXR1cm4geyB0eXBlOiBwYWNrZXRzbGlzdFt0eXBlXSwgZGF0YTogcmVzdCB9O1xuXHR9O1xuXHRcblx0ZnVuY3Rpb24gdHJ5RGVjb2RlKGRhdGEpIHtcblx0ICB0cnkge1xuXHQgICAgZGF0YSA9IHV0ZjguZGVjb2RlKGRhdGEsIHsgc3RyaWN0OiBmYWxzZSB9KTtcblx0ICB9IGNhdGNoIChlKSB7XG5cdCAgICByZXR1cm4gZmFsc2U7XG5cdCAgfVxuXHQgIHJldHVybiBkYXRhO1xuXHR9XG5cdFxuXHQvKipcblx0ICogRGVjb2RlcyBhIHBhY2tldCBlbmNvZGVkIGluIGEgYmFzZTY0IHN0cmluZ1xuXHQgKlxuXHQgKiBAcGFyYW0ge1N0cmluZ30gYmFzZTY0IGVuY29kZWQgbWVzc2FnZVxuXHQgKiBAcmV0dXJuIHtPYmplY3R9IHdpdGggYHR5cGVgIGFuZCBgZGF0YWAgKGlmIGFueSlcblx0ICovXG5cdFxuXHRleHBvcnRzLmRlY29kZUJhc2U2NFBhY2tldCA9IGZ1bmN0aW9uKG1zZywgYmluYXJ5VHlwZSkge1xuXHQgIHZhciB0eXBlID0gcGFja2V0c2xpc3RbbXNnLmNoYXJBdCgwKV07XG5cdCAgaWYgKCFiYXNlNjRlbmNvZGVyKSB7XG5cdCAgICByZXR1cm4geyB0eXBlOiB0eXBlLCBkYXRhOiB7IGJhc2U2NDogdHJ1ZSwgZGF0YTogbXNnLnN1YnN0cigxKSB9IH07XG5cdCAgfVxuXHRcblx0ICB2YXIgZGF0YSA9IGJhc2U2NGVuY29kZXIuZGVjb2RlKG1zZy5zdWJzdHIoMSkpO1xuXHRcblx0ICBpZiAoYmluYXJ5VHlwZSA9PT0gJ2Jsb2InICYmIEJsb2IpIHtcblx0ICAgIGRhdGEgPSBuZXcgQmxvYihbZGF0YV0pO1xuXHQgIH1cblx0XG5cdCAgcmV0dXJuIHsgdHlwZTogdHlwZSwgZGF0YTogZGF0YSB9O1xuXHR9O1xuXHRcblx0LyoqXG5cdCAqIEVuY29kZXMgbXVsdGlwbGUgbWVzc2FnZXMgKHBheWxvYWQpLlxuXHQgKlxuXHQgKiAgICAgPGxlbmd0aD46ZGF0YVxuXHQgKlxuXHQgKiBFeGFtcGxlOlxuXHQgKlxuXHQgKiAgICAgMTE6aGVsbG8gd29ybGQyOmhpXG5cdCAqXG5cdCAqIElmIGFueSBjb250ZW50cyBhcmUgYmluYXJ5LCB0aGV5IHdpbGwgYmUgZW5jb2RlZCBhcyBiYXNlNjQgc3RyaW5ncy4gQmFzZTY0XG5cdCAqIGVuY29kZWQgc3RyaW5ncyBhcmUgbWFya2VkIHdpdGggYSBiIGJlZm9yZSB0aGUgbGVuZ3RoIHNwZWNpZmllclxuXHQgKlxuXHQgKiBAcGFyYW0ge0FycmF5fSBwYWNrZXRzXG5cdCAqIEBhcGkgcHJpdmF0ZVxuXHQgKi9cblx0XG5cdGV4cG9ydHMuZW5jb2RlUGF5bG9hZCA9IGZ1bmN0aW9uIChwYWNrZXRzLCBzdXBwb3J0c0JpbmFyeSwgY2FsbGJhY2spIHtcblx0ICBpZiAodHlwZW9mIHN1cHBvcnRzQmluYXJ5ID09PSAnZnVuY3Rpb24nKSB7XG5cdCAgICBjYWxsYmFjayA9IHN1cHBvcnRzQmluYXJ5O1xuXHQgICAgc3VwcG9ydHNCaW5hcnkgPSBudWxsO1xuXHQgIH1cblx0XG5cdCAgdmFyIGlzQmluYXJ5ID0gaGFzQmluYXJ5KHBhY2tldHMpO1xuXHRcblx0ICBpZiAoc3VwcG9ydHNCaW5hcnkgJiYgaXNCaW5hcnkpIHtcblx0ICAgIGlmIChCbG9iICYmICFkb250U2VuZEJsb2JzKSB7XG5cdCAgICAgIHJldHVybiBleHBvcnRzLmVuY29kZVBheWxvYWRBc0Jsb2IocGFja2V0cywgY2FsbGJhY2spO1xuXHQgICAgfVxuXHRcblx0ICAgIHJldHVybiBleHBvcnRzLmVuY29kZVBheWxvYWRBc0FycmF5QnVmZmVyKHBhY2tldHMsIGNhbGxiYWNrKTtcblx0ICB9XG5cdFxuXHQgIGlmICghcGFja2V0cy5sZW5ndGgpIHtcblx0ICAgIHJldHVybiBjYWxsYmFjaygnMDonKTtcblx0ICB9XG5cdFxuXHQgIGZ1bmN0aW9uIHNldExlbmd0aEhlYWRlcihtZXNzYWdlKSB7XG5cdCAgICByZXR1cm4gbWVzc2FnZS5sZW5ndGggKyAnOicgKyBtZXNzYWdlO1xuXHQgIH1cblx0XG5cdCAgZnVuY3Rpb24gZW5jb2RlT25lKHBhY2tldCwgZG9uZUNhbGxiYWNrKSB7XG5cdCAgICBleHBvcnRzLmVuY29kZVBhY2tldChwYWNrZXQsICFpc0JpbmFyeSA/IGZhbHNlIDogc3VwcG9ydHNCaW5hcnksIGZhbHNlLCBmdW5jdGlvbihtZXNzYWdlKSB7XG5cdCAgICAgIGRvbmVDYWxsYmFjayhudWxsLCBzZXRMZW5ndGhIZWFkZXIobWVzc2FnZSkpO1xuXHQgICAgfSk7XG5cdCAgfVxuXHRcblx0ICBtYXAocGFja2V0cywgZW5jb2RlT25lLCBmdW5jdGlvbihlcnIsIHJlc3VsdHMpIHtcblx0ICAgIHJldHVybiBjYWxsYmFjayhyZXN1bHRzLmpvaW4oJycpKTtcblx0ICB9KTtcblx0fTtcblx0XG5cdC8qKlxuXHQgKiBBc3luYyBhcnJheSBtYXAgdXNpbmcgYWZ0ZXJcblx0ICovXG5cdFxuXHRmdW5jdGlvbiBtYXAoYXJ5LCBlYWNoLCBkb25lKSB7XG5cdCAgdmFyIHJlc3VsdCA9IG5ldyBBcnJheShhcnkubGVuZ3RoKTtcblx0ICB2YXIgbmV4dCA9IGFmdGVyKGFyeS5sZW5ndGgsIGRvbmUpO1xuXHRcblx0ICB2YXIgZWFjaFdpdGhJbmRleCA9IGZ1bmN0aW9uKGksIGVsLCBjYikge1xuXHQgICAgZWFjaChlbCwgZnVuY3Rpb24oZXJyb3IsIG1zZykge1xuXHQgICAgICByZXN1bHRbaV0gPSBtc2c7XG5cdCAgICAgIGNiKGVycm9yLCByZXN1bHQpO1xuXHQgICAgfSk7XG5cdCAgfTtcblx0XG5cdCAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcnkubGVuZ3RoOyBpKyspIHtcblx0ICAgIGVhY2hXaXRoSW5kZXgoaSwgYXJ5W2ldLCBuZXh0KTtcblx0ICB9XG5cdH1cblx0XG5cdC8qXG5cdCAqIERlY29kZXMgZGF0YSB3aGVuIGEgcGF5bG9hZCBpcyBtYXliZSBleHBlY3RlZC4gUG9zc2libGUgYmluYXJ5IGNvbnRlbnRzIGFyZVxuXHQgKiBkZWNvZGVkIGZyb20gdGhlaXIgYmFzZTY0IHJlcHJlc2VudGF0aW9uXG5cdCAqXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBkYXRhLCBjYWxsYmFjayBtZXRob2Rcblx0ICogQGFwaSBwdWJsaWNcblx0ICovXG5cdFxuXHRleHBvcnRzLmRlY29kZVBheWxvYWQgPSBmdW5jdGlvbiAoZGF0YSwgYmluYXJ5VHlwZSwgY2FsbGJhY2spIHtcblx0ICBpZiAodHlwZW9mIGRhdGEgIT09ICdzdHJpbmcnKSB7XG5cdCAgICByZXR1cm4gZXhwb3J0cy5kZWNvZGVQYXlsb2FkQXNCaW5hcnkoZGF0YSwgYmluYXJ5VHlwZSwgY2FsbGJhY2spO1xuXHQgIH1cblx0XG5cdCAgaWYgKHR5cGVvZiBiaW5hcnlUeXBlID09PSAnZnVuY3Rpb24nKSB7XG5cdCAgICBjYWxsYmFjayA9IGJpbmFyeVR5cGU7XG5cdCAgICBiaW5hcnlUeXBlID0gbnVsbDtcblx0ICB9XG5cdFxuXHQgIHZhciBwYWNrZXQ7XG5cdCAgaWYgKGRhdGEgPT09ICcnKSB7XG5cdCAgICAvLyBwYXJzZXIgZXJyb3IgLSBpZ25vcmluZyBwYXlsb2FkXG5cdCAgICByZXR1cm4gY2FsbGJhY2soZXJyLCAwLCAxKTtcblx0ICB9XG5cdFxuXHQgIHZhciBsZW5ndGggPSAnJywgbiwgbXNnO1xuXHRcblx0ICBmb3IgKHZhciBpID0gMCwgbCA9IGRhdGEubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG5cdCAgICB2YXIgY2hyID0gZGF0YS5jaGFyQXQoaSk7XG5cdFxuXHQgICAgaWYgKGNociAhPT0gJzonKSB7XG5cdCAgICAgIGxlbmd0aCArPSBjaHI7XG5cdCAgICAgIGNvbnRpbnVlO1xuXHQgICAgfVxuXHRcblx0ICAgIGlmIChsZW5ndGggPT09ICcnIHx8IChsZW5ndGggIT0gKG4gPSBOdW1iZXIobGVuZ3RoKSkpKSB7XG5cdCAgICAgIC8vIHBhcnNlciBlcnJvciAtIGlnbm9yaW5nIHBheWxvYWRcblx0ICAgICAgcmV0dXJuIGNhbGxiYWNrKGVyciwgMCwgMSk7XG5cdCAgICB9XG5cdFxuXHQgICAgbXNnID0gZGF0YS5zdWJzdHIoaSArIDEsIG4pO1xuXHRcblx0ICAgIGlmIChsZW5ndGggIT0gbXNnLmxlbmd0aCkge1xuXHQgICAgICAvLyBwYXJzZXIgZXJyb3IgLSBpZ25vcmluZyBwYXlsb2FkXG5cdCAgICAgIHJldHVybiBjYWxsYmFjayhlcnIsIDAsIDEpO1xuXHQgICAgfVxuXHRcblx0ICAgIGlmIChtc2cubGVuZ3RoKSB7XG5cdCAgICAgIHBhY2tldCA9IGV4cG9ydHMuZGVjb2RlUGFja2V0KG1zZywgYmluYXJ5VHlwZSwgZmFsc2UpO1xuXHRcblx0ICAgICAgaWYgKGVyci50eXBlID09PSBwYWNrZXQudHlwZSAmJiBlcnIuZGF0YSA9PT0gcGFja2V0LmRhdGEpIHtcblx0ICAgICAgICAvLyBwYXJzZXIgZXJyb3IgaW4gaW5kaXZpZHVhbCBwYWNrZXQgLSBpZ25vcmluZyBwYXlsb2FkXG5cdCAgICAgICAgcmV0dXJuIGNhbGxiYWNrKGVyciwgMCwgMSk7XG5cdCAgICAgIH1cblx0XG5cdCAgICAgIHZhciByZXQgPSBjYWxsYmFjayhwYWNrZXQsIGkgKyBuLCBsKTtcblx0ICAgICAgaWYgKGZhbHNlID09PSByZXQpIHJldHVybjtcblx0ICAgIH1cblx0XG5cdCAgICAvLyBhZHZhbmNlIGN1cnNvclxuXHQgICAgaSArPSBuO1xuXHQgICAgbGVuZ3RoID0gJyc7XG5cdCAgfVxuXHRcblx0ICBpZiAobGVuZ3RoICE9PSAnJykge1xuXHQgICAgLy8gcGFyc2VyIGVycm9yIC0gaWdub3JpbmcgcGF5bG9hZFxuXHQgICAgcmV0dXJuIGNhbGxiYWNrKGVyciwgMCwgMSk7XG5cdCAgfVxuXHRcblx0fTtcblx0XG5cdC8qKlxuXHQgKiBFbmNvZGVzIG11bHRpcGxlIG1lc3NhZ2VzIChwYXlsb2FkKSBhcyBiaW5hcnkuXG5cdCAqXG5cdCAqIDwxID0gYmluYXJ5LCAwID0gc3RyaW5nPjxudW1iZXIgZnJvbSAwLTk+PG51bWJlciBmcm9tIDAtOT5bLi4uXTxudW1iZXJcblx0ICogMjU1PjxkYXRhPlxuXHQgKlxuXHQgKiBFeGFtcGxlOlxuXHQgKiAxIDMgMjU1IDEgMiAzLCBpZiB0aGUgYmluYXJ5IGNvbnRlbnRzIGFyZSBpbnRlcnByZXRlZCBhcyA4IGJpdCBpbnRlZ2Vyc1xuXHQgKlxuXHQgKiBAcGFyYW0ge0FycmF5fSBwYWNrZXRzXG5cdCAqIEByZXR1cm4ge0FycmF5QnVmZmVyfSBlbmNvZGVkIHBheWxvYWRcblx0ICogQGFwaSBwcml2YXRlXG5cdCAqL1xuXHRcblx0ZXhwb3J0cy5lbmNvZGVQYXlsb2FkQXNBcnJheUJ1ZmZlciA9IGZ1bmN0aW9uKHBhY2tldHMsIGNhbGxiYWNrKSB7XG5cdCAgaWYgKCFwYWNrZXRzLmxlbmd0aCkge1xuXHQgICAgcmV0dXJuIGNhbGxiYWNrKG5ldyBBcnJheUJ1ZmZlcigwKSk7XG5cdCAgfVxuXHRcblx0ICBmdW5jdGlvbiBlbmNvZGVPbmUocGFja2V0LCBkb25lQ2FsbGJhY2spIHtcblx0ICAgIGV4cG9ydHMuZW5jb2RlUGFja2V0KHBhY2tldCwgdHJ1ZSwgdHJ1ZSwgZnVuY3Rpb24oZGF0YSkge1xuXHQgICAgICByZXR1cm4gZG9uZUNhbGxiYWNrKG51bGwsIGRhdGEpO1xuXHQgICAgfSk7XG5cdCAgfVxuXHRcblx0ICBtYXAocGFja2V0cywgZW5jb2RlT25lLCBmdW5jdGlvbihlcnIsIGVuY29kZWRQYWNrZXRzKSB7XG5cdCAgICB2YXIgdG90YWxMZW5ndGggPSBlbmNvZGVkUGFja2V0cy5yZWR1Y2UoZnVuY3Rpb24oYWNjLCBwKSB7XG5cdCAgICAgIHZhciBsZW47XG5cdCAgICAgIGlmICh0eXBlb2YgcCA9PT0gJ3N0cmluZycpe1xuXHQgICAgICAgIGxlbiA9IHAubGVuZ3RoO1xuXHQgICAgICB9IGVsc2Uge1xuXHQgICAgICAgIGxlbiA9IHAuYnl0ZUxlbmd0aDtcblx0ICAgICAgfVxuXHQgICAgICByZXR1cm4gYWNjICsgbGVuLnRvU3RyaW5nKCkubGVuZ3RoICsgbGVuICsgMjsgLy8gc3RyaW5nL2JpbmFyeSBpZGVudGlmaWVyICsgc2VwYXJhdG9yID0gMlxuXHQgICAgfSwgMCk7XG5cdFxuXHQgICAgdmFyIHJlc3VsdEFycmF5ID0gbmV3IFVpbnQ4QXJyYXkodG90YWxMZW5ndGgpO1xuXHRcblx0ICAgIHZhciBidWZmZXJJbmRleCA9IDA7XG5cdCAgICBlbmNvZGVkUGFja2V0cy5mb3JFYWNoKGZ1bmN0aW9uKHApIHtcblx0ICAgICAgdmFyIGlzU3RyaW5nID0gdHlwZW9mIHAgPT09ICdzdHJpbmcnO1xuXHQgICAgICB2YXIgYWIgPSBwO1xuXHQgICAgICBpZiAoaXNTdHJpbmcpIHtcblx0ICAgICAgICB2YXIgdmlldyA9IG5ldyBVaW50OEFycmF5KHAubGVuZ3RoKTtcblx0ICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHAubGVuZ3RoOyBpKyspIHtcblx0ICAgICAgICAgIHZpZXdbaV0gPSBwLmNoYXJDb2RlQXQoaSk7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIGFiID0gdmlldy5idWZmZXI7XG5cdCAgICAgIH1cblx0XG5cdCAgICAgIGlmIChpc1N0cmluZykgeyAvLyBub3QgdHJ1ZSBiaW5hcnlcblx0ICAgICAgICByZXN1bHRBcnJheVtidWZmZXJJbmRleCsrXSA9IDA7XG5cdCAgICAgIH0gZWxzZSB7IC8vIHRydWUgYmluYXJ5XG5cdCAgICAgICAgcmVzdWx0QXJyYXlbYnVmZmVySW5kZXgrK10gPSAxO1xuXHQgICAgICB9XG5cdFxuXHQgICAgICB2YXIgbGVuU3RyID0gYWIuYnl0ZUxlbmd0aC50b1N0cmluZygpO1xuXHQgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlblN0ci5sZW5ndGg7IGkrKykge1xuXHQgICAgICAgIHJlc3VsdEFycmF5W2J1ZmZlckluZGV4KytdID0gcGFyc2VJbnQobGVuU3RyW2ldKTtcblx0ICAgICAgfVxuXHQgICAgICByZXN1bHRBcnJheVtidWZmZXJJbmRleCsrXSA9IDI1NTtcblx0XG5cdCAgICAgIHZhciB2aWV3ID0gbmV3IFVpbnQ4QXJyYXkoYWIpO1xuXHQgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHZpZXcubGVuZ3RoOyBpKyspIHtcblx0ICAgICAgICByZXN1bHRBcnJheVtidWZmZXJJbmRleCsrXSA9IHZpZXdbaV07XG5cdCAgICAgIH1cblx0ICAgIH0pO1xuXHRcblx0ICAgIHJldHVybiBjYWxsYmFjayhyZXN1bHRBcnJheS5idWZmZXIpO1xuXHQgIH0pO1xuXHR9O1xuXHRcblx0LyoqXG5cdCAqIEVuY29kZSBhcyBCbG9iXG5cdCAqL1xuXHRcblx0ZXhwb3J0cy5lbmNvZGVQYXlsb2FkQXNCbG9iID0gZnVuY3Rpb24ocGFja2V0cywgY2FsbGJhY2spIHtcblx0ICBmdW5jdGlvbiBlbmNvZGVPbmUocGFja2V0LCBkb25lQ2FsbGJhY2spIHtcblx0ICAgIGV4cG9ydHMuZW5jb2RlUGFja2V0KHBhY2tldCwgdHJ1ZSwgdHJ1ZSwgZnVuY3Rpb24oZW5jb2RlZCkge1xuXHQgICAgICB2YXIgYmluYXJ5SWRlbnRpZmllciA9IG5ldyBVaW50OEFycmF5KDEpO1xuXHQgICAgICBiaW5hcnlJZGVudGlmaWVyWzBdID0gMTtcblx0ICAgICAgaWYgKHR5cGVvZiBlbmNvZGVkID09PSAnc3RyaW5nJykge1xuXHQgICAgICAgIHZhciB2aWV3ID0gbmV3IFVpbnQ4QXJyYXkoZW5jb2RlZC5sZW5ndGgpO1xuXHQgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZW5jb2RlZC5sZW5ndGg7IGkrKykge1xuXHQgICAgICAgICAgdmlld1tpXSA9IGVuY29kZWQuY2hhckNvZGVBdChpKTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgZW5jb2RlZCA9IHZpZXcuYnVmZmVyO1xuXHQgICAgICAgIGJpbmFyeUlkZW50aWZpZXJbMF0gPSAwO1xuXHQgICAgICB9XG5cdFxuXHQgICAgICB2YXIgbGVuID0gKGVuY29kZWQgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlcilcblx0ICAgICAgICA/IGVuY29kZWQuYnl0ZUxlbmd0aFxuXHQgICAgICAgIDogZW5jb2RlZC5zaXplO1xuXHRcblx0ICAgICAgdmFyIGxlblN0ciA9IGxlbi50b1N0cmluZygpO1xuXHQgICAgICB2YXIgbGVuZ3RoQXJ5ID0gbmV3IFVpbnQ4QXJyYXkobGVuU3RyLmxlbmd0aCArIDEpO1xuXHQgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlblN0ci5sZW5ndGg7IGkrKykge1xuXHQgICAgICAgIGxlbmd0aEFyeVtpXSA9IHBhcnNlSW50KGxlblN0cltpXSk7XG5cdCAgICAgIH1cblx0ICAgICAgbGVuZ3RoQXJ5W2xlblN0ci5sZW5ndGhdID0gMjU1O1xuXHRcblx0ICAgICAgaWYgKEJsb2IpIHtcblx0ICAgICAgICB2YXIgYmxvYiA9IG5ldyBCbG9iKFtiaW5hcnlJZGVudGlmaWVyLmJ1ZmZlciwgbGVuZ3RoQXJ5LmJ1ZmZlciwgZW5jb2RlZF0pO1xuXHQgICAgICAgIGRvbmVDYWxsYmFjayhudWxsLCBibG9iKTtcblx0ICAgICAgfVxuXHQgICAgfSk7XG5cdCAgfVxuXHRcblx0ICBtYXAocGFja2V0cywgZW5jb2RlT25lLCBmdW5jdGlvbihlcnIsIHJlc3VsdHMpIHtcblx0ICAgIHJldHVybiBjYWxsYmFjayhuZXcgQmxvYihyZXN1bHRzKSk7XG5cdCAgfSk7XG5cdH07XG5cdFxuXHQvKlxuXHQgKiBEZWNvZGVzIGRhdGEgd2hlbiBhIHBheWxvYWQgaXMgbWF5YmUgZXhwZWN0ZWQuIFN0cmluZ3MgYXJlIGRlY29kZWQgYnlcblx0ICogaW50ZXJwcmV0aW5nIGVhY2ggYnl0ZSBhcyBhIGtleSBjb2RlIGZvciBlbnRyaWVzIG1hcmtlZCB0byBzdGFydCB3aXRoIDAuIFNlZVxuXHQgKiBkZXNjcmlwdGlvbiBvZiBlbmNvZGVQYXlsb2FkQXNCaW5hcnlcblx0ICpcblx0ICogQHBhcmFtIHtBcnJheUJ1ZmZlcn0gZGF0YSwgY2FsbGJhY2sgbWV0aG9kXG5cdCAqIEBhcGkgcHVibGljXG5cdCAqL1xuXHRcblx0ZXhwb3J0cy5kZWNvZGVQYXlsb2FkQXNCaW5hcnkgPSBmdW5jdGlvbiAoZGF0YSwgYmluYXJ5VHlwZSwgY2FsbGJhY2spIHtcblx0ICBpZiAodHlwZW9mIGJpbmFyeVR5cGUgPT09ICdmdW5jdGlvbicpIHtcblx0ICAgIGNhbGxiYWNrID0gYmluYXJ5VHlwZTtcblx0ICAgIGJpbmFyeVR5cGUgPSBudWxsO1xuXHQgIH1cblx0XG5cdCAgdmFyIGJ1ZmZlclRhaWwgPSBkYXRhO1xuXHQgIHZhciBidWZmZXJzID0gW107XG5cdFxuXHQgIHdoaWxlIChidWZmZXJUYWlsLmJ5dGVMZW5ndGggPiAwKSB7XG5cdCAgICB2YXIgdGFpbEFycmF5ID0gbmV3IFVpbnQ4QXJyYXkoYnVmZmVyVGFpbCk7XG5cdCAgICB2YXIgaXNTdHJpbmcgPSB0YWlsQXJyYXlbMF0gPT09IDA7XG5cdCAgICB2YXIgbXNnTGVuZ3RoID0gJyc7XG5cdFxuXHQgICAgZm9yICh2YXIgaSA9IDE7IDsgaSsrKSB7XG5cdCAgICAgIGlmICh0YWlsQXJyYXlbaV0gPT09IDI1NSkgYnJlYWs7XG5cdFxuXHQgICAgICAvLyAzMTAgPSBjaGFyIGxlbmd0aCBvZiBOdW1iZXIuTUFYX1ZBTFVFXG5cdCAgICAgIGlmIChtc2dMZW5ndGgubGVuZ3RoID4gMzEwKSB7XG5cdCAgICAgICAgcmV0dXJuIGNhbGxiYWNrKGVyciwgMCwgMSk7XG5cdCAgICAgIH1cblx0XG5cdCAgICAgIG1zZ0xlbmd0aCArPSB0YWlsQXJyYXlbaV07XG5cdCAgICB9XG5cdFxuXHQgICAgYnVmZmVyVGFpbCA9IHNsaWNlQnVmZmVyKGJ1ZmZlclRhaWwsIDIgKyBtc2dMZW5ndGgubGVuZ3RoKTtcblx0ICAgIG1zZ0xlbmd0aCA9IHBhcnNlSW50KG1zZ0xlbmd0aCk7XG5cdFxuXHQgICAgdmFyIG1zZyA9IHNsaWNlQnVmZmVyKGJ1ZmZlclRhaWwsIDAsIG1zZ0xlbmd0aCk7XG5cdCAgICBpZiAoaXNTdHJpbmcpIHtcblx0ICAgICAgdHJ5IHtcblx0ICAgICAgICBtc2cgPSBTdHJpbmcuZnJvbUNoYXJDb2RlLmFwcGx5KG51bGwsIG5ldyBVaW50OEFycmF5KG1zZykpO1xuXHQgICAgICB9IGNhdGNoIChlKSB7XG5cdCAgICAgICAgLy8gaVBob25lIFNhZmFyaSBkb2Vzbid0IGxldCB5b3UgYXBwbHkgdG8gdHlwZWQgYXJyYXlzXG5cdCAgICAgICAgdmFyIHR5cGVkID0gbmV3IFVpbnQ4QXJyYXkobXNnKTtcblx0ICAgICAgICBtc2cgPSAnJztcblx0ICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHR5cGVkLmxlbmd0aDsgaSsrKSB7XG5cdCAgICAgICAgICBtc2cgKz0gU3RyaW5nLmZyb21DaGFyQ29kZSh0eXBlZFtpXSk7XG5cdCAgICAgICAgfVxuXHQgICAgICB9XG5cdCAgICB9XG5cdFxuXHQgICAgYnVmZmVycy5wdXNoKG1zZyk7XG5cdCAgICBidWZmZXJUYWlsID0gc2xpY2VCdWZmZXIoYnVmZmVyVGFpbCwgbXNnTGVuZ3RoKTtcblx0ICB9XG5cdFxuXHQgIHZhciB0b3RhbCA9IGJ1ZmZlcnMubGVuZ3RoO1xuXHQgIGJ1ZmZlcnMuZm9yRWFjaChmdW5jdGlvbihidWZmZXIsIGkpIHtcblx0ICAgIGNhbGxiYWNrKGV4cG9ydHMuZGVjb2RlUGFja2V0KGJ1ZmZlciwgYmluYXJ5VHlwZSwgdHJ1ZSksIGksIHRvdGFsKTtcblx0ICB9KTtcblx0fTtcblx0XG5cdC8qIFdFQlBBQ0sgVkFSIElOSkVDVElPTiAqL30uY2FsbChleHBvcnRzLCAoZnVuY3Rpb24oKSB7IHJldHVybiB0aGlzOyB9KCkpKSlcblxuLyoqKi8gfSksXG4vKiAyMSAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xuXG5cdFxuXHQvKipcblx0ICogR2V0cyB0aGUga2V5cyBmb3IgYW4gb2JqZWN0LlxuXHQgKlxuXHQgKiBAcmV0dXJuIHtBcnJheX0ga2V5c1xuXHQgKiBAYXBpIHByaXZhdGVcblx0ICovXG5cdFxuXHRtb2R1bGUuZXhwb3J0cyA9IE9iamVjdC5rZXlzIHx8IGZ1bmN0aW9uIGtleXMgKG9iail7XG5cdCAgdmFyIGFyciA9IFtdO1xuXHQgIHZhciBoYXMgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xuXHRcblx0ICBmb3IgKHZhciBpIGluIG9iaikge1xuXHQgICAgaWYgKGhhcy5jYWxsKG9iaiwgaSkpIHtcblx0ICAgICAgYXJyLnB1c2goaSk7XG5cdCAgICB9XG5cdCAgfVxuXHQgIHJldHVybiBhcnI7XG5cdH07XG5cblxuLyoqKi8gfSksXG4vKiAyMiAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xuXG5cdC8qKlxuXHQgKiBBbiBhYnN0cmFjdGlvbiBmb3Igc2xpY2luZyBhbiBhcnJheWJ1ZmZlciBldmVuIHdoZW5cblx0ICogQXJyYXlCdWZmZXIucHJvdG90eXBlLnNsaWNlIGlzIG5vdCBzdXBwb3J0ZWRcblx0ICpcblx0ICogQGFwaSBwdWJsaWNcblx0ICovXG5cdFxuXHRtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGFycmF5YnVmZmVyLCBzdGFydCwgZW5kKSB7XG5cdCAgdmFyIGJ5dGVzID0gYXJyYXlidWZmZXIuYnl0ZUxlbmd0aDtcblx0ICBzdGFydCA9IHN0YXJ0IHx8IDA7XG5cdCAgZW5kID0gZW5kIHx8IGJ5dGVzO1xuXHRcblx0ICBpZiAoYXJyYXlidWZmZXIuc2xpY2UpIHsgcmV0dXJuIGFycmF5YnVmZmVyLnNsaWNlKHN0YXJ0LCBlbmQpOyB9XG5cdFxuXHQgIGlmIChzdGFydCA8IDApIHsgc3RhcnQgKz0gYnl0ZXM7IH1cblx0ICBpZiAoZW5kIDwgMCkgeyBlbmQgKz0gYnl0ZXM7IH1cblx0ICBpZiAoZW5kID4gYnl0ZXMpIHsgZW5kID0gYnl0ZXM7IH1cblx0XG5cdCAgaWYgKHN0YXJ0ID49IGJ5dGVzIHx8IHN0YXJ0ID49IGVuZCB8fCBieXRlcyA9PT0gMCkge1xuXHQgICAgcmV0dXJuIG5ldyBBcnJheUJ1ZmZlcigwKTtcblx0ICB9XG5cdFxuXHQgIHZhciBhYnYgPSBuZXcgVWludDhBcnJheShhcnJheWJ1ZmZlcik7XG5cdCAgdmFyIHJlc3VsdCA9IG5ldyBVaW50OEFycmF5KGVuZCAtIHN0YXJ0KTtcblx0ICBmb3IgKHZhciBpID0gc3RhcnQsIGlpID0gMDsgaSA8IGVuZDsgaSsrLCBpaSsrKSB7XG5cdCAgICByZXN1bHRbaWldID0gYWJ2W2ldO1xuXHQgIH1cblx0ICByZXR1cm4gcmVzdWx0LmJ1ZmZlcjtcblx0fTtcblxuXG4vKioqLyB9KSxcbi8qIDIzICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XG5cblx0bW9kdWxlLmV4cG9ydHMgPSBhZnRlclxuXHRcblx0ZnVuY3Rpb24gYWZ0ZXIoY291bnQsIGNhbGxiYWNrLCBlcnJfY2IpIHtcblx0ICAgIHZhciBiYWlsID0gZmFsc2Vcblx0ICAgIGVycl9jYiA9IGVycl9jYiB8fCBub29wXG5cdCAgICBwcm94eS5jb3VudCA9IGNvdW50XG5cdFxuXHQgICAgcmV0dXJuIChjb3VudCA9PT0gMCkgPyBjYWxsYmFjaygpIDogcHJveHlcblx0XG5cdCAgICBmdW5jdGlvbiBwcm94eShlcnIsIHJlc3VsdCkge1xuXHQgICAgICAgIGlmIChwcm94eS5jb3VudCA8PSAwKSB7XG5cdCAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignYWZ0ZXIgY2FsbGVkIHRvbyBtYW55IHRpbWVzJylcblx0ICAgICAgICB9XG5cdCAgICAgICAgLS1wcm94eS5jb3VudFxuXHRcblx0ICAgICAgICAvLyBhZnRlciBmaXJzdCBlcnJvciwgcmVzdCBhcmUgcGFzc2VkIHRvIGVycl9jYlxuXHQgICAgICAgIGlmIChlcnIpIHtcblx0ICAgICAgICAgICAgYmFpbCA9IHRydWVcblx0ICAgICAgICAgICAgY2FsbGJhY2soZXJyKVxuXHQgICAgICAgICAgICAvLyBmdXR1cmUgZXJyb3IgY2FsbGJhY2tzIHdpbGwgZ28gdG8gZXJyb3IgaGFuZGxlclxuXHQgICAgICAgICAgICBjYWxsYmFjayA9IGVycl9jYlxuXHQgICAgICAgIH0gZWxzZSBpZiAocHJveHkuY291bnQgPT09IDAgJiYgIWJhaWwpIHtcblx0ICAgICAgICAgICAgY2FsbGJhY2sobnVsbCwgcmVzdWx0KVxuXHQgICAgICAgIH1cblx0ICAgIH1cblx0fVxuXHRcblx0ZnVuY3Rpb24gbm9vcCgpIHt9XG5cblxuLyoqKi8gfSksXG4vKiAyNCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cdHZhciBfX1dFQlBBQ0tfQU1EX0RFRklORV9SRVNVTFRfXzsvKiBXRUJQQUNLIFZBUiBJTkpFQ1RJT04gKi8oZnVuY3Rpb24obW9kdWxlLCBnbG9iYWwpIHsvKiEgaHR0cHM6Ly9tdGhzLmJlL3V0ZjhqcyB2Mi4xLjIgYnkgQG1hdGhpYXMgKi9cblx0OyhmdW5jdGlvbihyb290KSB7XG5cdFxuXHRcdC8vIERldGVjdCBmcmVlIHZhcmlhYmxlcyBgZXhwb3J0c2Bcblx0XHR2YXIgZnJlZUV4cG9ydHMgPSB0eXBlb2YgZXhwb3J0cyA9PSAnb2JqZWN0JyAmJiBleHBvcnRzO1xuXHRcblx0XHQvLyBEZXRlY3QgZnJlZSB2YXJpYWJsZSBgbW9kdWxlYFxuXHRcdHZhciBmcmVlTW9kdWxlID0gdHlwZW9mIG1vZHVsZSA9PSAnb2JqZWN0JyAmJiBtb2R1bGUgJiZcblx0XHRcdG1vZHVsZS5leHBvcnRzID09IGZyZWVFeHBvcnRzICYmIG1vZHVsZTtcblx0XG5cdFx0Ly8gRGV0ZWN0IGZyZWUgdmFyaWFibGUgYGdsb2JhbGAsIGZyb20gTm9kZS5qcyBvciBCcm93c2VyaWZpZWQgY29kZSxcblx0XHQvLyBhbmQgdXNlIGl0IGFzIGByb290YFxuXHRcdHZhciBmcmVlR2xvYmFsID0gdHlwZW9mIGdsb2JhbCA9PSAnb2JqZWN0JyAmJiBnbG9iYWw7XG5cdFx0aWYgKGZyZWVHbG9iYWwuZ2xvYmFsID09PSBmcmVlR2xvYmFsIHx8IGZyZWVHbG9iYWwud2luZG93ID09PSBmcmVlR2xvYmFsKSB7XG5cdFx0XHRyb290ID0gZnJlZUdsb2JhbDtcblx0XHR9XG5cdFxuXHRcdC8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXHRcblx0XHR2YXIgc3RyaW5nRnJvbUNoYXJDb2RlID0gU3RyaW5nLmZyb21DaGFyQ29kZTtcblx0XG5cdFx0Ly8gVGFrZW4gZnJvbSBodHRwczovL210aHMuYmUvcHVueWNvZGVcblx0XHRmdW5jdGlvbiB1Y3MyZGVjb2RlKHN0cmluZykge1xuXHRcdFx0dmFyIG91dHB1dCA9IFtdO1xuXHRcdFx0dmFyIGNvdW50ZXIgPSAwO1xuXHRcdFx0dmFyIGxlbmd0aCA9IHN0cmluZy5sZW5ndGg7XG5cdFx0XHR2YXIgdmFsdWU7XG5cdFx0XHR2YXIgZXh0cmE7XG5cdFx0XHR3aGlsZSAoY291bnRlciA8IGxlbmd0aCkge1xuXHRcdFx0XHR2YWx1ZSA9IHN0cmluZy5jaGFyQ29kZUF0KGNvdW50ZXIrKyk7XG5cdFx0XHRcdGlmICh2YWx1ZSA+PSAweEQ4MDAgJiYgdmFsdWUgPD0gMHhEQkZGICYmIGNvdW50ZXIgPCBsZW5ndGgpIHtcblx0XHRcdFx0XHQvLyBoaWdoIHN1cnJvZ2F0ZSwgYW5kIHRoZXJlIGlzIGEgbmV4dCBjaGFyYWN0ZXJcblx0XHRcdFx0XHRleHRyYSA9IHN0cmluZy5jaGFyQ29kZUF0KGNvdW50ZXIrKyk7XG5cdFx0XHRcdFx0aWYgKChleHRyYSAmIDB4RkMwMCkgPT0gMHhEQzAwKSB7IC8vIGxvdyBzdXJyb2dhdGVcblx0XHRcdFx0XHRcdG91dHB1dC5wdXNoKCgodmFsdWUgJiAweDNGRikgPDwgMTApICsgKGV4dHJhICYgMHgzRkYpICsgMHgxMDAwMCk7XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdC8vIHVubWF0Y2hlZCBzdXJyb2dhdGU7IG9ubHkgYXBwZW5kIHRoaXMgY29kZSB1bml0LCBpbiBjYXNlIHRoZSBuZXh0XG5cdFx0XHRcdFx0XHQvLyBjb2RlIHVuaXQgaXMgdGhlIGhpZ2ggc3Vycm9nYXRlIG9mIGEgc3Vycm9nYXRlIHBhaXJcblx0XHRcdFx0XHRcdG91dHB1dC5wdXNoKHZhbHVlKTtcblx0XHRcdFx0XHRcdGNvdW50ZXItLTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0b3V0cHV0LnB1c2godmFsdWUpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gb3V0cHV0O1xuXHRcdH1cblx0XG5cdFx0Ly8gVGFrZW4gZnJvbSBodHRwczovL210aHMuYmUvcHVueWNvZGVcblx0XHRmdW5jdGlvbiB1Y3MyZW5jb2RlKGFycmF5KSB7XG5cdFx0XHR2YXIgbGVuZ3RoID0gYXJyYXkubGVuZ3RoO1xuXHRcdFx0dmFyIGluZGV4ID0gLTE7XG5cdFx0XHR2YXIgdmFsdWU7XG5cdFx0XHR2YXIgb3V0cHV0ID0gJyc7XG5cdFx0XHR3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuXHRcdFx0XHR2YWx1ZSA9IGFycmF5W2luZGV4XTtcblx0XHRcdFx0aWYgKHZhbHVlID4gMHhGRkZGKSB7XG5cdFx0XHRcdFx0dmFsdWUgLT0gMHgxMDAwMDtcblx0XHRcdFx0XHRvdXRwdXQgKz0gc3RyaW5nRnJvbUNoYXJDb2RlKHZhbHVlID4+PiAxMCAmIDB4M0ZGIHwgMHhEODAwKTtcblx0XHRcdFx0XHR2YWx1ZSA9IDB4REMwMCB8IHZhbHVlICYgMHgzRkY7XG5cdFx0XHRcdH1cblx0XHRcdFx0b3V0cHV0ICs9IHN0cmluZ0Zyb21DaGFyQ29kZSh2YWx1ZSk7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gb3V0cHV0O1xuXHRcdH1cblx0XG5cdFx0ZnVuY3Rpb24gY2hlY2tTY2FsYXJWYWx1ZShjb2RlUG9pbnQsIHN0cmljdCkge1xuXHRcdFx0aWYgKGNvZGVQb2ludCA+PSAweEQ4MDAgJiYgY29kZVBvaW50IDw9IDB4REZGRikge1xuXHRcdFx0XHRpZiAoc3RyaWN0KSB7XG5cdFx0XHRcdFx0dGhyb3cgRXJyb3IoXG5cdFx0XHRcdFx0XHQnTG9uZSBzdXJyb2dhdGUgVSsnICsgY29kZVBvaW50LnRvU3RyaW5nKDE2KS50b1VwcGVyQ2FzZSgpICtcblx0XHRcdFx0XHRcdCcgaXMgbm90IGEgc2NhbGFyIHZhbHVlJ1xuXHRcdFx0XHRcdCk7XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0fVxuXHRcdC8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXHRcblx0XHRmdW5jdGlvbiBjcmVhdGVCeXRlKGNvZGVQb2ludCwgc2hpZnQpIHtcblx0XHRcdHJldHVybiBzdHJpbmdGcm9tQ2hhckNvZGUoKChjb2RlUG9pbnQgPj4gc2hpZnQpICYgMHgzRikgfCAweDgwKTtcblx0XHR9XG5cdFxuXHRcdGZ1bmN0aW9uIGVuY29kZUNvZGVQb2ludChjb2RlUG9pbnQsIHN0cmljdCkge1xuXHRcdFx0aWYgKChjb2RlUG9pbnQgJiAweEZGRkZGRjgwKSA9PSAwKSB7IC8vIDEtYnl0ZSBzZXF1ZW5jZVxuXHRcdFx0XHRyZXR1cm4gc3RyaW5nRnJvbUNoYXJDb2RlKGNvZGVQb2ludCk7XG5cdFx0XHR9XG5cdFx0XHR2YXIgc3ltYm9sID0gJyc7XG5cdFx0XHRpZiAoKGNvZGVQb2ludCAmIDB4RkZGRkY4MDApID09IDApIHsgLy8gMi1ieXRlIHNlcXVlbmNlXG5cdFx0XHRcdHN5bWJvbCA9IHN0cmluZ0Zyb21DaGFyQ29kZSgoKGNvZGVQb2ludCA+PiA2KSAmIDB4MUYpIHwgMHhDMCk7XG5cdFx0XHR9XG5cdFx0XHRlbHNlIGlmICgoY29kZVBvaW50ICYgMHhGRkZGMDAwMCkgPT0gMCkgeyAvLyAzLWJ5dGUgc2VxdWVuY2Vcblx0XHRcdFx0aWYgKCFjaGVja1NjYWxhclZhbHVlKGNvZGVQb2ludCwgc3RyaWN0KSkge1xuXHRcdFx0XHRcdGNvZGVQb2ludCA9IDB4RkZGRDtcblx0XHRcdFx0fVxuXHRcdFx0XHRzeW1ib2wgPSBzdHJpbmdGcm9tQ2hhckNvZGUoKChjb2RlUG9pbnQgPj4gMTIpICYgMHgwRikgfCAweEUwKTtcblx0XHRcdFx0c3ltYm9sICs9IGNyZWF0ZUJ5dGUoY29kZVBvaW50LCA2KTtcblx0XHRcdH1cblx0XHRcdGVsc2UgaWYgKChjb2RlUG9pbnQgJiAweEZGRTAwMDAwKSA9PSAwKSB7IC8vIDQtYnl0ZSBzZXF1ZW5jZVxuXHRcdFx0XHRzeW1ib2wgPSBzdHJpbmdGcm9tQ2hhckNvZGUoKChjb2RlUG9pbnQgPj4gMTgpICYgMHgwNykgfCAweEYwKTtcblx0XHRcdFx0c3ltYm9sICs9IGNyZWF0ZUJ5dGUoY29kZVBvaW50LCAxMik7XG5cdFx0XHRcdHN5bWJvbCArPSBjcmVhdGVCeXRlKGNvZGVQb2ludCwgNik7XG5cdFx0XHR9XG5cdFx0XHRzeW1ib2wgKz0gc3RyaW5nRnJvbUNoYXJDb2RlKChjb2RlUG9pbnQgJiAweDNGKSB8IDB4ODApO1xuXHRcdFx0cmV0dXJuIHN5bWJvbDtcblx0XHR9XG5cdFxuXHRcdGZ1bmN0aW9uIHV0ZjhlbmNvZGUoc3RyaW5nLCBvcHRzKSB7XG5cdFx0XHRvcHRzID0gb3B0cyB8fCB7fTtcblx0XHRcdHZhciBzdHJpY3QgPSBmYWxzZSAhPT0gb3B0cy5zdHJpY3Q7XG5cdFxuXHRcdFx0dmFyIGNvZGVQb2ludHMgPSB1Y3MyZGVjb2RlKHN0cmluZyk7XG5cdFx0XHR2YXIgbGVuZ3RoID0gY29kZVBvaW50cy5sZW5ndGg7XG5cdFx0XHR2YXIgaW5kZXggPSAtMTtcblx0XHRcdHZhciBjb2RlUG9pbnQ7XG5cdFx0XHR2YXIgYnl0ZVN0cmluZyA9ICcnO1xuXHRcdFx0d2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcblx0XHRcdFx0Y29kZVBvaW50ID0gY29kZVBvaW50c1tpbmRleF07XG5cdFx0XHRcdGJ5dGVTdHJpbmcgKz0gZW5jb2RlQ29kZVBvaW50KGNvZGVQb2ludCwgc3RyaWN0KTtcblx0XHRcdH1cblx0XHRcdHJldHVybiBieXRlU3RyaW5nO1xuXHRcdH1cblx0XG5cdFx0LyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cdFxuXHRcdGZ1bmN0aW9uIHJlYWRDb250aW51YXRpb25CeXRlKCkge1xuXHRcdFx0aWYgKGJ5dGVJbmRleCA+PSBieXRlQ291bnQpIHtcblx0XHRcdFx0dGhyb3cgRXJyb3IoJ0ludmFsaWQgYnl0ZSBpbmRleCcpO1xuXHRcdFx0fVxuXHRcblx0XHRcdHZhciBjb250aW51YXRpb25CeXRlID0gYnl0ZUFycmF5W2J5dGVJbmRleF0gJiAweEZGO1xuXHRcdFx0Ynl0ZUluZGV4Kys7XG5cdFxuXHRcdFx0aWYgKChjb250aW51YXRpb25CeXRlICYgMHhDMCkgPT0gMHg4MCkge1xuXHRcdFx0XHRyZXR1cm4gY29udGludWF0aW9uQnl0ZSAmIDB4M0Y7XG5cdFx0XHR9XG5cdFxuXHRcdFx0Ly8gSWYgd2UgZW5kIHVwIGhlcmUsIGl04oCZcyBub3QgYSBjb250aW51YXRpb24gYnl0ZVxuXHRcdFx0dGhyb3cgRXJyb3IoJ0ludmFsaWQgY29udGludWF0aW9uIGJ5dGUnKTtcblx0XHR9XG5cdFxuXHRcdGZ1bmN0aW9uIGRlY29kZVN5bWJvbChzdHJpY3QpIHtcblx0XHRcdHZhciBieXRlMTtcblx0XHRcdHZhciBieXRlMjtcblx0XHRcdHZhciBieXRlMztcblx0XHRcdHZhciBieXRlNDtcblx0XHRcdHZhciBjb2RlUG9pbnQ7XG5cdFxuXHRcdFx0aWYgKGJ5dGVJbmRleCA+IGJ5dGVDb3VudCkge1xuXHRcdFx0XHR0aHJvdyBFcnJvcignSW52YWxpZCBieXRlIGluZGV4Jyk7XG5cdFx0XHR9XG5cdFxuXHRcdFx0aWYgKGJ5dGVJbmRleCA9PSBieXRlQ291bnQpIHtcblx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0fVxuXHRcblx0XHRcdC8vIFJlYWQgZmlyc3QgYnl0ZVxuXHRcdFx0Ynl0ZTEgPSBieXRlQXJyYXlbYnl0ZUluZGV4XSAmIDB4RkY7XG5cdFx0XHRieXRlSW5kZXgrKztcblx0XG5cdFx0XHQvLyAxLWJ5dGUgc2VxdWVuY2UgKG5vIGNvbnRpbnVhdGlvbiBieXRlcylcblx0XHRcdGlmICgoYnl0ZTEgJiAweDgwKSA9PSAwKSB7XG5cdFx0XHRcdHJldHVybiBieXRlMTtcblx0XHRcdH1cblx0XG5cdFx0XHQvLyAyLWJ5dGUgc2VxdWVuY2Vcblx0XHRcdGlmICgoYnl0ZTEgJiAweEUwKSA9PSAweEMwKSB7XG5cdFx0XHRcdGJ5dGUyID0gcmVhZENvbnRpbnVhdGlvbkJ5dGUoKTtcblx0XHRcdFx0Y29kZVBvaW50ID0gKChieXRlMSAmIDB4MUYpIDw8IDYpIHwgYnl0ZTI7XG5cdFx0XHRcdGlmIChjb2RlUG9pbnQgPj0gMHg4MCkge1xuXHRcdFx0XHRcdHJldHVybiBjb2RlUG9pbnQ7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0dGhyb3cgRXJyb3IoJ0ludmFsaWQgY29udGludWF0aW9uIGJ5dGUnKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcblx0XHRcdC8vIDMtYnl0ZSBzZXF1ZW5jZSAobWF5IGluY2x1ZGUgdW5wYWlyZWQgc3Vycm9nYXRlcylcblx0XHRcdGlmICgoYnl0ZTEgJiAweEYwKSA9PSAweEUwKSB7XG5cdFx0XHRcdGJ5dGUyID0gcmVhZENvbnRpbnVhdGlvbkJ5dGUoKTtcblx0XHRcdFx0Ynl0ZTMgPSByZWFkQ29udGludWF0aW9uQnl0ZSgpO1xuXHRcdFx0XHRjb2RlUG9pbnQgPSAoKGJ5dGUxICYgMHgwRikgPDwgMTIpIHwgKGJ5dGUyIDw8IDYpIHwgYnl0ZTM7XG5cdFx0XHRcdGlmIChjb2RlUG9pbnQgPj0gMHgwODAwKSB7XG5cdFx0XHRcdFx0cmV0dXJuIGNoZWNrU2NhbGFyVmFsdWUoY29kZVBvaW50LCBzdHJpY3QpID8gY29kZVBvaW50IDogMHhGRkZEO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHRocm93IEVycm9yKCdJbnZhbGlkIGNvbnRpbnVhdGlvbiBieXRlJyk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XG5cdFx0XHQvLyA0LWJ5dGUgc2VxdWVuY2Vcblx0XHRcdGlmICgoYnl0ZTEgJiAweEY4KSA9PSAweEYwKSB7XG5cdFx0XHRcdGJ5dGUyID0gcmVhZENvbnRpbnVhdGlvbkJ5dGUoKTtcblx0XHRcdFx0Ynl0ZTMgPSByZWFkQ29udGludWF0aW9uQnl0ZSgpO1xuXHRcdFx0XHRieXRlNCA9IHJlYWRDb250aW51YXRpb25CeXRlKCk7XG5cdFx0XHRcdGNvZGVQb2ludCA9ICgoYnl0ZTEgJiAweDA3KSA8PCAweDEyKSB8IChieXRlMiA8PCAweDBDKSB8XG5cdFx0XHRcdFx0KGJ5dGUzIDw8IDB4MDYpIHwgYnl0ZTQ7XG5cdFx0XHRcdGlmIChjb2RlUG9pbnQgPj0gMHgwMTAwMDAgJiYgY29kZVBvaW50IDw9IDB4MTBGRkZGKSB7XG5cdFx0XHRcdFx0cmV0dXJuIGNvZGVQb2ludDtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcblx0XHRcdHRocm93IEVycm9yKCdJbnZhbGlkIFVURi04IGRldGVjdGVkJyk7XG5cdFx0fVxuXHRcblx0XHR2YXIgYnl0ZUFycmF5O1xuXHRcdHZhciBieXRlQ291bnQ7XG5cdFx0dmFyIGJ5dGVJbmRleDtcblx0XHRmdW5jdGlvbiB1dGY4ZGVjb2RlKGJ5dGVTdHJpbmcsIG9wdHMpIHtcblx0XHRcdG9wdHMgPSBvcHRzIHx8IHt9O1xuXHRcdFx0dmFyIHN0cmljdCA9IGZhbHNlICE9PSBvcHRzLnN0cmljdDtcblx0XG5cdFx0XHRieXRlQXJyYXkgPSB1Y3MyZGVjb2RlKGJ5dGVTdHJpbmcpO1xuXHRcdFx0Ynl0ZUNvdW50ID0gYnl0ZUFycmF5Lmxlbmd0aDtcblx0XHRcdGJ5dGVJbmRleCA9IDA7XG5cdFx0XHR2YXIgY29kZVBvaW50cyA9IFtdO1xuXHRcdFx0dmFyIHRtcDtcblx0XHRcdHdoaWxlICgodG1wID0gZGVjb2RlU3ltYm9sKHN0cmljdCkpICE9PSBmYWxzZSkge1xuXHRcdFx0XHRjb2RlUG9pbnRzLnB1c2godG1wKTtcblx0XHRcdH1cblx0XHRcdHJldHVybiB1Y3MyZW5jb2RlKGNvZGVQb2ludHMpO1xuXHRcdH1cblx0XG5cdFx0LyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cdFxuXHRcdHZhciB1dGY4ID0ge1xuXHRcdFx0J3ZlcnNpb24nOiAnMi4xLjInLFxuXHRcdFx0J2VuY29kZSc6IHV0ZjhlbmNvZGUsXG5cdFx0XHQnZGVjb2RlJzogdXRmOGRlY29kZVxuXHRcdH07XG5cdFxuXHRcdC8vIFNvbWUgQU1EIGJ1aWxkIG9wdGltaXplcnMsIGxpa2Ugci5qcywgY2hlY2sgZm9yIHNwZWNpZmljIGNvbmRpdGlvbiBwYXR0ZXJuc1xuXHRcdC8vIGxpa2UgdGhlIGZvbGxvd2luZzpcblx0XHRpZiAoXG5cdFx0XHR0cnVlXG5cdFx0KSB7XG5cdFx0XHQhKF9fV0VCUEFDS19BTURfREVGSU5FX1JFU1VMVF9fID0gZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHJldHVybiB1dGY4O1xuXHRcdFx0fS5jYWxsKGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18sIGV4cG9ydHMsIG1vZHVsZSksIF9fV0VCUEFDS19BTURfREVGSU5FX1JFU1VMVF9fICE9PSB1bmRlZmluZWQgJiYgKG1vZHVsZS5leHBvcnRzID0gX19XRUJQQUNLX0FNRF9ERUZJTkVfUkVTVUxUX18pKTtcblx0XHR9XHRlbHNlIGlmIChmcmVlRXhwb3J0cyAmJiAhZnJlZUV4cG9ydHMubm9kZVR5cGUpIHtcblx0XHRcdGlmIChmcmVlTW9kdWxlKSB7IC8vIGluIE5vZGUuanMgb3IgUmluZ29KUyB2MC44LjArXG5cdFx0XHRcdGZyZWVNb2R1bGUuZXhwb3J0cyA9IHV0Zjg7XG5cdFx0XHR9IGVsc2UgeyAvLyBpbiBOYXJ3aGFsIG9yIFJpbmdvSlMgdjAuNy4wLVxuXHRcdFx0XHR2YXIgb2JqZWN0ID0ge307XG5cdFx0XHRcdHZhciBoYXNPd25Qcm9wZXJ0eSA9IG9iamVjdC5oYXNPd25Qcm9wZXJ0eTtcblx0XHRcdFx0Zm9yICh2YXIga2V5IGluIHV0ZjgpIHtcblx0XHRcdFx0XHRoYXNPd25Qcm9wZXJ0eS5jYWxsKHV0ZjgsIGtleSkgJiYgKGZyZWVFeHBvcnRzW2tleV0gPSB1dGY4W2tleV0pO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fSBlbHNlIHsgLy8gaW4gUmhpbm8gb3IgYSB3ZWIgYnJvd3NlclxuXHRcdFx0cm9vdC51dGY4ID0gdXRmODtcblx0XHR9XG5cdFxuXHR9KHRoaXMpKTtcblx0XG5cdC8qIFdFQlBBQ0sgVkFSIElOSkVDVElPTiAqL30uY2FsbChleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKDI1KShtb2R1bGUpLCAoZnVuY3Rpb24oKSB7IHJldHVybiB0aGlzOyB9KCkpKSlcblxuLyoqKi8gfSksXG4vKiAyNSAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xuXG5cdG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24obW9kdWxlKSB7XHJcblx0XHRpZighbW9kdWxlLndlYnBhY2tQb2x5ZmlsbCkge1xyXG5cdFx0XHRtb2R1bGUuZGVwcmVjYXRlID0gZnVuY3Rpb24oKSB7fTtcclxuXHRcdFx0bW9kdWxlLnBhdGhzID0gW107XHJcblx0XHRcdC8vIG1vZHVsZS5wYXJlbnQgPSB1bmRlZmluZWQgYnkgZGVmYXVsdFxyXG5cdFx0XHRtb2R1bGUuY2hpbGRyZW4gPSBbXTtcclxuXHRcdFx0bW9kdWxlLndlYnBhY2tQb2x5ZmlsbCA9IDE7XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gbW9kdWxlO1xyXG5cdH1cclxuXG5cbi8qKiovIH0pLFxuLyogMjYgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcblxuXHQvKlxuXHQgKiBiYXNlNjQtYXJyYXlidWZmZXJcblx0ICogaHR0cHM6Ly9naXRodWIuY29tL25pa2xhc3ZoL2Jhc2U2NC1hcnJheWJ1ZmZlclxuXHQgKlxuXHQgKiBDb3B5cmlnaHQgKGMpIDIwMTIgTmlrbGFzIHZvbiBIZXJ0emVuXG5cdCAqIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZS5cblx0ICovXG5cdChmdW5jdGlvbigpe1xuXHQgIFwidXNlIHN0cmljdFwiO1xuXHRcblx0ICB2YXIgY2hhcnMgPSBcIkFCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXowMTIzNDU2Nzg5Ky9cIjtcblx0XG5cdCAgLy8gVXNlIGEgbG9va3VwIHRhYmxlIHRvIGZpbmQgdGhlIGluZGV4LlxuXHQgIHZhciBsb29rdXAgPSBuZXcgVWludDhBcnJheSgyNTYpO1xuXHQgIGZvciAodmFyIGkgPSAwOyBpIDwgY2hhcnMubGVuZ3RoOyBpKyspIHtcblx0ICAgIGxvb2t1cFtjaGFycy5jaGFyQ29kZUF0KGkpXSA9IGk7XG5cdCAgfVxuXHRcblx0ICBleHBvcnRzLmVuY29kZSA9IGZ1bmN0aW9uKGFycmF5YnVmZmVyKSB7XG5cdCAgICB2YXIgYnl0ZXMgPSBuZXcgVWludDhBcnJheShhcnJheWJ1ZmZlciksXG5cdCAgICBpLCBsZW4gPSBieXRlcy5sZW5ndGgsIGJhc2U2NCA9IFwiXCI7XG5cdFxuXHQgICAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSs9Mykge1xuXHQgICAgICBiYXNlNjQgKz0gY2hhcnNbYnl0ZXNbaV0gPj4gMl07XG5cdCAgICAgIGJhc2U2NCArPSBjaGFyc1soKGJ5dGVzW2ldICYgMykgPDwgNCkgfCAoYnl0ZXNbaSArIDFdID4+IDQpXTtcblx0ICAgICAgYmFzZTY0ICs9IGNoYXJzWygoYnl0ZXNbaSArIDFdICYgMTUpIDw8IDIpIHwgKGJ5dGVzW2kgKyAyXSA+PiA2KV07XG5cdCAgICAgIGJhc2U2NCArPSBjaGFyc1tieXRlc1tpICsgMl0gJiA2M107XG5cdCAgICB9XG5cdFxuXHQgICAgaWYgKChsZW4gJSAzKSA9PT0gMikge1xuXHQgICAgICBiYXNlNjQgPSBiYXNlNjQuc3Vic3RyaW5nKDAsIGJhc2U2NC5sZW5ndGggLSAxKSArIFwiPVwiO1xuXHQgICAgfSBlbHNlIGlmIChsZW4gJSAzID09PSAxKSB7XG5cdCAgICAgIGJhc2U2NCA9IGJhc2U2NC5zdWJzdHJpbmcoMCwgYmFzZTY0Lmxlbmd0aCAtIDIpICsgXCI9PVwiO1xuXHQgICAgfVxuXHRcblx0ICAgIHJldHVybiBiYXNlNjQ7XG5cdCAgfTtcblx0XG5cdCAgZXhwb3J0cy5kZWNvZGUgPSAgZnVuY3Rpb24oYmFzZTY0KSB7XG5cdCAgICB2YXIgYnVmZmVyTGVuZ3RoID0gYmFzZTY0Lmxlbmd0aCAqIDAuNzUsXG5cdCAgICBsZW4gPSBiYXNlNjQubGVuZ3RoLCBpLCBwID0gMCxcblx0ICAgIGVuY29kZWQxLCBlbmNvZGVkMiwgZW5jb2RlZDMsIGVuY29kZWQ0O1xuXHRcblx0ICAgIGlmIChiYXNlNjRbYmFzZTY0Lmxlbmd0aCAtIDFdID09PSBcIj1cIikge1xuXHQgICAgICBidWZmZXJMZW5ndGgtLTtcblx0ICAgICAgaWYgKGJhc2U2NFtiYXNlNjQubGVuZ3RoIC0gMl0gPT09IFwiPVwiKSB7XG5cdCAgICAgICAgYnVmZmVyTGVuZ3RoLS07XG5cdCAgICAgIH1cblx0ICAgIH1cblx0XG5cdCAgICB2YXIgYXJyYXlidWZmZXIgPSBuZXcgQXJyYXlCdWZmZXIoYnVmZmVyTGVuZ3RoKSxcblx0ICAgIGJ5dGVzID0gbmV3IFVpbnQ4QXJyYXkoYXJyYXlidWZmZXIpO1xuXHRcblx0ICAgIGZvciAoaSA9IDA7IGkgPCBsZW47IGkrPTQpIHtcblx0ICAgICAgZW5jb2RlZDEgPSBsb29rdXBbYmFzZTY0LmNoYXJDb2RlQXQoaSldO1xuXHQgICAgICBlbmNvZGVkMiA9IGxvb2t1cFtiYXNlNjQuY2hhckNvZGVBdChpKzEpXTtcblx0ICAgICAgZW5jb2RlZDMgPSBsb29rdXBbYmFzZTY0LmNoYXJDb2RlQXQoaSsyKV07XG5cdCAgICAgIGVuY29kZWQ0ID0gbG9va3VwW2Jhc2U2NC5jaGFyQ29kZUF0KGkrMyldO1xuXHRcblx0ICAgICAgYnl0ZXNbcCsrXSA9IChlbmNvZGVkMSA8PCAyKSB8IChlbmNvZGVkMiA+PiA0KTtcblx0ICAgICAgYnl0ZXNbcCsrXSA9ICgoZW5jb2RlZDIgJiAxNSkgPDwgNCkgfCAoZW5jb2RlZDMgPj4gMik7XG5cdCAgICAgIGJ5dGVzW3ArK10gPSAoKGVuY29kZWQzICYgMykgPDwgNikgfCAoZW5jb2RlZDQgJiA2Myk7XG5cdCAgICB9XG5cdFxuXHQgICAgcmV0dXJuIGFycmF5YnVmZmVyO1xuXHQgIH07XG5cdH0pKCk7XG5cblxuLyoqKi8gfSksXG4vKiAyNyAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xuXG5cdC8qIFdFQlBBQ0sgVkFSIElOSkVDVElPTiAqLyhmdW5jdGlvbihnbG9iYWwpIHsvKipcblx0ICogQ3JlYXRlIGEgYmxvYiBidWlsZGVyIGV2ZW4gd2hlbiB2ZW5kb3IgcHJlZml4ZXMgZXhpc3Rcblx0ICovXG5cdFxuXHR2YXIgQmxvYkJ1aWxkZXIgPSBnbG9iYWwuQmxvYkJ1aWxkZXJcblx0ICB8fCBnbG9iYWwuV2ViS2l0QmxvYkJ1aWxkZXJcblx0ICB8fCBnbG9iYWwuTVNCbG9iQnVpbGRlclxuXHQgIHx8IGdsb2JhbC5Nb3pCbG9iQnVpbGRlcjtcblx0XG5cdC8qKlxuXHQgKiBDaGVjayBpZiBCbG9iIGNvbnN0cnVjdG9yIGlzIHN1cHBvcnRlZFxuXHQgKi9cblx0XG5cdHZhciBibG9iU3VwcG9ydGVkID0gKGZ1bmN0aW9uKCkge1xuXHQgIHRyeSB7XG5cdCAgICB2YXIgYSA9IG5ldyBCbG9iKFsnaGknXSk7XG5cdCAgICByZXR1cm4gYS5zaXplID09PSAyO1xuXHQgIH0gY2F0Y2goZSkge1xuXHQgICAgcmV0dXJuIGZhbHNlO1xuXHQgIH1cblx0fSkoKTtcblx0XG5cdC8qKlxuXHQgKiBDaGVjayBpZiBCbG9iIGNvbnN0cnVjdG9yIHN1cHBvcnRzIEFycmF5QnVmZmVyVmlld3Ncblx0ICogRmFpbHMgaW4gU2FmYXJpIDYsIHNvIHdlIG5lZWQgdG8gbWFwIHRvIEFycmF5QnVmZmVycyB0aGVyZS5cblx0ICovXG5cdFxuXHR2YXIgYmxvYlN1cHBvcnRzQXJyYXlCdWZmZXJWaWV3ID0gYmxvYlN1cHBvcnRlZCAmJiAoZnVuY3Rpb24oKSB7XG5cdCAgdHJ5IHtcblx0ICAgIHZhciBiID0gbmV3IEJsb2IoW25ldyBVaW50OEFycmF5KFsxLDJdKV0pO1xuXHQgICAgcmV0dXJuIGIuc2l6ZSA9PT0gMjtcblx0ICB9IGNhdGNoKGUpIHtcblx0ICAgIHJldHVybiBmYWxzZTtcblx0ICB9XG5cdH0pKCk7XG5cdFxuXHQvKipcblx0ICogQ2hlY2sgaWYgQmxvYkJ1aWxkZXIgaXMgc3VwcG9ydGVkXG5cdCAqL1xuXHRcblx0dmFyIGJsb2JCdWlsZGVyU3VwcG9ydGVkID0gQmxvYkJ1aWxkZXJcblx0ICAmJiBCbG9iQnVpbGRlci5wcm90b3R5cGUuYXBwZW5kXG5cdCAgJiYgQmxvYkJ1aWxkZXIucHJvdG90eXBlLmdldEJsb2I7XG5cdFxuXHQvKipcblx0ICogSGVscGVyIGZ1bmN0aW9uIHRoYXQgbWFwcyBBcnJheUJ1ZmZlclZpZXdzIHRvIEFycmF5QnVmZmVyc1xuXHQgKiBVc2VkIGJ5IEJsb2JCdWlsZGVyIGNvbnN0cnVjdG9yIGFuZCBvbGQgYnJvd3NlcnMgdGhhdCBkaWRuJ3Rcblx0ICogc3VwcG9ydCBpdCBpbiB0aGUgQmxvYiBjb25zdHJ1Y3Rvci5cblx0ICovXG5cdFxuXHRmdW5jdGlvbiBtYXBBcnJheUJ1ZmZlclZpZXdzKGFyeSkge1xuXHQgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJ5Lmxlbmd0aDsgaSsrKSB7XG5cdCAgICB2YXIgY2h1bmsgPSBhcnlbaV07XG5cdCAgICBpZiAoY2h1bmsuYnVmZmVyIGluc3RhbmNlb2YgQXJyYXlCdWZmZXIpIHtcblx0ICAgICAgdmFyIGJ1ZiA9IGNodW5rLmJ1ZmZlcjtcblx0XG5cdCAgICAgIC8vIGlmIHRoaXMgaXMgYSBzdWJhcnJheSwgbWFrZSBhIGNvcHkgc28gd2Ugb25seVxuXHQgICAgICAvLyBpbmNsdWRlIHRoZSBzdWJhcnJheSByZWdpb24gZnJvbSB0aGUgdW5kZXJseWluZyBidWZmZXJcblx0ICAgICAgaWYgKGNodW5rLmJ5dGVMZW5ndGggIT09IGJ1Zi5ieXRlTGVuZ3RoKSB7XG5cdCAgICAgICAgdmFyIGNvcHkgPSBuZXcgVWludDhBcnJheShjaHVuay5ieXRlTGVuZ3RoKTtcblx0ICAgICAgICBjb3B5LnNldChuZXcgVWludDhBcnJheShidWYsIGNodW5rLmJ5dGVPZmZzZXQsIGNodW5rLmJ5dGVMZW5ndGgpKTtcblx0ICAgICAgICBidWYgPSBjb3B5LmJ1ZmZlcjtcblx0ICAgICAgfVxuXHRcblx0ICAgICAgYXJ5W2ldID0gYnVmO1xuXHQgICAgfVxuXHQgIH1cblx0fVxuXHRcblx0ZnVuY3Rpb24gQmxvYkJ1aWxkZXJDb25zdHJ1Y3RvcihhcnksIG9wdGlvbnMpIHtcblx0ICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblx0XG5cdCAgdmFyIGJiID0gbmV3IEJsb2JCdWlsZGVyKCk7XG5cdCAgbWFwQXJyYXlCdWZmZXJWaWV3cyhhcnkpO1xuXHRcblx0ICBmb3IgKHZhciBpID0gMDsgaSA8IGFyeS5sZW5ndGg7IGkrKykge1xuXHQgICAgYmIuYXBwZW5kKGFyeVtpXSk7XG5cdCAgfVxuXHRcblx0ICByZXR1cm4gKG9wdGlvbnMudHlwZSkgPyBiYi5nZXRCbG9iKG9wdGlvbnMudHlwZSkgOiBiYi5nZXRCbG9iKCk7XG5cdH07XG5cdFxuXHRmdW5jdGlvbiBCbG9iQ29uc3RydWN0b3IoYXJ5LCBvcHRpb25zKSB7XG5cdCAgbWFwQXJyYXlCdWZmZXJWaWV3cyhhcnkpO1xuXHQgIHJldHVybiBuZXcgQmxvYihhcnksIG9wdGlvbnMgfHwge30pO1xuXHR9O1xuXHRcblx0bW9kdWxlLmV4cG9ydHMgPSAoZnVuY3Rpb24oKSB7XG5cdCAgaWYgKGJsb2JTdXBwb3J0ZWQpIHtcblx0ICAgIHJldHVybiBibG9iU3VwcG9ydHNBcnJheUJ1ZmZlclZpZXcgPyBnbG9iYWwuQmxvYiA6IEJsb2JDb25zdHJ1Y3Rvcjtcblx0ICB9IGVsc2UgaWYgKGJsb2JCdWlsZGVyU3VwcG9ydGVkKSB7XG5cdCAgICByZXR1cm4gQmxvYkJ1aWxkZXJDb25zdHJ1Y3Rvcjtcblx0ICB9IGVsc2Uge1xuXHQgICAgcmV0dXJuIHVuZGVmaW5lZDtcblx0ICB9XG5cdH0pKCk7XG5cdFxuXHQvKiBXRUJQQUNLIFZBUiBJTkpFQ1RJT04gKi99LmNhbGwoZXhwb3J0cywgKGZ1bmN0aW9uKCkgeyByZXR1cm4gdGhpczsgfSgpKSkpXG5cbi8qKiovIH0pLFxuLyogMjggKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcblxuXHQvKipcclxuXHQgKiBDb21waWxlcyBhIHF1ZXJ5c3RyaW5nXHJcblx0ICogUmV0dXJucyBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhlIG9iamVjdFxyXG5cdCAqXHJcblx0ICogQHBhcmFtIHtPYmplY3R9XHJcblx0ICogQGFwaSBwcml2YXRlXHJcblx0ICovXHJcblx0XHJcblx0ZXhwb3J0cy5lbmNvZGUgPSBmdW5jdGlvbiAob2JqKSB7XHJcblx0ICB2YXIgc3RyID0gJyc7XHJcblx0XHJcblx0ICBmb3IgKHZhciBpIGluIG9iaikge1xyXG5cdCAgICBpZiAob2JqLmhhc093blByb3BlcnR5KGkpKSB7XHJcblx0ICAgICAgaWYgKHN0ci5sZW5ndGgpIHN0ciArPSAnJic7XHJcblx0ICAgICAgc3RyICs9IGVuY29kZVVSSUNvbXBvbmVudChpKSArICc9JyArIGVuY29kZVVSSUNvbXBvbmVudChvYmpbaV0pO1xyXG5cdCAgICB9XHJcblx0ICB9XHJcblx0XHJcblx0ICByZXR1cm4gc3RyO1xyXG5cdH07XHJcblx0XHJcblx0LyoqXHJcblx0ICogUGFyc2VzIGEgc2ltcGxlIHF1ZXJ5c3RyaW5nIGludG8gYW4gb2JqZWN0XHJcblx0ICpcclxuXHQgKiBAcGFyYW0ge1N0cmluZ30gcXNcclxuXHQgKiBAYXBpIHByaXZhdGVcclxuXHQgKi9cclxuXHRcclxuXHRleHBvcnRzLmRlY29kZSA9IGZ1bmN0aW9uKHFzKXtcclxuXHQgIHZhciBxcnkgPSB7fTtcclxuXHQgIHZhciBwYWlycyA9IHFzLnNwbGl0KCcmJyk7XHJcblx0ICBmb3IgKHZhciBpID0gMCwgbCA9IHBhaXJzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xyXG5cdCAgICB2YXIgcGFpciA9IHBhaXJzW2ldLnNwbGl0KCc9Jyk7XHJcblx0ICAgIHFyeVtkZWNvZGVVUklDb21wb25lbnQocGFpclswXSldID0gZGVjb2RlVVJJQ29tcG9uZW50KHBhaXJbMV0pO1xyXG5cdCAgfVxyXG5cdCAgcmV0dXJuIHFyeTtcclxuXHR9O1xyXG5cblxuLyoqKi8gfSksXG4vKiAyOSAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xuXG5cdFxuXHRtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGEsIGIpe1xuXHQgIHZhciBmbiA9IGZ1bmN0aW9uKCl7fTtcblx0ICBmbi5wcm90b3R5cGUgPSBiLnByb3RvdHlwZTtcblx0ICBhLnByb3RvdHlwZSA9IG5ldyBmbjtcblx0ICBhLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IGE7XG5cdH07XG5cbi8qKiovIH0pLFxuLyogMzAgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcblxuXHQndXNlIHN0cmljdCc7XG5cdFxuXHR2YXIgYWxwaGFiZXQgPSAnMDEyMzQ1Njc4OUFCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXotXycuc3BsaXQoJycpXG5cdCAgLCBsZW5ndGggPSA2NFxuXHQgICwgbWFwID0ge31cblx0ICAsIHNlZWQgPSAwXG5cdCAgLCBpID0gMFxuXHQgICwgcHJldjtcblx0XG5cdC8qKlxuXHQgKiBSZXR1cm4gYSBzdHJpbmcgcmVwcmVzZW50aW5nIHRoZSBzcGVjaWZpZWQgbnVtYmVyLlxuXHQgKlxuXHQgKiBAcGFyYW0ge051bWJlcn0gbnVtIFRoZSBudW1iZXIgdG8gY29udmVydC5cblx0ICogQHJldHVybnMge1N0cmluZ30gVGhlIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGUgbnVtYmVyLlxuXHQgKiBAYXBpIHB1YmxpY1xuXHQgKi9cblx0ZnVuY3Rpb24gZW5jb2RlKG51bSkge1xuXHQgIHZhciBlbmNvZGVkID0gJyc7XG5cdFxuXHQgIGRvIHtcblx0ICAgIGVuY29kZWQgPSBhbHBoYWJldFtudW0gJSBsZW5ndGhdICsgZW5jb2RlZDtcblx0ICAgIG51bSA9IE1hdGguZmxvb3IobnVtIC8gbGVuZ3RoKTtcblx0ICB9IHdoaWxlIChudW0gPiAwKTtcblx0XG5cdCAgcmV0dXJuIGVuY29kZWQ7XG5cdH1cblx0XG5cdC8qKlxuXHQgKiBSZXR1cm4gdGhlIGludGVnZXIgdmFsdWUgc3BlY2lmaWVkIGJ5IHRoZSBnaXZlbiBzdHJpbmcuXG5cdCAqXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBzdHIgVGhlIHN0cmluZyB0byBjb252ZXJ0LlxuXHQgKiBAcmV0dXJucyB7TnVtYmVyfSBUaGUgaW50ZWdlciB2YWx1ZSByZXByZXNlbnRlZCBieSB0aGUgc3RyaW5nLlxuXHQgKiBAYXBpIHB1YmxpY1xuXHQgKi9cblx0ZnVuY3Rpb24gZGVjb2RlKHN0cikge1xuXHQgIHZhciBkZWNvZGVkID0gMDtcblx0XG5cdCAgZm9yIChpID0gMDsgaSA8IHN0ci5sZW5ndGg7IGkrKykge1xuXHQgICAgZGVjb2RlZCA9IGRlY29kZWQgKiBsZW5ndGggKyBtYXBbc3RyLmNoYXJBdChpKV07XG5cdCAgfVxuXHRcblx0ICByZXR1cm4gZGVjb2RlZDtcblx0fVxuXHRcblx0LyoqXG5cdCAqIFllYXN0OiBBIHRpbnkgZ3Jvd2luZyBpZCBnZW5lcmF0b3IuXG5cdCAqXG5cdCAqIEByZXR1cm5zIHtTdHJpbmd9IEEgdW5pcXVlIGlkLlxuXHQgKiBAYXBpIHB1YmxpY1xuXHQgKi9cblx0ZnVuY3Rpb24geWVhc3QoKSB7XG5cdCAgdmFyIG5vdyA9IGVuY29kZSgrbmV3IERhdGUoKSk7XG5cdFxuXHQgIGlmIChub3cgIT09IHByZXYpIHJldHVybiBzZWVkID0gMCwgcHJldiA9IG5vdztcblx0ICByZXR1cm4gbm93ICsnLicrIGVuY29kZShzZWVkKyspO1xuXHR9XG5cdFxuXHQvL1xuXHQvLyBNYXAgZWFjaCBjaGFyYWN0ZXIgdG8gaXRzIGluZGV4LlxuXHQvL1xuXHRmb3IgKDsgaSA8IGxlbmd0aDsgaSsrKSBtYXBbYWxwaGFiZXRbaV1dID0gaTtcblx0XG5cdC8vXG5cdC8vIEV4cG9zZSB0aGUgYHllYXN0YCwgYGVuY29kZWAgYW5kIGBkZWNvZGVgIGZ1bmN0aW9ucy5cblx0Ly9cblx0eWVhc3QuZW5jb2RlID0gZW5jb2RlO1xuXHR5ZWFzdC5kZWNvZGUgPSBkZWNvZGU7XG5cdG1vZHVsZS5leHBvcnRzID0geWVhc3Q7XG5cblxuLyoqKi8gfSksXG4vKiAzMSAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cdC8qIFdFQlBBQ0sgVkFSIElOSkVDVElPTiAqLyhmdW5jdGlvbihnbG9iYWwpIHtcblx0LyoqXG5cdCAqIE1vZHVsZSByZXF1aXJlbWVudHMuXG5cdCAqL1xuXHRcblx0dmFyIFBvbGxpbmcgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDE4KTtcblx0dmFyIGluaGVyaXQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDI5KTtcblx0XG5cdC8qKlxuXHQgKiBNb2R1bGUgZXhwb3J0cy5cblx0ICovXG5cdFxuXHRtb2R1bGUuZXhwb3J0cyA9IEpTT05QUG9sbGluZztcblx0XG5cdC8qKlxuXHQgKiBDYWNoZWQgcmVndWxhciBleHByZXNzaW9ucy5cblx0ICovXG5cdFxuXHR2YXIgck5ld2xpbmUgPSAvXFxuL2c7XG5cdHZhciByRXNjYXBlZE5ld2xpbmUgPSAvXFxcXG4vZztcblx0XG5cdC8qKlxuXHQgKiBHbG9iYWwgSlNPTlAgY2FsbGJhY2tzLlxuXHQgKi9cblx0XG5cdHZhciBjYWxsYmFja3M7XG5cdFxuXHQvKipcblx0ICogTm9vcC5cblx0ICovXG5cdFxuXHRmdW5jdGlvbiBlbXB0eSAoKSB7IH1cblx0XG5cdC8qKlxuXHQgKiBKU09OUCBQb2xsaW5nIGNvbnN0cnVjdG9yLlxuXHQgKlxuXHQgKiBAcGFyYW0ge09iamVjdH0gb3B0cy5cblx0ICogQGFwaSBwdWJsaWNcblx0ICovXG5cdFxuXHRmdW5jdGlvbiBKU09OUFBvbGxpbmcgKG9wdHMpIHtcblx0ICBQb2xsaW5nLmNhbGwodGhpcywgb3B0cyk7XG5cdFxuXHQgIHRoaXMucXVlcnkgPSB0aGlzLnF1ZXJ5IHx8IHt9O1xuXHRcblx0ICAvLyBkZWZpbmUgZ2xvYmFsIGNhbGxiYWNrcyBhcnJheSBpZiBub3QgcHJlc2VudFxuXHQgIC8vIHdlIGRvIHRoaXMgaGVyZSAobGF6aWx5KSB0byBhdm9pZCB1bm5lZWRlZCBnbG9iYWwgcG9sbHV0aW9uXG5cdCAgaWYgKCFjYWxsYmFja3MpIHtcblx0ICAgIC8vIHdlIG5lZWQgdG8gY29uc2lkZXIgbXVsdGlwbGUgZW5naW5lcyBpbiB0aGUgc2FtZSBwYWdlXG5cdCAgICBpZiAoIWdsb2JhbC5fX19laW8pIGdsb2JhbC5fX19laW8gPSBbXTtcblx0ICAgIGNhbGxiYWNrcyA9IGdsb2JhbC5fX19laW87XG5cdCAgfVxuXHRcblx0ICAvLyBjYWxsYmFjayBpZGVudGlmaWVyXG5cdCAgdGhpcy5pbmRleCA9IGNhbGxiYWNrcy5sZW5ndGg7XG5cdFxuXHQgIC8vIGFkZCBjYWxsYmFjayB0byBqc29ucCBnbG9iYWxcblx0ICB2YXIgc2VsZiA9IHRoaXM7XG5cdCAgY2FsbGJhY2tzLnB1c2goZnVuY3Rpb24gKG1zZykge1xuXHQgICAgc2VsZi5vbkRhdGEobXNnKTtcblx0ICB9KTtcblx0XG5cdCAgLy8gYXBwZW5kIHRvIHF1ZXJ5IHN0cmluZ1xuXHQgIHRoaXMucXVlcnkuaiA9IHRoaXMuaW5kZXg7XG5cdFxuXHQgIC8vIHByZXZlbnQgc3B1cmlvdXMgZXJyb3JzIGZyb20gYmVpbmcgZW1pdHRlZCB3aGVuIHRoZSB3aW5kb3cgaXMgdW5sb2FkZWRcblx0ICBpZiAoZ2xvYmFsLmRvY3VtZW50ICYmIGdsb2JhbC5hZGRFdmVudExpc3RlbmVyKSB7XG5cdCAgICBnbG9iYWwuYWRkRXZlbnRMaXN0ZW5lcignYmVmb3JldW5sb2FkJywgZnVuY3Rpb24gKCkge1xuXHQgICAgICBpZiAoc2VsZi5zY3JpcHQpIHNlbGYuc2NyaXB0Lm9uZXJyb3IgPSBlbXB0eTtcblx0ICAgIH0sIGZhbHNlKTtcblx0ICB9XG5cdH1cblx0XG5cdC8qKlxuXHQgKiBJbmhlcml0cyBmcm9tIFBvbGxpbmcuXG5cdCAqL1xuXHRcblx0aW5oZXJpdChKU09OUFBvbGxpbmcsIFBvbGxpbmcpO1xuXHRcblx0Lypcblx0ICogSlNPTlAgb25seSBzdXBwb3J0cyBiaW5hcnkgYXMgYmFzZTY0IGVuY29kZWQgc3RyaW5nc1xuXHQgKi9cblx0XG5cdEpTT05QUG9sbGluZy5wcm90b3R5cGUuc3VwcG9ydHNCaW5hcnkgPSBmYWxzZTtcblx0XG5cdC8qKlxuXHQgKiBDbG9zZXMgdGhlIHNvY2tldC5cblx0ICpcblx0ICogQGFwaSBwcml2YXRlXG5cdCAqL1xuXHRcblx0SlNPTlBQb2xsaW5nLnByb3RvdHlwZS5kb0Nsb3NlID0gZnVuY3Rpb24gKCkge1xuXHQgIGlmICh0aGlzLnNjcmlwdCkge1xuXHQgICAgdGhpcy5zY3JpcHQucGFyZW50Tm9kZS5yZW1vdmVDaGlsZCh0aGlzLnNjcmlwdCk7XG5cdCAgICB0aGlzLnNjcmlwdCA9IG51bGw7XG5cdCAgfVxuXHRcblx0ICBpZiAodGhpcy5mb3JtKSB7XG5cdCAgICB0aGlzLmZvcm0ucGFyZW50Tm9kZS5yZW1vdmVDaGlsZCh0aGlzLmZvcm0pO1xuXHQgICAgdGhpcy5mb3JtID0gbnVsbDtcblx0ICAgIHRoaXMuaWZyYW1lID0gbnVsbDtcblx0ICB9XG5cdFxuXHQgIFBvbGxpbmcucHJvdG90eXBlLmRvQ2xvc2UuY2FsbCh0aGlzKTtcblx0fTtcblx0XG5cdC8qKlxuXHQgKiBTdGFydHMgYSBwb2xsIGN5Y2xlLlxuXHQgKlxuXHQgKiBAYXBpIHByaXZhdGVcblx0ICovXG5cdFxuXHRKU09OUFBvbGxpbmcucHJvdG90eXBlLmRvUG9sbCA9IGZ1bmN0aW9uICgpIHtcblx0ICB2YXIgc2VsZiA9IHRoaXM7XG5cdCAgdmFyIHNjcmlwdCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3NjcmlwdCcpO1xuXHRcblx0ICBpZiAodGhpcy5zY3JpcHQpIHtcblx0ICAgIHRoaXMuc2NyaXB0LnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQodGhpcy5zY3JpcHQpO1xuXHQgICAgdGhpcy5zY3JpcHQgPSBudWxsO1xuXHQgIH1cblx0XG5cdCAgc2NyaXB0LmFzeW5jID0gdHJ1ZTtcblx0ICBzY3JpcHQuc3JjID0gdGhpcy51cmkoKTtcblx0ICBzY3JpcHQub25lcnJvciA9IGZ1bmN0aW9uIChlKSB7XG5cdCAgICBzZWxmLm9uRXJyb3IoJ2pzb25wIHBvbGwgZXJyb3InLCBlKTtcblx0ICB9O1xuXHRcblx0ICB2YXIgaW5zZXJ0QXQgPSBkb2N1bWVudC5nZXRFbGVtZW50c0J5VGFnTmFtZSgnc2NyaXB0JylbMF07XG5cdCAgaWYgKGluc2VydEF0KSB7XG5cdCAgICBpbnNlcnRBdC5wYXJlbnROb2RlLmluc2VydEJlZm9yZShzY3JpcHQsIGluc2VydEF0KTtcblx0ICB9IGVsc2Uge1xuXHQgICAgKGRvY3VtZW50LmhlYWQgfHwgZG9jdW1lbnQuYm9keSkuYXBwZW5kQ2hpbGQoc2NyaXB0KTtcblx0ICB9XG5cdCAgdGhpcy5zY3JpcHQgPSBzY3JpcHQ7XG5cdFxuXHQgIHZhciBpc1VBZ2Vja28gPSAndW5kZWZpbmVkJyAhPT0gdHlwZW9mIG5hdmlnYXRvciAmJiAvZ2Vja28vaS50ZXN0KG5hdmlnYXRvci51c2VyQWdlbnQpO1xuXHRcblx0ICBpZiAoaXNVQWdlY2tvKSB7XG5cdCAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcblx0ICAgICAgdmFyIGlmcmFtZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2lmcmFtZScpO1xuXHQgICAgICBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKGlmcmFtZSk7XG5cdCAgICAgIGRvY3VtZW50LmJvZHkucmVtb3ZlQ2hpbGQoaWZyYW1lKTtcblx0ICAgIH0sIDEwMCk7XG5cdCAgfVxuXHR9O1xuXHRcblx0LyoqXG5cdCAqIFdyaXRlcyB3aXRoIGEgaGlkZGVuIGlmcmFtZS5cblx0ICpcblx0ICogQHBhcmFtIHtTdHJpbmd9IGRhdGEgdG8gc2VuZFxuXHQgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsZWQgdXBvbiBmbHVzaC5cblx0ICogQGFwaSBwcml2YXRlXG5cdCAqL1xuXHRcblx0SlNPTlBQb2xsaW5nLnByb3RvdHlwZS5kb1dyaXRlID0gZnVuY3Rpb24gKGRhdGEsIGZuKSB7XG5cdCAgdmFyIHNlbGYgPSB0aGlzO1xuXHRcblx0ICBpZiAoIXRoaXMuZm9ybSkge1xuXHQgICAgdmFyIGZvcm0gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdmb3JtJyk7XG5cdCAgICB2YXIgYXJlYSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3RleHRhcmVhJyk7XG5cdCAgICB2YXIgaWQgPSB0aGlzLmlmcmFtZUlkID0gJ2Vpb19pZnJhbWVfJyArIHRoaXMuaW5kZXg7XG5cdCAgICB2YXIgaWZyYW1lO1xuXHRcblx0ICAgIGZvcm0uY2xhc3NOYW1lID0gJ3NvY2tldGlvJztcblx0ICAgIGZvcm0uc3R5bGUucG9zaXRpb24gPSAnYWJzb2x1dGUnO1xuXHQgICAgZm9ybS5zdHlsZS50b3AgPSAnLTEwMDBweCc7XG5cdCAgICBmb3JtLnN0eWxlLmxlZnQgPSAnLTEwMDBweCc7XG5cdCAgICBmb3JtLnRhcmdldCA9IGlkO1xuXHQgICAgZm9ybS5tZXRob2QgPSAnUE9TVCc7XG5cdCAgICBmb3JtLnNldEF0dHJpYnV0ZSgnYWNjZXB0LWNoYXJzZXQnLCAndXRmLTgnKTtcblx0ICAgIGFyZWEubmFtZSA9ICdkJztcblx0ICAgIGZvcm0uYXBwZW5kQ2hpbGQoYXJlYSk7XG5cdCAgICBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKGZvcm0pO1xuXHRcblx0ICAgIHRoaXMuZm9ybSA9IGZvcm07XG5cdCAgICB0aGlzLmFyZWEgPSBhcmVhO1xuXHQgIH1cblx0XG5cdCAgdGhpcy5mb3JtLmFjdGlvbiA9IHRoaXMudXJpKCk7XG5cdFxuXHQgIGZ1bmN0aW9uIGNvbXBsZXRlICgpIHtcblx0ICAgIGluaXRJZnJhbWUoKTtcblx0ICAgIGZuKCk7XG5cdCAgfVxuXHRcblx0ICBmdW5jdGlvbiBpbml0SWZyYW1lICgpIHtcblx0ICAgIGlmIChzZWxmLmlmcmFtZSkge1xuXHQgICAgICB0cnkge1xuXHQgICAgICAgIHNlbGYuZm9ybS5yZW1vdmVDaGlsZChzZWxmLmlmcmFtZSk7XG5cdCAgICAgIH0gY2F0Y2ggKGUpIHtcblx0ICAgICAgICBzZWxmLm9uRXJyb3IoJ2pzb25wIHBvbGxpbmcgaWZyYW1lIHJlbW92YWwgZXJyb3InLCBlKTtcblx0ICAgICAgfVxuXHQgICAgfVxuXHRcblx0ICAgIHRyeSB7XG5cdCAgICAgIC8vIGllNiBkeW5hbWljIGlmcmFtZXMgd2l0aCB0YXJnZXQ9XCJcIiBzdXBwb3J0ICh0aGFua3MgQ2hyaXMgTGFtYmFjaGVyKVxuXHQgICAgICB2YXIgaHRtbCA9ICc8aWZyYW1lIHNyYz1cImphdmFzY3JpcHQ6MFwiIG5hbWU9XCInICsgc2VsZi5pZnJhbWVJZCArICdcIj4nO1xuXHQgICAgICBpZnJhbWUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KGh0bWwpO1xuXHQgICAgfSBjYXRjaCAoZSkge1xuXHQgICAgICBpZnJhbWUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdpZnJhbWUnKTtcblx0ICAgICAgaWZyYW1lLm5hbWUgPSBzZWxmLmlmcmFtZUlkO1xuXHQgICAgICBpZnJhbWUuc3JjID0gJ2phdmFzY3JpcHQ6MCc7XG5cdCAgICB9XG5cdFxuXHQgICAgaWZyYW1lLmlkID0gc2VsZi5pZnJhbWVJZDtcblx0XG5cdCAgICBzZWxmLmZvcm0uYXBwZW5kQ2hpbGQoaWZyYW1lKTtcblx0ICAgIHNlbGYuaWZyYW1lID0gaWZyYW1lO1xuXHQgIH1cblx0XG5cdCAgaW5pdElmcmFtZSgpO1xuXHRcblx0ICAvLyBlc2NhcGUgXFxuIHRvIHByZXZlbnQgaXQgZnJvbSBiZWluZyBjb252ZXJ0ZWQgaW50byBcXHJcXG4gYnkgc29tZSBVQXNcblx0ICAvLyBkb3VibGUgZXNjYXBpbmcgaXMgcmVxdWlyZWQgZm9yIGVzY2FwZWQgbmV3IGxpbmVzIGJlY2F1c2UgdW5lc2NhcGluZyBvZiBuZXcgbGluZXMgY2FuIGJlIGRvbmUgc2FmZWx5IG9uIHNlcnZlci1zaWRlXG5cdCAgZGF0YSA9IGRhdGEucmVwbGFjZShyRXNjYXBlZE5ld2xpbmUsICdcXFxcXFxuJyk7XG5cdCAgdGhpcy5hcmVhLnZhbHVlID0gZGF0YS5yZXBsYWNlKHJOZXdsaW5lLCAnXFxcXG4nKTtcblx0XG5cdCAgdHJ5IHtcblx0ICAgIHRoaXMuZm9ybS5zdWJtaXQoKTtcblx0ICB9IGNhdGNoIChlKSB7fVxuXHRcblx0ICBpZiAodGhpcy5pZnJhbWUuYXR0YWNoRXZlbnQpIHtcblx0ICAgIHRoaXMuaWZyYW1lLm9ucmVhZHlzdGF0ZWNoYW5nZSA9IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgaWYgKHNlbGYuaWZyYW1lLnJlYWR5U3RhdGUgPT09ICdjb21wbGV0ZScpIHtcblx0ICAgICAgICBjb21wbGV0ZSgpO1xuXHQgICAgICB9XG5cdCAgICB9O1xuXHQgIH0gZWxzZSB7XG5cdCAgICB0aGlzLmlmcmFtZS5vbmxvYWQgPSBjb21wbGV0ZTtcblx0ICB9XG5cdH07XG5cdFxuXHQvKiBXRUJQQUNLIFZBUiBJTkpFQ1RJT04gKi99LmNhbGwoZXhwb3J0cywgKGZ1bmN0aW9uKCkgeyByZXR1cm4gdGhpczsgfSgpKSkpXG5cbi8qKiovIH0pLFxuLyogMzIgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXHQvKiBXRUJQQUNLIFZBUiBJTkpFQ1RJT04gKi8oZnVuY3Rpb24oZ2xvYmFsKSB7LyoqXG5cdCAqIE1vZHVsZSBkZXBlbmRlbmNpZXMuXG5cdCAqL1xuXHRcblx0dmFyIFRyYW5zcG9ydCA9IF9fd2VicGFja19yZXF1aXJlX18oMTkpO1xuXHR2YXIgcGFyc2VyID0gX193ZWJwYWNrX3JlcXVpcmVfXygyMCk7XG5cdHZhciBwYXJzZXFzID0gX193ZWJwYWNrX3JlcXVpcmVfXygyOCk7XG5cdHZhciBpbmhlcml0ID0gX193ZWJwYWNrX3JlcXVpcmVfXygyOSk7XG5cdHZhciB5ZWFzdCA9IF9fd2VicGFja19yZXF1aXJlX18oMzApO1xuXHR2YXIgZGVidWcgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDMpKCdlbmdpbmUuaW8tY2xpZW50OndlYnNvY2tldCcpO1xuXHR2YXIgQnJvd3NlcldlYlNvY2tldCA9IGdsb2JhbC5XZWJTb2NrZXQgfHwgZ2xvYmFsLk1veldlYlNvY2tldDtcblx0dmFyIE5vZGVXZWJTb2NrZXQ7XG5cdGlmICh0eXBlb2Ygd2luZG93ID09PSAndW5kZWZpbmVkJykge1xuXHQgIHRyeSB7XG5cdCAgICBOb2RlV2ViU29ja2V0ID0gX193ZWJwYWNrX3JlcXVpcmVfXygzMyk7XG5cdCAgfSBjYXRjaCAoZSkgeyB9XG5cdH1cblx0XG5cdC8qKlxuXHQgKiBHZXQgZWl0aGVyIHRoZSBgV2ViU29ja2V0YCBvciBgTW96V2ViU29ja2V0YCBnbG9iYWxzXG5cdCAqIGluIHRoZSBicm93c2VyIG9yIHRyeSB0byByZXNvbHZlIFdlYlNvY2tldC1jb21wYXRpYmxlXG5cdCAqIGludGVyZmFjZSBleHBvc2VkIGJ5IGB3c2AgZm9yIE5vZGUtbGlrZSBlbnZpcm9ubWVudC5cblx0ICovXG5cdFxuXHR2YXIgV2ViU29ja2V0ID0gQnJvd3NlcldlYlNvY2tldDtcblx0aWYgKCFXZWJTb2NrZXQgJiYgdHlwZW9mIHdpbmRvdyA9PT0gJ3VuZGVmaW5lZCcpIHtcblx0ICBXZWJTb2NrZXQgPSBOb2RlV2ViU29ja2V0O1xuXHR9XG5cdFxuXHQvKipcblx0ICogTW9kdWxlIGV4cG9ydHMuXG5cdCAqL1xuXHRcblx0bW9kdWxlLmV4cG9ydHMgPSBXUztcblx0XG5cdC8qKlxuXHQgKiBXZWJTb2NrZXQgdHJhbnNwb3J0IGNvbnN0cnVjdG9yLlxuXHQgKlxuXHQgKiBAYXBpIHtPYmplY3R9IGNvbm5lY3Rpb24gb3B0aW9uc1xuXHQgKiBAYXBpIHB1YmxpY1xuXHQgKi9cblx0XG5cdGZ1bmN0aW9uIFdTIChvcHRzKSB7XG5cdCAgdmFyIGZvcmNlQmFzZTY0ID0gKG9wdHMgJiYgb3B0cy5mb3JjZUJhc2U2NCk7XG5cdCAgaWYgKGZvcmNlQmFzZTY0KSB7XG5cdCAgICB0aGlzLnN1cHBvcnRzQmluYXJ5ID0gZmFsc2U7XG5cdCAgfVxuXHQgIHRoaXMucGVyTWVzc2FnZURlZmxhdGUgPSBvcHRzLnBlck1lc3NhZ2VEZWZsYXRlO1xuXHQgIHRoaXMudXNpbmdCcm93c2VyV2ViU29ja2V0ID0gQnJvd3NlcldlYlNvY2tldCAmJiAhb3B0cy5mb3JjZU5vZGU7XG5cdCAgdGhpcy5wcm90b2NvbHMgPSBvcHRzLnByb3RvY29scztcblx0ICBpZiAoIXRoaXMudXNpbmdCcm93c2VyV2ViU29ja2V0KSB7XG5cdCAgICBXZWJTb2NrZXQgPSBOb2RlV2ViU29ja2V0O1xuXHQgIH1cblx0ICBUcmFuc3BvcnQuY2FsbCh0aGlzLCBvcHRzKTtcblx0fVxuXHRcblx0LyoqXG5cdCAqIEluaGVyaXRzIGZyb20gVHJhbnNwb3J0LlxuXHQgKi9cblx0XG5cdGluaGVyaXQoV1MsIFRyYW5zcG9ydCk7XG5cdFxuXHQvKipcblx0ICogVHJhbnNwb3J0IG5hbWUuXG5cdCAqXG5cdCAqIEBhcGkgcHVibGljXG5cdCAqL1xuXHRcblx0V1MucHJvdG90eXBlLm5hbWUgPSAnd2Vic29ja2V0Jztcblx0XG5cdC8qXG5cdCAqIFdlYlNvY2tldHMgc3VwcG9ydCBiaW5hcnlcblx0ICovXG5cdFxuXHRXUy5wcm90b3R5cGUuc3VwcG9ydHNCaW5hcnkgPSB0cnVlO1xuXHRcblx0LyoqXG5cdCAqIE9wZW5zIHNvY2tldC5cblx0ICpcblx0ICogQGFwaSBwcml2YXRlXG5cdCAqL1xuXHRcblx0V1MucHJvdG90eXBlLmRvT3BlbiA9IGZ1bmN0aW9uICgpIHtcblx0ICBpZiAoIXRoaXMuY2hlY2soKSkge1xuXHQgICAgLy8gbGV0IHByb2JlIHRpbWVvdXRcblx0ICAgIHJldHVybjtcblx0ICB9XG5cdFxuXHQgIHZhciB1cmkgPSB0aGlzLnVyaSgpO1xuXHQgIHZhciBwcm90b2NvbHMgPSB0aGlzLnByb3RvY29scztcblx0ICB2YXIgb3B0cyA9IHtcblx0ICAgIGFnZW50OiB0aGlzLmFnZW50LFxuXHQgICAgcGVyTWVzc2FnZURlZmxhdGU6IHRoaXMucGVyTWVzc2FnZURlZmxhdGVcblx0ICB9O1xuXHRcblx0ICAvLyBTU0wgb3B0aW9ucyBmb3IgTm9kZS5qcyBjbGllbnRcblx0ICBvcHRzLnBmeCA9IHRoaXMucGZ4O1xuXHQgIG9wdHMua2V5ID0gdGhpcy5rZXk7XG5cdCAgb3B0cy5wYXNzcGhyYXNlID0gdGhpcy5wYXNzcGhyYXNlO1xuXHQgIG9wdHMuY2VydCA9IHRoaXMuY2VydDtcblx0ICBvcHRzLmNhID0gdGhpcy5jYTtcblx0ICBvcHRzLmNpcGhlcnMgPSB0aGlzLmNpcGhlcnM7XG5cdCAgb3B0cy5yZWplY3RVbmF1dGhvcml6ZWQgPSB0aGlzLnJlamVjdFVuYXV0aG9yaXplZDtcblx0ICBpZiAodGhpcy5leHRyYUhlYWRlcnMpIHtcblx0ICAgIG9wdHMuaGVhZGVycyA9IHRoaXMuZXh0cmFIZWFkZXJzO1xuXHQgIH1cblx0ICBpZiAodGhpcy5sb2NhbEFkZHJlc3MpIHtcblx0ICAgIG9wdHMubG9jYWxBZGRyZXNzID0gdGhpcy5sb2NhbEFkZHJlc3M7XG5cdCAgfVxuXHRcblx0ICB0cnkge1xuXHQgICAgdGhpcy53cyA9IHRoaXMudXNpbmdCcm93c2VyV2ViU29ja2V0ID8gKHByb3RvY29scyA/IG5ldyBXZWJTb2NrZXQodXJpLCBwcm90b2NvbHMpIDogbmV3IFdlYlNvY2tldCh1cmkpKSA6IG5ldyBXZWJTb2NrZXQodXJpLCBwcm90b2NvbHMsIG9wdHMpO1xuXHQgIH0gY2F0Y2ggKGVycikge1xuXHQgICAgcmV0dXJuIHRoaXMuZW1pdCgnZXJyb3InLCBlcnIpO1xuXHQgIH1cblx0XG5cdCAgaWYgKHRoaXMud3MuYmluYXJ5VHlwZSA9PT0gdW5kZWZpbmVkKSB7XG5cdCAgICB0aGlzLnN1cHBvcnRzQmluYXJ5ID0gZmFsc2U7XG5cdCAgfVxuXHRcblx0ICBpZiAodGhpcy53cy5zdXBwb3J0cyAmJiB0aGlzLndzLnN1cHBvcnRzLmJpbmFyeSkge1xuXHQgICAgdGhpcy5zdXBwb3J0c0JpbmFyeSA9IHRydWU7XG5cdCAgICB0aGlzLndzLmJpbmFyeVR5cGUgPSAnbm9kZWJ1ZmZlcic7XG5cdCAgfSBlbHNlIHtcblx0ICAgIHRoaXMud3MuYmluYXJ5VHlwZSA9ICdhcnJheWJ1ZmZlcic7XG5cdCAgfVxuXHRcblx0ICB0aGlzLmFkZEV2ZW50TGlzdGVuZXJzKCk7XG5cdH07XG5cdFxuXHQvKipcblx0ICogQWRkcyBldmVudCBsaXN0ZW5lcnMgdG8gdGhlIHNvY2tldFxuXHQgKlxuXHQgKiBAYXBpIHByaXZhdGVcblx0ICovXG5cdFxuXHRXUy5wcm90b3R5cGUuYWRkRXZlbnRMaXN0ZW5lcnMgPSBmdW5jdGlvbiAoKSB7XG5cdCAgdmFyIHNlbGYgPSB0aGlzO1xuXHRcblx0ICB0aGlzLndzLm9ub3BlbiA9IGZ1bmN0aW9uICgpIHtcblx0ICAgIHNlbGYub25PcGVuKCk7XG5cdCAgfTtcblx0ICB0aGlzLndzLm9uY2xvc2UgPSBmdW5jdGlvbiAoKSB7XG5cdCAgICBzZWxmLm9uQ2xvc2UoKTtcblx0ICB9O1xuXHQgIHRoaXMud3Mub25tZXNzYWdlID0gZnVuY3Rpb24gKGV2KSB7XG5cdCAgICBzZWxmLm9uRGF0YShldi5kYXRhKTtcblx0ICB9O1xuXHQgIHRoaXMud3Mub25lcnJvciA9IGZ1bmN0aW9uIChlKSB7XG5cdCAgICBzZWxmLm9uRXJyb3IoJ3dlYnNvY2tldCBlcnJvcicsIGUpO1xuXHQgIH07XG5cdH07XG5cdFxuXHQvKipcblx0ICogV3JpdGVzIGRhdGEgdG8gc29ja2V0LlxuXHQgKlxuXHQgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBvZiBwYWNrZXRzLlxuXHQgKiBAYXBpIHByaXZhdGVcblx0ICovXG5cdFxuXHRXUy5wcm90b3R5cGUud3JpdGUgPSBmdW5jdGlvbiAocGFja2V0cykge1xuXHQgIHZhciBzZWxmID0gdGhpcztcblx0ICB0aGlzLndyaXRhYmxlID0gZmFsc2U7XG5cdFxuXHQgIC8vIGVuY29kZVBhY2tldCBlZmZpY2llbnQgYXMgaXQgdXNlcyBXUyBmcmFtaW5nXG5cdCAgLy8gbm8gbmVlZCBmb3IgZW5jb2RlUGF5bG9hZFxuXHQgIHZhciB0b3RhbCA9IHBhY2tldHMubGVuZ3RoO1xuXHQgIGZvciAodmFyIGkgPSAwLCBsID0gdG90YWw7IGkgPCBsOyBpKyspIHtcblx0ICAgIChmdW5jdGlvbiAocGFja2V0KSB7XG5cdCAgICAgIHBhcnNlci5lbmNvZGVQYWNrZXQocGFja2V0LCBzZWxmLnN1cHBvcnRzQmluYXJ5LCBmdW5jdGlvbiAoZGF0YSkge1xuXHQgICAgICAgIGlmICghc2VsZi51c2luZ0Jyb3dzZXJXZWJTb2NrZXQpIHtcblx0ICAgICAgICAgIC8vIGFsd2F5cyBjcmVhdGUgYSBuZXcgb2JqZWN0IChHSC00MzcpXG5cdCAgICAgICAgICB2YXIgb3B0cyA9IHt9O1xuXHQgICAgICAgICAgaWYgKHBhY2tldC5vcHRpb25zKSB7XG5cdCAgICAgICAgICAgIG9wdHMuY29tcHJlc3MgPSBwYWNrZXQub3B0aW9ucy5jb21wcmVzcztcblx0ICAgICAgICAgIH1cblx0XG5cdCAgICAgICAgICBpZiAoc2VsZi5wZXJNZXNzYWdlRGVmbGF0ZSkge1xuXHQgICAgICAgICAgICB2YXIgbGVuID0gJ3N0cmluZycgPT09IHR5cGVvZiBkYXRhID8gZ2xvYmFsLkJ1ZmZlci5ieXRlTGVuZ3RoKGRhdGEpIDogZGF0YS5sZW5ndGg7XG5cdCAgICAgICAgICAgIGlmIChsZW4gPCBzZWxmLnBlck1lc3NhZ2VEZWZsYXRlLnRocmVzaG9sZCkge1xuXHQgICAgICAgICAgICAgIG9wdHMuY29tcHJlc3MgPSBmYWxzZTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgfVxuXHQgICAgICAgIH1cblx0XG5cdCAgICAgICAgLy8gU29tZXRpbWVzIHRoZSB3ZWJzb2NrZXQgaGFzIGFscmVhZHkgYmVlbiBjbG9zZWQgYnV0IHRoZSBicm93c2VyIGRpZG4ndFxuXHQgICAgICAgIC8vIGhhdmUgYSBjaGFuY2Ugb2YgaW5mb3JtaW5nIHVzIGFib3V0IGl0IHlldCwgaW4gdGhhdCBjYXNlIHNlbmQgd2lsbFxuXHQgICAgICAgIC8vIHRocm93IGFuIGVycm9yXG5cdCAgICAgICAgdHJ5IHtcblx0ICAgICAgICAgIGlmIChzZWxmLnVzaW5nQnJvd3NlcldlYlNvY2tldCkge1xuXHQgICAgICAgICAgICAvLyBUeXBlRXJyb3IgaXMgdGhyb3duIHdoZW4gcGFzc2luZyB0aGUgc2Vjb25kIGFyZ3VtZW50IG9uIFNhZmFyaVxuXHQgICAgICAgICAgICBzZWxmLndzLnNlbmQoZGF0YSk7XG5cdCAgICAgICAgICB9IGVsc2Uge1xuXHQgICAgICAgICAgICBzZWxmLndzLnNlbmQoZGF0YSwgb3B0cyk7XG5cdCAgICAgICAgICB9XG5cdCAgICAgICAgfSBjYXRjaCAoZSkge1xuXHRcblx0ICAgICAgICB9XG5cdFxuXHQgICAgICAgIC0tdG90YWwgfHwgZG9uZSgpO1xuXHQgICAgICB9KTtcblx0ICAgIH0pKHBhY2tldHNbaV0pO1xuXHQgIH1cblx0XG5cdCAgZnVuY3Rpb24gZG9uZSAoKSB7XG5cdCAgICBzZWxmLmVtaXQoJ2ZsdXNoJyk7XG5cdFxuXHQgICAgLy8gZmFrZSBkcmFpblxuXHQgICAgLy8gZGVmZXIgdG8gbmV4dCB0aWNrIHRvIGFsbG93IFNvY2tldCB0byBjbGVhciB3cml0ZUJ1ZmZlclxuXHQgICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG5cdCAgICAgIHNlbGYud3JpdGFibGUgPSB0cnVlO1xuXHQgICAgICBzZWxmLmVtaXQoJ2RyYWluJyk7XG5cdCAgICB9LCAwKTtcblx0ICB9XG5cdH07XG5cdFxuXHQvKipcblx0ICogQ2FsbGVkIHVwb24gY2xvc2Vcblx0ICpcblx0ICogQGFwaSBwcml2YXRlXG5cdCAqL1xuXHRcblx0V1MucHJvdG90eXBlLm9uQ2xvc2UgPSBmdW5jdGlvbiAoKSB7XG5cdCAgVHJhbnNwb3J0LnByb3RvdHlwZS5vbkNsb3NlLmNhbGwodGhpcyk7XG5cdH07XG5cdFxuXHQvKipcblx0ICogQ2xvc2VzIHNvY2tldC5cblx0ICpcblx0ICogQGFwaSBwcml2YXRlXG5cdCAqL1xuXHRcblx0V1MucHJvdG90eXBlLmRvQ2xvc2UgPSBmdW5jdGlvbiAoKSB7XG5cdCAgaWYgKHR5cGVvZiB0aGlzLndzICE9PSAndW5kZWZpbmVkJykge1xuXHQgICAgdGhpcy53cy5jbG9zZSgpO1xuXHQgIH1cblx0fTtcblx0XG5cdC8qKlxuXHQgKiBHZW5lcmF0ZXMgdXJpIGZvciBjb25uZWN0aW9uLlxuXHQgKlxuXHQgKiBAYXBpIHByaXZhdGVcblx0ICovXG5cdFxuXHRXUy5wcm90b3R5cGUudXJpID0gZnVuY3Rpb24gKCkge1xuXHQgIHZhciBxdWVyeSA9IHRoaXMucXVlcnkgfHwge307XG5cdCAgdmFyIHNjaGVtYSA9IHRoaXMuc2VjdXJlID8gJ3dzcycgOiAnd3MnO1xuXHQgIHZhciBwb3J0ID0gJyc7XG5cdFxuXHQgIC8vIGF2b2lkIHBvcnQgaWYgZGVmYXVsdCBmb3Igc2NoZW1hXG5cdCAgaWYgKHRoaXMucG9ydCAmJiAoKCd3c3MnID09PSBzY2hlbWEgJiYgTnVtYmVyKHRoaXMucG9ydCkgIT09IDQ0MykgfHxcblx0ICAgICgnd3MnID09PSBzY2hlbWEgJiYgTnVtYmVyKHRoaXMucG9ydCkgIT09IDgwKSkpIHtcblx0ICAgIHBvcnQgPSAnOicgKyB0aGlzLnBvcnQ7XG5cdCAgfVxuXHRcblx0ICAvLyBhcHBlbmQgdGltZXN0YW1wIHRvIFVSSVxuXHQgIGlmICh0aGlzLnRpbWVzdGFtcFJlcXVlc3RzKSB7XG5cdCAgICBxdWVyeVt0aGlzLnRpbWVzdGFtcFBhcmFtXSA9IHllYXN0KCk7XG5cdCAgfVxuXHRcblx0ICAvLyBjb21tdW5pY2F0ZSBiaW5hcnkgc3VwcG9ydCBjYXBhYmlsaXRpZXNcblx0ICBpZiAoIXRoaXMuc3VwcG9ydHNCaW5hcnkpIHtcblx0ICAgIHF1ZXJ5LmI2NCA9IDE7XG5cdCAgfVxuXHRcblx0ICBxdWVyeSA9IHBhcnNlcXMuZW5jb2RlKHF1ZXJ5KTtcblx0XG5cdCAgLy8gcHJlcGVuZCA/IHRvIHF1ZXJ5XG5cdCAgaWYgKHF1ZXJ5Lmxlbmd0aCkge1xuXHQgICAgcXVlcnkgPSAnPycgKyBxdWVyeTtcblx0ICB9XG5cdFxuXHQgIHZhciBpcHY2ID0gdGhpcy5ob3N0bmFtZS5pbmRleE9mKCc6JykgIT09IC0xO1xuXHQgIHJldHVybiBzY2hlbWEgKyAnOi8vJyArIChpcHY2ID8gJ1snICsgdGhpcy5ob3N0bmFtZSArICddJyA6IHRoaXMuaG9zdG5hbWUpICsgcG9ydCArIHRoaXMucGF0aCArIHF1ZXJ5O1xuXHR9O1xuXHRcblx0LyoqXG5cdCAqIEZlYXR1cmUgZGV0ZWN0aW9uIGZvciBXZWJTb2NrZXQuXG5cdCAqXG5cdCAqIEByZXR1cm4ge0Jvb2xlYW59IHdoZXRoZXIgdGhpcyB0cmFuc3BvcnQgaXMgYXZhaWxhYmxlLlxuXHQgKiBAYXBpIHB1YmxpY1xuXHQgKi9cblx0XG5cdFdTLnByb3RvdHlwZS5jaGVjayA9IGZ1bmN0aW9uICgpIHtcblx0ICByZXR1cm4gISFXZWJTb2NrZXQgJiYgISgnX19pbml0aWFsaXplJyBpbiBXZWJTb2NrZXQgJiYgdGhpcy5uYW1lID09PSBXUy5wcm90b3R5cGUubmFtZSk7XG5cdH07XG5cdFxuXHQvKiBXRUJQQUNLIFZBUiBJTkpFQ1RJT04gKi99LmNhbGwoZXhwb3J0cywgKGZ1bmN0aW9uKCkgeyByZXR1cm4gdGhpczsgfSgpKSkpXG5cbi8qKiovIH0pLFxuLyogMzMgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcblxuXHQvKiAoaWdub3JlZCkgKi9cblxuLyoqKi8gfSksXG4vKiAzNCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xuXG5cdFxuXHR2YXIgaW5kZXhPZiA9IFtdLmluZGV4T2Y7XG5cdFxuXHRtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGFyciwgb2JqKXtcblx0ICBpZiAoaW5kZXhPZikgcmV0dXJuIGFyci5pbmRleE9mKG9iaik7XG5cdCAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcnIubGVuZ3RoOyArK2kpIHtcblx0ICAgIGlmIChhcnJbaV0gPT09IG9iaikgcmV0dXJuIGk7XG5cdCAgfVxuXHQgIHJldHVybiAtMTtcblx0fTtcblxuLyoqKi8gfSksXG4vKiAzNSAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xuXG5cdC8qIFdFQlBBQ0sgVkFSIElOSkVDVElPTiAqLyhmdW5jdGlvbihnbG9iYWwpIHsvKipcclxuXHQgKiBKU09OIHBhcnNlLlxyXG5cdCAqXHJcblx0ICogQHNlZSBCYXNlZCBvbiBqUXVlcnkjcGFyc2VKU09OIChNSVQpIGFuZCBKU09OMlxyXG5cdCAqIEBhcGkgcHJpdmF0ZVxyXG5cdCAqL1xyXG5cdFxyXG5cdHZhciBydmFsaWRjaGFycyA9IC9eW1xcXSw6e31cXHNdKiQvO1xyXG5cdHZhciBydmFsaWRlc2NhcGUgPSAvXFxcXCg/OltcIlxcXFxcXC9iZm5ydF18dVswLTlhLWZBLUZdezR9KS9nO1xyXG5cdHZhciBydmFsaWR0b2tlbnMgPSAvXCJbXlwiXFxcXFxcblxccl0qXCJ8dHJ1ZXxmYWxzZXxudWxsfC0/XFxkKyg/OlxcLlxcZCopPyg/OltlRV1bK1xcLV0/XFxkKyk/L2c7XHJcblx0dmFyIHJ2YWxpZGJyYWNlcyA9IC8oPzpefDp8LCkoPzpcXHMqXFxbKSsvZztcclxuXHR2YXIgcnRyaW1MZWZ0ID0gL15cXHMrLztcclxuXHR2YXIgcnRyaW1SaWdodCA9IC9cXHMrJC87XHJcblx0XHJcblx0bW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBwYXJzZWpzb24oZGF0YSkge1xyXG5cdCAgaWYgKCdzdHJpbmcnICE9IHR5cGVvZiBkYXRhIHx8ICFkYXRhKSB7XHJcblx0ICAgIHJldHVybiBudWxsO1xyXG5cdCAgfVxyXG5cdFxyXG5cdCAgZGF0YSA9IGRhdGEucmVwbGFjZShydHJpbUxlZnQsICcnKS5yZXBsYWNlKHJ0cmltUmlnaHQsICcnKTtcclxuXHRcclxuXHQgIC8vIEF0dGVtcHQgdG8gcGFyc2UgdXNpbmcgdGhlIG5hdGl2ZSBKU09OIHBhcnNlciBmaXJzdFxyXG5cdCAgaWYgKGdsb2JhbC5KU09OICYmIEpTT04ucGFyc2UpIHtcclxuXHQgICAgcmV0dXJuIEpTT04ucGFyc2UoZGF0YSk7XHJcblx0ICB9XHJcblx0XHJcblx0ICBpZiAocnZhbGlkY2hhcnMudGVzdChkYXRhLnJlcGxhY2UocnZhbGlkZXNjYXBlLCAnQCcpXHJcblx0ICAgICAgLnJlcGxhY2UocnZhbGlkdG9rZW5zLCAnXScpXHJcblx0ICAgICAgLnJlcGxhY2UocnZhbGlkYnJhY2VzLCAnJykpKSB7XHJcblx0ICAgIHJldHVybiAobmV3IEZ1bmN0aW9uKCdyZXR1cm4gJyArIGRhdGEpKSgpO1xyXG5cdCAgfVxyXG5cdH07XG5cdC8qIFdFQlBBQ0sgVkFSIElOSkVDVElPTiAqL30uY2FsbChleHBvcnRzLCAoZnVuY3Rpb24oKSB7IHJldHVybiB0aGlzOyB9KCkpKSlcblxuLyoqKi8gfSksXG4vKiAzNiAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cdCd1c2Ugc3RyaWN0Jztcblx0XG5cdHZhciBfdHlwZW9mID0gdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPT09IFwic3ltYm9sXCIgPyBmdW5jdGlvbiAob2JqKSB7IHJldHVybiB0eXBlb2Ygb2JqOyB9IDogZnVuY3Rpb24gKG9iaikgeyByZXR1cm4gb2JqICYmIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBvYmouY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBvYmogIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIG9iajsgfTtcblx0XG5cdC8qKlxuXHQgKiBNb2R1bGUgZGVwZW5kZW5jaWVzLlxuXHQgKi9cblx0XG5cdHZhciBwYXJzZXIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQpO1xuXHR2YXIgRW1pdHRlciA9IF9fd2VicGFja19yZXF1aXJlX18oNSk7XG5cdHZhciB0b0FycmF5ID0gX193ZWJwYWNrX3JlcXVpcmVfXygzNyk7XG5cdHZhciBvbiA9IF9fd2VicGFja19yZXF1aXJlX18oMzgpO1xuXHR2YXIgYmluZCA9IF9fd2VicGFja19yZXF1aXJlX18oMzkpO1xuXHR2YXIgZGVidWcgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDMpKCdzb2NrZXQuaW8tY2xpZW50OnNvY2tldCcpO1xuXHR2YXIgcGFyc2VxcyA9IF9fd2VicGFja19yZXF1aXJlX18oMjgpO1xuXHRcblx0LyoqXG5cdCAqIE1vZHVsZSBleHBvcnRzLlxuXHQgKi9cblx0XG5cdG1vZHVsZS5leHBvcnRzID0gZXhwb3J0cyA9IFNvY2tldDtcblx0XG5cdC8qKlxuXHQgKiBJbnRlcm5hbCBldmVudHMgKGJsYWNrbGlzdGVkKS5cblx0ICogVGhlc2UgZXZlbnRzIGNhbid0IGJlIGVtaXR0ZWQgYnkgdGhlIHVzZXIuXG5cdCAqXG5cdCAqIEBhcGkgcHJpdmF0ZVxuXHQgKi9cblx0XG5cdHZhciBldmVudHMgPSB7XG5cdCAgY29ubmVjdDogMSxcblx0ICBjb25uZWN0X2Vycm9yOiAxLFxuXHQgIGNvbm5lY3RfdGltZW91dDogMSxcblx0ICBjb25uZWN0aW5nOiAxLFxuXHQgIGRpc2Nvbm5lY3Q6IDEsXG5cdCAgZXJyb3I6IDEsXG5cdCAgcmVjb25uZWN0OiAxLFxuXHQgIHJlY29ubmVjdF9hdHRlbXB0OiAxLFxuXHQgIHJlY29ubmVjdF9mYWlsZWQ6IDEsXG5cdCAgcmVjb25uZWN0X2Vycm9yOiAxLFxuXHQgIHJlY29ubmVjdGluZzogMSxcblx0ICBwaW5nOiAxLFxuXHQgIHBvbmc6IDFcblx0fTtcblx0XG5cdC8qKlxuXHQgKiBTaG9ydGN1dCB0byBgRW1pdHRlciNlbWl0YC5cblx0ICovXG5cdFxuXHR2YXIgZW1pdCA9IEVtaXR0ZXIucHJvdG90eXBlLmVtaXQ7XG5cdFxuXHQvKipcblx0ICogYFNvY2tldGAgY29uc3RydWN0b3IuXG5cdCAqXG5cdCAqIEBhcGkgcHVibGljXG5cdCAqL1xuXHRcblx0ZnVuY3Rpb24gU29ja2V0KGlvLCBuc3AsIG9wdHMpIHtcblx0ICB0aGlzLmlvID0gaW87XG5cdCAgdGhpcy5uc3AgPSBuc3A7XG5cdCAgdGhpcy5qc29uID0gdGhpczsgLy8gY29tcGF0XG5cdCAgdGhpcy5pZHMgPSAwO1xuXHQgIHRoaXMuYWNrcyA9IHt9O1xuXHQgIHRoaXMucmVjZWl2ZUJ1ZmZlciA9IFtdO1xuXHQgIHRoaXMuc2VuZEJ1ZmZlciA9IFtdO1xuXHQgIHRoaXMuY29ubmVjdGVkID0gZmFsc2U7XG5cdCAgdGhpcy5kaXNjb25uZWN0ZWQgPSB0cnVlO1xuXHQgIGlmIChvcHRzICYmIG9wdHMucXVlcnkpIHtcblx0ICAgIHRoaXMucXVlcnkgPSBvcHRzLnF1ZXJ5O1xuXHQgIH1cblx0ICBpZiAodGhpcy5pby5hdXRvQ29ubmVjdCkgdGhpcy5vcGVuKCk7XG5cdH1cblx0XG5cdC8qKlxuXHQgKiBNaXggaW4gYEVtaXR0ZXJgLlxuXHQgKi9cblx0XG5cdEVtaXR0ZXIoU29ja2V0LnByb3RvdHlwZSk7XG5cdFxuXHQvKipcblx0ICogU3Vic2NyaWJlIHRvIG9wZW4sIGNsb3NlIGFuZCBwYWNrZXQgZXZlbnRzXG5cdCAqXG5cdCAqIEBhcGkgcHJpdmF0ZVxuXHQgKi9cblx0XG5cdFNvY2tldC5wcm90b3R5cGUuc3ViRXZlbnRzID0gZnVuY3Rpb24gKCkge1xuXHQgIGlmICh0aGlzLnN1YnMpIHJldHVybjtcblx0XG5cdCAgdmFyIGlvID0gdGhpcy5pbztcblx0ICB0aGlzLnN1YnMgPSBbb24oaW8sICdvcGVuJywgYmluZCh0aGlzLCAnb25vcGVuJykpLCBvbihpbywgJ3BhY2tldCcsIGJpbmQodGhpcywgJ29ucGFja2V0JykpLCBvbihpbywgJ2Nsb3NlJywgYmluZCh0aGlzLCAnb25jbG9zZScpKV07XG5cdH07XG5cdFxuXHQvKipcblx0ICogXCJPcGVuc1wiIHRoZSBzb2NrZXQuXG5cdCAqXG5cdCAqIEBhcGkgcHVibGljXG5cdCAqL1xuXHRcblx0U29ja2V0LnByb3RvdHlwZS5vcGVuID0gU29ja2V0LnByb3RvdHlwZS5jb25uZWN0ID0gZnVuY3Rpb24gKCkge1xuXHQgIGlmICh0aGlzLmNvbm5lY3RlZCkgcmV0dXJuIHRoaXM7XG5cdFxuXHQgIHRoaXMuc3ViRXZlbnRzKCk7XG5cdCAgdGhpcy5pby5vcGVuKCk7IC8vIGVuc3VyZSBvcGVuXG5cdCAgaWYgKCdvcGVuJyA9PT0gdGhpcy5pby5yZWFkeVN0YXRlKSB0aGlzLm9ub3BlbigpO1xuXHQgIHRoaXMuZW1pdCgnY29ubmVjdGluZycpO1xuXHQgIHJldHVybiB0aGlzO1xuXHR9O1xuXHRcblx0LyoqXG5cdCAqIFNlbmRzIGEgYG1lc3NhZ2VgIGV2ZW50LlxuXHQgKlxuXHQgKiBAcmV0dXJuIHtTb2NrZXR9IHNlbGZcblx0ICogQGFwaSBwdWJsaWNcblx0ICovXG5cdFxuXHRTb2NrZXQucHJvdG90eXBlLnNlbmQgPSBmdW5jdGlvbiAoKSB7XG5cdCAgdmFyIGFyZ3MgPSB0b0FycmF5KGFyZ3VtZW50cyk7XG5cdCAgYXJncy51bnNoaWZ0KCdtZXNzYWdlJyk7XG5cdCAgdGhpcy5lbWl0LmFwcGx5KHRoaXMsIGFyZ3MpO1xuXHQgIHJldHVybiB0aGlzO1xuXHR9O1xuXHRcblx0LyoqXG5cdCAqIE92ZXJyaWRlIGBlbWl0YC5cblx0ICogSWYgdGhlIGV2ZW50IGlzIGluIGBldmVudHNgLCBpdCdzIGVtaXR0ZWQgbm9ybWFsbHkuXG5cdCAqXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBldmVudCBuYW1lXG5cdCAqIEByZXR1cm4ge1NvY2tldH0gc2VsZlxuXHQgKiBAYXBpIHB1YmxpY1xuXHQgKi9cblx0XG5cdFNvY2tldC5wcm90b3R5cGUuZW1pdCA9IGZ1bmN0aW9uIChldikge1xuXHQgIGlmIChldmVudHMuaGFzT3duUHJvcGVydHkoZXYpKSB7XG5cdCAgICBlbWl0LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG5cdCAgICByZXR1cm4gdGhpcztcblx0ICB9XG5cdFxuXHQgIHZhciBhcmdzID0gdG9BcnJheShhcmd1bWVudHMpO1xuXHQgIHZhciBwYWNrZXQgPSB7IHR5cGU6IHBhcnNlci5FVkVOVCwgZGF0YTogYXJncyB9O1xuXHRcblx0ICBwYWNrZXQub3B0aW9ucyA9IHt9O1xuXHQgIHBhY2tldC5vcHRpb25zLmNvbXByZXNzID0gIXRoaXMuZmxhZ3MgfHwgZmFsc2UgIT09IHRoaXMuZmxhZ3MuY29tcHJlc3M7XG5cdFxuXHQgIC8vIGV2ZW50IGFjayBjYWxsYmFja1xuXHQgIGlmICgnZnVuY3Rpb24nID09PSB0eXBlb2YgYXJnc1thcmdzLmxlbmd0aCAtIDFdKSB7XG5cdFxuXHQgICAgdGhpcy5hY2tzW3RoaXMuaWRzXSA9IGFyZ3MucG9wKCk7XG5cdCAgICBwYWNrZXQuaWQgPSB0aGlzLmlkcysrO1xuXHQgIH1cblx0XG5cdCAgaWYgKHRoaXMuY29ubmVjdGVkKSB7XG5cdCAgICB0aGlzLnBhY2tldChwYWNrZXQpO1xuXHQgIH0gZWxzZSB7XG5cdCAgICB0aGlzLnNlbmRCdWZmZXIucHVzaChwYWNrZXQpO1xuXHQgIH1cblx0XG5cdCAgZGVsZXRlIHRoaXMuZmxhZ3M7XG5cdFxuXHQgIHJldHVybiB0aGlzO1xuXHR9O1xuXHRcblx0LyoqXG5cdCAqIFNlbmRzIGEgcGFja2V0LlxuXHQgKlxuXHQgKiBAcGFyYW0ge09iamVjdH0gcGFja2V0XG5cdCAqIEBhcGkgcHJpdmF0ZVxuXHQgKi9cblx0XG5cdFNvY2tldC5wcm90b3R5cGUucGFja2V0ID0gZnVuY3Rpb24gKHBhY2tldCkge1xuXHQgIHBhY2tldC5uc3AgPSB0aGlzLm5zcDtcblx0ICB0aGlzLmlvLnBhY2tldChwYWNrZXQpO1xuXHR9O1xuXHRcblx0LyoqXG5cdCAqIENhbGxlZCB1cG9uIGVuZ2luZSBgb3BlbmAuXG5cdCAqXG5cdCAqIEBhcGkgcHJpdmF0ZVxuXHQgKi9cblx0XG5cdFNvY2tldC5wcm90b3R5cGUub25vcGVuID0gZnVuY3Rpb24gKCkge1xuXHRcblx0ICAvLyB3cml0ZSBjb25uZWN0IHBhY2tldCBpZiBuZWNlc3Nhcnlcblx0ICBpZiAoJy8nICE9PSB0aGlzLm5zcCkge1xuXHQgICAgaWYgKHRoaXMucXVlcnkpIHtcblx0ICAgICAgdmFyIHF1ZXJ5ID0gX3R5cGVvZih0aGlzLnF1ZXJ5KSA9PT0gJ29iamVjdCcgPyBwYXJzZXFzLmVuY29kZSh0aGlzLnF1ZXJ5KSA6IHRoaXMucXVlcnk7XG5cdFxuXHQgICAgICB0aGlzLnBhY2tldCh7IHR5cGU6IHBhcnNlci5DT05ORUNULCBxdWVyeTogcXVlcnkgfSk7XG5cdCAgICB9IGVsc2Uge1xuXHQgICAgICB0aGlzLnBhY2tldCh7IHR5cGU6IHBhcnNlci5DT05ORUNUIH0pO1xuXHQgICAgfVxuXHQgIH1cblx0fTtcblx0XG5cdC8qKlxuXHQgKiBDYWxsZWQgdXBvbiBlbmdpbmUgYGNsb3NlYC5cblx0ICpcblx0ICogQHBhcmFtIHtTdHJpbmd9IHJlYXNvblxuXHQgKiBAYXBpIHByaXZhdGVcblx0ICovXG5cdFxuXHRTb2NrZXQucHJvdG90eXBlLm9uY2xvc2UgPSBmdW5jdGlvbiAocmVhc29uKSB7XG5cdFxuXHQgIHRoaXMuY29ubmVjdGVkID0gZmFsc2U7XG5cdCAgdGhpcy5kaXNjb25uZWN0ZWQgPSB0cnVlO1xuXHQgIGRlbGV0ZSB0aGlzLmlkO1xuXHQgIHRoaXMuZW1pdCgnZGlzY29ubmVjdCcsIHJlYXNvbik7XG5cdH07XG5cdFxuXHQvKipcblx0ICogQ2FsbGVkIHdpdGggc29ja2V0IHBhY2tldC5cblx0ICpcblx0ICogQHBhcmFtIHtPYmplY3R9IHBhY2tldFxuXHQgKiBAYXBpIHByaXZhdGVcblx0ICovXG5cdFxuXHRTb2NrZXQucHJvdG90eXBlLm9ucGFja2V0ID0gZnVuY3Rpb24gKHBhY2tldCkge1xuXHQgIGlmIChwYWNrZXQubnNwICE9PSB0aGlzLm5zcCkgcmV0dXJuO1xuXHRcblx0ICBzd2l0Y2ggKHBhY2tldC50eXBlKSB7XG5cdCAgICBjYXNlIHBhcnNlci5DT05ORUNUOlxuXHQgICAgICB0aGlzLm9uY29ubmVjdCgpO1xuXHQgICAgICBicmVhaztcblx0XG5cdCAgICBjYXNlIHBhcnNlci5FVkVOVDpcblx0ICAgICAgdGhpcy5vbmV2ZW50KHBhY2tldCk7XG5cdCAgICAgIGJyZWFrO1xuXHRcblx0ICAgIGNhc2UgcGFyc2VyLkJJTkFSWV9FVkVOVDpcblx0ICAgICAgdGhpcy5vbmV2ZW50KHBhY2tldCk7XG5cdCAgICAgIGJyZWFrO1xuXHRcblx0ICAgIGNhc2UgcGFyc2VyLkFDSzpcblx0ICAgICAgdGhpcy5vbmFjayhwYWNrZXQpO1xuXHQgICAgICBicmVhaztcblx0XG5cdCAgICBjYXNlIHBhcnNlci5CSU5BUllfQUNLOlxuXHQgICAgICB0aGlzLm9uYWNrKHBhY2tldCk7XG5cdCAgICAgIGJyZWFrO1xuXHRcblx0ICAgIGNhc2UgcGFyc2VyLkRJU0NPTk5FQ1Q6XG5cdCAgICAgIHRoaXMub25kaXNjb25uZWN0KCk7XG5cdCAgICAgIGJyZWFrO1xuXHRcblx0ICAgIGNhc2UgcGFyc2VyLkVSUk9SOlxuXHQgICAgICB0aGlzLmVtaXQoJ2Vycm9yJywgcGFja2V0LmRhdGEpO1xuXHQgICAgICBicmVhaztcblx0ICB9XG5cdH07XG5cdFxuXHQvKipcblx0ICogQ2FsbGVkIHVwb24gYSBzZXJ2ZXIgZXZlbnQuXG5cdCAqXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBwYWNrZXRcblx0ICogQGFwaSBwcml2YXRlXG5cdCAqL1xuXHRcblx0U29ja2V0LnByb3RvdHlwZS5vbmV2ZW50ID0gZnVuY3Rpb24gKHBhY2tldCkge1xuXHQgIHZhciBhcmdzID0gcGFja2V0LmRhdGEgfHwgW107XG5cdFxuXHQgIGlmIChudWxsICE9IHBhY2tldC5pZCkge1xuXHRcblx0ICAgIGFyZ3MucHVzaCh0aGlzLmFjayhwYWNrZXQuaWQpKTtcblx0ICB9XG5cdFxuXHQgIGlmICh0aGlzLmNvbm5lY3RlZCkge1xuXHQgICAgZW1pdC5hcHBseSh0aGlzLCBhcmdzKTtcblx0ICB9IGVsc2Uge1xuXHQgICAgdGhpcy5yZWNlaXZlQnVmZmVyLnB1c2goYXJncyk7XG5cdCAgfVxuXHR9O1xuXHRcblx0LyoqXG5cdCAqIFByb2R1Y2VzIGFuIGFjayBjYWxsYmFjayB0byBlbWl0IHdpdGggYW4gZXZlbnQuXG5cdCAqXG5cdCAqIEBhcGkgcHJpdmF0ZVxuXHQgKi9cblx0XG5cdFNvY2tldC5wcm90b3R5cGUuYWNrID0gZnVuY3Rpb24gKGlkKSB7XG5cdCAgdmFyIHNlbGYgPSB0aGlzO1xuXHQgIHZhciBzZW50ID0gZmFsc2U7XG5cdCAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcblx0ICAgIC8vIHByZXZlbnQgZG91YmxlIGNhbGxiYWNrc1xuXHQgICAgaWYgKHNlbnQpIHJldHVybjtcblx0ICAgIHNlbnQgPSB0cnVlO1xuXHQgICAgdmFyIGFyZ3MgPSB0b0FycmF5KGFyZ3VtZW50cyk7XG5cdFxuXHQgICAgc2VsZi5wYWNrZXQoe1xuXHQgICAgICB0eXBlOiBwYXJzZXIuQUNLLFxuXHQgICAgICBpZDogaWQsXG5cdCAgICAgIGRhdGE6IGFyZ3Ncblx0ICAgIH0pO1xuXHQgIH07XG5cdH07XG5cdFxuXHQvKipcblx0ICogQ2FsbGVkIHVwb24gYSBzZXJ2ZXIgYWNrbm93bGVnZW1lbnQuXG5cdCAqXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBwYWNrZXRcblx0ICogQGFwaSBwcml2YXRlXG5cdCAqL1xuXHRcblx0U29ja2V0LnByb3RvdHlwZS5vbmFjayA9IGZ1bmN0aW9uIChwYWNrZXQpIHtcblx0ICB2YXIgYWNrID0gdGhpcy5hY2tzW3BhY2tldC5pZF07XG5cdCAgaWYgKCdmdW5jdGlvbicgPT09IHR5cGVvZiBhY2spIHtcblx0XG5cdCAgICBhY2suYXBwbHkodGhpcywgcGFja2V0LmRhdGEpO1xuXHQgICAgZGVsZXRlIHRoaXMuYWNrc1twYWNrZXQuaWRdO1xuXHQgIH0gZWxzZSB7fVxuXHR9O1xuXHRcblx0LyoqXG5cdCAqIENhbGxlZCB1cG9uIHNlcnZlciBjb25uZWN0LlxuXHQgKlxuXHQgKiBAYXBpIHByaXZhdGVcblx0ICovXG5cdFxuXHRTb2NrZXQucHJvdG90eXBlLm9uY29ubmVjdCA9IGZ1bmN0aW9uICgpIHtcblx0ICB0aGlzLmNvbm5lY3RlZCA9IHRydWU7XG5cdCAgdGhpcy5kaXNjb25uZWN0ZWQgPSBmYWxzZTtcblx0ICB0aGlzLmVtaXQoJ2Nvbm5lY3QnKTtcblx0ICB0aGlzLmVtaXRCdWZmZXJlZCgpO1xuXHR9O1xuXHRcblx0LyoqXG5cdCAqIEVtaXQgYnVmZmVyZWQgZXZlbnRzIChyZWNlaXZlZCBhbmQgZW1pdHRlZCkuXG5cdCAqXG5cdCAqIEBhcGkgcHJpdmF0ZVxuXHQgKi9cblx0XG5cdFNvY2tldC5wcm90b3R5cGUuZW1pdEJ1ZmZlcmVkID0gZnVuY3Rpb24gKCkge1xuXHQgIHZhciBpO1xuXHQgIGZvciAoaSA9IDA7IGkgPCB0aGlzLnJlY2VpdmVCdWZmZXIubGVuZ3RoOyBpKyspIHtcblx0ICAgIGVtaXQuYXBwbHkodGhpcywgdGhpcy5yZWNlaXZlQnVmZmVyW2ldKTtcblx0ICB9XG5cdCAgdGhpcy5yZWNlaXZlQnVmZmVyID0gW107XG5cdFxuXHQgIGZvciAoaSA9IDA7IGkgPCB0aGlzLnNlbmRCdWZmZXIubGVuZ3RoOyBpKyspIHtcblx0ICAgIHRoaXMucGFja2V0KHRoaXMuc2VuZEJ1ZmZlcltpXSk7XG5cdCAgfVxuXHQgIHRoaXMuc2VuZEJ1ZmZlciA9IFtdO1xuXHR9O1xuXHRcblx0LyoqXG5cdCAqIENhbGxlZCB1cG9uIHNlcnZlciBkaXNjb25uZWN0LlxuXHQgKlxuXHQgKiBAYXBpIHByaXZhdGVcblx0ICovXG5cdFxuXHRTb2NrZXQucHJvdG90eXBlLm9uZGlzY29ubmVjdCA9IGZ1bmN0aW9uICgpIHtcblx0XG5cdCAgdGhpcy5kZXN0cm95KCk7XG5cdCAgdGhpcy5vbmNsb3NlKCdpbyBzZXJ2ZXIgZGlzY29ubmVjdCcpO1xuXHR9O1xuXHRcblx0LyoqXG5cdCAqIENhbGxlZCB1cG9uIGZvcmNlZCBjbGllbnQvc2VydmVyIHNpZGUgZGlzY29ubmVjdGlvbnMsXG5cdCAqIHRoaXMgbWV0aG9kIGVuc3VyZXMgdGhlIG1hbmFnZXIgc3RvcHMgdHJhY2tpbmcgdXMgYW5kXG5cdCAqIHRoYXQgcmVjb25uZWN0aW9ucyBkb24ndCBnZXQgdHJpZ2dlcmVkIGZvciB0aGlzLlxuXHQgKlxuXHQgKiBAYXBpIHByaXZhdGUuXG5cdCAqL1xuXHRcblx0U29ja2V0LnByb3RvdHlwZS5kZXN0cm95ID0gZnVuY3Rpb24gKCkge1xuXHQgIGlmICh0aGlzLnN1YnMpIHtcblx0ICAgIC8vIGNsZWFuIHN1YnNjcmlwdGlvbnMgdG8gYXZvaWQgcmVjb25uZWN0aW9uc1xuXHQgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLnN1YnMubGVuZ3RoOyBpKyspIHtcblx0ICAgICAgdGhpcy5zdWJzW2ldLmRlc3Ryb3koKTtcblx0ICAgIH1cblx0ICAgIHRoaXMuc3VicyA9IG51bGw7XG5cdCAgfVxuXHRcblx0ICB0aGlzLmlvLmRlc3Ryb3kodGhpcyk7XG5cdH07XG5cdFxuXHQvKipcblx0ICogRGlzY29ubmVjdHMgdGhlIHNvY2tldCBtYW51YWxseS5cblx0ICpcblx0ICogQHJldHVybiB7U29ja2V0fSBzZWxmXG5cdCAqIEBhcGkgcHVibGljXG5cdCAqL1xuXHRcblx0U29ja2V0LnByb3RvdHlwZS5jbG9zZSA9IFNvY2tldC5wcm90b3R5cGUuZGlzY29ubmVjdCA9IGZ1bmN0aW9uICgpIHtcblx0ICBpZiAodGhpcy5jb25uZWN0ZWQpIHtcblx0XG5cdCAgICB0aGlzLnBhY2tldCh7IHR5cGU6IHBhcnNlci5ESVNDT05ORUNUIH0pO1xuXHQgIH1cblx0XG5cdCAgLy8gcmVtb3ZlIHNvY2tldCBmcm9tIHBvb2xcblx0ICB0aGlzLmRlc3Ryb3koKTtcblx0XG5cdCAgaWYgKHRoaXMuY29ubmVjdGVkKSB7XG5cdCAgICAvLyBmaXJlIGV2ZW50c1xuXHQgICAgdGhpcy5vbmNsb3NlKCdpbyBjbGllbnQgZGlzY29ubmVjdCcpO1xuXHQgIH1cblx0ICByZXR1cm4gdGhpcztcblx0fTtcblx0XG5cdC8qKlxuXHQgKiBTZXRzIHRoZSBjb21wcmVzcyBmbGFnLlxuXHQgKlxuXHQgKiBAcGFyYW0ge0Jvb2xlYW59IGlmIGB0cnVlYCwgY29tcHJlc3NlcyB0aGUgc2VuZGluZyBkYXRhXG5cdCAqIEByZXR1cm4ge1NvY2tldH0gc2VsZlxuXHQgKiBAYXBpIHB1YmxpY1xuXHQgKi9cblx0XG5cdFNvY2tldC5wcm90b3R5cGUuY29tcHJlc3MgPSBmdW5jdGlvbiAoY29tcHJlc3MpIHtcblx0ICB0aGlzLmZsYWdzID0gdGhpcy5mbGFncyB8fCB7fTtcblx0ICB0aGlzLmZsYWdzLmNvbXByZXNzID0gY29tcHJlc3M7XG5cdCAgcmV0dXJuIHRoaXM7XG5cdH07XG5cbi8qKiovIH0pLFxuLyogMzcgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcblxuXHRtb2R1bGUuZXhwb3J0cyA9IHRvQXJyYXlcblx0XG5cdGZ1bmN0aW9uIHRvQXJyYXkobGlzdCwgaW5kZXgpIHtcblx0ICAgIHZhciBhcnJheSA9IFtdXG5cdFxuXHQgICAgaW5kZXggPSBpbmRleCB8fCAwXG5cdFxuXHQgICAgZm9yICh2YXIgaSA9IGluZGV4IHx8IDA7IGkgPCBsaXN0Lmxlbmd0aDsgaSsrKSB7XG5cdCAgICAgICAgYXJyYXlbaSAtIGluZGV4XSA9IGxpc3RbaV1cblx0ICAgIH1cblx0XG5cdCAgICByZXR1cm4gYXJyYXlcblx0fVxuXG5cbi8qKiovIH0pLFxuLyogMzggKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcblxuXHRcInVzZSBzdHJpY3RcIjtcblx0XG5cdC8qKlxuXHQgKiBNb2R1bGUgZXhwb3J0cy5cblx0ICovXG5cdFxuXHRtb2R1bGUuZXhwb3J0cyA9IG9uO1xuXHRcblx0LyoqXG5cdCAqIEhlbHBlciBmb3Igc3Vic2NyaXB0aW9ucy5cblx0ICpcblx0ICogQHBhcmFtIHtPYmplY3R8RXZlbnRFbWl0dGVyfSBvYmogd2l0aCBgRW1pdHRlcmAgbWl4aW4gb3IgYEV2ZW50RW1pdHRlcmBcblx0ICogQHBhcmFtIHtTdHJpbmd9IGV2ZW50IG5hbWVcblx0ICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2tcblx0ICogQGFwaSBwdWJsaWNcblx0ICovXG5cdFxuXHRmdW5jdGlvbiBvbihvYmosIGV2LCBmbikge1xuXHQgIG9iai5vbihldiwgZm4pO1xuXHQgIHJldHVybiB7XG5cdCAgICBkZXN0cm95OiBmdW5jdGlvbiBkZXN0cm95KCkge1xuXHQgICAgICBvYmoucmVtb3ZlTGlzdGVuZXIoZXYsIGZuKTtcblx0ICAgIH1cblx0ICB9O1xuXHR9XG5cbi8qKiovIH0pLFxuLyogMzkgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcblxuXHQvKipcblx0ICogU2xpY2UgcmVmZXJlbmNlLlxuXHQgKi9cblx0XG5cdHZhciBzbGljZSA9IFtdLnNsaWNlO1xuXHRcblx0LyoqXG5cdCAqIEJpbmQgYG9iamAgdG8gYGZuYC5cblx0ICpcblx0ICogQHBhcmFtIHtPYmplY3R9IG9ialxuXHQgKiBAcGFyYW0ge0Z1bmN0aW9ufFN0cmluZ30gZm4gb3Igc3RyaW5nXG5cdCAqIEByZXR1cm4ge0Z1bmN0aW9ufVxuXHQgKiBAYXBpIHB1YmxpY1xuXHQgKi9cblx0XG5cdG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24ob2JqLCBmbil7XG5cdCAgaWYgKCdzdHJpbmcnID09IHR5cGVvZiBmbikgZm4gPSBvYmpbZm5dO1xuXHQgIGlmICgnZnVuY3Rpb24nICE9IHR5cGVvZiBmbikgdGhyb3cgbmV3IEVycm9yKCdiaW5kKCkgcmVxdWlyZXMgYSBmdW5jdGlvbicpO1xuXHQgIHZhciBhcmdzID0gc2xpY2UuY2FsbChhcmd1bWVudHMsIDIpO1xuXHQgIHJldHVybiBmdW5jdGlvbigpe1xuXHQgICAgcmV0dXJuIGZuLmFwcGx5KG9iaiwgYXJncy5jb25jYXQoc2xpY2UuY2FsbChhcmd1bWVudHMpKSk7XG5cdCAgfVxuXHR9O1xuXG5cbi8qKiovIH0pLFxuLyogNDAgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcblxuXHRcblx0LyoqXG5cdCAqIEV4cG9zZSBgQmFja29mZmAuXG5cdCAqL1xuXHRcblx0bW9kdWxlLmV4cG9ydHMgPSBCYWNrb2ZmO1xuXHRcblx0LyoqXG5cdCAqIEluaXRpYWxpemUgYmFja29mZiB0aW1lciB3aXRoIGBvcHRzYC5cblx0ICpcblx0ICogLSBgbWluYCBpbml0aWFsIHRpbWVvdXQgaW4gbWlsbGlzZWNvbmRzIFsxMDBdXG5cdCAqIC0gYG1heGAgbWF4IHRpbWVvdXQgWzEwMDAwXVxuXHQgKiAtIGBqaXR0ZXJgIFswXVxuXHQgKiAtIGBmYWN0b3JgIFsyXVxuXHQgKlxuXHQgKiBAcGFyYW0ge09iamVjdH0gb3B0c1xuXHQgKiBAYXBpIHB1YmxpY1xuXHQgKi9cblx0XG5cdGZ1bmN0aW9uIEJhY2tvZmYob3B0cykge1xuXHQgIG9wdHMgPSBvcHRzIHx8IHt9O1xuXHQgIHRoaXMubXMgPSBvcHRzLm1pbiB8fCAxMDA7XG5cdCAgdGhpcy5tYXggPSBvcHRzLm1heCB8fCAxMDAwMDtcblx0ICB0aGlzLmZhY3RvciA9IG9wdHMuZmFjdG9yIHx8IDI7XG5cdCAgdGhpcy5qaXR0ZXIgPSBvcHRzLmppdHRlciA+IDAgJiYgb3B0cy5qaXR0ZXIgPD0gMSA/IG9wdHMuaml0dGVyIDogMDtcblx0ICB0aGlzLmF0dGVtcHRzID0gMDtcblx0fVxuXHRcblx0LyoqXG5cdCAqIFJldHVybiB0aGUgYmFja29mZiBkdXJhdGlvbi5cblx0ICpcblx0ICogQHJldHVybiB7TnVtYmVyfVxuXHQgKiBAYXBpIHB1YmxpY1xuXHQgKi9cblx0XG5cdEJhY2tvZmYucHJvdG90eXBlLmR1cmF0aW9uID0gZnVuY3Rpb24oKXtcblx0ICB2YXIgbXMgPSB0aGlzLm1zICogTWF0aC5wb3codGhpcy5mYWN0b3IsIHRoaXMuYXR0ZW1wdHMrKyk7XG5cdCAgaWYgKHRoaXMuaml0dGVyKSB7XG5cdCAgICB2YXIgcmFuZCA9ICBNYXRoLnJhbmRvbSgpO1xuXHQgICAgdmFyIGRldmlhdGlvbiA9IE1hdGguZmxvb3IocmFuZCAqIHRoaXMuaml0dGVyICogbXMpO1xuXHQgICAgbXMgPSAoTWF0aC5mbG9vcihyYW5kICogMTApICYgMSkgPT0gMCAgPyBtcyAtIGRldmlhdGlvbiA6IG1zICsgZGV2aWF0aW9uO1xuXHQgIH1cblx0ICByZXR1cm4gTWF0aC5taW4obXMsIHRoaXMubWF4KSB8IDA7XG5cdH07XG5cdFxuXHQvKipcblx0ICogUmVzZXQgdGhlIG51bWJlciBvZiBhdHRlbXB0cy5cblx0ICpcblx0ICogQGFwaSBwdWJsaWNcblx0ICovXG5cdFxuXHRCYWNrb2ZmLnByb3RvdHlwZS5yZXNldCA9IGZ1bmN0aW9uKCl7XG5cdCAgdGhpcy5hdHRlbXB0cyA9IDA7XG5cdH07XG5cdFxuXHQvKipcblx0ICogU2V0IHRoZSBtaW5pbXVtIGR1cmF0aW9uXG5cdCAqXG5cdCAqIEBhcGkgcHVibGljXG5cdCAqL1xuXHRcblx0QmFja29mZi5wcm90b3R5cGUuc2V0TWluID0gZnVuY3Rpb24obWluKXtcblx0ICB0aGlzLm1zID0gbWluO1xuXHR9O1xuXHRcblx0LyoqXG5cdCAqIFNldCB0aGUgbWF4aW11bSBkdXJhdGlvblxuXHQgKlxuXHQgKiBAYXBpIHB1YmxpY1xuXHQgKi9cblx0XG5cdEJhY2tvZmYucHJvdG90eXBlLnNldE1heCA9IGZ1bmN0aW9uKG1heCl7XG5cdCAgdGhpcy5tYXggPSBtYXg7XG5cdH07XG5cdFxuXHQvKipcblx0ICogU2V0IHRoZSBqaXR0ZXJcblx0ICpcblx0ICogQGFwaSBwdWJsaWNcblx0ICovXG5cdFxuXHRCYWNrb2ZmLnByb3RvdHlwZS5zZXRKaXR0ZXIgPSBmdW5jdGlvbihqaXR0ZXIpe1xuXHQgIHRoaXMuaml0dGVyID0gaml0dGVyO1xuXHR9O1xuXHRcblxuXG4vKioqLyB9KVxuLyoqKioqKi8gXSlcbn0pO1xuO1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyBzb2NrZXQuaW8uc2xpbS5qcyIsIiBcdC8vIFRoZSBtb2R1bGUgY2FjaGVcbiBcdHZhciBpbnN0YWxsZWRNb2R1bGVzID0ge307XG5cbiBcdC8vIFRoZSByZXF1aXJlIGZ1bmN0aW9uXG4gXHRmdW5jdGlvbiBfX3dlYnBhY2tfcmVxdWlyZV9fKG1vZHVsZUlkKSB7XG5cbiBcdFx0Ly8gQ2hlY2sgaWYgbW9kdWxlIGlzIGluIGNhY2hlXG4gXHRcdGlmKGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdKVxuIFx0XHRcdHJldHVybiBpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXS5leHBvcnRzO1xuXG4gXHRcdC8vIENyZWF0ZSBhIG5ldyBtb2R1bGUgKGFuZCBwdXQgaXQgaW50byB0aGUgY2FjaGUpXG4gXHRcdHZhciBtb2R1bGUgPSBpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXSA9IHtcbiBcdFx0XHRleHBvcnRzOiB7fSxcbiBcdFx0XHRpZDogbW9kdWxlSWQsXG4gXHRcdFx0bG9hZGVkOiBmYWxzZVxuIFx0XHR9O1xuXG4gXHRcdC8vIEV4ZWN1dGUgdGhlIG1vZHVsZSBmdW5jdGlvblxuIFx0XHRtb2R1bGVzW21vZHVsZUlkXS5jYWxsKG1vZHVsZS5leHBvcnRzLCBtb2R1bGUsIG1vZHVsZS5leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKTtcblxuIFx0XHQvLyBGbGFnIHRoZSBtb2R1bGUgYXMgbG9hZGVkXG4gXHRcdG1vZHVsZS5sb2FkZWQgPSB0cnVlO1xuXG4gXHRcdC8vIFJldHVybiB0aGUgZXhwb3J0cyBvZiB0aGUgbW9kdWxlXG4gXHRcdHJldHVybiBtb2R1bGUuZXhwb3J0cztcbiBcdH1cblxuXG4gXHQvLyBleHBvc2UgdGhlIG1vZHVsZXMgb2JqZWN0IChfX3dlYnBhY2tfbW9kdWxlc19fKVxuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5tID0gbW9kdWxlcztcblxuIFx0Ly8gZXhwb3NlIHRoZSBtb2R1bGUgY2FjaGVcbiBcdF9fd2VicGFja19yZXF1aXJlX18uYyA9IGluc3RhbGxlZE1vZHVsZXM7XG5cbiBcdC8vIF9fd2VicGFja19wdWJsaWNfcGF0aF9fXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLnAgPSBcIlwiO1xuXG4gXHQvLyBMb2FkIGVudHJ5IG1vZHVsZSBhbmQgcmV0dXJuIGV4cG9ydHNcbiBcdHJldHVybiBfX3dlYnBhY2tfcmVxdWlyZV9fKDApO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIHdlYnBhY2svYm9vdHN0cmFwIDZlZmMzM2Y0NTY2OTFmNDU4YTkwIiwiXG4vKipcbiAqIE1vZHVsZSBkZXBlbmRlbmNpZXMuXG4gKi9cblxudmFyIHVybCA9IHJlcXVpcmUoJy4vdXJsJyk7XG52YXIgcGFyc2VyID0gcmVxdWlyZSgnc29ja2V0LmlvLXBhcnNlcicpO1xudmFyIE1hbmFnZXIgPSByZXF1aXJlKCcuL21hbmFnZXInKTtcbnZhciBkZWJ1ZyA9IHJlcXVpcmUoJ2RlYnVnJykoJ3NvY2tldC5pby1jbGllbnQnKTtcblxuLyoqXG4gKiBNb2R1bGUgZXhwb3J0cy5cbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHMgPSBsb29rdXA7XG5cbi8qKlxuICogTWFuYWdlcnMgY2FjaGUuXG4gKi9cblxudmFyIGNhY2hlID0gZXhwb3J0cy5tYW5hZ2VycyA9IHt9O1xuXG4vKipcbiAqIExvb2tzIHVwIGFuIGV4aXN0aW5nIGBNYW5hZ2VyYCBmb3IgbXVsdGlwbGV4aW5nLlxuICogSWYgdGhlIHVzZXIgc3VtbW9uczpcbiAqXG4gKiAgIGBpbygnaHR0cDovL2xvY2FsaG9zdC9hJyk7YFxuICogICBgaW8oJ2h0dHA6Ly9sb2NhbGhvc3QvYicpO2BcbiAqXG4gKiBXZSByZXVzZSB0aGUgZXhpc3RpbmcgaW5zdGFuY2UgYmFzZWQgb24gc2FtZSBzY2hlbWUvcG9ydC9ob3N0LFxuICogYW5kIHdlIGluaXRpYWxpemUgc29ja2V0cyBmb3IgZWFjaCBuYW1lc3BhY2UuXG4gKlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5mdW5jdGlvbiBsb29rdXAgKHVyaSwgb3B0cykge1xuICBpZiAodHlwZW9mIHVyaSA9PT0gJ29iamVjdCcpIHtcbiAgICBvcHRzID0gdXJpO1xuICAgIHVyaSA9IHVuZGVmaW5lZDtcbiAgfVxuXG4gIG9wdHMgPSBvcHRzIHx8IHt9O1xuXG4gIHZhciBwYXJzZWQgPSB1cmwodXJpKTtcbiAgdmFyIHNvdXJjZSA9IHBhcnNlZC5zb3VyY2U7XG4gIHZhciBpZCA9IHBhcnNlZC5pZDtcbiAgdmFyIHBhdGggPSBwYXJzZWQucGF0aDtcbiAgdmFyIHNhbWVOYW1lc3BhY2UgPSBjYWNoZVtpZF0gJiYgcGF0aCBpbiBjYWNoZVtpZF0ubnNwcztcbiAgdmFyIG5ld0Nvbm5lY3Rpb24gPSBvcHRzLmZvcmNlTmV3IHx8IG9wdHNbJ2ZvcmNlIG5ldyBjb25uZWN0aW9uJ10gfHxcbiAgICAgICAgICAgICAgICAgICAgICBmYWxzZSA9PT0gb3B0cy5tdWx0aXBsZXggfHwgc2FtZU5hbWVzcGFjZTtcblxuICB2YXIgaW87XG5cbiAgaWYgKG5ld0Nvbm5lY3Rpb24pIHtcblxuICAgIGlvID0gTWFuYWdlcihzb3VyY2UsIG9wdHMpO1xuICB9IGVsc2Uge1xuICAgIGlmICghY2FjaGVbaWRdKSB7XG5cbiAgICAgIGNhY2hlW2lkXSA9IE1hbmFnZXIoc291cmNlLCBvcHRzKTtcbiAgICB9XG4gICAgaW8gPSBjYWNoZVtpZF07XG4gIH1cbiAgaWYgKHBhcnNlZC5xdWVyeSAmJiAhb3B0cy5xdWVyeSkge1xuICAgIG9wdHMucXVlcnkgPSBwYXJzZWQucXVlcnk7XG4gIH1cbiAgcmV0dXJuIGlvLnNvY2tldChwYXJzZWQucGF0aCwgb3B0cyk7XG59XG5cbi8qKlxuICogUHJvdG9jb2wgdmVyc2lvbi5cbiAqXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmV4cG9ydHMucHJvdG9jb2wgPSBwYXJzZXIucHJvdG9jb2w7XG5cbi8qKlxuICogYGNvbm5lY3RgLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSB1cmlcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZXhwb3J0cy5jb25uZWN0ID0gbG9va3VwO1xuXG4vKipcbiAqIEV4cG9zZSBjb25zdHJ1Y3RvcnMgZm9yIHN0YW5kYWxvbmUgYnVpbGQuXG4gKlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5leHBvcnRzLk1hbmFnZXIgPSByZXF1aXJlKCcuL21hbmFnZXInKTtcbmV4cG9ydHMuU29ja2V0ID0gcmVxdWlyZSgnLi9zb2NrZXQnKTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL2xpYi9pbmRleC5qcyIsIlxuLyoqXG4gKiBNb2R1bGUgZGVwZW5kZW5jaWVzLlxuICovXG5cbnZhciBwYXJzZXVyaSA9IHJlcXVpcmUoJ3BhcnNldXJpJyk7XG52YXIgZGVidWcgPSByZXF1aXJlKCdkZWJ1ZycpKCdzb2NrZXQuaW8tY2xpZW50OnVybCcpO1xuXG4vKipcbiAqIE1vZHVsZSBleHBvcnRzLlxuICovXG5cbm1vZHVsZS5leHBvcnRzID0gdXJsO1xuXG4vKipcbiAqIFVSTCBwYXJzZXIuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHVybFxuICogQHBhcmFtIHtPYmplY3R9IEFuIG9iamVjdCBtZWFudCB0byBtaW1pYyB3aW5kb3cubG9jYXRpb24uXG4gKiAgICAgICAgICAgICAgICAgRGVmYXVsdHMgdG8gd2luZG93LmxvY2F0aW9uLlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5mdW5jdGlvbiB1cmwgKHVyaSwgbG9jKSB7XG4gIHZhciBvYmogPSB1cmk7XG5cbiAgLy8gZGVmYXVsdCB0byB3aW5kb3cubG9jYXRpb25cbiAgbG9jID0gbG9jIHx8IGdsb2JhbC5sb2NhdGlvbjtcbiAgaWYgKG51bGwgPT0gdXJpKSB1cmkgPSBsb2MucHJvdG9jb2wgKyAnLy8nICsgbG9jLmhvc3Q7XG5cbiAgLy8gcmVsYXRpdmUgcGF0aCBzdXBwb3J0XG4gIGlmICgnc3RyaW5nJyA9PT0gdHlwZW9mIHVyaSkge1xuICAgIGlmICgnLycgPT09IHVyaS5jaGFyQXQoMCkpIHtcbiAgICAgIGlmICgnLycgPT09IHVyaS5jaGFyQXQoMSkpIHtcbiAgICAgICAgdXJpID0gbG9jLnByb3RvY29sICsgdXJpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdXJpID0gbG9jLmhvc3QgKyB1cmk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKCEvXihodHRwcz98d3NzPyk6XFwvXFwvLy50ZXN0KHVyaSkpIHtcblxuICAgICAgaWYgKCd1bmRlZmluZWQnICE9PSB0eXBlb2YgbG9jKSB7XG4gICAgICAgIHVyaSA9IGxvYy5wcm90b2NvbCArICcvLycgKyB1cmk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB1cmkgPSAnaHR0cHM6Ly8nICsgdXJpO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIHBhcnNlXG5cbiAgICBvYmogPSBwYXJzZXVyaSh1cmkpO1xuICB9XG5cbiAgLy8gbWFrZSBzdXJlIHdlIHRyZWF0IGBsb2NhbGhvc3Q6ODBgIGFuZCBgbG9jYWxob3N0YCBlcXVhbGx5XG4gIGlmICghb2JqLnBvcnQpIHtcbiAgICBpZiAoL14oaHR0cHx3cykkLy50ZXN0KG9iai5wcm90b2NvbCkpIHtcbiAgICAgIG9iai5wb3J0ID0gJzgwJztcbiAgICB9IGVsc2UgaWYgKC9eKGh0dHB8d3MpcyQvLnRlc3Qob2JqLnByb3RvY29sKSkge1xuICAgICAgb2JqLnBvcnQgPSAnNDQzJztcbiAgICB9XG4gIH1cblxuICBvYmoucGF0aCA9IG9iai5wYXRoIHx8ICcvJztcblxuICB2YXIgaXB2NiA9IG9iai5ob3N0LmluZGV4T2YoJzonKSAhPT0gLTE7XG4gIHZhciBob3N0ID0gaXB2NiA/ICdbJyArIG9iai5ob3N0ICsgJ10nIDogb2JqLmhvc3Q7XG5cbiAgLy8gZGVmaW5lIHVuaXF1ZSBpZFxuICBvYmouaWQgPSBvYmoucHJvdG9jb2wgKyAnOi8vJyArIGhvc3QgKyAnOicgKyBvYmoucG9ydDtcbiAgLy8gZGVmaW5lIGhyZWZcbiAgb2JqLmhyZWYgPSBvYmoucHJvdG9jb2wgKyAnOi8vJyArIGhvc3QgKyAobG9jICYmIGxvYy5wb3J0ID09PSBvYmoucG9ydCA/ICcnIDogKCc6JyArIG9iai5wb3J0KSk7XG5cbiAgcmV0dXJuIG9iajtcbn1cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL2xpYi91cmwuanMiLCIvKipcclxuICogUGFyc2VzIGFuIFVSSVxyXG4gKlxyXG4gKiBAYXV0aG9yIFN0ZXZlbiBMZXZpdGhhbiA8c3RldmVubGV2aXRoYW4uY29tPiAoTUlUIGxpY2Vuc2UpXHJcbiAqIEBhcGkgcHJpdmF0ZVxyXG4gKi9cclxuXHJcbnZhciByZSA9IC9eKD86KD8hW146QF0rOlteOkBcXC9dKkApKGh0dHB8aHR0cHN8d3N8d3NzKTpcXC9cXC8pPygoPzooKFteOkBdKikoPzo6KFteOkBdKikpPyk/QCk/KCg/OlthLWYwLTldezAsNH06KXsyLDd9W2EtZjAtOV17MCw0fXxbXjpcXC8/I10qKSg/OjooXFxkKikpPykoKChcXC8oPzpbXj8jXSg/IVtePyNcXC9dKlxcLltePyNcXC8uXSsoPzpbPyNdfCQpKSkqXFwvPyk/KFtePyNcXC9dKikpKD86XFw/KFteI10qKSk/KD86IyguKikpPykvO1xyXG5cclxudmFyIHBhcnRzID0gW1xyXG4gICAgJ3NvdXJjZScsICdwcm90b2NvbCcsICdhdXRob3JpdHknLCAndXNlckluZm8nLCAndXNlcicsICdwYXNzd29yZCcsICdob3N0JywgJ3BvcnQnLCAncmVsYXRpdmUnLCAncGF0aCcsICdkaXJlY3RvcnknLCAnZmlsZScsICdxdWVyeScsICdhbmNob3InXHJcbl07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIHBhcnNldXJpKHN0cikge1xyXG4gICAgdmFyIHNyYyA9IHN0cixcclxuICAgICAgICBiID0gc3RyLmluZGV4T2YoJ1snKSxcclxuICAgICAgICBlID0gc3RyLmluZGV4T2YoJ10nKTtcclxuXHJcbiAgICBpZiAoYiAhPSAtMSAmJiBlICE9IC0xKSB7XHJcbiAgICAgICAgc3RyID0gc3RyLnN1YnN0cmluZygwLCBiKSArIHN0ci5zdWJzdHJpbmcoYiwgZSkucmVwbGFjZSgvOi9nLCAnOycpICsgc3RyLnN1YnN0cmluZyhlLCBzdHIubGVuZ3RoKTtcclxuICAgIH1cclxuXHJcbiAgICB2YXIgbSA9IHJlLmV4ZWMoc3RyIHx8ICcnKSxcclxuICAgICAgICB1cmkgPSB7fSxcclxuICAgICAgICBpID0gMTQ7XHJcblxyXG4gICAgd2hpbGUgKGktLSkge1xyXG4gICAgICAgIHVyaVtwYXJ0c1tpXV0gPSBtW2ldIHx8ICcnO1xyXG4gICAgfVxyXG5cclxuICAgIGlmIChiICE9IC0xICYmIGUgIT0gLTEpIHtcclxuICAgICAgICB1cmkuc291cmNlID0gc3JjO1xyXG4gICAgICAgIHVyaS5ob3N0ID0gdXJpLmhvc3Quc3Vic3RyaW5nKDEsIHVyaS5ob3N0Lmxlbmd0aCAtIDEpLnJlcGxhY2UoLzsvZywgJzonKTtcclxuICAgICAgICB1cmkuYXV0aG9yaXR5ID0gdXJpLmF1dGhvcml0eS5yZXBsYWNlKCdbJywgJycpLnJlcGxhY2UoJ10nLCAnJykucmVwbGFjZSgvOy9nLCAnOicpO1xyXG4gICAgICAgIHVyaS5pcHY2dXJpID0gdHJ1ZTtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gdXJpO1xyXG59O1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vcGFyc2V1cmkvaW5kZXguanNcbi8vIG1vZHVsZSBpZCA9IDJcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGZ1bmN0aW9uICgpIHt9OyB9O1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3VwcG9ydC9ub29wLmpzIiwiXG4vKipcbiAqIE1vZHVsZSBkZXBlbmRlbmNpZXMuXG4gKi9cblxudmFyIGRlYnVnID0gcmVxdWlyZSgnZGVidWcnKSgnc29ja2V0LmlvLXBhcnNlcicpO1xudmFyIEVtaXR0ZXIgPSByZXF1aXJlKCdjb21wb25lbnQtZW1pdHRlcicpO1xudmFyIGhhc0JpbiA9IHJlcXVpcmUoJ2hhcy1iaW5hcnkyJyk7XG52YXIgYmluYXJ5ID0gcmVxdWlyZSgnLi9iaW5hcnknKTtcbnZhciBpc0J1ZiA9IHJlcXVpcmUoJy4vaXMtYnVmZmVyJyk7XG5cbi8qKlxuICogUHJvdG9jb2wgdmVyc2lvbi5cbiAqXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmV4cG9ydHMucHJvdG9jb2wgPSA0O1xuXG4vKipcbiAqIFBhY2tldCB0eXBlcy5cbiAqXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmV4cG9ydHMudHlwZXMgPSBbXG4gICdDT05ORUNUJyxcbiAgJ0RJU0NPTk5FQ1QnLFxuICAnRVZFTlQnLFxuICAnQUNLJyxcbiAgJ0VSUk9SJyxcbiAgJ0JJTkFSWV9FVkVOVCcsXG4gICdCSU5BUllfQUNLJ1xuXTtcblxuLyoqXG4gKiBQYWNrZXQgdHlwZSBgY29ubmVjdGAuXG4gKlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5leHBvcnRzLkNPTk5FQ1QgPSAwO1xuXG4vKipcbiAqIFBhY2tldCB0eXBlIGBkaXNjb25uZWN0YC5cbiAqXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmV4cG9ydHMuRElTQ09OTkVDVCA9IDE7XG5cbi8qKlxuICogUGFja2V0IHR5cGUgYGV2ZW50YC5cbiAqXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmV4cG9ydHMuRVZFTlQgPSAyO1xuXG4vKipcbiAqIFBhY2tldCB0eXBlIGBhY2tgLlxuICpcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZXhwb3J0cy5BQ0sgPSAzO1xuXG4vKipcbiAqIFBhY2tldCB0eXBlIGBlcnJvcmAuXG4gKlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5leHBvcnRzLkVSUk9SID0gNDtcblxuLyoqXG4gKiBQYWNrZXQgdHlwZSAnYmluYXJ5IGV2ZW50J1xuICpcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZXhwb3J0cy5CSU5BUllfRVZFTlQgPSA1O1xuXG4vKipcbiAqIFBhY2tldCB0eXBlIGBiaW5hcnkgYWNrYC4gRm9yIGFja3Mgd2l0aCBiaW5hcnkgYXJndW1lbnRzLlxuICpcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZXhwb3J0cy5CSU5BUllfQUNLID0gNjtcblxuLyoqXG4gKiBFbmNvZGVyIGNvbnN0cnVjdG9yLlxuICpcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZXhwb3J0cy5FbmNvZGVyID0gRW5jb2RlcjtcblxuLyoqXG4gKiBEZWNvZGVyIGNvbnN0cnVjdG9yLlxuICpcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZXhwb3J0cy5EZWNvZGVyID0gRGVjb2RlcjtcblxuLyoqXG4gKiBBIHNvY2tldC5pbyBFbmNvZGVyIGluc3RhbmNlXG4gKlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5mdW5jdGlvbiBFbmNvZGVyKCkge31cblxuLyoqXG4gKiBFbmNvZGUgYSBwYWNrZXQgYXMgYSBzaW5nbGUgc3RyaW5nIGlmIG5vbi1iaW5hcnksIG9yIGFzIGFcbiAqIGJ1ZmZlciBzZXF1ZW5jZSwgZGVwZW5kaW5nIG9uIHBhY2tldCB0eXBlLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmogLSBwYWNrZXQgb2JqZWN0XG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFjayAtIGZ1bmN0aW9uIHRvIGhhbmRsZSBlbmNvZGluZ3MgKGxpa2VseSBlbmdpbmUud3JpdGUpXG4gKiBAcmV0dXJuIENhbGxzIGNhbGxiYWNrIHdpdGggQXJyYXkgb2YgZW5jb2RpbmdzXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbkVuY29kZXIucHJvdG90eXBlLmVuY29kZSA9IGZ1bmN0aW9uKG9iaiwgY2FsbGJhY2spe1xuICBpZiAoKG9iai50eXBlID09PSBleHBvcnRzLkVWRU5UIHx8IG9iai50eXBlID09PSBleHBvcnRzLkFDSykgJiYgaGFzQmluKG9iai5kYXRhKSkge1xuICAgIG9iai50eXBlID0gb2JqLnR5cGUgPT09IGV4cG9ydHMuRVZFTlQgPyBleHBvcnRzLkJJTkFSWV9FVkVOVCA6IGV4cG9ydHMuQklOQVJZX0FDSztcbiAgfVxuXG5cblxuICBpZiAoZXhwb3J0cy5CSU5BUllfRVZFTlQgPT09IG9iai50eXBlIHx8IGV4cG9ydHMuQklOQVJZX0FDSyA9PT0gb2JqLnR5cGUpIHtcbiAgICBlbmNvZGVBc0JpbmFyeShvYmosIGNhbGxiYWNrKTtcbiAgfVxuICBlbHNlIHtcbiAgICB2YXIgZW5jb2RpbmcgPSBlbmNvZGVBc1N0cmluZyhvYmopO1xuICAgIGNhbGxiYWNrKFtlbmNvZGluZ10pO1xuICB9XG59O1xuXG4vKipcbiAqIEVuY29kZSBwYWNrZXQgYXMgc3RyaW5nLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBwYWNrZXRcbiAqIEByZXR1cm4ge1N0cmluZ30gZW5jb2RlZFxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gZW5jb2RlQXNTdHJpbmcob2JqKSB7XG5cbiAgLy8gZmlyc3QgaXMgdHlwZVxuICB2YXIgc3RyID0gJycgKyBvYmoudHlwZTtcblxuICAvLyBhdHRhY2htZW50cyBpZiB3ZSBoYXZlIHRoZW1cbiAgaWYgKGV4cG9ydHMuQklOQVJZX0VWRU5UID09PSBvYmoudHlwZSB8fCBleHBvcnRzLkJJTkFSWV9BQ0sgPT09IG9iai50eXBlKSB7XG4gICAgc3RyICs9IG9iai5hdHRhY2htZW50cyArICctJztcbiAgfVxuXG4gIC8vIGlmIHdlIGhhdmUgYSBuYW1lc3BhY2Ugb3RoZXIgdGhhbiBgL2BcbiAgLy8gd2UgYXBwZW5kIGl0IGZvbGxvd2VkIGJ5IGEgY29tbWEgYCxgXG4gIGlmIChvYmoubnNwICYmICcvJyAhPT0gb2JqLm5zcCkge1xuICAgIHN0ciArPSBvYmoubnNwICsgJywnO1xuICB9XG5cbiAgLy8gaW1tZWRpYXRlbHkgZm9sbG93ZWQgYnkgdGhlIGlkXG4gIGlmIChudWxsICE9IG9iai5pZCkge1xuICAgIHN0ciArPSBvYmouaWQ7XG4gIH1cblxuICAvLyBqc29uIGRhdGFcbiAgaWYgKG51bGwgIT0gb2JqLmRhdGEpIHtcbiAgICBzdHIgKz0gSlNPTi5zdHJpbmdpZnkob2JqLmRhdGEpO1xuICB9XG5cblxuICByZXR1cm4gc3RyO1xufVxuXG4vKipcbiAqIEVuY29kZSBwYWNrZXQgYXMgJ2J1ZmZlciBzZXF1ZW5jZScgYnkgcmVtb3ZpbmcgYmxvYnMsIGFuZFxuICogZGVjb25zdHJ1Y3RpbmcgcGFja2V0IGludG8gb2JqZWN0IHdpdGggcGxhY2Vob2xkZXJzIGFuZFxuICogYSBsaXN0IG9mIGJ1ZmZlcnMuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IHBhY2tldFxuICogQHJldHVybiB7QnVmZmVyfSBlbmNvZGVkXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBlbmNvZGVBc0JpbmFyeShvYmosIGNhbGxiYWNrKSB7XG5cbiAgZnVuY3Rpb24gd3JpdGVFbmNvZGluZyhibG9ibGVzc0RhdGEpIHtcbiAgICB2YXIgZGVjb25zdHJ1Y3Rpb24gPSBiaW5hcnkuZGVjb25zdHJ1Y3RQYWNrZXQoYmxvYmxlc3NEYXRhKTtcbiAgICB2YXIgcGFjayA9IGVuY29kZUFzU3RyaW5nKGRlY29uc3RydWN0aW9uLnBhY2tldCk7XG4gICAgdmFyIGJ1ZmZlcnMgPSBkZWNvbnN0cnVjdGlvbi5idWZmZXJzO1xuXG4gICAgYnVmZmVycy51bnNoaWZ0KHBhY2spOyAvLyBhZGQgcGFja2V0IGluZm8gdG8gYmVnaW5uaW5nIG9mIGRhdGEgbGlzdFxuICAgIGNhbGxiYWNrKGJ1ZmZlcnMpOyAvLyB3cml0ZSBhbGwgdGhlIGJ1ZmZlcnNcbiAgfVxuXG4gIGJpbmFyeS5yZW1vdmVCbG9icyhvYmosIHdyaXRlRW5jb2RpbmcpO1xufVxuXG4vKipcbiAqIEEgc29ja2V0LmlvIERlY29kZXIgaW5zdGFuY2VcbiAqXG4gKiBAcmV0dXJuIHtPYmplY3R9IGRlY29kZXJcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZnVuY3Rpb24gRGVjb2RlcigpIHtcbiAgdGhpcy5yZWNvbnN0cnVjdG9yID0gbnVsbDtcbn1cblxuLyoqXG4gKiBNaXggaW4gYEVtaXR0ZXJgIHdpdGggRGVjb2Rlci5cbiAqL1xuXG5FbWl0dGVyKERlY29kZXIucHJvdG90eXBlKTtcblxuLyoqXG4gKiBEZWNvZGVzIGFuIGVjb2RlZCBwYWNrZXQgc3RyaW5nIGludG8gcGFja2V0IEpTT04uXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IG9iaiAtIGVuY29kZWQgcGFja2V0XG4gKiBAcmV0dXJuIHtPYmplY3R9IHBhY2tldFxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5EZWNvZGVyLnByb3RvdHlwZS5hZGQgPSBmdW5jdGlvbihvYmopIHtcbiAgdmFyIHBhY2tldDtcbiAgaWYgKHR5cGVvZiBvYmogPT09ICdzdHJpbmcnKSB7XG4gICAgcGFja2V0ID0gZGVjb2RlU3RyaW5nKG9iaik7XG4gICAgaWYgKGV4cG9ydHMuQklOQVJZX0VWRU5UID09PSBwYWNrZXQudHlwZSB8fCBleHBvcnRzLkJJTkFSWV9BQ0sgPT09IHBhY2tldC50eXBlKSB7IC8vIGJpbmFyeSBwYWNrZXQncyBqc29uXG4gICAgICB0aGlzLnJlY29uc3RydWN0b3IgPSBuZXcgQmluYXJ5UmVjb25zdHJ1Y3RvcihwYWNrZXQpO1xuXG4gICAgICAvLyBubyBhdHRhY2htZW50cywgbGFiZWxlZCBiaW5hcnkgYnV0IG5vIGJpbmFyeSBkYXRhIHRvIGZvbGxvd1xuICAgICAgaWYgKHRoaXMucmVjb25zdHJ1Y3Rvci5yZWNvblBhY2suYXR0YWNobWVudHMgPT09IDApIHtcbiAgICAgICAgdGhpcy5lbWl0KCdkZWNvZGVkJywgcGFja2V0KTtcbiAgICAgIH1cbiAgICB9IGVsc2UgeyAvLyBub24tYmluYXJ5IGZ1bGwgcGFja2V0XG4gICAgICB0aGlzLmVtaXQoJ2RlY29kZWQnLCBwYWNrZXQpO1xuICAgIH1cbiAgfVxuICBlbHNlIGlmIChpc0J1ZihvYmopIHx8IG9iai5iYXNlNjQpIHsgLy8gcmF3IGJpbmFyeSBkYXRhXG4gICAgaWYgKCF0aGlzLnJlY29uc3RydWN0b3IpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignZ290IGJpbmFyeSBkYXRhIHdoZW4gbm90IHJlY29uc3RydWN0aW5nIGEgcGFja2V0Jyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHBhY2tldCA9IHRoaXMucmVjb25zdHJ1Y3Rvci50YWtlQmluYXJ5RGF0YShvYmopO1xuICAgICAgaWYgKHBhY2tldCkgeyAvLyByZWNlaXZlZCBmaW5hbCBidWZmZXJcbiAgICAgICAgdGhpcy5yZWNvbnN0cnVjdG9yID0gbnVsbDtcbiAgICAgICAgdGhpcy5lbWl0KCdkZWNvZGVkJywgcGFja2V0KTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgZWxzZSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdVbmtub3duIHR5cGU6ICcgKyBvYmopO1xuICB9XG59O1xuXG4vKipcbiAqIERlY29kZSBhIHBhY2tldCBTdHJpbmcgKEpTT04gZGF0YSlcbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gc3RyXG4gKiBAcmV0dXJuIHtPYmplY3R9IHBhY2tldFxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gZGVjb2RlU3RyaW5nKHN0cikge1xuICB2YXIgaSA9IDA7XG4gIC8vIGxvb2sgdXAgdHlwZVxuICB2YXIgcCA9IHtcbiAgICB0eXBlOiBOdW1iZXIoc3RyLmNoYXJBdCgwKSlcbiAgfTtcblxuICBpZiAobnVsbCA9PSBleHBvcnRzLnR5cGVzW3AudHlwZV0pIHJldHVybiBlcnJvcigpO1xuXG4gIC8vIGxvb2sgdXAgYXR0YWNobWVudHMgaWYgdHlwZSBiaW5hcnlcbiAgaWYgKGV4cG9ydHMuQklOQVJZX0VWRU5UID09PSBwLnR5cGUgfHwgZXhwb3J0cy5CSU5BUllfQUNLID09PSBwLnR5cGUpIHtcbiAgICB2YXIgYnVmID0gJyc7XG4gICAgd2hpbGUgKHN0ci5jaGFyQXQoKytpKSAhPT0gJy0nKSB7XG4gICAgICBidWYgKz0gc3RyLmNoYXJBdChpKTtcbiAgICAgIGlmIChpID09IHN0ci5sZW5ndGgpIGJyZWFrO1xuICAgIH1cbiAgICBpZiAoYnVmICE9IE51bWJlcihidWYpIHx8IHN0ci5jaGFyQXQoaSkgIT09ICctJykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbGxlZ2FsIGF0dGFjaG1lbnRzJyk7XG4gICAgfVxuICAgIHAuYXR0YWNobWVudHMgPSBOdW1iZXIoYnVmKTtcbiAgfVxuXG4gIC8vIGxvb2sgdXAgbmFtZXNwYWNlIChpZiBhbnkpXG4gIGlmICgnLycgPT09IHN0ci5jaGFyQXQoaSArIDEpKSB7XG4gICAgcC5uc3AgPSAnJztcbiAgICB3aGlsZSAoKytpKSB7XG4gICAgICB2YXIgYyA9IHN0ci5jaGFyQXQoaSk7XG4gICAgICBpZiAoJywnID09PSBjKSBicmVhaztcbiAgICAgIHAubnNwICs9IGM7XG4gICAgICBpZiAoaSA9PT0gc3RyLmxlbmd0aCkgYnJlYWs7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHAubnNwID0gJy8nO1xuICB9XG5cbiAgLy8gbG9vayB1cCBpZFxuICB2YXIgbmV4dCA9IHN0ci5jaGFyQXQoaSArIDEpO1xuICBpZiAoJycgIT09IG5leHQgJiYgTnVtYmVyKG5leHQpID09IG5leHQpIHtcbiAgICBwLmlkID0gJyc7XG4gICAgd2hpbGUgKCsraSkge1xuICAgICAgdmFyIGMgPSBzdHIuY2hhckF0KGkpO1xuICAgICAgaWYgKG51bGwgPT0gYyB8fCBOdW1iZXIoYykgIT0gYykge1xuICAgICAgICAtLWk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgcC5pZCArPSBzdHIuY2hhckF0KGkpO1xuICAgICAgaWYgKGkgPT09IHN0ci5sZW5ndGgpIGJyZWFrO1xuICAgIH1cbiAgICBwLmlkID0gTnVtYmVyKHAuaWQpO1xuICB9XG5cbiAgLy8gbG9vayB1cCBqc29uIGRhdGFcbiAgaWYgKHN0ci5jaGFyQXQoKytpKSkge1xuICAgIHAgPSB0cnlQYXJzZShwLCBzdHIuc3Vic3RyKGkpKTtcbiAgfVxuXG5cbiAgcmV0dXJuIHA7XG59XG5cbmZ1bmN0aW9uIHRyeVBhcnNlKHAsIHN0cikge1xuICB0cnkge1xuICAgIHAuZGF0YSA9IEpTT04ucGFyc2Uoc3RyKTtcbiAgfSBjYXRjaChlKXtcbiAgICByZXR1cm4gZXJyb3IoKTtcbiAgfVxuICByZXR1cm4gcDsgXG59XG5cbi8qKlxuICogRGVhbGxvY2F0ZXMgYSBwYXJzZXIncyByZXNvdXJjZXNcbiAqXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbkRlY29kZXIucHJvdG90eXBlLmRlc3Ryb3kgPSBmdW5jdGlvbigpIHtcbiAgaWYgKHRoaXMucmVjb25zdHJ1Y3Rvcikge1xuICAgIHRoaXMucmVjb25zdHJ1Y3Rvci5maW5pc2hlZFJlY29uc3RydWN0aW9uKCk7XG4gIH1cbn07XG5cbi8qKlxuICogQSBtYW5hZ2VyIG9mIGEgYmluYXJ5IGV2ZW50J3MgJ2J1ZmZlciBzZXF1ZW5jZScuIFNob3VsZFxuICogYmUgY29uc3RydWN0ZWQgd2hlbmV2ZXIgYSBwYWNrZXQgb2YgdHlwZSBCSU5BUllfRVZFTlQgaXNcbiAqIGRlY29kZWQuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IHBhY2tldFxuICogQHJldHVybiB7QmluYXJ5UmVjb25zdHJ1Y3Rvcn0gaW5pdGlhbGl6ZWQgcmVjb25zdHJ1Y3RvclxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gQmluYXJ5UmVjb25zdHJ1Y3RvcihwYWNrZXQpIHtcbiAgdGhpcy5yZWNvblBhY2sgPSBwYWNrZXQ7XG4gIHRoaXMuYnVmZmVycyA9IFtdO1xufVxuXG4vKipcbiAqIE1ldGhvZCB0byBiZSBjYWxsZWQgd2hlbiBiaW5hcnkgZGF0YSByZWNlaXZlZCBmcm9tIGNvbm5lY3Rpb25cbiAqIGFmdGVyIGEgQklOQVJZX0VWRU5UIHBhY2tldC5cbiAqXG4gKiBAcGFyYW0ge0J1ZmZlciB8IEFycmF5QnVmZmVyfSBiaW5EYXRhIC0gdGhlIHJhdyBiaW5hcnkgZGF0YSByZWNlaXZlZFxuICogQHJldHVybiB7bnVsbCB8IE9iamVjdH0gcmV0dXJucyBudWxsIGlmIG1vcmUgYmluYXJ5IGRhdGEgaXMgZXhwZWN0ZWQgb3JcbiAqICAgYSByZWNvbnN0cnVjdGVkIHBhY2tldCBvYmplY3QgaWYgYWxsIGJ1ZmZlcnMgaGF2ZSBiZWVuIHJlY2VpdmVkLlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuQmluYXJ5UmVjb25zdHJ1Y3Rvci5wcm90b3R5cGUudGFrZUJpbmFyeURhdGEgPSBmdW5jdGlvbihiaW5EYXRhKSB7XG4gIHRoaXMuYnVmZmVycy5wdXNoKGJpbkRhdGEpO1xuICBpZiAodGhpcy5idWZmZXJzLmxlbmd0aCA9PT0gdGhpcy5yZWNvblBhY2suYXR0YWNobWVudHMpIHsgLy8gZG9uZSB3aXRoIGJ1ZmZlciBsaXN0XG4gICAgdmFyIHBhY2tldCA9IGJpbmFyeS5yZWNvbnN0cnVjdFBhY2tldCh0aGlzLnJlY29uUGFjaywgdGhpcy5idWZmZXJzKTtcbiAgICB0aGlzLmZpbmlzaGVkUmVjb25zdHJ1Y3Rpb24oKTtcbiAgICByZXR1cm4gcGFja2V0O1xuICB9XG4gIHJldHVybiBudWxsO1xufTtcblxuLyoqXG4gKiBDbGVhbnMgdXAgYmluYXJ5IHBhY2tldCByZWNvbnN0cnVjdGlvbiB2YXJpYWJsZXMuXG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuQmluYXJ5UmVjb25zdHJ1Y3Rvci5wcm90b3R5cGUuZmluaXNoZWRSZWNvbnN0cnVjdGlvbiA9IGZ1bmN0aW9uKCkge1xuICB0aGlzLnJlY29uUGFjayA9IG51bGw7XG4gIHRoaXMuYnVmZmVycyA9IFtdO1xufTtcblxuZnVuY3Rpb24gZXJyb3IoKSB7XG4gIHJldHVybiB7XG4gICAgdHlwZTogZXhwb3J0cy5FUlJPUixcbiAgICBkYXRhOiAncGFyc2VyIGVycm9yJ1xuICB9O1xufVxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3NvY2tldC5pby1wYXJzZXIvaW5kZXguanNcbi8vIG1vZHVsZSBpZCA9IDRcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiXHJcbi8qKlxyXG4gKiBFeHBvc2UgYEVtaXR0ZXJgLlxyXG4gKi9cclxuXHJcbmlmICh0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJykge1xyXG4gIG1vZHVsZS5leHBvcnRzID0gRW1pdHRlcjtcclxufVxyXG5cclxuLyoqXHJcbiAqIEluaXRpYWxpemUgYSBuZXcgYEVtaXR0ZXJgLlxyXG4gKlxyXG4gKiBAYXBpIHB1YmxpY1xyXG4gKi9cclxuXHJcbmZ1bmN0aW9uIEVtaXR0ZXIob2JqKSB7XHJcbiAgaWYgKG9iaikgcmV0dXJuIG1peGluKG9iaik7XHJcbn07XHJcblxyXG4vKipcclxuICogTWl4aW4gdGhlIGVtaXR0ZXIgcHJvcGVydGllcy5cclxuICpcclxuICogQHBhcmFtIHtPYmplY3R9IG9ialxyXG4gKiBAcmV0dXJuIHtPYmplY3R9XHJcbiAqIEBhcGkgcHJpdmF0ZVxyXG4gKi9cclxuXHJcbmZ1bmN0aW9uIG1peGluKG9iaikge1xyXG4gIGZvciAodmFyIGtleSBpbiBFbWl0dGVyLnByb3RvdHlwZSkge1xyXG4gICAgb2JqW2tleV0gPSBFbWl0dGVyLnByb3RvdHlwZVtrZXldO1xyXG4gIH1cclxuICByZXR1cm4gb2JqO1xyXG59XHJcblxyXG4vKipcclxuICogTGlzdGVuIG9uIHRoZSBnaXZlbiBgZXZlbnRgIHdpdGggYGZuYC5cclxuICpcclxuICogQHBhcmFtIHtTdHJpbmd9IGV2ZW50XHJcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuXHJcbiAqIEByZXR1cm4ge0VtaXR0ZXJ9XHJcbiAqIEBhcGkgcHVibGljXHJcbiAqL1xyXG5cclxuRW1pdHRlci5wcm90b3R5cGUub24gPVxyXG5FbWl0dGVyLnByb3RvdHlwZS5hZGRFdmVudExpc3RlbmVyID0gZnVuY3Rpb24oZXZlbnQsIGZuKXtcclxuICB0aGlzLl9jYWxsYmFja3MgPSB0aGlzLl9jYWxsYmFja3MgfHwge307XHJcbiAgKHRoaXMuX2NhbGxiYWNrc1snJCcgKyBldmVudF0gPSB0aGlzLl9jYWxsYmFja3NbJyQnICsgZXZlbnRdIHx8IFtdKVxyXG4gICAgLnB1c2goZm4pO1xyXG4gIHJldHVybiB0aGlzO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIEFkZHMgYW4gYGV2ZW50YCBsaXN0ZW5lciB0aGF0IHdpbGwgYmUgaW52b2tlZCBhIHNpbmdsZVxyXG4gKiB0aW1lIHRoZW4gYXV0b21hdGljYWxseSByZW1vdmVkLlxyXG4gKlxyXG4gKiBAcGFyYW0ge1N0cmluZ30gZXZlbnRcclxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm5cclxuICogQHJldHVybiB7RW1pdHRlcn1cclxuICogQGFwaSBwdWJsaWNcclxuICovXHJcblxyXG5FbWl0dGVyLnByb3RvdHlwZS5vbmNlID0gZnVuY3Rpb24oZXZlbnQsIGZuKXtcclxuICBmdW5jdGlvbiBvbigpIHtcclxuICAgIHRoaXMub2ZmKGV2ZW50LCBvbik7XHJcbiAgICBmbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xyXG4gIH1cclxuXHJcbiAgb24uZm4gPSBmbjtcclxuICB0aGlzLm9uKGV2ZW50LCBvbik7XHJcbiAgcmV0dXJuIHRoaXM7XHJcbn07XHJcblxyXG4vKipcclxuICogUmVtb3ZlIHRoZSBnaXZlbiBjYWxsYmFjayBmb3IgYGV2ZW50YCBvciBhbGxcclxuICogcmVnaXN0ZXJlZCBjYWxsYmFja3MuXHJcbiAqXHJcbiAqIEBwYXJhbSB7U3RyaW5nfSBldmVudFxyXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmblxyXG4gKiBAcmV0dXJuIHtFbWl0dGVyfVxyXG4gKiBAYXBpIHB1YmxpY1xyXG4gKi9cclxuXHJcbkVtaXR0ZXIucHJvdG90eXBlLm9mZiA9XHJcbkVtaXR0ZXIucHJvdG90eXBlLnJlbW92ZUxpc3RlbmVyID1cclxuRW1pdHRlci5wcm90b3R5cGUucmVtb3ZlQWxsTGlzdGVuZXJzID1cclxuRW1pdHRlci5wcm90b3R5cGUucmVtb3ZlRXZlbnRMaXN0ZW5lciA9IGZ1bmN0aW9uKGV2ZW50LCBmbil7XHJcbiAgdGhpcy5fY2FsbGJhY2tzID0gdGhpcy5fY2FsbGJhY2tzIHx8IHt9O1xyXG5cclxuICAvLyBhbGxcclxuICBpZiAoMCA9PSBhcmd1bWVudHMubGVuZ3RoKSB7XHJcbiAgICB0aGlzLl9jYWxsYmFja3MgPSB7fTtcclxuICAgIHJldHVybiB0aGlzO1xyXG4gIH1cclxuXHJcbiAgLy8gc3BlY2lmaWMgZXZlbnRcclxuICB2YXIgY2FsbGJhY2tzID0gdGhpcy5fY2FsbGJhY2tzWyckJyArIGV2ZW50XTtcclxuICBpZiAoIWNhbGxiYWNrcykgcmV0dXJuIHRoaXM7XHJcblxyXG4gIC8vIHJlbW92ZSBhbGwgaGFuZGxlcnNcclxuICBpZiAoMSA9PSBhcmd1bWVudHMubGVuZ3RoKSB7XHJcbiAgICBkZWxldGUgdGhpcy5fY2FsbGJhY2tzWyckJyArIGV2ZW50XTtcclxuICAgIHJldHVybiB0aGlzO1xyXG4gIH1cclxuXHJcbiAgLy8gcmVtb3ZlIHNwZWNpZmljIGhhbmRsZXJcclxuICB2YXIgY2I7XHJcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBjYWxsYmFja3MubGVuZ3RoOyBpKyspIHtcclxuICAgIGNiID0gY2FsbGJhY2tzW2ldO1xyXG4gICAgaWYgKGNiID09PSBmbiB8fCBjYi5mbiA9PT0gZm4pIHtcclxuICAgICAgY2FsbGJhY2tzLnNwbGljZShpLCAxKTtcclxuICAgICAgYnJlYWs7XHJcbiAgICB9XHJcbiAgfVxyXG4gIHJldHVybiB0aGlzO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIEVtaXQgYGV2ZW50YCB3aXRoIHRoZSBnaXZlbiBhcmdzLlxyXG4gKlxyXG4gKiBAcGFyYW0ge1N0cmluZ30gZXZlbnRcclxuICogQHBhcmFtIHtNaXhlZH0gLi4uXHJcbiAqIEByZXR1cm4ge0VtaXR0ZXJ9XHJcbiAqL1xyXG5cclxuRW1pdHRlci5wcm90b3R5cGUuZW1pdCA9IGZ1bmN0aW9uKGV2ZW50KXtcclxuICB0aGlzLl9jYWxsYmFja3MgPSB0aGlzLl9jYWxsYmFja3MgfHwge307XHJcbiAgdmFyIGFyZ3MgPSBbXS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMSlcclxuICAgICwgY2FsbGJhY2tzID0gdGhpcy5fY2FsbGJhY2tzWyckJyArIGV2ZW50XTtcclxuXHJcbiAgaWYgKGNhbGxiYWNrcykge1xyXG4gICAgY2FsbGJhY2tzID0gY2FsbGJhY2tzLnNsaWNlKDApO1xyXG4gICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IGNhbGxiYWNrcy5sZW5ndGg7IGkgPCBsZW47ICsraSkge1xyXG4gICAgICBjYWxsYmFja3NbaV0uYXBwbHkodGhpcywgYXJncyk7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICByZXR1cm4gdGhpcztcclxufTtcclxuXHJcbi8qKlxyXG4gKiBSZXR1cm4gYXJyYXkgb2YgY2FsbGJhY2tzIGZvciBgZXZlbnRgLlxyXG4gKlxyXG4gKiBAcGFyYW0ge1N0cmluZ30gZXZlbnRcclxuICogQHJldHVybiB7QXJyYXl9XHJcbiAqIEBhcGkgcHVibGljXHJcbiAqL1xyXG5cclxuRW1pdHRlci5wcm90b3R5cGUubGlzdGVuZXJzID0gZnVuY3Rpb24oZXZlbnQpe1xyXG4gIHRoaXMuX2NhbGxiYWNrcyA9IHRoaXMuX2NhbGxiYWNrcyB8fCB7fTtcclxuICByZXR1cm4gdGhpcy5fY2FsbGJhY2tzWyckJyArIGV2ZW50XSB8fCBbXTtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBDaGVjayBpZiB0aGlzIGVtaXR0ZXIgaGFzIGBldmVudGAgaGFuZGxlcnMuXHJcbiAqXHJcbiAqIEBwYXJhbSB7U3RyaW5nfSBldmVudFxyXG4gKiBAcmV0dXJuIHtCb29sZWFufVxyXG4gKiBAYXBpIHB1YmxpY1xyXG4gKi9cclxuXHJcbkVtaXR0ZXIucHJvdG90eXBlLmhhc0xpc3RlbmVycyA9IGZ1bmN0aW9uKGV2ZW50KXtcclxuICByZXR1cm4gISEgdGhpcy5saXN0ZW5lcnMoZXZlbnQpLmxlbmd0aDtcclxufTtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2NvbXBvbmVudC1lbWl0dGVyL2luZGV4LmpzXG4vLyBtb2R1bGUgaWQgPSA1XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qIGdsb2JhbCBCbG9iIEZpbGUgKi9cblxuLypcbiAqIE1vZHVsZSByZXF1aXJlbWVudHMuXG4gKi9cblxudmFyIGlzQXJyYXkgPSByZXF1aXJlKCdpc2FycmF5Jyk7XG5cbnZhciB0b1N0cmluZyA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmc7XG52YXIgd2l0aE5hdGl2ZUJsb2IgPSB0eXBlb2YgZ2xvYmFsLkJsb2IgPT09ICdmdW5jdGlvbicgfHwgdG9TdHJpbmcuY2FsbChnbG9iYWwuQmxvYikgPT09ICdbb2JqZWN0IEJsb2JDb25zdHJ1Y3Rvcl0nO1xudmFyIHdpdGhOYXRpdmVGaWxlID0gdHlwZW9mIGdsb2JhbC5GaWxlID09PSAnZnVuY3Rpb24nIHx8IHRvU3RyaW5nLmNhbGwoZ2xvYmFsLkZpbGUpID09PSAnW29iamVjdCBGaWxlQ29uc3RydWN0b3JdJztcblxuLyoqXG4gKiBNb2R1bGUgZXhwb3J0cy5cbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IGhhc0JpbmFyeTtcblxuLyoqXG4gKiBDaGVja3MgZm9yIGJpbmFyeSBkYXRhLlxuICpcbiAqIFN1cHBvcnRzIEJ1ZmZlciwgQXJyYXlCdWZmZXIsIEJsb2IgYW5kIEZpbGUuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IGFueXRoaW5nXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmZ1bmN0aW9uIGhhc0JpbmFyeSAob2JqKSB7XG4gIGlmICghb2JqIHx8IHR5cGVvZiBvYmogIT09ICdvYmplY3QnKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgaWYgKGlzQXJyYXkob2JqKSkge1xuICAgIGZvciAodmFyIGkgPSAwLCBsID0gb2JqLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgaWYgKGhhc0JpbmFyeShvYmpbaV0pKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBpZiAoKHR5cGVvZiBnbG9iYWwuQnVmZmVyID09PSAnZnVuY3Rpb24nICYmIGdsb2JhbC5CdWZmZXIuaXNCdWZmZXIgJiYgZ2xvYmFsLkJ1ZmZlci5pc0J1ZmZlcihvYmopKSB8fFxuICAgICAodHlwZW9mIGdsb2JhbC5BcnJheUJ1ZmZlciA9PT0gJ2Z1bmN0aW9uJyAmJiBvYmogaW5zdGFuY2VvZiBBcnJheUJ1ZmZlcikgfHxcbiAgICAgKHdpdGhOYXRpdmVCbG9iICYmIG9iaiBpbnN0YW5jZW9mIEJsb2IpIHx8XG4gICAgICh3aXRoTmF0aXZlRmlsZSAmJiBvYmogaW5zdGFuY2VvZiBGaWxlKVxuICAgICkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgLy8gc2VlOiBodHRwczovL2dpdGh1Yi5jb20vQXV0b21hdHRpYy9oYXMtYmluYXJ5L3B1bGwvNFxuICBpZiAob2JqLnRvSlNPTiAmJiB0eXBlb2Ygb2JqLnRvSlNPTiA9PT0gJ2Z1bmN0aW9uJyAmJiBhcmd1bWVudHMubGVuZ3RoID09PSAxKSB7XG4gICAgcmV0dXJuIGhhc0JpbmFyeShvYmoudG9KU09OKCksIHRydWUpO1xuICB9XG5cbiAgZm9yICh2YXIga2V5IGluIG9iaikge1xuICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBrZXkpICYmIGhhc0JpbmFyeShvYmpba2V5XSkpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn1cblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9oYXMtYmluYXJ5Mi9pbmRleC5qc1xuLy8gbW9kdWxlIGlkID0gNlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgdG9TdHJpbmcgPSB7fS50b1N0cmluZztcblxubW9kdWxlLmV4cG9ydHMgPSBBcnJheS5pc0FycmF5IHx8IGZ1bmN0aW9uIChhcnIpIHtcbiAgcmV0dXJuIHRvU3RyaW5nLmNhbGwoYXJyKSA9PSAnW29iamVjdCBBcnJheV0nO1xufTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9pc2FycmF5L2luZGV4LmpzXG4vLyBtb2R1bGUgaWQgPSAzN1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKmdsb2JhbCBCbG9iLEZpbGUqL1xuXG4vKipcbiAqIE1vZHVsZSByZXF1aXJlbWVudHNcbiAqL1xuXG52YXIgaXNBcnJheSA9IHJlcXVpcmUoJ2lzYXJyYXknKTtcbnZhciBpc0J1ZiA9IHJlcXVpcmUoJy4vaXMtYnVmZmVyJyk7XG52YXIgdG9TdHJpbmcgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nO1xudmFyIHdpdGhOYXRpdmVCbG9iID0gdHlwZW9mIGdsb2JhbC5CbG9iID09PSAnZnVuY3Rpb24nIHx8IHRvU3RyaW5nLmNhbGwoZ2xvYmFsLkJsb2IpID09PSAnW29iamVjdCBCbG9iQ29uc3RydWN0b3JdJztcbnZhciB3aXRoTmF0aXZlRmlsZSA9IHR5cGVvZiBnbG9iYWwuRmlsZSA9PT0gJ2Z1bmN0aW9uJyB8fCB0b1N0cmluZy5jYWxsKGdsb2JhbC5GaWxlKSA9PT0gJ1tvYmplY3QgRmlsZUNvbnN0cnVjdG9yXSc7XG5cbi8qKlxuICogUmVwbGFjZXMgZXZlcnkgQnVmZmVyIHwgQXJyYXlCdWZmZXIgaW4gcGFja2V0IHdpdGggYSBudW1iZXJlZCBwbGFjZWhvbGRlci5cbiAqIEFueXRoaW5nIHdpdGggYmxvYnMgb3IgZmlsZXMgc2hvdWxkIGJlIGZlZCB0aHJvdWdoIHJlbW92ZUJsb2JzIGJlZm9yZSBjb21pbmdcbiAqIGhlcmUuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IHBhY2tldCAtIHNvY2tldC5pbyBldmVudCBwYWNrZXRcbiAqIEByZXR1cm4ge09iamVjdH0gd2l0aCBkZWNvbnN0cnVjdGVkIHBhY2tldCBhbmQgbGlzdCBvZiBidWZmZXJzXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmV4cG9ydHMuZGVjb25zdHJ1Y3RQYWNrZXQgPSBmdW5jdGlvbihwYWNrZXQpIHtcbiAgdmFyIGJ1ZmZlcnMgPSBbXTtcbiAgdmFyIHBhY2tldERhdGEgPSBwYWNrZXQuZGF0YTtcbiAgdmFyIHBhY2sgPSBwYWNrZXQ7XG4gIHBhY2suZGF0YSA9IF9kZWNvbnN0cnVjdFBhY2tldChwYWNrZXREYXRhLCBidWZmZXJzKTtcbiAgcGFjay5hdHRhY2htZW50cyA9IGJ1ZmZlcnMubGVuZ3RoOyAvLyBudW1iZXIgb2YgYmluYXJ5ICdhdHRhY2htZW50cydcbiAgcmV0dXJuIHtwYWNrZXQ6IHBhY2ssIGJ1ZmZlcnM6IGJ1ZmZlcnN9O1xufTtcblxuZnVuY3Rpb24gX2RlY29uc3RydWN0UGFja2V0KGRhdGEsIGJ1ZmZlcnMpIHtcbiAgaWYgKCFkYXRhKSByZXR1cm4gZGF0YTtcblxuICBpZiAoaXNCdWYoZGF0YSkpIHtcbiAgICB2YXIgcGxhY2Vob2xkZXIgPSB7IF9wbGFjZWhvbGRlcjogdHJ1ZSwgbnVtOiBidWZmZXJzLmxlbmd0aCB9O1xuICAgIGJ1ZmZlcnMucHVzaChkYXRhKTtcbiAgICByZXR1cm4gcGxhY2Vob2xkZXI7XG4gIH0gZWxzZSBpZiAoaXNBcnJheShkYXRhKSkge1xuICAgIHZhciBuZXdEYXRhID0gbmV3IEFycmF5KGRhdGEubGVuZ3RoKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGRhdGEubGVuZ3RoOyBpKyspIHtcbiAgICAgIG5ld0RhdGFbaV0gPSBfZGVjb25zdHJ1Y3RQYWNrZXQoZGF0YVtpXSwgYnVmZmVycyk7XG4gICAgfVxuICAgIHJldHVybiBuZXdEYXRhO1xuICB9IGVsc2UgaWYgKHR5cGVvZiBkYXRhID09PSAnb2JqZWN0JyAmJiAhKGRhdGEgaW5zdGFuY2VvZiBEYXRlKSkge1xuICAgIHZhciBuZXdEYXRhID0ge307XG4gICAgZm9yICh2YXIga2V5IGluIGRhdGEpIHtcbiAgICAgIG5ld0RhdGFba2V5XSA9IF9kZWNvbnN0cnVjdFBhY2tldChkYXRhW2tleV0sIGJ1ZmZlcnMpO1xuICAgIH1cbiAgICByZXR1cm4gbmV3RGF0YTtcbiAgfVxuICByZXR1cm4gZGF0YTtcbn1cblxuLyoqXG4gKiBSZWNvbnN0cnVjdHMgYSBiaW5hcnkgcGFja2V0IGZyb20gaXRzIHBsYWNlaG9sZGVyIHBhY2tldCBhbmQgYnVmZmVyc1xuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBwYWNrZXQgLSBldmVudCBwYWNrZXQgd2l0aCBwbGFjZWhvbGRlcnNcbiAqIEBwYXJhbSB7QXJyYXl9IGJ1ZmZlcnMgLSBiaW5hcnkgYnVmZmVycyB0byBwdXQgaW4gcGxhY2Vob2xkZXIgcG9zaXRpb25zXG4gKiBAcmV0dXJuIHtPYmplY3R9IHJlY29uc3RydWN0ZWQgcGFja2V0XG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmV4cG9ydHMucmVjb25zdHJ1Y3RQYWNrZXQgPSBmdW5jdGlvbihwYWNrZXQsIGJ1ZmZlcnMpIHtcbiAgcGFja2V0LmRhdGEgPSBfcmVjb25zdHJ1Y3RQYWNrZXQocGFja2V0LmRhdGEsIGJ1ZmZlcnMpO1xuICBwYWNrZXQuYXR0YWNobWVudHMgPSB1bmRlZmluZWQ7IC8vIG5vIGxvbmdlciB1c2VmdWxcbiAgcmV0dXJuIHBhY2tldDtcbn07XG5cbmZ1bmN0aW9uIF9yZWNvbnN0cnVjdFBhY2tldChkYXRhLCBidWZmZXJzKSB7XG4gIGlmICghZGF0YSkgcmV0dXJuIGRhdGE7XG5cbiAgaWYgKGRhdGEgJiYgZGF0YS5fcGxhY2Vob2xkZXIpIHtcbiAgICByZXR1cm4gYnVmZmVyc1tkYXRhLm51bV07IC8vIGFwcHJvcHJpYXRlIGJ1ZmZlciAoc2hvdWxkIGJlIG5hdHVyYWwgb3JkZXIgYW55d2F5KVxuICB9IGVsc2UgaWYgKGlzQXJyYXkoZGF0YSkpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGRhdGEubGVuZ3RoOyBpKyspIHtcbiAgICAgIGRhdGFbaV0gPSBfcmVjb25zdHJ1Y3RQYWNrZXQoZGF0YVtpXSwgYnVmZmVycyk7XG4gICAgfVxuICB9IGVsc2UgaWYgKHR5cGVvZiBkYXRhID09PSAnb2JqZWN0Jykge1xuICAgIGZvciAodmFyIGtleSBpbiBkYXRhKSB7XG4gICAgICBkYXRhW2tleV0gPSBfcmVjb25zdHJ1Y3RQYWNrZXQoZGF0YVtrZXldLCBidWZmZXJzKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZGF0YTtcbn1cblxuLyoqXG4gKiBBc3luY2hyb25vdXNseSByZW1vdmVzIEJsb2JzIG9yIEZpbGVzIGZyb20gZGF0YSB2aWFcbiAqIEZpbGVSZWFkZXIncyByZWFkQXNBcnJheUJ1ZmZlciBtZXRob2QuIFVzZWQgYmVmb3JlIGVuY29kaW5nXG4gKiBkYXRhIGFzIG1zZ3BhY2suIENhbGxzIGNhbGxiYWNrIHdpdGggdGhlIGJsb2JsZXNzIGRhdGEuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IGRhdGFcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5leHBvcnRzLnJlbW92ZUJsb2JzID0gZnVuY3Rpb24oZGF0YSwgY2FsbGJhY2spIHtcbiAgZnVuY3Rpb24gX3JlbW92ZUJsb2JzKG9iaiwgY3VyS2V5LCBjb250YWluaW5nT2JqZWN0KSB7XG4gICAgaWYgKCFvYmopIHJldHVybiBvYmo7XG5cbiAgICAvLyBjb252ZXJ0IGFueSBibG9iXG4gICAgaWYgKCh3aXRoTmF0aXZlQmxvYiAmJiBvYmogaW5zdGFuY2VvZiBCbG9iKSB8fFxuICAgICAgICAod2l0aE5hdGl2ZUZpbGUgJiYgb2JqIGluc3RhbmNlb2YgRmlsZSkpIHtcbiAgICAgIHBlbmRpbmdCbG9icysrO1xuXG4gICAgICAvLyBhc3luYyBmaWxlcmVhZGVyXG4gICAgICB2YXIgZmlsZVJlYWRlciA9IG5ldyBGaWxlUmVhZGVyKCk7XG4gICAgICBmaWxlUmVhZGVyLm9ubG9hZCA9IGZ1bmN0aW9uKCkgeyAvLyB0aGlzLnJlc3VsdCA9PSBhcnJheWJ1ZmZlclxuICAgICAgICBpZiAoY29udGFpbmluZ09iamVjdCkge1xuICAgICAgICAgIGNvbnRhaW5pbmdPYmplY3RbY3VyS2V5XSA9IHRoaXMucmVzdWx0O1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIGJsb2JsZXNzRGF0YSA9IHRoaXMucmVzdWx0O1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gaWYgbm90aGluZyBwZW5kaW5nIGl0cyBjYWxsYmFjayB0aW1lXG4gICAgICAgIGlmKCEgLS1wZW5kaW5nQmxvYnMpIHtcbiAgICAgICAgICBjYWxsYmFjayhibG9ibGVzc0RhdGEpO1xuICAgICAgICB9XG4gICAgICB9O1xuXG4gICAgICBmaWxlUmVhZGVyLnJlYWRBc0FycmF5QnVmZmVyKG9iaik7IC8vIGJsb2IgLT4gYXJyYXlidWZmZXJcbiAgICB9IGVsc2UgaWYgKGlzQXJyYXkob2JqKSkgeyAvLyBoYW5kbGUgYXJyYXlcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgb2JqLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIF9yZW1vdmVCbG9icyhvYmpbaV0sIGksIG9iaik7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmICh0eXBlb2Ygb2JqID09PSAnb2JqZWN0JyAmJiAhaXNCdWYob2JqKSkgeyAvLyBhbmQgb2JqZWN0XG4gICAgICBmb3IgKHZhciBrZXkgaW4gb2JqKSB7XG4gICAgICAgIF9yZW1vdmVCbG9icyhvYmpba2V5XSwga2V5LCBvYmopO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHZhciBwZW5kaW5nQmxvYnMgPSAwO1xuICB2YXIgYmxvYmxlc3NEYXRhID0gZGF0YTtcbiAgX3JlbW92ZUJsb2JzKGJsb2JsZXNzRGF0YSk7XG4gIGlmICghcGVuZGluZ0Jsb2JzKSB7XG4gICAgY2FsbGJhY2soYmxvYmxlc3NEYXRhKTtcbiAgfVxufTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9zb2NrZXQuaW8tcGFyc2VyL2JpbmFyeS5qc1xuLy8gbW9kdWxlIGlkID0gOFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJcbm1vZHVsZS5leHBvcnRzID0gaXNCdWY7XG5cbi8qKlxuICogUmV0dXJucyB0cnVlIGlmIG9iaiBpcyBhIGJ1ZmZlciBvciBhbiBhcnJheWJ1ZmZlci5cbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBpc0J1ZihvYmopIHtcbiAgcmV0dXJuIChnbG9iYWwuQnVmZmVyICYmIGdsb2JhbC5CdWZmZXIuaXNCdWZmZXIob2JqKSkgfHxcbiAgICAgICAgIChnbG9iYWwuQXJyYXlCdWZmZXIgJiYgb2JqIGluc3RhbmNlb2YgQXJyYXlCdWZmZXIpO1xufVxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3NvY2tldC5pby1wYXJzZXIvaXMtYnVmZmVyLmpzXG4vLyBtb2R1bGUgaWQgPSA5XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIlxuLyoqXG4gKiBNb2R1bGUgZGVwZW5kZW5jaWVzLlxuICovXG5cbnZhciBlaW8gPSByZXF1aXJlKCdlbmdpbmUuaW8tY2xpZW50Jyk7XG52YXIgU29ja2V0ID0gcmVxdWlyZSgnLi9zb2NrZXQnKTtcbnZhciBFbWl0dGVyID0gcmVxdWlyZSgnY29tcG9uZW50LWVtaXR0ZXInKTtcbnZhciBwYXJzZXIgPSByZXF1aXJlKCdzb2NrZXQuaW8tcGFyc2VyJyk7XG52YXIgb24gPSByZXF1aXJlKCcuL29uJyk7XG52YXIgYmluZCA9IHJlcXVpcmUoJ2NvbXBvbmVudC1iaW5kJyk7XG52YXIgZGVidWcgPSByZXF1aXJlKCdkZWJ1ZycpKCdzb2NrZXQuaW8tY2xpZW50Om1hbmFnZXInKTtcbnZhciBpbmRleE9mID0gcmVxdWlyZSgnaW5kZXhvZicpO1xudmFyIEJhY2tvZmYgPSByZXF1aXJlKCdiYWNrbzInKTtcblxuLyoqXG4gKiBJRTYrIGhhc093blByb3BlcnR5XG4gKi9cblxudmFyIGhhcyA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG5cbi8qKlxuICogTW9kdWxlIGV4cG9ydHNcbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IE1hbmFnZXI7XG5cbi8qKlxuICogYE1hbmFnZXJgIGNvbnN0cnVjdG9yLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBlbmdpbmUgaW5zdGFuY2Ugb3IgZW5naW5lIHVyaS9vcHRzXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5mdW5jdGlvbiBNYW5hZ2VyICh1cmksIG9wdHMpIHtcbiAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIE1hbmFnZXIpKSByZXR1cm4gbmV3IE1hbmFnZXIodXJpLCBvcHRzKTtcbiAgaWYgKHVyaSAmJiAoJ29iamVjdCcgPT09IHR5cGVvZiB1cmkpKSB7XG4gICAgb3B0cyA9IHVyaTtcbiAgICB1cmkgPSB1bmRlZmluZWQ7XG4gIH1cbiAgb3B0cyA9IG9wdHMgfHwge307XG5cbiAgb3B0cy5wYXRoID0gb3B0cy5wYXRoIHx8ICcvc29ja2V0LmlvJztcbiAgdGhpcy5uc3BzID0ge307XG4gIHRoaXMuc3VicyA9IFtdO1xuICB0aGlzLm9wdHMgPSBvcHRzO1xuICB0aGlzLnJlY29ubmVjdGlvbihvcHRzLnJlY29ubmVjdGlvbiAhPT0gZmFsc2UpO1xuICB0aGlzLnJlY29ubmVjdGlvbkF0dGVtcHRzKG9wdHMucmVjb25uZWN0aW9uQXR0ZW1wdHMgfHwgSW5maW5pdHkpO1xuICB0aGlzLnJlY29ubmVjdGlvbkRlbGF5KG9wdHMucmVjb25uZWN0aW9uRGVsYXkgfHwgMTAwMCk7XG4gIHRoaXMucmVjb25uZWN0aW9uRGVsYXlNYXgob3B0cy5yZWNvbm5lY3Rpb25EZWxheU1heCB8fCA1MDAwKTtcbiAgdGhpcy5yYW5kb21pemF0aW9uRmFjdG9yKG9wdHMucmFuZG9taXphdGlvbkZhY3RvciB8fCAwLjUpO1xuICB0aGlzLmJhY2tvZmYgPSBuZXcgQmFja29mZih7XG4gICAgbWluOiB0aGlzLnJlY29ubmVjdGlvbkRlbGF5KCksXG4gICAgbWF4OiB0aGlzLnJlY29ubmVjdGlvbkRlbGF5TWF4KCksXG4gICAgaml0dGVyOiB0aGlzLnJhbmRvbWl6YXRpb25GYWN0b3IoKVxuICB9KTtcbiAgdGhpcy50aW1lb3V0KG51bGwgPT0gb3B0cy50aW1lb3V0ID8gMjAwMDAgOiBvcHRzLnRpbWVvdXQpO1xuICB0aGlzLnJlYWR5U3RhdGUgPSAnY2xvc2VkJztcbiAgdGhpcy51cmkgPSB1cmk7XG4gIHRoaXMuY29ubmVjdGluZyA9IFtdO1xuICB0aGlzLmxhc3RQaW5nID0gbnVsbDtcbiAgdGhpcy5lbmNvZGluZyA9IGZhbHNlO1xuICB0aGlzLnBhY2tldEJ1ZmZlciA9IFtdO1xuICB2YXIgX3BhcnNlciA9IG9wdHMucGFyc2VyIHx8IHBhcnNlcjtcbiAgdGhpcy5lbmNvZGVyID0gbmV3IF9wYXJzZXIuRW5jb2RlcigpO1xuICB0aGlzLmRlY29kZXIgPSBuZXcgX3BhcnNlci5EZWNvZGVyKCk7XG4gIHRoaXMuYXV0b0Nvbm5lY3QgPSBvcHRzLmF1dG9Db25uZWN0ICE9PSBmYWxzZTtcbiAgaWYgKHRoaXMuYXV0b0Nvbm5lY3QpIHRoaXMub3BlbigpO1xufVxuXG4vKipcbiAqIFByb3BhZ2F0ZSBnaXZlbiBldmVudCB0byBzb2NrZXRzIGFuZCBlbWl0IG9uIGB0aGlzYFxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbk1hbmFnZXIucHJvdG90eXBlLmVtaXRBbGwgPSBmdW5jdGlvbiAoKSB7XG4gIHRoaXMuZW1pdC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICBmb3IgKHZhciBuc3AgaW4gdGhpcy5uc3BzKSB7XG4gICAgaWYgKGhhcy5jYWxsKHRoaXMubnNwcywgbnNwKSkge1xuICAgICAgdGhpcy5uc3BzW25zcF0uZW1pdC5hcHBseSh0aGlzLm5zcHNbbnNwXSwgYXJndW1lbnRzKTtcbiAgICB9XG4gIH1cbn07XG5cbi8qKlxuICogVXBkYXRlIGBzb2NrZXQuaWRgIG9mIGFsbCBzb2NrZXRzXG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuTWFuYWdlci5wcm90b3R5cGUudXBkYXRlU29ja2V0SWRzID0gZnVuY3Rpb24gKCkge1xuICBmb3IgKHZhciBuc3AgaW4gdGhpcy5uc3BzKSB7XG4gICAgaWYgKGhhcy5jYWxsKHRoaXMubnNwcywgbnNwKSkge1xuICAgICAgdGhpcy5uc3BzW25zcF0uaWQgPSB0aGlzLmdlbmVyYXRlSWQobnNwKTtcbiAgICB9XG4gIH1cbn07XG5cbi8qKlxuICogZ2VuZXJhdGUgYHNvY2tldC5pZGAgZm9yIHRoZSBnaXZlbiBgbnNwYFxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBuc3BcbiAqIEByZXR1cm4ge1N0cmluZ31cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbk1hbmFnZXIucHJvdG90eXBlLmdlbmVyYXRlSWQgPSBmdW5jdGlvbiAobnNwKSB7XG4gIHJldHVybiAobnNwID09PSAnLycgPyAnJyA6IChuc3AgKyAnIycpKSArIHRoaXMuZW5naW5lLmlkO1xufTtcblxuLyoqXG4gKiBNaXggaW4gYEVtaXR0ZXJgLlxuICovXG5cbkVtaXR0ZXIoTWFuYWdlci5wcm90b3R5cGUpO1xuXG4vKipcbiAqIFNldHMgdGhlIGByZWNvbm5lY3Rpb25gIGNvbmZpZy5cbiAqXG4gKiBAcGFyYW0ge0Jvb2xlYW59IHRydWUvZmFsc2UgaWYgaXQgc2hvdWxkIGF1dG9tYXRpY2FsbHkgcmVjb25uZWN0XG4gKiBAcmV0dXJuIHtNYW5hZ2VyfSBzZWxmIG9yIHZhbHVlXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbk1hbmFnZXIucHJvdG90eXBlLnJlY29ubmVjdGlvbiA9IGZ1bmN0aW9uICh2KSB7XG4gIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIHRoaXMuX3JlY29ubmVjdGlvbjtcbiAgdGhpcy5fcmVjb25uZWN0aW9uID0gISF2O1xuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogU2V0cyB0aGUgcmVjb25uZWN0aW9uIGF0dGVtcHRzIGNvbmZpZy5cbiAqXG4gKiBAcGFyYW0ge051bWJlcn0gbWF4IHJlY29ubmVjdGlvbiBhdHRlbXB0cyBiZWZvcmUgZ2l2aW5nIHVwXG4gKiBAcmV0dXJuIHtNYW5hZ2VyfSBzZWxmIG9yIHZhbHVlXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbk1hbmFnZXIucHJvdG90eXBlLnJlY29ubmVjdGlvbkF0dGVtcHRzID0gZnVuY3Rpb24gKHYpIHtcbiAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gdGhpcy5fcmVjb25uZWN0aW9uQXR0ZW1wdHM7XG4gIHRoaXMuX3JlY29ubmVjdGlvbkF0dGVtcHRzID0gdjtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIFNldHMgdGhlIGRlbGF5IGJldHdlZW4gcmVjb25uZWN0aW9ucy5cbiAqXG4gKiBAcGFyYW0ge051bWJlcn0gZGVsYXlcbiAqIEByZXR1cm4ge01hbmFnZXJ9IHNlbGYgb3IgdmFsdWVcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuTWFuYWdlci5wcm90b3R5cGUucmVjb25uZWN0aW9uRGVsYXkgPSBmdW5jdGlvbiAodikge1xuICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiB0aGlzLl9yZWNvbm5lY3Rpb25EZWxheTtcbiAgdGhpcy5fcmVjb25uZWN0aW9uRGVsYXkgPSB2O1xuICB0aGlzLmJhY2tvZmYgJiYgdGhpcy5iYWNrb2ZmLnNldE1pbih2KTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5NYW5hZ2VyLnByb3RvdHlwZS5yYW5kb21pemF0aW9uRmFjdG9yID0gZnVuY3Rpb24gKHYpIHtcbiAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gdGhpcy5fcmFuZG9taXphdGlvbkZhY3RvcjtcbiAgdGhpcy5fcmFuZG9taXphdGlvbkZhY3RvciA9IHY7XG4gIHRoaXMuYmFja29mZiAmJiB0aGlzLmJhY2tvZmYuc2V0Sml0dGVyKHYpO1xuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogU2V0cyB0aGUgbWF4aW11bSBkZWxheSBiZXR3ZWVuIHJlY29ubmVjdGlvbnMuXG4gKlxuICogQHBhcmFtIHtOdW1iZXJ9IGRlbGF5XG4gKiBAcmV0dXJuIHtNYW5hZ2VyfSBzZWxmIG9yIHZhbHVlXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbk1hbmFnZXIucHJvdG90eXBlLnJlY29ubmVjdGlvbkRlbGF5TWF4ID0gZnVuY3Rpb24gKHYpIHtcbiAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gdGhpcy5fcmVjb25uZWN0aW9uRGVsYXlNYXg7XG4gIHRoaXMuX3JlY29ubmVjdGlvbkRlbGF5TWF4ID0gdjtcbiAgdGhpcy5iYWNrb2ZmICYmIHRoaXMuYmFja29mZi5zZXRNYXgodik7XG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBTZXRzIHRoZSBjb25uZWN0aW9uIHRpbWVvdXQuIGBmYWxzZWAgdG8gZGlzYWJsZVxuICpcbiAqIEByZXR1cm4ge01hbmFnZXJ9IHNlbGYgb3IgdmFsdWVcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuTWFuYWdlci5wcm90b3R5cGUudGltZW91dCA9IGZ1bmN0aW9uICh2KSB7XG4gIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIHRoaXMuX3RpbWVvdXQ7XG4gIHRoaXMuX3RpbWVvdXQgPSB2O1xuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogU3RhcnRzIHRyeWluZyB0byByZWNvbm5lY3QgaWYgcmVjb25uZWN0aW9uIGlzIGVuYWJsZWQgYW5kIHdlIGhhdmUgbm90XG4gKiBzdGFydGVkIHJlY29ubmVjdGluZyB5ZXRcbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5NYW5hZ2VyLnByb3RvdHlwZS5tYXliZVJlY29ubmVjdE9uT3BlbiA9IGZ1bmN0aW9uICgpIHtcbiAgLy8gT25seSB0cnkgdG8gcmVjb25uZWN0IGlmIGl0J3MgdGhlIGZpcnN0IHRpbWUgd2UncmUgY29ubmVjdGluZ1xuICBpZiAoIXRoaXMucmVjb25uZWN0aW5nICYmIHRoaXMuX3JlY29ubmVjdGlvbiAmJiB0aGlzLmJhY2tvZmYuYXR0ZW1wdHMgPT09IDApIHtcbiAgICAvLyBrZWVwcyByZWNvbm5lY3Rpb24gZnJvbSBmaXJpbmcgdHdpY2UgZm9yIHRoZSBzYW1lIHJlY29ubmVjdGlvbiBsb29wXG4gICAgdGhpcy5yZWNvbm5lY3QoKTtcbiAgfVxufTtcblxuLyoqXG4gKiBTZXRzIHRoZSBjdXJyZW50IHRyYW5zcG9ydCBgc29ja2V0YC5cbiAqXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBvcHRpb25hbCwgY2FsbGJhY2tcbiAqIEByZXR1cm4ge01hbmFnZXJ9IHNlbGZcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuTWFuYWdlci5wcm90b3R5cGUub3BlbiA9XG5NYW5hZ2VyLnByb3RvdHlwZS5jb25uZWN0ID0gZnVuY3Rpb24gKGZuLCBvcHRzKSB7XG5cbiAgaWYgKH50aGlzLnJlYWR5U3RhdGUuaW5kZXhPZignb3BlbicpKSByZXR1cm4gdGhpcztcblxuXG4gIHRoaXMuZW5naW5lID0gZWlvKHRoaXMudXJpLCB0aGlzLm9wdHMpO1xuICB2YXIgc29ja2V0ID0gdGhpcy5lbmdpbmU7XG4gIHZhciBzZWxmID0gdGhpcztcbiAgdGhpcy5yZWFkeVN0YXRlID0gJ29wZW5pbmcnO1xuICB0aGlzLnNraXBSZWNvbm5lY3QgPSBmYWxzZTtcblxuICAvLyBlbWl0IGBvcGVuYFxuICB2YXIgb3BlblN1YiA9IG9uKHNvY2tldCwgJ29wZW4nLCBmdW5jdGlvbiAoKSB7XG4gICAgc2VsZi5vbm9wZW4oKTtcbiAgICBmbiAmJiBmbigpO1xuICB9KTtcblxuICAvLyBlbWl0IGBjb25uZWN0X2Vycm9yYFxuICB2YXIgZXJyb3JTdWIgPSBvbihzb2NrZXQsICdlcnJvcicsIGZ1bmN0aW9uIChkYXRhKSB7XG5cbiAgICBzZWxmLmNsZWFudXAoKTtcbiAgICBzZWxmLnJlYWR5U3RhdGUgPSAnY2xvc2VkJztcbiAgICBzZWxmLmVtaXRBbGwoJ2Nvbm5lY3RfZXJyb3InLCBkYXRhKTtcbiAgICBpZiAoZm4pIHtcbiAgICAgIHZhciBlcnIgPSBuZXcgRXJyb3IoJ0Nvbm5lY3Rpb24gZXJyb3InKTtcbiAgICAgIGVyci5kYXRhID0gZGF0YTtcbiAgICAgIGZuKGVycik7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIE9ubHkgZG8gdGhpcyBpZiB0aGVyZSBpcyBubyBmbiB0byBoYW5kbGUgdGhlIGVycm9yXG4gICAgICBzZWxmLm1heWJlUmVjb25uZWN0T25PcGVuKCk7XG4gICAgfVxuICB9KTtcblxuICAvLyBlbWl0IGBjb25uZWN0X3RpbWVvdXRgXG4gIGlmIChmYWxzZSAhPT0gdGhpcy5fdGltZW91dCkge1xuICAgIHZhciB0aW1lb3V0ID0gdGhpcy5fdGltZW91dDtcblxuXG4gICAgLy8gc2V0IHRpbWVyXG4gICAgdmFyIHRpbWVyID0gc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG5cbiAgICAgIG9wZW5TdWIuZGVzdHJveSgpO1xuICAgICAgc29ja2V0LmNsb3NlKCk7XG4gICAgICBzb2NrZXQuZW1pdCgnZXJyb3InLCAndGltZW91dCcpO1xuICAgICAgc2VsZi5lbWl0QWxsKCdjb25uZWN0X3RpbWVvdXQnLCB0aW1lb3V0KTtcbiAgICB9LCB0aW1lb3V0KTtcblxuICAgIHRoaXMuc3Vicy5wdXNoKHtcbiAgICAgIGRlc3Ryb3k6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgY2xlYXJUaW1lb3V0KHRpbWVyKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIHRoaXMuc3Vicy5wdXNoKG9wZW5TdWIpO1xuICB0aGlzLnN1YnMucHVzaChlcnJvclN1Yik7XG5cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIENhbGxlZCB1cG9uIHRyYW5zcG9ydCBvcGVuLlxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbk1hbmFnZXIucHJvdG90eXBlLm9ub3BlbiA9IGZ1bmN0aW9uICgpIHtcblxuXG4gIC8vIGNsZWFyIG9sZCBzdWJzXG4gIHRoaXMuY2xlYW51cCgpO1xuXG4gIC8vIG1hcmsgYXMgb3BlblxuICB0aGlzLnJlYWR5U3RhdGUgPSAnb3Blbic7XG4gIHRoaXMuZW1pdCgnb3BlbicpO1xuXG4gIC8vIGFkZCBuZXcgc3Vic1xuICB2YXIgc29ja2V0ID0gdGhpcy5lbmdpbmU7XG4gIHRoaXMuc3Vicy5wdXNoKG9uKHNvY2tldCwgJ2RhdGEnLCBiaW5kKHRoaXMsICdvbmRhdGEnKSkpO1xuICB0aGlzLnN1YnMucHVzaChvbihzb2NrZXQsICdwaW5nJywgYmluZCh0aGlzLCAnb25waW5nJykpKTtcbiAgdGhpcy5zdWJzLnB1c2gob24oc29ja2V0LCAncG9uZycsIGJpbmQodGhpcywgJ29ucG9uZycpKSk7XG4gIHRoaXMuc3Vicy5wdXNoKG9uKHNvY2tldCwgJ2Vycm9yJywgYmluZCh0aGlzLCAnb25lcnJvcicpKSk7XG4gIHRoaXMuc3Vicy5wdXNoKG9uKHNvY2tldCwgJ2Nsb3NlJywgYmluZCh0aGlzLCAnb25jbG9zZScpKSk7XG4gIHRoaXMuc3Vicy5wdXNoKG9uKHRoaXMuZGVjb2RlciwgJ2RlY29kZWQnLCBiaW5kKHRoaXMsICdvbmRlY29kZWQnKSkpO1xufTtcblxuLyoqXG4gKiBDYWxsZWQgdXBvbiBhIHBpbmcuXG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuTWFuYWdlci5wcm90b3R5cGUub25waW5nID0gZnVuY3Rpb24gKCkge1xuICB0aGlzLmxhc3RQaW5nID0gbmV3IERhdGUoKTtcbiAgdGhpcy5lbWl0QWxsKCdwaW5nJyk7XG59O1xuXG4vKipcbiAqIENhbGxlZCB1cG9uIGEgcGFja2V0LlxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbk1hbmFnZXIucHJvdG90eXBlLm9ucG9uZyA9IGZ1bmN0aW9uICgpIHtcbiAgdGhpcy5lbWl0QWxsKCdwb25nJywgbmV3IERhdGUoKSAtIHRoaXMubGFzdFBpbmcpO1xufTtcblxuLyoqXG4gKiBDYWxsZWQgd2l0aCBkYXRhLlxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbk1hbmFnZXIucHJvdG90eXBlLm9uZGF0YSA9IGZ1bmN0aW9uIChkYXRhKSB7XG4gIHRoaXMuZGVjb2Rlci5hZGQoZGF0YSk7XG59O1xuXG4vKipcbiAqIENhbGxlZCB3aGVuIHBhcnNlciBmdWxseSBkZWNvZGVzIGEgcGFja2V0LlxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbk1hbmFnZXIucHJvdG90eXBlLm9uZGVjb2RlZCA9IGZ1bmN0aW9uIChwYWNrZXQpIHtcbiAgdGhpcy5lbWl0KCdwYWNrZXQnLCBwYWNrZXQpO1xufTtcblxuLyoqXG4gKiBDYWxsZWQgdXBvbiBzb2NrZXQgZXJyb3IuXG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuTWFuYWdlci5wcm90b3R5cGUub25lcnJvciA9IGZ1bmN0aW9uIChlcnIpIHtcblxuICB0aGlzLmVtaXRBbGwoJ2Vycm9yJywgZXJyKTtcbn07XG5cbi8qKlxuICogQ3JlYXRlcyBhIG5ldyBzb2NrZXQgZm9yIHRoZSBnaXZlbiBgbnNwYC5cbiAqXG4gKiBAcmV0dXJuIHtTb2NrZXR9XG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbk1hbmFnZXIucHJvdG90eXBlLnNvY2tldCA9IGZ1bmN0aW9uIChuc3AsIG9wdHMpIHtcbiAgdmFyIHNvY2tldCA9IHRoaXMubnNwc1tuc3BdO1xuICBpZiAoIXNvY2tldCkge1xuICAgIHNvY2tldCA9IG5ldyBTb2NrZXQodGhpcywgbnNwLCBvcHRzKTtcbiAgICB0aGlzLm5zcHNbbnNwXSA9IHNvY2tldDtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgc29ja2V0Lm9uKCdjb25uZWN0aW5nJywgb25Db25uZWN0aW5nKTtcbiAgICBzb2NrZXQub24oJ2Nvbm5lY3QnLCBmdW5jdGlvbiAoKSB7XG4gICAgICBzb2NrZXQuaWQgPSBzZWxmLmdlbmVyYXRlSWQobnNwKTtcbiAgICB9KTtcblxuICAgIGlmICh0aGlzLmF1dG9Db25uZWN0KSB7XG4gICAgICAvLyBtYW51YWxseSBjYWxsIGhlcmUgc2luY2UgY29ubmVjdGluZyBldmVudCBpcyBmaXJlZCBiZWZvcmUgbGlzdGVuaW5nXG4gICAgICBvbkNvbm5lY3RpbmcoKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBvbkNvbm5lY3RpbmcgKCkge1xuICAgIGlmICghfmluZGV4T2Yoc2VsZi5jb25uZWN0aW5nLCBzb2NrZXQpKSB7XG4gICAgICBzZWxmLmNvbm5lY3RpbmcucHVzaChzb2NrZXQpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBzb2NrZXQ7XG59O1xuXG4vKipcbiAqIENhbGxlZCB1cG9uIGEgc29ja2V0IGNsb3NlLlxuICpcbiAqIEBwYXJhbSB7U29ja2V0fSBzb2NrZXRcbiAqL1xuXG5NYW5hZ2VyLnByb3RvdHlwZS5kZXN0cm95ID0gZnVuY3Rpb24gKHNvY2tldCkge1xuICB2YXIgaW5kZXggPSBpbmRleE9mKHRoaXMuY29ubmVjdGluZywgc29ja2V0KTtcbiAgaWYgKH5pbmRleCkgdGhpcy5jb25uZWN0aW5nLnNwbGljZShpbmRleCwgMSk7XG4gIGlmICh0aGlzLmNvbm5lY3RpbmcubGVuZ3RoKSByZXR1cm47XG5cbiAgdGhpcy5jbG9zZSgpO1xufTtcblxuLyoqXG4gKiBXcml0ZXMgYSBwYWNrZXQuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IHBhY2tldFxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuTWFuYWdlci5wcm90b3R5cGUucGFja2V0ID0gZnVuY3Rpb24gKHBhY2tldCkge1xuXG4gIHZhciBzZWxmID0gdGhpcztcbiAgaWYgKHBhY2tldC5xdWVyeSAmJiBwYWNrZXQudHlwZSA9PT0gMCkgcGFja2V0Lm5zcCArPSAnPycgKyBwYWNrZXQucXVlcnk7XG5cbiAgaWYgKCFzZWxmLmVuY29kaW5nKSB7XG4gICAgLy8gZW5jb2RlLCB0aGVuIHdyaXRlIHRvIGVuZ2luZSB3aXRoIHJlc3VsdFxuICAgIHNlbGYuZW5jb2RpbmcgPSB0cnVlO1xuICAgIHRoaXMuZW5jb2Rlci5lbmNvZGUocGFja2V0LCBmdW5jdGlvbiAoZW5jb2RlZFBhY2tldHMpIHtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZW5jb2RlZFBhY2tldHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgc2VsZi5lbmdpbmUud3JpdGUoZW5jb2RlZFBhY2tldHNbaV0sIHBhY2tldC5vcHRpb25zKTtcbiAgICAgIH1cbiAgICAgIHNlbGYuZW5jb2RpbmcgPSBmYWxzZTtcbiAgICAgIHNlbGYucHJvY2Vzc1BhY2tldFF1ZXVlKCk7XG4gICAgfSk7XG4gIH0gZWxzZSB7IC8vIGFkZCBwYWNrZXQgdG8gdGhlIHF1ZXVlXG4gICAgc2VsZi5wYWNrZXRCdWZmZXIucHVzaChwYWNrZXQpO1xuICB9XG59O1xuXG4vKipcbiAqIElmIHBhY2tldCBidWZmZXIgaXMgbm9uLWVtcHR5LCBiZWdpbnMgZW5jb2RpbmcgdGhlXG4gKiBuZXh0IHBhY2tldCBpbiBsaW5lLlxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbk1hbmFnZXIucHJvdG90eXBlLnByb2Nlc3NQYWNrZXRRdWV1ZSA9IGZ1bmN0aW9uICgpIHtcbiAgaWYgKHRoaXMucGFja2V0QnVmZmVyLmxlbmd0aCA+IDAgJiYgIXRoaXMuZW5jb2RpbmcpIHtcbiAgICB2YXIgcGFjayA9IHRoaXMucGFja2V0QnVmZmVyLnNoaWZ0KCk7XG4gICAgdGhpcy5wYWNrZXQocGFjayk7XG4gIH1cbn07XG5cbi8qKlxuICogQ2xlYW4gdXAgdHJhbnNwb3J0IHN1YnNjcmlwdGlvbnMgYW5kIHBhY2tldCBidWZmZXIuXG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuTWFuYWdlci5wcm90b3R5cGUuY2xlYW51cCA9IGZ1bmN0aW9uICgpIHtcblxuXG4gIHZhciBzdWJzTGVuZ3RoID0gdGhpcy5zdWJzLmxlbmd0aDtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdWJzTGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgc3ViID0gdGhpcy5zdWJzLnNoaWZ0KCk7XG4gICAgc3ViLmRlc3Ryb3koKTtcbiAgfVxuXG4gIHRoaXMucGFja2V0QnVmZmVyID0gW107XG4gIHRoaXMuZW5jb2RpbmcgPSBmYWxzZTtcbiAgdGhpcy5sYXN0UGluZyA9IG51bGw7XG5cbiAgdGhpcy5kZWNvZGVyLmRlc3Ryb3koKTtcbn07XG5cbi8qKlxuICogQ2xvc2UgdGhlIGN1cnJlbnQgc29ja2V0LlxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbk1hbmFnZXIucHJvdG90eXBlLmNsb3NlID1cbk1hbmFnZXIucHJvdG90eXBlLmRpc2Nvbm5lY3QgPSBmdW5jdGlvbiAoKSB7XG5cbiAgdGhpcy5za2lwUmVjb25uZWN0ID0gdHJ1ZTtcbiAgdGhpcy5yZWNvbm5lY3RpbmcgPSBmYWxzZTtcbiAgaWYgKCdvcGVuaW5nJyA9PT0gdGhpcy5yZWFkeVN0YXRlKSB7XG4gICAgLy8gYG9uY2xvc2VgIHdpbGwgbm90IGZpcmUgYmVjYXVzZVxuICAgIC8vIGFuIG9wZW4gZXZlbnQgbmV2ZXIgaGFwcGVuZWRcbiAgICB0aGlzLmNsZWFudXAoKTtcbiAgfVxuICB0aGlzLmJhY2tvZmYucmVzZXQoKTtcbiAgdGhpcy5yZWFkeVN0YXRlID0gJ2Nsb3NlZCc7XG4gIGlmICh0aGlzLmVuZ2luZSkgdGhpcy5lbmdpbmUuY2xvc2UoKTtcbn07XG5cbi8qKlxuICogQ2FsbGVkIHVwb24gZW5naW5lIGNsb3NlLlxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbk1hbmFnZXIucHJvdG90eXBlLm9uY2xvc2UgPSBmdW5jdGlvbiAocmVhc29uKSB7XG5cblxuICB0aGlzLmNsZWFudXAoKTtcbiAgdGhpcy5iYWNrb2ZmLnJlc2V0KCk7XG4gIHRoaXMucmVhZHlTdGF0ZSA9ICdjbG9zZWQnO1xuICB0aGlzLmVtaXQoJ2Nsb3NlJywgcmVhc29uKTtcblxuICBpZiAodGhpcy5fcmVjb25uZWN0aW9uICYmICF0aGlzLnNraXBSZWNvbm5lY3QpIHtcbiAgICB0aGlzLnJlY29ubmVjdCgpO1xuICB9XG59O1xuXG4vKipcbiAqIEF0dGVtcHQgYSByZWNvbm5lY3Rpb24uXG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuTWFuYWdlci5wcm90b3R5cGUucmVjb25uZWN0ID0gZnVuY3Rpb24gKCkge1xuICBpZiAodGhpcy5yZWNvbm5lY3RpbmcgfHwgdGhpcy5za2lwUmVjb25uZWN0KSByZXR1cm4gdGhpcztcblxuICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgaWYgKHRoaXMuYmFja29mZi5hdHRlbXB0cyA+PSB0aGlzLl9yZWNvbm5lY3Rpb25BdHRlbXB0cykge1xuXG4gICAgdGhpcy5iYWNrb2ZmLnJlc2V0KCk7XG4gICAgdGhpcy5lbWl0QWxsKCdyZWNvbm5lY3RfZmFpbGVkJyk7XG4gICAgdGhpcy5yZWNvbm5lY3RpbmcgPSBmYWxzZTtcbiAgfSBlbHNlIHtcbiAgICB2YXIgZGVsYXkgPSB0aGlzLmJhY2tvZmYuZHVyYXRpb24oKTtcblxuXG4gICAgdGhpcy5yZWNvbm5lY3RpbmcgPSB0cnVlO1xuICAgIHZhciB0aW1lciA9IHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgaWYgKHNlbGYuc2tpcFJlY29ubmVjdCkgcmV0dXJuO1xuXG5cbiAgICAgIHNlbGYuZW1pdEFsbCgncmVjb25uZWN0X2F0dGVtcHQnLCBzZWxmLmJhY2tvZmYuYXR0ZW1wdHMpO1xuICAgICAgc2VsZi5lbWl0QWxsKCdyZWNvbm5lY3RpbmcnLCBzZWxmLmJhY2tvZmYuYXR0ZW1wdHMpO1xuXG4gICAgICAvLyBjaGVjayBhZ2FpbiBmb3IgdGhlIGNhc2Ugc29ja2V0IGNsb3NlZCBpbiBhYm92ZSBldmVudHNcbiAgICAgIGlmIChzZWxmLnNraXBSZWNvbm5lY3QpIHJldHVybjtcblxuICAgICAgc2VsZi5vcGVuKGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgaWYgKGVycikge1xuXG4gICAgICAgICAgc2VsZi5yZWNvbm5lY3RpbmcgPSBmYWxzZTtcbiAgICAgICAgICBzZWxmLnJlY29ubmVjdCgpO1xuICAgICAgICAgIHNlbGYuZW1pdEFsbCgncmVjb25uZWN0X2Vycm9yJywgZXJyLmRhdGEpO1xuICAgICAgICB9IGVsc2Uge1xuXG4gICAgICAgICAgc2VsZi5vbnJlY29ubmVjdCgpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9LCBkZWxheSk7XG5cbiAgICB0aGlzLnN1YnMucHVzaCh7XG4gICAgICBkZXN0cm95OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGNsZWFyVGltZW91dCh0aW1lcik7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbn07XG5cbi8qKlxuICogQ2FsbGVkIHVwb24gc3VjY2Vzc2Z1bCByZWNvbm5lY3QuXG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuTWFuYWdlci5wcm90b3R5cGUub25yZWNvbm5lY3QgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBhdHRlbXB0ID0gdGhpcy5iYWNrb2ZmLmF0dGVtcHRzO1xuICB0aGlzLnJlY29ubmVjdGluZyA9IGZhbHNlO1xuICB0aGlzLmJhY2tvZmYucmVzZXQoKTtcbiAgdGhpcy51cGRhdGVTb2NrZXRJZHMoKTtcbiAgdGhpcy5lbWl0QWxsKCdyZWNvbm5lY3QnLCBhdHRlbXB0KTtcbn07XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9saWIvbWFuYWdlci5qcyIsIlxubW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2xpYi9pbmRleCcpO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2VuZ2luZS5pby1jbGllbnQvaW5kZXguanNcbi8vIG1vZHVsZSBpZCA9IDExXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIlxubW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL3NvY2tldCcpO1xuXG4vKipcbiAqIEV4cG9ydHMgcGFyc2VyXG4gKlxuICogQGFwaSBwdWJsaWNcbiAqXG4gKi9cbm1vZHVsZS5leHBvcnRzLnBhcnNlciA9IHJlcXVpcmUoJ2VuZ2luZS5pby1wYXJzZXInKTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9lbmdpbmUuaW8tY2xpZW50L2xpYi9pbmRleC5qc1xuLy8gbW9kdWxlIGlkID0gMTJcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLyoqXG4gKiBNb2R1bGUgZGVwZW5kZW5jaWVzLlxuICovXG5cbnZhciB0cmFuc3BvcnRzID0gcmVxdWlyZSgnLi90cmFuc3BvcnRzL2luZGV4Jyk7XG52YXIgRW1pdHRlciA9IHJlcXVpcmUoJ2NvbXBvbmVudC1lbWl0dGVyJyk7XG52YXIgZGVidWcgPSByZXF1aXJlKCdkZWJ1ZycpKCdlbmdpbmUuaW8tY2xpZW50OnNvY2tldCcpO1xudmFyIGluZGV4ID0gcmVxdWlyZSgnaW5kZXhvZicpO1xudmFyIHBhcnNlciA9IHJlcXVpcmUoJ2VuZ2luZS5pby1wYXJzZXInKTtcbnZhciBwYXJzZXVyaSA9IHJlcXVpcmUoJ3BhcnNldXJpJyk7XG52YXIgcGFyc2Vqc29uID0gcmVxdWlyZSgncGFyc2Vqc29uJyk7XG52YXIgcGFyc2VxcyA9IHJlcXVpcmUoJ3BhcnNlcXMnKTtcblxuLyoqXG4gKiBNb2R1bGUgZXhwb3J0cy5cbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IFNvY2tldDtcblxuLyoqXG4gKiBTb2NrZXQgY29uc3RydWN0b3IuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd8T2JqZWN0fSB1cmkgb3Igb3B0aW9uc1xuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZnVuY3Rpb24gU29ja2V0ICh1cmksIG9wdHMpIHtcbiAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIFNvY2tldCkpIHJldHVybiBuZXcgU29ja2V0KHVyaSwgb3B0cyk7XG5cbiAgb3B0cyA9IG9wdHMgfHwge307XG5cbiAgaWYgKHVyaSAmJiAnb2JqZWN0JyA9PT0gdHlwZW9mIHVyaSkge1xuICAgIG9wdHMgPSB1cmk7XG4gICAgdXJpID0gbnVsbDtcbiAgfVxuXG4gIGlmICh1cmkpIHtcbiAgICB1cmkgPSBwYXJzZXVyaSh1cmkpO1xuICAgIG9wdHMuaG9zdG5hbWUgPSB1cmkuaG9zdDtcbiAgICBvcHRzLnNlY3VyZSA9IHVyaS5wcm90b2NvbCA9PT0gJ2h0dHBzJyB8fCB1cmkucHJvdG9jb2wgPT09ICd3c3MnO1xuICAgIG9wdHMucG9ydCA9IHVyaS5wb3J0O1xuICAgIGlmICh1cmkucXVlcnkpIG9wdHMucXVlcnkgPSB1cmkucXVlcnk7XG4gIH0gZWxzZSBpZiAob3B0cy5ob3N0KSB7XG4gICAgb3B0cy5ob3N0bmFtZSA9IHBhcnNldXJpKG9wdHMuaG9zdCkuaG9zdDtcbiAgfVxuXG4gIHRoaXMuc2VjdXJlID0gbnVsbCAhPSBvcHRzLnNlY3VyZSA/IG9wdHMuc2VjdXJlXG4gICAgOiAoZ2xvYmFsLmxvY2F0aW9uICYmICdodHRwczonID09PSBsb2NhdGlvbi5wcm90b2NvbCk7XG5cbiAgaWYgKG9wdHMuaG9zdG5hbWUgJiYgIW9wdHMucG9ydCkge1xuICAgIC8vIGlmIG5vIHBvcnQgaXMgc3BlY2lmaWVkIG1hbnVhbGx5LCB1c2UgdGhlIHByb3RvY29sIGRlZmF1bHRcbiAgICBvcHRzLnBvcnQgPSB0aGlzLnNlY3VyZSA/ICc0NDMnIDogJzgwJztcbiAgfVxuXG4gIHRoaXMuYWdlbnQgPSBvcHRzLmFnZW50IHx8IGZhbHNlO1xuICB0aGlzLmhvc3RuYW1lID0gb3B0cy5ob3N0bmFtZSB8fFxuICAgIChnbG9iYWwubG9jYXRpb24gPyBsb2NhdGlvbi5ob3N0bmFtZSA6ICdsb2NhbGhvc3QnKTtcbiAgdGhpcy5wb3J0ID0gb3B0cy5wb3J0IHx8IChnbG9iYWwubG9jYXRpb24gJiYgbG9jYXRpb24ucG9ydFxuICAgICAgPyBsb2NhdGlvbi5wb3J0XG4gICAgICA6ICh0aGlzLnNlY3VyZSA/IDQ0MyA6IDgwKSk7XG4gIHRoaXMucXVlcnkgPSBvcHRzLnF1ZXJ5IHx8IHt9O1xuICBpZiAoJ3N0cmluZycgPT09IHR5cGVvZiB0aGlzLnF1ZXJ5KSB0aGlzLnF1ZXJ5ID0gcGFyc2Vxcy5kZWNvZGUodGhpcy5xdWVyeSk7XG4gIHRoaXMudXBncmFkZSA9IGZhbHNlICE9PSBvcHRzLnVwZ3JhZGU7XG4gIHRoaXMucGF0aCA9IChvcHRzLnBhdGggfHwgJy9lbmdpbmUuaW8nKS5yZXBsYWNlKC9cXC8kLywgJycpICsgJy8nO1xuICB0aGlzLmZvcmNlSlNPTlAgPSAhIW9wdHMuZm9yY2VKU09OUDtcbiAgdGhpcy5qc29ucCA9IGZhbHNlICE9PSBvcHRzLmpzb25wO1xuICB0aGlzLmZvcmNlQmFzZTY0ID0gISFvcHRzLmZvcmNlQmFzZTY0O1xuICB0aGlzLmVuYWJsZXNYRFIgPSAhIW9wdHMuZW5hYmxlc1hEUjtcbiAgdGhpcy50aW1lc3RhbXBQYXJhbSA9IG9wdHMudGltZXN0YW1wUGFyYW0gfHwgJ3QnO1xuICB0aGlzLnRpbWVzdGFtcFJlcXVlc3RzID0gb3B0cy50aW1lc3RhbXBSZXF1ZXN0cztcbiAgdGhpcy50cmFuc3BvcnRzID0gb3B0cy50cmFuc3BvcnRzIHx8IFsncG9sbGluZycsICd3ZWJzb2NrZXQnXTtcbiAgdGhpcy50cmFuc3BvcnRPcHRpb25zID0gb3B0cy50cmFuc3BvcnRPcHRpb25zIHx8IHt9O1xuICB0aGlzLnJlYWR5U3RhdGUgPSAnJztcbiAgdGhpcy53cml0ZUJ1ZmZlciA9IFtdO1xuICB0aGlzLnByZXZCdWZmZXJMZW4gPSAwO1xuICB0aGlzLnBvbGljeVBvcnQgPSBvcHRzLnBvbGljeVBvcnQgfHwgODQzO1xuICB0aGlzLnJlbWVtYmVyVXBncmFkZSA9IG9wdHMucmVtZW1iZXJVcGdyYWRlIHx8IGZhbHNlO1xuICB0aGlzLmJpbmFyeVR5cGUgPSBudWxsO1xuICB0aGlzLm9ubHlCaW5hcnlVcGdyYWRlcyA9IG9wdHMub25seUJpbmFyeVVwZ3JhZGVzO1xuICB0aGlzLnBlck1lc3NhZ2VEZWZsYXRlID0gZmFsc2UgIT09IG9wdHMucGVyTWVzc2FnZURlZmxhdGUgPyAob3B0cy5wZXJNZXNzYWdlRGVmbGF0ZSB8fCB7fSkgOiBmYWxzZTtcblxuICBpZiAodHJ1ZSA9PT0gdGhpcy5wZXJNZXNzYWdlRGVmbGF0ZSkgdGhpcy5wZXJNZXNzYWdlRGVmbGF0ZSA9IHt9O1xuICBpZiAodGhpcy5wZXJNZXNzYWdlRGVmbGF0ZSAmJiBudWxsID09IHRoaXMucGVyTWVzc2FnZURlZmxhdGUudGhyZXNob2xkKSB7XG4gICAgdGhpcy5wZXJNZXNzYWdlRGVmbGF0ZS50aHJlc2hvbGQgPSAxMDI0O1xuICB9XG5cbiAgLy8gU1NMIG9wdGlvbnMgZm9yIE5vZGUuanMgY2xpZW50XG4gIHRoaXMucGZ4ID0gb3B0cy5wZnggfHwgbnVsbDtcbiAgdGhpcy5rZXkgPSBvcHRzLmtleSB8fCBudWxsO1xuICB0aGlzLnBhc3NwaHJhc2UgPSBvcHRzLnBhc3NwaHJhc2UgfHwgbnVsbDtcbiAgdGhpcy5jZXJ0ID0gb3B0cy5jZXJ0IHx8IG51bGw7XG4gIHRoaXMuY2EgPSBvcHRzLmNhIHx8IG51bGw7XG4gIHRoaXMuY2lwaGVycyA9IG9wdHMuY2lwaGVycyB8fCBudWxsO1xuICB0aGlzLnJlamVjdFVuYXV0aG9yaXplZCA9IG9wdHMucmVqZWN0VW5hdXRob3JpemVkID09PSB1bmRlZmluZWQgPyB0cnVlIDogb3B0cy5yZWplY3RVbmF1dGhvcml6ZWQ7XG4gIHRoaXMuZm9yY2VOb2RlID0gISFvcHRzLmZvcmNlTm9kZTtcblxuICAvLyBvdGhlciBvcHRpb25zIGZvciBOb2RlLmpzIGNsaWVudFxuICB2YXIgZnJlZUdsb2JhbCA9IHR5cGVvZiBnbG9iYWwgPT09ICdvYmplY3QnICYmIGdsb2JhbDtcbiAgaWYgKGZyZWVHbG9iYWwuZ2xvYmFsID09PSBmcmVlR2xvYmFsKSB7XG4gICAgaWYgKG9wdHMuZXh0cmFIZWFkZXJzICYmIE9iamVjdC5rZXlzKG9wdHMuZXh0cmFIZWFkZXJzKS5sZW5ndGggPiAwKSB7XG4gICAgICB0aGlzLmV4dHJhSGVhZGVycyA9IG9wdHMuZXh0cmFIZWFkZXJzO1xuICAgIH1cblxuICAgIGlmIChvcHRzLmxvY2FsQWRkcmVzcykge1xuICAgICAgdGhpcy5sb2NhbEFkZHJlc3MgPSBvcHRzLmxvY2FsQWRkcmVzcztcbiAgICB9XG4gIH1cblxuICAvLyBzZXQgb24gaGFuZHNoYWtlXG4gIHRoaXMuaWQgPSBudWxsO1xuICB0aGlzLnVwZ3JhZGVzID0gbnVsbDtcbiAgdGhpcy5waW5nSW50ZXJ2YWwgPSBudWxsO1xuICB0aGlzLnBpbmdUaW1lb3V0ID0gbnVsbDtcblxuICAvLyBzZXQgb24gaGVhcnRiZWF0XG4gIHRoaXMucGluZ0ludGVydmFsVGltZXIgPSBudWxsO1xuICB0aGlzLnBpbmdUaW1lb3V0VGltZXIgPSBudWxsO1xuXG4gIHRoaXMub3BlbigpO1xufVxuXG5Tb2NrZXQucHJpb3JXZWJzb2NrZXRTdWNjZXNzID0gZmFsc2U7XG5cbi8qKlxuICogTWl4IGluIGBFbWl0dGVyYC5cbiAqL1xuXG5FbWl0dGVyKFNvY2tldC5wcm90b3R5cGUpO1xuXG4vKipcbiAqIFByb3RvY29sIHZlcnNpb24uXG4gKlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5Tb2NrZXQucHJvdG9jb2wgPSBwYXJzZXIucHJvdG9jb2w7IC8vIHRoaXMgaXMgYW4gaW50XG5cbi8qKlxuICogRXhwb3NlIGRlcHMgZm9yIGxlZ2FjeSBjb21wYXRpYmlsaXR5XG4gKiBhbmQgc3RhbmRhbG9uZSBicm93c2VyIGFjY2Vzcy5cbiAqL1xuXG5Tb2NrZXQuU29ja2V0ID0gU29ja2V0O1xuU29ja2V0LlRyYW5zcG9ydCA9IHJlcXVpcmUoJy4vdHJhbnNwb3J0Jyk7XG5Tb2NrZXQudHJhbnNwb3J0cyA9IHJlcXVpcmUoJy4vdHJhbnNwb3J0cy9pbmRleCcpO1xuU29ja2V0LnBhcnNlciA9IHJlcXVpcmUoJ2VuZ2luZS5pby1wYXJzZXInKTtcblxuLyoqXG4gKiBDcmVhdGVzIHRyYW5zcG9ydCBvZiB0aGUgZ2l2ZW4gdHlwZS5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gdHJhbnNwb3J0IG5hbWVcbiAqIEByZXR1cm4ge1RyYW5zcG9ydH1cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblNvY2tldC5wcm90b3R5cGUuY3JlYXRlVHJhbnNwb3J0ID0gZnVuY3Rpb24gKG5hbWUpIHtcblxuICB2YXIgcXVlcnkgPSBjbG9uZSh0aGlzLnF1ZXJ5KTtcblxuICAvLyBhcHBlbmQgZW5naW5lLmlvIHByb3RvY29sIGlkZW50aWZpZXJcbiAgcXVlcnkuRUlPID0gcGFyc2VyLnByb3RvY29sO1xuXG4gIC8vIHRyYW5zcG9ydCBuYW1lXG4gIHF1ZXJ5LnRyYW5zcG9ydCA9IG5hbWU7XG5cbiAgLy8gcGVyLXRyYW5zcG9ydCBvcHRpb25zXG4gIHZhciBvcHRpb25zID0gdGhpcy50cmFuc3BvcnRPcHRpb25zW25hbWVdIHx8IHt9O1xuXG4gIC8vIHNlc3Npb24gaWQgaWYgd2UgYWxyZWFkeSBoYXZlIG9uZVxuICBpZiAodGhpcy5pZCkgcXVlcnkuc2lkID0gdGhpcy5pZDtcblxuICB2YXIgdHJhbnNwb3J0ID0gbmV3IHRyYW5zcG9ydHNbbmFtZV0oe1xuICAgIHF1ZXJ5OiBxdWVyeSxcbiAgICBzb2NrZXQ6IHRoaXMsXG4gICAgYWdlbnQ6IG9wdGlvbnMuYWdlbnQgfHwgdGhpcy5hZ2VudCxcbiAgICBob3N0bmFtZTogb3B0aW9ucy5ob3N0bmFtZSB8fCB0aGlzLmhvc3RuYW1lLFxuICAgIHBvcnQ6IG9wdGlvbnMucG9ydCB8fCB0aGlzLnBvcnQsXG4gICAgc2VjdXJlOiBvcHRpb25zLnNlY3VyZSB8fCB0aGlzLnNlY3VyZSxcbiAgICBwYXRoOiBvcHRpb25zLnBhdGggfHwgdGhpcy5wYXRoLFxuICAgIGZvcmNlSlNPTlA6IG9wdGlvbnMuZm9yY2VKU09OUCB8fCB0aGlzLmZvcmNlSlNPTlAsXG4gICAganNvbnA6IG9wdGlvbnMuanNvbnAgfHwgdGhpcy5qc29ucCxcbiAgICBmb3JjZUJhc2U2NDogb3B0aW9ucy5mb3JjZUJhc2U2NCB8fCB0aGlzLmZvcmNlQmFzZTY0LFxuICAgIGVuYWJsZXNYRFI6IG9wdGlvbnMuZW5hYmxlc1hEUiB8fCB0aGlzLmVuYWJsZXNYRFIsXG4gICAgdGltZXN0YW1wUmVxdWVzdHM6IG9wdGlvbnMudGltZXN0YW1wUmVxdWVzdHMgfHwgdGhpcy50aW1lc3RhbXBSZXF1ZXN0cyxcbiAgICB0aW1lc3RhbXBQYXJhbTogb3B0aW9ucy50aW1lc3RhbXBQYXJhbSB8fCB0aGlzLnRpbWVzdGFtcFBhcmFtLFxuICAgIHBvbGljeVBvcnQ6IG9wdGlvbnMucG9saWN5UG9ydCB8fCB0aGlzLnBvbGljeVBvcnQsXG4gICAgcGZ4OiBvcHRpb25zLnBmeCB8fCB0aGlzLnBmeCxcbiAgICBrZXk6IG9wdGlvbnMua2V5IHx8IHRoaXMua2V5LFxuICAgIHBhc3NwaHJhc2U6IG9wdGlvbnMucGFzc3BocmFzZSB8fCB0aGlzLnBhc3NwaHJhc2UsXG4gICAgY2VydDogb3B0aW9ucy5jZXJ0IHx8IHRoaXMuY2VydCxcbiAgICBjYTogb3B0aW9ucy5jYSB8fCB0aGlzLmNhLFxuICAgIGNpcGhlcnM6IG9wdGlvbnMuY2lwaGVycyB8fCB0aGlzLmNpcGhlcnMsXG4gICAgcmVqZWN0VW5hdXRob3JpemVkOiBvcHRpb25zLnJlamVjdFVuYXV0aG9yaXplZCB8fCB0aGlzLnJlamVjdFVuYXV0aG9yaXplZCxcbiAgICBwZXJNZXNzYWdlRGVmbGF0ZTogb3B0aW9ucy5wZXJNZXNzYWdlRGVmbGF0ZSB8fCB0aGlzLnBlck1lc3NhZ2VEZWZsYXRlLFxuICAgIGV4dHJhSGVhZGVyczogb3B0aW9ucy5leHRyYUhlYWRlcnMgfHwgdGhpcy5leHRyYUhlYWRlcnMsXG4gICAgZm9yY2VOb2RlOiBvcHRpb25zLmZvcmNlTm9kZSB8fCB0aGlzLmZvcmNlTm9kZSxcbiAgICBsb2NhbEFkZHJlc3M6IG9wdGlvbnMubG9jYWxBZGRyZXNzIHx8IHRoaXMubG9jYWxBZGRyZXNzLFxuICAgIHJlcXVlc3RUaW1lb3V0OiBvcHRpb25zLnJlcXVlc3RUaW1lb3V0IHx8IHRoaXMucmVxdWVzdFRpbWVvdXQsXG4gICAgcHJvdG9jb2xzOiBvcHRpb25zLnByb3RvY29scyB8fCB2b2lkICgwKVxuICB9KTtcblxuICByZXR1cm4gdHJhbnNwb3J0O1xufTtcblxuZnVuY3Rpb24gY2xvbmUgKG9iaikge1xuICB2YXIgbyA9IHt9O1xuICBmb3IgKHZhciBpIGluIG9iaikge1xuICAgIGlmIChvYmouaGFzT3duUHJvcGVydHkoaSkpIHtcbiAgICAgIG9baV0gPSBvYmpbaV07XG4gICAgfVxuICB9XG4gIHJldHVybiBvO1xufVxuXG4vKipcbiAqIEluaXRpYWxpemVzIHRyYW5zcG9ydCB0byB1c2UgYW5kIHN0YXJ0cyBwcm9iZS5cbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuU29ja2V0LnByb3RvdHlwZS5vcGVuID0gZnVuY3Rpb24gKCkge1xuICB2YXIgdHJhbnNwb3J0O1xuICBpZiAodGhpcy5yZW1lbWJlclVwZ3JhZGUgJiYgU29ja2V0LnByaW9yV2Vic29ja2V0U3VjY2VzcyAmJiB0aGlzLnRyYW5zcG9ydHMuaW5kZXhPZignd2Vic29ja2V0JykgIT09IC0xKSB7XG4gICAgdHJhbnNwb3J0ID0gJ3dlYnNvY2tldCc7XG4gIH0gZWxzZSBpZiAoMCA9PT0gdGhpcy50cmFuc3BvcnRzLmxlbmd0aCkge1xuICAgIC8vIEVtaXQgZXJyb3Igb24gbmV4dCB0aWNrIHNvIGl0IGNhbiBiZSBsaXN0ZW5lZCB0b1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgIHNlbGYuZW1pdCgnZXJyb3InLCAnTm8gdHJhbnNwb3J0cyBhdmFpbGFibGUnKTtcbiAgICB9LCAwKTtcbiAgICByZXR1cm47XG4gIH0gZWxzZSB7XG4gICAgdHJhbnNwb3J0ID0gdGhpcy50cmFuc3BvcnRzWzBdO1xuICB9XG4gIHRoaXMucmVhZHlTdGF0ZSA9ICdvcGVuaW5nJztcblxuICAvLyBSZXRyeSB3aXRoIHRoZSBuZXh0IHRyYW5zcG9ydCBpZiB0aGUgdHJhbnNwb3J0IGlzIGRpc2FibGVkIChqc29ucDogZmFsc2UpXG4gIHRyeSB7XG4gICAgdHJhbnNwb3J0ID0gdGhpcy5jcmVhdGVUcmFuc3BvcnQodHJhbnNwb3J0KTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIHRoaXMudHJhbnNwb3J0cy5zaGlmdCgpO1xuICAgIHRoaXMub3BlbigpO1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHRyYW5zcG9ydC5vcGVuKCk7XG4gIHRoaXMuc2V0VHJhbnNwb3J0KHRyYW5zcG9ydCk7XG59O1xuXG4vKipcbiAqIFNldHMgdGhlIGN1cnJlbnQgdHJhbnNwb3J0LiBEaXNhYmxlcyB0aGUgZXhpc3Rpbmcgb25lIChpZiBhbnkpLlxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblNvY2tldC5wcm90b3R5cGUuc2V0VHJhbnNwb3J0ID0gZnVuY3Rpb24gKHRyYW5zcG9ydCkge1xuXG4gIHZhciBzZWxmID0gdGhpcztcblxuICBpZiAodGhpcy50cmFuc3BvcnQpIHtcblxuICAgIHRoaXMudHJhbnNwb3J0LnJlbW92ZUFsbExpc3RlbmVycygpO1xuICB9XG5cbiAgLy8gc2V0IHVwIHRyYW5zcG9ydFxuICB0aGlzLnRyYW5zcG9ydCA9IHRyYW5zcG9ydDtcblxuICAvLyBzZXQgdXAgdHJhbnNwb3J0IGxpc3RlbmVyc1xuICB0cmFuc3BvcnRcbiAgLm9uKCdkcmFpbicsIGZ1bmN0aW9uICgpIHtcbiAgICBzZWxmLm9uRHJhaW4oKTtcbiAgfSlcbiAgLm9uKCdwYWNrZXQnLCBmdW5jdGlvbiAocGFja2V0KSB7XG4gICAgc2VsZi5vblBhY2tldChwYWNrZXQpO1xuICB9KVxuICAub24oJ2Vycm9yJywgZnVuY3Rpb24gKGUpIHtcbiAgICBzZWxmLm9uRXJyb3IoZSk7XG4gIH0pXG4gIC5vbignY2xvc2UnLCBmdW5jdGlvbiAoKSB7XG4gICAgc2VsZi5vbkNsb3NlKCd0cmFuc3BvcnQgY2xvc2UnKTtcbiAgfSk7XG59O1xuXG4vKipcbiAqIFByb2JlcyBhIHRyYW5zcG9ydC5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gdHJhbnNwb3J0IG5hbWVcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblNvY2tldC5wcm90b3R5cGUucHJvYmUgPSBmdW5jdGlvbiAobmFtZSkge1xuXG4gIHZhciB0cmFuc3BvcnQgPSB0aGlzLmNyZWF0ZVRyYW5zcG9ydChuYW1lLCB7IHByb2JlOiAxIH0pO1xuICB2YXIgZmFpbGVkID0gZmFsc2U7XG4gIHZhciBzZWxmID0gdGhpcztcblxuICBTb2NrZXQucHJpb3JXZWJzb2NrZXRTdWNjZXNzID0gZmFsc2U7XG5cbiAgZnVuY3Rpb24gb25UcmFuc3BvcnRPcGVuICgpIHtcbiAgICBpZiAoc2VsZi5vbmx5QmluYXJ5VXBncmFkZXMpIHtcbiAgICAgIHZhciB1cGdyYWRlTG9zZXNCaW5hcnkgPSAhdGhpcy5zdXBwb3J0c0JpbmFyeSAmJiBzZWxmLnRyYW5zcG9ydC5zdXBwb3J0c0JpbmFyeTtcbiAgICAgIGZhaWxlZCA9IGZhaWxlZCB8fCB1cGdyYWRlTG9zZXNCaW5hcnk7XG4gICAgfVxuICAgIGlmIChmYWlsZWQpIHJldHVybjtcblxuXG4gICAgdHJhbnNwb3J0LnNlbmQoW3sgdHlwZTogJ3BpbmcnLCBkYXRhOiAncHJvYmUnIH1dKTtcbiAgICB0cmFuc3BvcnQub25jZSgncGFja2V0JywgZnVuY3Rpb24gKG1zZykge1xuICAgICAgaWYgKGZhaWxlZCkgcmV0dXJuO1xuICAgICAgaWYgKCdwb25nJyA9PT0gbXNnLnR5cGUgJiYgJ3Byb2JlJyA9PT0gbXNnLmRhdGEpIHtcblxuICAgICAgICBzZWxmLnVwZ3JhZGluZyA9IHRydWU7XG4gICAgICAgIHNlbGYuZW1pdCgndXBncmFkaW5nJywgdHJhbnNwb3J0KTtcbiAgICAgICAgaWYgKCF0cmFuc3BvcnQpIHJldHVybjtcbiAgICAgICAgU29ja2V0LnByaW9yV2Vic29ja2V0U3VjY2VzcyA9ICd3ZWJzb2NrZXQnID09PSB0cmFuc3BvcnQubmFtZTtcblxuXG4gICAgICAgIHNlbGYudHJhbnNwb3J0LnBhdXNlKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBpZiAoZmFpbGVkKSByZXR1cm47XG4gICAgICAgICAgaWYgKCdjbG9zZWQnID09PSBzZWxmLnJlYWR5U3RhdGUpIHJldHVybjtcblxuXG4gICAgICAgICAgY2xlYW51cCgpO1xuXG4gICAgICAgICAgc2VsZi5zZXRUcmFuc3BvcnQodHJhbnNwb3J0KTtcbiAgICAgICAgICB0cmFuc3BvcnQuc2VuZChbeyB0eXBlOiAndXBncmFkZScgfV0pO1xuICAgICAgICAgIHNlbGYuZW1pdCgndXBncmFkZScsIHRyYW5zcG9ydCk7XG4gICAgICAgICAgdHJhbnNwb3J0ID0gbnVsbDtcbiAgICAgICAgICBzZWxmLnVwZ3JhZGluZyA9IGZhbHNlO1xuICAgICAgICAgIHNlbGYuZmx1c2goKTtcbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2Uge1xuXG4gICAgICAgIHZhciBlcnIgPSBuZXcgRXJyb3IoJ3Byb2JlIGVycm9yJyk7XG4gICAgICAgIGVyci50cmFuc3BvcnQgPSB0cmFuc3BvcnQubmFtZTtcbiAgICAgICAgc2VsZi5lbWl0KCd1cGdyYWRlRXJyb3InLCBlcnIpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgZnVuY3Rpb24gZnJlZXplVHJhbnNwb3J0ICgpIHtcbiAgICBpZiAoZmFpbGVkKSByZXR1cm47XG5cbiAgICAvLyBBbnkgY2FsbGJhY2sgY2FsbGVkIGJ5IHRyYW5zcG9ydCBzaG91bGQgYmUgaWdub3JlZCBzaW5jZSBub3dcbiAgICBmYWlsZWQgPSB0cnVlO1xuXG4gICAgY2xlYW51cCgpO1xuXG4gICAgdHJhbnNwb3J0LmNsb3NlKCk7XG4gICAgdHJhbnNwb3J0ID0gbnVsbDtcbiAgfVxuXG4gIC8vIEhhbmRsZSBhbnkgZXJyb3IgdGhhdCBoYXBwZW5zIHdoaWxlIHByb2JpbmdcbiAgZnVuY3Rpb24gb25lcnJvciAoZXJyKSB7XG4gICAgdmFyIGVycm9yID0gbmV3IEVycm9yKCdwcm9iZSBlcnJvcjogJyArIGVycik7XG4gICAgZXJyb3IudHJhbnNwb3J0ID0gdHJhbnNwb3J0Lm5hbWU7XG5cbiAgICBmcmVlemVUcmFuc3BvcnQoKTtcblxuXG5cbiAgICBzZWxmLmVtaXQoJ3VwZ3JhZGVFcnJvcicsIGVycm9yKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIG9uVHJhbnNwb3J0Q2xvc2UgKCkge1xuICAgIG9uZXJyb3IoJ3RyYW5zcG9ydCBjbG9zZWQnKTtcbiAgfVxuXG4gIC8vIFdoZW4gdGhlIHNvY2tldCBpcyBjbG9zZWQgd2hpbGUgd2UncmUgcHJvYmluZ1xuICBmdW5jdGlvbiBvbmNsb3NlICgpIHtcbiAgICBvbmVycm9yKCdzb2NrZXQgY2xvc2VkJyk7XG4gIH1cblxuICAvLyBXaGVuIHRoZSBzb2NrZXQgaXMgdXBncmFkZWQgd2hpbGUgd2UncmUgcHJvYmluZ1xuICBmdW5jdGlvbiBvbnVwZ3JhZGUgKHRvKSB7XG4gICAgaWYgKHRyYW5zcG9ydCAmJiB0by5uYW1lICE9PSB0cmFuc3BvcnQubmFtZSkge1xuXG4gICAgICBmcmVlemVUcmFuc3BvcnQoKTtcbiAgICB9XG4gIH1cblxuICAvLyBSZW1vdmUgYWxsIGxpc3RlbmVycyBvbiB0aGUgdHJhbnNwb3J0IGFuZCBvbiBzZWxmXG4gIGZ1bmN0aW9uIGNsZWFudXAgKCkge1xuICAgIHRyYW5zcG9ydC5yZW1vdmVMaXN0ZW5lcignb3BlbicsIG9uVHJhbnNwb3J0T3Blbik7XG4gICAgdHJhbnNwb3J0LnJlbW92ZUxpc3RlbmVyKCdlcnJvcicsIG9uZXJyb3IpO1xuICAgIHRyYW5zcG9ydC5yZW1vdmVMaXN0ZW5lcignY2xvc2UnLCBvblRyYW5zcG9ydENsb3NlKTtcbiAgICBzZWxmLnJlbW92ZUxpc3RlbmVyKCdjbG9zZScsIG9uY2xvc2UpO1xuICAgIHNlbGYucmVtb3ZlTGlzdGVuZXIoJ3VwZ3JhZGluZycsIG9udXBncmFkZSk7XG4gIH1cblxuICB0cmFuc3BvcnQub25jZSgnb3BlbicsIG9uVHJhbnNwb3J0T3Blbik7XG4gIHRyYW5zcG9ydC5vbmNlKCdlcnJvcicsIG9uZXJyb3IpO1xuICB0cmFuc3BvcnQub25jZSgnY2xvc2UnLCBvblRyYW5zcG9ydENsb3NlKTtcblxuICB0aGlzLm9uY2UoJ2Nsb3NlJywgb25jbG9zZSk7XG4gIHRoaXMub25jZSgndXBncmFkaW5nJywgb251cGdyYWRlKTtcblxuICB0cmFuc3BvcnQub3BlbigpO1xufTtcblxuLyoqXG4gKiBDYWxsZWQgd2hlbiBjb25uZWN0aW9uIGlzIGRlZW1lZCBvcGVuLlxuICpcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuU29ja2V0LnByb3RvdHlwZS5vbk9wZW4gPSBmdW5jdGlvbiAoKSB7XG5cbiAgdGhpcy5yZWFkeVN0YXRlID0gJ29wZW4nO1xuICBTb2NrZXQucHJpb3JXZWJzb2NrZXRTdWNjZXNzID0gJ3dlYnNvY2tldCcgPT09IHRoaXMudHJhbnNwb3J0Lm5hbWU7XG4gIHRoaXMuZW1pdCgnb3BlbicpO1xuICB0aGlzLmZsdXNoKCk7XG5cbiAgLy8gd2UgY2hlY2sgZm9yIGByZWFkeVN0YXRlYCBpbiBjYXNlIGFuIGBvcGVuYFxuICAvLyBsaXN0ZW5lciBhbHJlYWR5IGNsb3NlZCB0aGUgc29ja2V0XG4gIGlmICgnb3BlbicgPT09IHRoaXMucmVhZHlTdGF0ZSAmJiB0aGlzLnVwZ3JhZGUgJiYgdGhpcy50cmFuc3BvcnQucGF1c2UpIHtcblxuICAgIGZvciAodmFyIGkgPSAwLCBsID0gdGhpcy51cGdyYWRlcy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgIHRoaXMucHJvYmUodGhpcy51cGdyYWRlc1tpXSk7XG4gICAgfVxuICB9XG59O1xuXG4vKipcbiAqIEhhbmRsZXMgYSBwYWNrZXQuXG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuU29ja2V0LnByb3RvdHlwZS5vblBhY2tldCA9IGZ1bmN0aW9uIChwYWNrZXQpIHtcbiAgaWYgKCdvcGVuaW5nJyA9PT0gdGhpcy5yZWFkeVN0YXRlIHx8ICdvcGVuJyA9PT0gdGhpcy5yZWFkeVN0YXRlIHx8XG4gICAgICAnY2xvc2luZycgPT09IHRoaXMucmVhZHlTdGF0ZSkge1xuXG5cbiAgICB0aGlzLmVtaXQoJ3BhY2tldCcsIHBhY2tldCk7XG5cbiAgICAvLyBTb2NrZXQgaXMgbGl2ZSAtIGFueSBwYWNrZXQgY291bnRzXG4gICAgdGhpcy5lbWl0KCdoZWFydGJlYXQnKTtcblxuICAgIHN3aXRjaCAocGFja2V0LnR5cGUpIHtcbiAgICAgIGNhc2UgJ29wZW4nOlxuICAgICAgICB0aGlzLm9uSGFuZHNoYWtlKHBhcnNlanNvbihwYWNrZXQuZGF0YSkpO1xuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSAncG9uZyc6XG4gICAgICAgIHRoaXMuc2V0UGluZygpO1xuICAgICAgICB0aGlzLmVtaXQoJ3BvbmcnKTtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgJ2Vycm9yJzpcbiAgICAgICAgdmFyIGVyciA9IG5ldyBFcnJvcignc2VydmVyIGVycm9yJyk7XG4gICAgICAgIGVyci5jb2RlID0gcGFja2V0LmRhdGE7XG4gICAgICAgIHRoaXMub25FcnJvcihlcnIpO1xuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSAnbWVzc2FnZSc6XG4gICAgICAgIHRoaXMuZW1pdCgnZGF0YScsIHBhY2tldC5kYXRhKTtcbiAgICAgICAgdGhpcy5lbWl0KCdtZXNzYWdlJywgcGFja2V0LmRhdGEpO1xuICAgICAgICBicmVhaztcbiAgICB9XG4gIH0gZWxzZSB7XG5cbiAgfVxufTtcblxuLyoqXG4gKiBDYWxsZWQgdXBvbiBoYW5kc2hha2UgY29tcGxldGlvbi5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gaGFuZHNoYWtlIG9ialxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuU29ja2V0LnByb3RvdHlwZS5vbkhhbmRzaGFrZSA9IGZ1bmN0aW9uIChkYXRhKSB7XG4gIHRoaXMuZW1pdCgnaGFuZHNoYWtlJywgZGF0YSk7XG4gIHRoaXMuaWQgPSBkYXRhLnNpZDtcbiAgdGhpcy50cmFuc3BvcnQucXVlcnkuc2lkID0gZGF0YS5zaWQ7XG4gIHRoaXMudXBncmFkZXMgPSB0aGlzLmZpbHRlclVwZ3JhZGVzKGRhdGEudXBncmFkZXMpO1xuICB0aGlzLnBpbmdJbnRlcnZhbCA9IGRhdGEucGluZ0ludGVydmFsO1xuICB0aGlzLnBpbmdUaW1lb3V0ID0gZGF0YS5waW5nVGltZW91dDtcbiAgdGhpcy5vbk9wZW4oKTtcbiAgLy8gSW4gY2FzZSBvcGVuIGhhbmRsZXIgY2xvc2VzIHNvY2tldFxuICBpZiAoJ2Nsb3NlZCcgPT09IHRoaXMucmVhZHlTdGF0ZSkgcmV0dXJuO1xuICB0aGlzLnNldFBpbmcoKTtcblxuICAvLyBQcm9sb25nIGxpdmVuZXNzIG9mIHNvY2tldCBvbiBoZWFydGJlYXRcbiAgdGhpcy5yZW1vdmVMaXN0ZW5lcignaGVhcnRiZWF0JywgdGhpcy5vbkhlYXJ0YmVhdCk7XG4gIHRoaXMub24oJ2hlYXJ0YmVhdCcsIHRoaXMub25IZWFydGJlYXQpO1xufTtcblxuLyoqXG4gKiBSZXNldHMgcGluZyB0aW1lb3V0LlxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblNvY2tldC5wcm90b3R5cGUub25IZWFydGJlYXQgPSBmdW5jdGlvbiAodGltZW91dCkge1xuICBjbGVhclRpbWVvdXQodGhpcy5waW5nVGltZW91dFRpbWVyKTtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICBzZWxmLnBpbmdUaW1lb3V0VGltZXIgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoJ2Nsb3NlZCcgPT09IHNlbGYucmVhZHlTdGF0ZSkgcmV0dXJuO1xuICAgIHNlbGYub25DbG9zZSgncGluZyB0aW1lb3V0Jyk7XG4gIH0sIHRpbWVvdXQgfHwgKHNlbGYucGluZ0ludGVydmFsICsgc2VsZi5waW5nVGltZW91dCkpO1xufTtcblxuLyoqXG4gKiBQaW5ncyBzZXJ2ZXIgZXZlcnkgYHRoaXMucGluZ0ludGVydmFsYCBhbmQgZXhwZWN0cyByZXNwb25zZVxuICogd2l0aGluIGB0aGlzLnBpbmdUaW1lb3V0YCBvciBjbG9zZXMgY29ubmVjdGlvbi5cbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5Tb2NrZXQucHJvdG90eXBlLnNldFBpbmcgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBzZWxmID0gdGhpcztcbiAgY2xlYXJUaW1lb3V0KHNlbGYucGluZ0ludGVydmFsVGltZXIpO1xuICBzZWxmLnBpbmdJbnRlcnZhbFRpbWVyID0gc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG5cbiAgICBzZWxmLnBpbmcoKTtcbiAgICBzZWxmLm9uSGVhcnRiZWF0KHNlbGYucGluZ1RpbWVvdXQpO1xuICB9LCBzZWxmLnBpbmdJbnRlcnZhbCk7XG59O1xuXG4vKipcbiogU2VuZHMgYSBwaW5nIHBhY2tldC5cbipcbiogQGFwaSBwcml2YXRlXG4qL1xuXG5Tb2NrZXQucHJvdG90eXBlLnBpbmcgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBzZWxmID0gdGhpcztcbiAgdGhpcy5zZW5kUGFja2V0KCdwaW5nJywgZnVuY3Rpb24gKCkge1xuICAgIHNlbGYuZW1pdCgncGluZycpO1xuICB9KTtcbn07XG5cbi8qKlxuICogQ2FsbGVkIG9uIGBkcmFpbmAgZXZlbnRcbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5Tb2NrZXQucHJvdG90eXBlLm9uRHJhaW4gPSBmdW5jdGlvbiAoKSB7XG4gIHRoaXMud3JpdGVCdWZmZXIuc3BsaWNlKDAsIHRoaXMucHJldkJ1ZmZlckxlbik7XG5cbiAgLy8gc2V0dGluZyBwcmV2QnVmZmVyTGVuID0gMCBpcyB2ZXJ5IGltcG9ydGFudFxuICAvLyBmb3IgZXhhbXBsZSwgd2hlbiB1cGdyYWRpbmcsIHVwZ3JhZGUgcGFja2V0IGlzIHNlbnQgb3ZlcixcbiAgLy8gYW5kIGEgbm9uemVybyBwcmV2QnVmZmVyTGVuIGNvdWxkIGNhdXNlIHByb2JsZW1zIG9uIGBkcmFpbmBcbiAgdGhpcy5wcmV2QnVmZmVyTGVuID0gMDtcblxuICBpZiAoMCA9PT0gdGhpcy53cml0ZUJ1ZmZlci5sZW5ndGgpIHtcbiAgICB0aGlzLmVtaXQoJ2RyYWluJyk7XG4gIH0gZWxzZSB7XG4gICAgdGhpcy5mbHVzaCgpO1xuICB9XG59O1xuXG4vKipcbiAqIEZsdXNoIHdyaXRlIGJ1ZmZlcnMuXG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuU29ja2V0LnByb3RvdHlwZS5mbHVzaCA9IGZ1bmN0aW9uICgpIHtcbiAgaWYgKCdjbG9zZWQnICE9PSB0aGlzLnJlYWR5U3RhdGUgJiYgdGhpcy50cmFuc3BvcnQud3JpdGFibGUgJiZcbiAgICAhdGhpcy51cGdyYWRpbmcgJiYgdGhpcy53cml0ZUJ1ZmZlci5sZW5ndGgpIHtcblxuICAgIHRoaXMudHJhbnNwb3J0LnNlbmQodGhpcy53cml0ZUJ1ZmZlcik7XG4gICAgLy8ga2VlcCB0cmFjayBvZiBjdXJyZW50IGxlbmd0aCBvZiB3cml0ZUJ1ZmZlclxuICAgIC8vIHNwbGljZSB3cml0ZUJ1ZmZlciBhbmQgY2FsbGJhY2tCdWZmZXIgb24gYGRyYWluYFxuICAgIHRoaXMucHJldkJ1ZmZlckxlbiA9IHRoaXMud3JpdGVCdWZmZXIubGVuZ3RoO1xuICAgIHRoaXMuZW1pdCgnZmx1c2gnKTtcbiAgfVxufTtcblxuLyoqXG4gKiBTZW5kcyBhIG1lc3NhZ2UuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IG1lc3NhZ2UuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFjayBmdW5jdGlvbi5cbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zLlxuICogQHJldHVybiB7U29ja2V0fSBmb3IgY2hhaW5pbmcuXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cblNvY2tldC5wcm90b3R5cGUud3JpdGUgPVxuU29ja2V0LnByb3RvdHlwZS5zZW5kID0gZnVuY3Rpb24gKG1zZywgb3B0aW9ucywgZm4pIHtcbiAgdGhpcy5zZW5kUGFja2V0KCdtZXNzYWdlJywgbXNnLCBvcHRpb25zLCBmbik7XG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBTZW5kcyBhIHBhY2tldC5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gcGFja2V0IHR5cGUuXG4gKiBAcGFyYW0ge1N0cmluZ30gZGF0YS5cbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2sgZnVuY3Rpb24uXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5Tb2NrZXQucHJvdG90eXBlLnNlbmRQYWNrZXQgPSBmdW5jdGlvbiAodHlwZSwgZGF0YSwgb3B0aW9ucywgZm4pIHtcbiAgaWYgKCdmdW5jdGlvbicgPT09IHR5cGVvZiBkYXRhKSB7XG4gICAgZm4gPSBkYXRhO1xuICAgIGRhdGEgPSB1bmRlZmluZWQ7XG4gIH1cblxuICBpZiAoJ2Z1bmN0aW9uJyA9PT0gdHlwZW9mIG9wdGlvbnMpIHtcbiAgICBmbiA9IG9wdGlvbnM7XG4gICAgb3B0aW9ucyA9IG51bGw7XG4gIH1cblxuICBpZiAoJ2Nsb3NpbmcnID09PSB0aGlzLnJlYWR5U3RhdGUgfHwgJ2Nsb3NlZCcgPT09IHRoaXMucmVhZHlTdGF0ZSkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICBvcHRpb25zLmNvbXByZXNzID0gZmFsc2UgIT09IG9wdGlvbnMuY29tcHJlc3M7XG5cbiAgdmFyIHBhY2tldCA9IHtcbiAgICB0eXBlOiB0eXBlLFxuICAgIGRhdGE6IGRhdGEsXG4gICAgb3B0aW9uczogb3B0aW9uc1xuICB9O1xuICB0aGlzLmVtaXQoJ3BhY2tldENyZWF0ZScsIHBhY2tldCk7XG4gIHRoaXMud3JpdGVCdWZmZXIucHVzaChwYWNrZXQpO1xuICBpZiAoZm4pIHRoaXMub25jZSgnZmx1c2gnLCBmbik7XG4gIHRoaXMuZmx1c2goKTtcbn07XG5cbi8qKlxuICogQ2xvc2VzIHRoZSBjb25uZWN0aW9uLlxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblNvY2tldC5wcm90b3R5cGUuY2xvc2UgPSBmdW5jdGlvbiAoKSB7XG4gIGlmICgnb3BlbmluZycgPT09IHRoaXMucmVhZHlTdGF0ZSB8fCAnb3BlbicgPT09IHRoaXMucmVhZHlTdGF0ZSkge1xuICAgIHRoaXMucmVhZHlTdGF0ZSA9ICdjbG9zaW5nJztcblxuICAgIHZhciBzZWxmID0gdGhpcztcblxuICAgIGlmICh0aGlzLndyaXRlQnVmZmVyLmxlbmd0aCkge1xuICAgICAgdGhpcy5vbmNlKCdkcmFpbicsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMudXBncmFkaW5nKSB7XG4gICAgICAgICAgd2FpdEZvclVwZ3JhZGUoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjbG9zZSgpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9IGVsc2UgaWYgKHRoaXMudXBncmFkaW5nKSB7XG4gICAgICB3YWl0Rm9yVXBncmFkZSgpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjbG9zZSgpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGNsb3NlICgpIHtcbiAgICBzZWxmLm9uQ2xvc2UoJ2ZvcmNlZCBjbG9zZScpO1xuXG4gICAgc2VsZi50cmFuc3BvcnQuY2xvc2UoKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNsZWFudXBBbmRDbG9zZSAoKSB7XG4gICAgc2VsZi5yZW1vdmVMaXN0ZW5lcigndXBncmFkZScsIGNsZWFudXBBbmRDbG9zZSk7XG4gICAgc2VsZi5yZW1vdmVMaXN0ZW5lcigndXBncmFkZUVycm9yJywgY2xlYW51cEFuZENsb3NlKTtcbiAgICBjbG9zZSgpO1xuICB9XG5cbiAgZnVuY3Rpb24gd2FpdEZvclVwZ3JhZGUgKCkge1xuICAgIC8vIHdhaXQgZm9yIHVwZ3JhZGUgdG8gZmluaXNoIHNpbmNlIHdlIGNhbid0IHNlbmQgcGFja2V0cyB3aGlsZSBwYXVzaW5nIGEgdHJhbnNwb3J0XG4gICAgc2VsZi5vbmNlKCd1cGdyYWRlJywgY2xlYW51cEFuZENsb3NlKTtcbiAgICBzZWxmLm9uY2UoJ3VwZ3JhZGVFcnJvcicsIGNsZWFudXBBbmRDbG9zZSk7XG4gIH1cblxuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogQ2FsbGVkIHVwb24gdHJhbnNwb3J0IGVycm9yXG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuU29ja2V0LnByb3RvdHlwZS5vbkVycm9yID0gZnVuY3Rpb24gKGVycikge1xuXG4gIFNvY2tldC5wcmlvcldlYnNvY2tldFN1Y2Nlc3MgPSBmYWxzZTtcbiAgdGhpcy5lbWl0KCdlcnJvcicsIGVycik7XG4gIHRoaXMub25DbG9zZSgndHJhbnNwb3J0IGVycm9yJywgZXJyKTtcbn07XG5cbi8qKlxuICogQ2FsbGVkIHVwb24gdHJhbnNwb3J0IGNsb3NlLlxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblNvY2tldC5wcm90b3R5cGUub25DbG9zZSA9IGZ1bmN0aW9uIChyZWFzb24sIGRlc2MpIHtcbiAgaWYgKCdvcGVuaW5nJyA9PT0gdGhpcy5yZWFkeVN0YXRlIHx8ICdvcGVuJyA9PT0gdGhpcy5yZWFkeVN0YXRlIHx8ICdjbG9zaW5nJyA9PT0gdGhpcy5yZWFkeVN0YXRlKSB7XG5cbiAgICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgICAvLyBjbGVhciB0aW1lcnNcbiAgICBjbGVhclRpbWVvdXQodGhpcy5waW5nSW50ZXJ2YWxUaW1lcik7XG4gICAgY2xlYXJUaW1lb3V0KHRoaXMucGluZ1RpbWVvdXRUaW1lcik7XG5cbiAgICAvLyBzdG9wIGV2ZW50IGZyb20gZmlyaW5nIGFnYWluIGZvciB0cmFuc3BvcnRcbiAgICB0aGlzLnRyYW5zcG9ydC5yZW1vdmVBbGxMaXN0ZW5lcnMoJ2Nsb3NlJyk7XG5cbiAgICAvLyBlbnN1cmUgdHJhbnNwb3J0IHdvbid0IHN0YXkgb3BlblxuICAgIHRoaXMudHJhbnNwb3J0LmNsb3NlKCk7XG5cbiAgICAvLyBpZ25vcmUgZnVydGhlciB0cmFuc3BvcnQgY29tbXVuaWNhdGlvblxuICAgIHRoaXMudHJhbnNwb3J0LnJlbW92ZUFsbExpc3RlbmVycygpO1xuXG4gICAgLy8gc2V0IHJlYWR5IHN0YXRlXG4gICAgdGhpcy5yZWFkeVN0YXRlID0gJ2Nsb3NlZCc7XG5cbiAgICAvLyBjbGVhciBzZXNzaW9uIGlkXG4gICAgdGhpcy5pZCA9IG51bGw7XG5cbiAgICAvLyBlbWl0IGNsb3NlIGV2ZW50XG4gICAgdGhpcy5lbWl0KCdjbG9zZScsIHJlYXNvbiwgZGVzYyk7XG5cbiAgICAvLyBjbGVhbiBidWZmZXJzIGFmdGVyLCBzbyB1c2VycyBjYW4gc3RpbGxcbiAgICAvLyBncmFiIHRoZSBidWZmZXJzIG9uIGBjbG9zZWAgZXZlbnRcbiAgICBzZWxmLndyaXRlQnVmZmVyID0gW107XG4gICAgc2VsZi5wcmV2QnVmZmVyTGVuID0gMDtcbiAgfVxufTtcblxuLyoqXG4gKiBGaWx0ZXJzIHVwZ3JhZGVzLCByZXR1cm5pbmcgb25seSB0aG9zZSBtYXRjaGluZyBjbGllbnQgdHJhbnNwb3J0cy5cbiAqXG4gKiBAcGFyYW0ge0FycmF5fSBzZXJ2ZXIgdXBncmFkZXNcbiAqIEBhcGkgcHJpdmF0ZVxuICpcbiAqL1xuXG5Tb2NrZXQucHJvdG90eXBlLmZpbHRlclVwZ3JhZGVzID0gZnVuY3Rpb24gKHVwZ3JhZGVzKSB7XG4gIHZhciBmaWx0ZXJlZFVwZ3JhZGVzID0gW107XG4gIGZvciAodmFyIGkgPSAwLCBqID0gdXBncmFkZXMubGVuZ3RoOyBpIDwgajsgaSsrKSB7XG4gICAgaWYgKH5pbmRleCh0aGlzLnRyYW5zcG9ydHMsIHVwZ3JhZGVzW2ldKSkgZmlsdGVyZWRVcGdyYWRlcy5wdXNoKHVwZ3JhZGVzW2ldKTtcbiAgfVxuICByZXR1cm4gZmlsdGVyZWRVcGdyYWRlcztcbn07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vZW5naW5lLmlvLWNsaWVudC9saWIvc29ja2V0LmpzXG4vLyBtb2R1bGUgaWQgPSAxM1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKipcbiAqIE1vZHVsZSBkZXBlbmRlbmNpZXNcbiAqL1xuXG52YXIgWE1MSHR0cFJlcXVlc3QgPSByZXF1aXJlKCd4bWxodHRwcmVxdWVzdC1zc2wnKTtcbnZhciBYSFIgPSByZXF1aXJlKCcuL3BvbGxpbmcteGhyJyk7XG52YXIgSlNPTlAgPSByZXF1aXJlKCcuL3BvbGxpbmctanNvbnAnKTtcbnZhciB3ZWJzb2NrZXQgPSByZXF1aXJlKCcuL3dlYnNvY2tldCcpO1xuXG4vKipcbiAqIEV4cG9ydCB0cmFuc3BvcnRzLlxuICovXG5cbmV4cG9ydHMucG9sbGluZyA9IHBvbGxpbmc7XG5leHBvcnRzLndlYnNvY2tldCA9IHdlYnNvY2tldDtcblxuLyoqXG4gKiBQb2xsaW5nIHRyYW5zcG9ydCBwb2x5bW9ycGhpYyBjb25zdHJ1Y3Rvci5cbiAqIERlY2lkZXMgb24geGhyIHZzIGpzb25wIGJhc2VkIG9uIGZlYXR1cmUgZGV0ZWN0aW9uLlxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIHBvbGxpbmcgKG9wdHMpIHtcbiAgdmFyIHhocjtcbiAgdmFyIHhkID0gZmFsc2U7XG4gIHZhciB4cyA9IGZhbHNlO1xuICB2YXIganNvbnAgPSBmYWxzZSAhPT0gb3B0cy5qc29ucDtcblxuICBpZiAoZ2xvYmFsLmxvY2F0aW9uKSB7XG4gICAgdmFyIGlzU1NMID0gJ2h0dHBzOicgPT09IGxvY2F0aW9uLnByb3RvY29sO1xuICAgIHZhciBwb3J0ID0gbG9jYXRpb24ucG9ydDtcblxuICAgIC8vIHNvbWUgdXNlciBhZ2VudHMgaGF2ZSBlbXB0eSBgbG9jYXRpb24ucG9ydGBcbiAgICBpZiAoIXBvcnQpIHtcbiAgICAgIHBvcnQgPSBpc1NTTCA/IDQ0MyA6IDgwO1xuICAgIH1cblxuICAgIHhkID0gb3B0cy5ob3N0bmFtZSAhPT0gbG9jYXRpb24uaG9zdG5hbWUgfHwgcG9ydCAhPT0gb3B0cy5wb3J0O1xuICAgIHhzID0gb3B0cy5zZWN1cmUgIT09IGlzU1NMO1xuICB9XG5cbiAgb3B0cy54ZG9tYWluID0geGQ7XG4gIG9wdHMueHNjaGVtZSA9IHhzO1xuICB4aHIgPSBuZXcgWE1MSHR0cFJlcXVlc3Qob3B0cyk7XG5cbiAgaWYgKCdvcGVuJyBpbiB4aHIgJiYgIW9wdHMuZm9yY2VKU09OUCkge1xuICAgIHJldHVybiBuZXcgWEhSKG9wdHMpO1xuICB9IGVsc2Uge1xuICAgIGlmICghanNvbnApIHRocm93IG5ldyBFcnJvcignSlNPTlAgZGlzYWJsZWQnKTtcbiAgICByZXR1cm4gbmV3IEpTT05QKG9wdHMpO1xuICB9XG59XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vZW5naW5lLmlvLWNsaWVudC9saWIvdHJhbnNwb3J0cy9pbmRleC5qc1xuLy8gbW9kdWxlIGlkID0gMTRcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLy8gYnJvd3NlciBzaGltIGZvciB4bWxodHRwcmVxdWVzdCBtb2R1bGVcblxudmFyIGhhc0NPUlMgPSByZXF1aXJlKCdoYXMtY29ycycpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChvcHRzKSB7XG4gIHZhciB4ZG9tYWluID0gb3B0cy54ZG9tYWluO1xuXG4gIC8vIHNjaGVtZSBtdXN0IGJlIHNhbWUgd2hlbiB1c2lnbiBYRG9tYWluUmVxdWVzdFxuICAvLyBodHRwOi8vYmxvZ3MubXNkbi5jb20vYi9pZWludGVybmFscy9hcmNoaXZlLzIwMTAvMDUvMTMveGRvbWFpbnJlcXVlc3QtcmVzdHJpY3Rpb25zLWxpbWl0YXRpb25zLWFuZC13b3JrYXJvdW5kcy5hc3B4XG4gIHZhciB4c2NoZW1lID0gb3B0cy54c2NoZW1lO1xuXG4gIC8vIFhEb21haW5SZXF1ZXN0IGhhcyBhIGZsb3cgb2Ygbm90IHNlbmRpbmcgY29va2llLCB0aGVyZWZvcmUgaXQgc2hvdWxkIGJlIGRpc2FibGVkIGFzIGEgZGVmYXVsdC5cbiAgLy8gaHR0cHM6Ly9naXRodWIuY29tL0F1dG9tYXR0aWMvZW5naW5lLmlvLWNsaWVudC9wdWxsLzIxN1xuICB2YXIgZW5hYmxlc1hEUiA9IG9wdHMuZW5hYmxlc1hEUjtcblxuICAvLyBYTUxIdHRwUmVxdWVzdCBjYW4gYmUgZGlzYWJsZWQgb24gSUVcbiAgdHJ5IHtcbiAgICBpZiAoJ3VuZGVmaW5lZCcgIT09IHR5cGVvZiBYTUxIdHRwUmVxdWVzdCAmJiAoIXhkb21haW4gfHwgaGFzQ09SUykpIHtcbiAgICAgIHJldHVybiBuZXcgWE1MSHR0cFJlcXVlc3QoKTtcbiAgICB9XG4gIH0gY2F0Y2ggKGUpIHsgfVxuXG4gIC8vIFVzZSBYRG9tYWluUmVxdWVzdCBmb3IgSUU4IGlmIGVuYWJsZXNYRFIgaXMgdHJ1ZVxuICAvLyBiZWNhdXNlIGxvYWRpbmcgYmFyIGtlZXBzIGZsYXNoaW5nIHdoZW4gdXNpbmcganNvbnAtcG9sbGluZ1xuICAvLyBodHRwczovL2dpdGh1Yi5jb20veXVqaW9zYWthL3NvY2tlLmlvLWllOC1sb2FkaW5nLWV4YW1wbGVcbiAgdHJ5IHtcbiAgICBpZiAoJ3VuZGVmaW5lZCcgIT09IHR5cGVvZiBYRG9tYWluUmVxdWVzdCAmJiAheHNjaGVtZSAmJiBlbmFibGVzWERSKSB7XG4gICAgICByZXR1cm4gbmV3IFhEb21haW5SZXF1ZXN0KCk7XG4gICAgfVxuICB9IGNhdGNoIChlKSB7IH1cblxuICBpZiAoIXhkb21haW4pIHtcbiAgICB0cnkge1xuICAgICAgcmV0dXJuIG5ldyBnbG9iYWxbWydBY3RpdmUnXS5jb25jYXQoJ09iamVjdCcpLmpvaW4oJ1gnKV0oJ01pY3Jvc29mdC5YTUxIVFRQJyk7XG4gICAgfSBjYXRjaCAoZSkgeyB9XG4gIH1cbn07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vZW5naW5lLmlvLWNsaWVudC9saWIveG1saHR0cHJlcXVlc3QuanNcbi8vIG1vZHVsZSBpZCA9IDE1XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIlxuLyoqXG4gKiBNb2R1bGUgZXhwb3J0cy5cbiAqXG4gKiBMb2dpYyBib3Jyb3dlZCBmcm9tIE1vZGVybml6cjpcbiAqXG4gKiAgIC0gaHR0cHM6Ly9naXRodWIuY29tL01vZGVybml6ci9Nb2Rlcm5penIvYmxvYi9tYXN0ZXIvZmVhdHVyZS1kZXRlY3RzL2NvcnMuanNcbiAqL1xuXG50cnkge1xuICBtb2R1bGUuZXhwb3J0cyA9IHR5cGVvZiBYTUxIdHRwUmVxdWVzdCAhPT0gJ3VuZGVmaW5lZCcgJiZcbiAgICAnd2l0aENyZWRlbnRpYWxzJyBpbiBuZXcgWE1MSHR0cFJlcXVlc3QoKTtcbn0gY2F0Y2ggKGVycikge1xuICAvLyBpZiBYTUxIdHRwIHN1cHBvcnQgaXMgZGlzYWJsZWQgaW4gSUUgdGhlbiBpdCB3aWxsIHRocm93XG4gIC8vIHdoZW4gdHJ5aW5nIHRvIGNyZWF0ZVxuICBtb2R1bGUuZXhwb3J0cyA9IGZhbHNlO1xufVxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2hhcy1jb3JzL2luZGV4LmpzXG4vLyBtb2R1bGUgaWQgPSAxNlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKipcbiAqIE1vZHVsZSByZXF1aXJlbWVudHMuXG4gKi9cblxudmFyIFhNTEh0dHBSZXF1ZXN0ID0gcmVxdWlyZSgneG1saHR0cHJlcXVlc3Qtc3NsJyk7XG52YXIgUG9sbGluZyA9IHJlcXVpcmUoJy4vcG9sbGluZycpO1xudmFyIEVtaXR0ZXIgPSByZXF1aXJlKCdjb21wb25lbnQtZW1pdHRlcicpO1xudmFyIGluaGVyaXQgPSByZXF1aXJlKCdjb21wb25lbnQtaW5oZXJpdCcpO1xudmFyIGRlYnVnID0gcmVxdWlyZSgnZGVidWcnKSgnZW5naW5lLmlvLWNsaWVudDpwb2xsaW5nLXhocicpO1xuXG4vKipcbiAqIE1vZHVsZSBleHBvcnRzLlxuICovXG5cbm1vZHVsZS5leHBvcnRzID0gWEhSO1xubW9kdWxlLmV4cG9ydHMuUmVxdWVzdCA9IFJlcXVlc3Q7XG5cbi8qKlxuICogRW1wdHkgZnVuY3Rpb25cbiAqL1xuXG5mdW5jdGlvbiBlbXB0eSAoKSB7fVxuXG4vKipcbiAqIFhIUiBQb2xsaW5nIGNvbnN0cnVjdG9yLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRzXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmZ1bmN0aW9uIFhIUiAob3B0cykge1xuICBQb2xsaW5nLmNhbGwodGhpcywgb3B0cyk7XG4gIHRoaXMucmVxdWVzdFRpbWVvdXQgPSBvcHRzLnJlcXVlc3RUaW1lb3V0O1xuICB0aGlzLmV4dHJhSGVhZGVycyA9IG9wdHMuZXh0cmFIZWFkZXJzO1xuXG4gIGlmIChnbG9iYWwubG9jYXRpb24pIHtcbiAgICB2YXIgaXNTU0wgPSAnaHR0cHM6JyA9PT0gbG9jYXRpb24ucHJvdG9jb2w7XG4gICAgdmFyIHBvcnQgPSBsb2NhdGlvbi5wb3J0O1xuXG4gICAgLy8gc29tZSB1c2VyIGFnZW50cyBoYXZlIGVtcHR5IGBsb2NhdGlvbi5wb3J0YFxuICAgIGlmICghcG9ydCkge1xuICAgICAgcG9ydCA9IGlzU1NMID8gNDQzIDogODA7XG4gICAgfVxuXG4gICAgdGhpcy54ZCA9IG9wdHMuaG9zdG5hbWUgIT09IGdsb2JhbC5sb2NhdGlvbi5ob3N0bmFtZSB8fFxuICAgICAgcG9ydCAhPT0gb3B0cy5wb3J0O1xuICAgIHRoaXMueHMgPSBvcHRzLnNlY3VyZSAhPT0gaXNTU0w7XG4gIH1cbn1cblxuLyoqXG4gKiBJbmhlcml0cyBmcm9tIFBvbGxpbmcuXG4gKi9cblxuaW5oZXJpdChYSFIsIFBvbGxpbmcpO1xuXG4vKipcbiAqIFhIUiBzdXBwb3J0cyBiaW5hcnlcbiAqL1xuXG5YSFIucHJvdG90eXBlLnN1cHBvcnRzQmluYXJ5ID0gdHJ1ZTtcblxuLyoqXG4gKiBDcmVhdGVzIGEgcmVxdWVzdC5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gbWV0aG9kXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5YSFIucHJvdG90eXBlLnJlcXVlc3QgPSBmdW5jdGlvbiAob3B0cykge1xuICBvcHRzID0gb3B0cyB8fCB7fTtcbiAgb3B0cy51cmkgPSB0aGlzLnVyaSgpO1xuICBvcHRzLnhkID0gdGhpcy54ZDtcbiAgb3B0cy54cyA9IHRoaXMueHM7XG4gIG9wdHMuYWdlbnQgPSB0aGlzLmFnZW50IHx8IGZhbHNlO1xuICBvcHRzLnN1cHBvcnRzQmluYXJ5ID0gdGhpcy5zdXBwb3J0c0JpbmFyeTtcbiAgb3B0cy5lbmFibGVzWERSID0gdGhpcy5lbmFibGVzWERSO1xuXG4gIC8vIFNTTCBvcHRpb25zIGZvciBOb2RlLmpzIGNsaWVudFxuICBvcHRzLnBmeCA9IHRoaXMucGZ4O1xuICBvcHRzLmtleSA9IHRoaXMua2V5O1xuICBvcHRzLnBhc3NwaHJhc2UgPSB0aGlzLnBhc3NwaHJhc2U7XG4gIG9wdHMuY2VydCA9IHRoaXMuY2VydDtcbiAgb3B0cy5jYSA9IHRoaXMuY2E7XG4gIG9wdHMuY2lwaGVycyA9IHRoaXMuY2lwaGVycztcbiAgb3B0cy5yZWplY3RVbmF1dGhvcml6ZWQgPSB0aGlzLnJlamVjdFVuYXV0aG9yaXplZDtcbiAgb3B0cy5yZXF1ZXN0VGltZW91dCA9IHRoaXMucmVxdWVzdFRpbWVvdXQ7XG5cbiAgLy8gb3RoZXIgb3B0aW9ucyBmb3IgTm9kZS5qcyBjbGllbnRcbiAgb3B0cy5leHRyYUhlYWRlcnMgPSB0aGlzLmV4dHJhSGVhZGVycztcblxuICByZXR1cm4gbmV3IFJlcXVlc3Qob3B0cyk7XG59O1xuXG4vKipcbiAqIFNlbmRzIGRhdGEuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IGRhdGEgdG8gc2VuZC5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxlZCB1cG9uIGZsdXNoLlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuWEhSLnByb3RvdHlwZS5kb1dyaXRlID0gZnVuY3Rpb24gKGRhdGEsIGZuKSB7XG4gIHZhciBpc0JpbmFyeSA9IHR5cGVvZiBkYXRhICE9PSAnc3RyaW5nJyAmJiBkYXRhICE9PSB1bmRlZmluZWQ7XG4gIHZhciByZXEgPSB0aGlzLnJlcXVlc3QoeyBtZXRob2Q6ICdQT1NUJywgZGF0YTogZGF0YSwgaXNCaW5hcnk6IGlzQmluYXJ5IH0pO1xuICB2YXIgc2VsZiA9IHRoaXM7XG4gIHJlcS5vbignc3VjY2VzcycsIGZuKTtcbiAgcmVxLm9uKCdlcnJvcicsIGZ1bmN0aW9uIChlcnIpIHtcbiAgICBzZWxmLm9uRXJyb3IoJ3hociBwb3N0IGVycm9yJywgZXJyKTtcbiAgfSk7XG4gIHRoaXMuc2VuZFhociA9IHJlcTtcbn07XG5cbi8qKlxuICogU3RhcnRzIGEgcG9sbCBjeWNsZS5cbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5YSFIucHJvdG90eXBlLmRvUG9sbCA9IGZ1bmN0aW9uICgpIHtcblxuICB2YXIgcmVxID0gdGhpcy5yZXF1ZXN0KCk7XG4gIHZhciBzZWxmID0gdGhpcztcbiAgcmVxLm9uKCdkYXRhJywgZnVuY3Rpb24gKGRhdGEpIHtcbiAgICBzZWxmLm9uRGF0YShkYXRhKTtcbiAgfSk7XG4gIHJlcS5vbignZXJyb3InLCBmdW5jdGlvbiAoZXJyKSB7XG4gICAgc2VsZi5vbkVycm9yKCd4aHIgcG9sbCBlcnJvcicsIGVycik7XG4gIH0pO1xuICB0aGlzLnBvbGxYaHIgPSByZXE7XG59O1xuXG4vKipcbiAqIFJlcXVlc3QgY29uc3RydWN0b3JcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5mdW5jdGlvbiBSZXF1ZXN0IChvcHRzKSB7XG4gIHRoaXMubWV0aG9kID0gb3B0cy5tZXRob2QgfHwgJ0dFVCc7XG4gIHRoaXMudXJpID0gb3B0cy51cmk7XG4gIHRoaXMueGQgPSAhIW9wdHMueGQ7XG4gIHRoaXMueHMgPSAhIW9wdHMueHM7XG4gIHRoaXMuYXN5bmMgPSBmYWxzZSAhPT0gb3B0cy5hc3luYztcbiAgdGhpcy5kYXRhID0gdW5kZWZpbmVkICE9PSBvcHRzLmRhdGEgPyBvcHRzLmRhdGEgOiBudWxsO1xuICB0aGlzLmFnZW50ID0gb3B0cy5hZ2VudDtcbiAgdGhpcy5pc0JpbmFyeSA9IG9wdHMuaXNCaW5hcnk7XG4gIHRoaXMuc3VwcG9ydHNCaW5hcnkgPSBvcHRzLnN1cHBvcnRzQmluYXJ5O1xuICB0aGlzLmVuYWJsZXNYRFIgPSBvcHRzLmVuYWJsZXNYRFI7XG4gIHRoaXMucmVxdWVzdFRpbWVvdXQgPSBvcHRzLnJlcXVlc3RUaW1lb3V0O1xuXG4gIC8vIFNTTCBvcHRpb25zIGZvciBOb2RlLmpzIGNsaWVudFxuICB0aGlzLnBmeCA9IG9wdHMucGZ4O1xuICB0aGlzLmtleSA9IG9wdHMua2V5O1xuICB0aGlzLnBhc3NwaHJhc2UgPSBvcHRzLnBhc3NwaHJhc2U7XG4gIHRoaXMuY2VydCA9IG9wdHMuY2VydDtcbiAgdGhpcy5jYSA9IG9wdHMuY2E7XG4gIHRoaXMuY2lwaGVycyA9IG9wdHMuY2lwaGVycztcbiAgdGhpcy5yZWplY3RVbmF1dGhvcml6ZWQgPSBvcHRzLnJlamVjdFVuYXV0aG9yaXplZDtcblxuICAvLyBvdGhlciBvcHRpb25zIGZvciBOb2RlLmpzIGNsaWVudFxuICB0aGlzLmV4dHJhSGVhZGVycyA9IG9wdHMuZXh0cmFIZWFkZXJzO1xuXG4gIHRoaXMuY3JlYXRlKCk7XG59XG5cbi8qKlxuICogTWl4IGluIGBFbWl0dGVyYC5cbiAqL1xuXG5FbWl0dGVyKFJlcXVlc3QucHJvdG90eXBlKTtcblxuLyoqXG4gKiBDcmVhdGVzIHRoZSBYSFIgb2JqZWN0IGFuZCBzZW5kcyB0aGUgcmVxdWVzdC5cbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5SZXF1ZXN0LnByb3RvdHlwZS5jcmVhdGUgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBvcHRzID0geyBhZ2VudDogdGhpcy5hZ2VudCwgeGRvbWFpbjogdGhpcy54ZCwgeHNjaGVtZTogdGhpcy54cywgZW5hYmxlc1hEUjogdGhpcy5lbmFibGVzWERSIH07XG5cbiAgLy8gU1NMIG9wdGlvbnMgZm9yIE5vZGUuanMgY2xpZW50XG4gIG9wdHMucGZ4ID0gdGhpcy5wZng7XG4gIG9wdHMua2V5ID0gdGhpcy5rZXk7XG4gIG9wdHMucGFzc3BocmFzZSA9IHRoaXMucGFzc3BocmFzZTtcbiAgb3B0cy5jZXJ0ID0gdGhpcy5jZXJ0O1xuICBvcHRzLmNhID0gdGhpcy5jYTtcbiAgb3B0cy5jaXBoZXJzID0gdGhpcy5jaXBoZXJzO1xuICBvcHRzLnJlamVjdFVuYXV0aG9yaXplZCA9IHRoaXMucmVqZWN0VW5hdXRob3JpemVkO1xuXG4gIHZhciB4aHIgPSB0aGlzLnhociA9IG5ldyBYTUxIdHRwUmVxdWVzdChvcHRzKTtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gIHRyeSB7XG5cbiAgICB4aHIub3Blbih0aGlzLm1ldGhvZCwgdGhpcy51cmksIHRoaXMuYXN5bmMpO1xuICAgIHRyeSB7XG4gICAgICBpZiAodGhpcy5leHRyYUhlYWRlcnMpIHtcbiAgICAgICAgeGhyLnNldERpc2FibGVIZWFkZXJDaGVjayAmJiB4aHIuc2V0RGlzYWJsZUhlYWRlckNoZWNrKHRydWUpO1xuICAgICAgICBmb3IgKHZhciBpIGluIHRoaXMuZXh0cmFIZWFkZXJzKSB7XG4gICAgICAgICAgaWYgKHRoaXMuZXh0cmFIZWFkZXJzLmhhc093blByb3BlcnR5KGkpKSB7XG4gICAgICAgICAgICB4aHIuc2V0UmVxdWVzdEhlYWRlcihpLCB0aGlzLmV4dHJhSGVhZGVyc1tpXSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBjYXRjaCAoZSkge31cblxuICAgIGlmICgnUE9TVCcgPT09IHRoaXMubWV0aG9kKSB7XG4gICAgICB0cnkge1xuICAgICAgICBpZiAodGhpcy5pc0JpbmFyeSkge1xuICAgICAgICAgIHhoci5zZXRSZXF1ZXN0SGVhZGVyKCdDb250ZW50LXR5cGUnLCAnYXBwbGljYXRpb24vb2N0ZXQtc3RyZWFtJyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgeGhyLnNldFJlcXVlc3RIZWFkZXIoJ0NvbnRlbnQtdHlwZScsICd0ZXh0L3BsYWluO2NoYXJzZXQ9VVRGLTgnKTtcbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAoZSkge31cbiAgICB9XG5cbiAgICB0cnkge1xuICAgICAgeGhyLnNldFJlcXVlc3RIZWFkZXIoJ0FjY2VwdCcsICcqLyonKTtcbiAgICB9IGNhdGNoIChlKSB7fVxuXG4gICAgLy8gaWU2IGNoZWNrXG4gICAgaWYgKCd3aXRoQ3JlZGVudGlhbHMnIGluIHhocikge1xuICAgICAgeGhyLndpdGhDcmVkZW50aWFscyA9IHRydWU7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMucmVxdWVzdFRpbWVvdXQpIHtcbiAgICAgIHhoci50aW1lb3V0ID0gdGhpcy5yZXF1ZXN0VGltZW91dDtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5oYXNYRFIoKSkge1xuICAgICAgeGhyLm9ubG9hZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgc2VsZi5vbkxvYWQoKTtcbiAgICAgIH07XG4gICAgICB4aHIub25lcnJvciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgc2VsZi5vbkVycm9yKHhoci5yZXNwb25zZVRleHQpO1xuICAgICAgfTtcbiAgICB9IGVsc2Uge1xuICAgICAgeGhyLm9ucmVhZHlzdGF0ZWNoYW5nZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHhoci5yZWFkeVN0YXRlID09PSAyKSB7XG4gICAgICAgICAgdmFyIGNvbnRlbnRUeXBlO1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb250ZW50VHlwZSA9IHhoci5nZXRSZXNwb25zZUhlYWRlcignQ29udGVudC1UeXBlJyk7XG4gICAgICAgICAgfSBjYXRjaCAoZSkge31cbiAgICAgICAgICBpZiAoY29udGVudFR5cGUgPT09ICdhcHBsaWNhdGlvbi9vY3RldC1zdHJlYW0nKSB7XG4gICAgICAgICAgICB4aHIucmVzcG9uc2VUeXBlID0gJ2FycmF5YnVmZmVyJztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKDQgIT09IHhoci5yZWFkeVN0YXRlKSByZXR1cm47XG4gICAgICAgIGlmICgyMDAgPT09IHhoci5zdGF0dXMgfHwgMTIyMyA9PT0geGhyLnN0YXR1cykge1xuICAgICAgICAgIHNlbGYub25Mb2FkKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gbWFrZSBzdXJlIHRoZSBgZXJyb3JgIGV2ZW50IGhhbmRsZXIgdGhhdCdzIHVzZXItc2V0XG4gICAgICAgICAgLy8gZG9lcyBub3QgdGhyb3cgaW4gdGhlIHNhbWUgdGljayBhbmQgZ2V0cyBjYXVnaHQgaGVyZVxuICAgICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgc2VsZi5vbkVycm9yKHhoci5zdGF0dXMpO1xuICAgICAgICAgIH0sIDApO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgIH1cblxuXG4gICAgeGhyLnNlbmQodGhpcy5kYXRhKTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIC8vIE5lZWQgdG8gZGVmZXIgc2luY2UgLmNyZWF0ZSgpIGlzIGNhbGxlZCBkaXJlY3RseSBmaHJvbSB0aGUgY29uc3RydWN0b3JcbiAgICAvLyBhbmQgdGh1cyB0aGUgJ2Vycm9yJyBldmVudCBjYW4gb25seSBiZSBvbmx5IGJvdW5kICphZnRlciogdGhpcyBleGNlcHRpb25cbiAgICAvLyBvY2N1cnMuICBUaGVyZWZvcmUsIGFsc28sIHdlIGNhbm5vdCB0aHJvdyBoZXJlIGF0IGFsbC5cbiAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgIHNlbGYub25FcnJvcihlKTtcbiAgICB9LCAwKTtcbiAgICByZXR1cm47XG4gIH1cblxuICBpZiAoZ2xvYmFsLmRvY3VtZW50KSB7XG4gICAgdGhpcy5pbmRleCA9IFJlcXVlc3QucmVxdWVzdHNDb3VudCsrO1xuICAgIFJlcXVlc3QucmVxdWVzdHNbdGhpcy5pbmRleF0gPSB0aGlzO1xuICB9XG59O1xuXG4vKipcbiAqIENhbGxlZCB1cG9uIHN1Y2Nlc3NmdWwgcmVzcG9uc2UuXG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuUmVxdWVzdC5wcm90b3R5cGUub25TdWNjZXNzID0gZnVuY3Rpb24gKCkge1xuICB0aGlzLmVtaXQoJ3N1Y2Nlc3MnKTtcbiAgdGhpcy5jbGVhbnVwKCk7XG59O1xuXG4vKipcbiAqIENhbGxlZCBpZiB3ZSBoYXZlIGRhdGEuXG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuUmVxdWVzdC5wcm90b3R5cGUub25EYXRhID0gZnVuY3Rpb24gKGRhdGEpIHtcbiAgdGhpcy5lbWl0KCdkYXRhJywgZGF0YSk7XG4gIHRoaXMub25TdWNjZXNzKCk7XG59O1xuXG4vKipcbiAqIENhbGxlZCB1cG9uIGVycm9yLlxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblJlcXVlc3QucHJvdG90eXBlLm9uRXJyb3IgPSBmdW5jdGlvbiAoZXJyKSB7XG4gIHRoaXMuZW1pdCgnZXJyb3InLCBlcnIpO1xuICB0aGlzLmNsZWFudXAodHJ1ZSk7XG59O1xuXG4vKipcbiAqIENsZWFucyB1cCBob3VzZS5cbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5SZXF1ZXN0LnByb3RvdHlwZS5jbGVhbnVwID0gZnVuY3Rpb24gKGZyb21FcnJvcikge1xuICBpZiAoJ3VuZGVmaW5lZCcgPT09IHR5cGVvZiB0aGlzLnhociB8fCBudWxsID09PSB0aGlzLnhocikge1xuICAgIHJldHVybjtcbiAgfVxuICAvLyB4bWxodHRwcmVxdWVzdFxuICBpZiAodGhpcy5oYXNYRFIoKSkge1xuICAgIHRoaXMueGhyLm9ubG9hZCA9IHRoaXMueGhyLm9uZXJyb3IgPSBlbXB0eTtcbiAgfSBlbHNlIHtcbiAgICB0aGlzLnhoci5vbnJlYWR5c3RhdGVjaGFuZ2UgPSBlbXB0eTtcbiAgfVxuXG4gIGlmIChmcm9tRXJyb3IpIHtcbiAgICB0cnkge1xuICAgICAgdGhpcy54aHIuYWJvcnQoKTtcbiAgICB9IGNhdGNoIChlKSB7fVxuICB9XG5cbiAgaWYgKGdsb2JhbC5kb2N1bWVudCkge1xuICAgIGRlbGV0ZSBSZXF1ZXN0LnJlcXVlc3RzW3RoaXMuaW5kZXhdO1xuICB9XG5cbiAgdGhpcy54aHIgPSBudWxsO1xufTtcblxuLyoqXG4gKiBDYWxsZWQgdXBvbiBsb2FkLlxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblJlcXVlc3QucHJvdG90eXBlLm9uTG9hZCA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIGRhdGE7XG4gIHRyeSB7XG4gICAgdmFyIGNvbnRlbnRUeXBlO1xuICAgIHRyeSB7XG4gICAgICBjb250ZW50VHlwZSA9IHRoaXMueGhyLmdldFJlc3BvbnNlSGVhZGVyKCdDb250ZW50LVR5cGUnKTtcbiAgICB9IGNhdGNoIChlKSB7fVxuICAgIGlmIChjb250ZW50VHlwZSA9PT0gJ2FwcGxpY2F0aW9uL29jdGV0LXN0cmVhbScpIHtcbiAgICAgIGRhdGEgPSB0aGlzLnhoci5yZXNwb25zZSB8fCB0aGlzLnhoci5yZXNwb25zZVRleHQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIGRhdGEgPSB0aGlzLnhoci5yZXNwb25zZVRleHQ7XG4gICAgfVxuICB9IGNhdGNoIChlKSB7XG4gICAgdGhpcy5vbkVycm9yKGUpO1xuICB9XG4gIGlmIChudWxsICE9IGRhdGEpIHtcbiAgICB0aGlzLm9uRGF0YShkYXRhKTtcbiAgfVxufTtcblxuLyoqXG4gKiBDaGVjayBpZiBpdCBoYXMgWERvbWFpblJlcXVlc3QuXG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuUmVxdWVzdC5wcm90b3R5cGUuaGFzWERSID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gJ3VuZGVmaW5lZCcgIT09IHR5cGVvZiBnbG9iYWwuWERvbWFpblJlcXVlc3QgJiYgIXRoaXMueHMgJiYgdGhpcy5lbmFibGVzWERSO1xufTtcblxuLyoqXG4gKiBBYm9ydHMgdGhlIHJlcXVlc3QuXG4gKlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5SZXF1ZXN0LnByb3RvdHlwZS5hYm9ydCA9IGZ1bmN0aW9uICgpIHtcbiAgdGhpcy5jbGVhbnVwKCk7XG59O1xuXG4vKipcbiAqIEFib3J0cyBwZW5kaW5nIHJlcXVlc3RzIHdoZW4gdW5sb2FkaW5nIHRoZSB3aW5kb3cuIFRoaXMgaXMgbmVlZGVkIHRvIHByZXZlbnRcbiAqIG1lbW9yeSBsZWFrcyAoZS5nLiB3aGVuIHVzaW5nIElFKSBhbmQgdG8gZW5zdXJlIHRoYXQgbm8gc3B1cmlvdXMgZXJyb3IgaXNcbiAqIGVtaXR0ZWQuXG4gKi9cblxuUmVxdWVzdC5yZXF1ZXN0c0NvdW50ID0gMDtcblJlcXVlc3QucmVxdWVzdHMgPSB7fTtcblxuaWYgKGdsb2JhbC5kb2N1bWVudCkge1xuICBpZiAoZ2xvYmFsLmF0dGFjaEV2ZW50KSB7XG4gICAgZ2xvYmFsLmF0dGFjaEV2ZW50KCdvbnVubG9hZCcsIHVubG9hZEhhbmRsZXIpO1xuICB9IGVsc2UgaWYgKGdsb2JhbC5hZGRFdmVudExpc3RlbmVyKSB7XG4gICAgZ2xvYmFsLmFkZEV2ZW50TGlzdGVuZXIoJ2JlZm9yZXVubG9hZCcsIHVubG9hZEhhbmRsZXIsIGZhbHNlKTtcbiAgfVxufVxuXG5mdW5jdGlvbiB1bmxvYWRIYW5kbGVyICgpIHtcbiAgZm9yICh2YXIgaSBpbiBSZXF1ZXN0LnJlcXVlc3RzKSB7XG4gICAgaWYgKFJlcXVlc3QucmVxdWVzdHMuaGFzT3duUHJvcGVydHkoaSkpIHtcbiAgICAgIFJlcXVlc3QucmVxdWVzdHNbaV0uYWJvcnQoKTtcbiAgICB9XG4gIH1cbn1cblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9lbmdpbmUuaW8tY2xpZW50L2xpYi90cmFuc3BvcnRzL3BvbGxpbmcteGhyLmpzXG4vLyBtb2R1bGUgaWQgPSAxN1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKipcbiAqIE1vZHVsZSBkZXBlbmRlbmNpZXMuXG4gKi9cblxudmFyIFRyYW5zcG9ydCA9IHJlcXVpcmUoJy4uL3RyYW5zcG9ydCcpO1xudmFyIHBhcnNlcXMgPSByZXF1aXJlKCdwYXJzZXFzJyk7XG52YXIgcGFyc2VyID0gcmVxdWlyZSgnZW5naW5lLmlvLXBhcnNlcicpO1xudmFyIGluaGVyaXQgPSByZXF1aXJlKCdjb21wb25lbnQtaW5oZXJpdCcpO1xudmFyIHllYXN0ID0gcmVxdWlyZSgneWVhc3QnKTtcbnZhciBkZWJ1ZyA9IHJlcXVpcmUoJ2RlYnVnJykoJ2VuZ2luZS5pby1jbGllbnQ6cG9sbGluZycpO1xuXG4vKipcbiAqIE1vZHVsZSBleHBvcnRzLlxuICovXG5cbm1vZHVsZS5leHBvcnRzID0gUG9sbGluZztcblxuLyoqXG4gKiBJcyBYSFIyIHN1cHBvcnRlZD9cbiAqL1xuXG52YXIgaGFzWEhSMiA9IChmdW5jdGlvbiAoKSB7XG4gIHZhciBYTUxIdHRwUmVxdWVzdCA9IHJlcXVpcmUoJ3htbGh0dHByZXF1ZXN0LXNzbCcpO1xuICB2YXIgeGhyID0gbmV3IFhNTEh0dHBSZXF1ZXN0KHsgeGRvbWFpbjogZmFsc2UgfSk7XG4gIHJldHVybiBudWxsICE9IHhoci5yZXNwb25zZVR5cGU7XG59KSgpO1xuXG4vKipcbiAqIFBvbGxpbmcgaW50ZXJmYWNlLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRzXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBQb2xsaW5nIChvcHRzKSB7XG4gIHZhciBmb3JjZUJhc2U2NCA9IChvcHRzICYmIG9wdHMuZm9yY2VCYXNlNjQpO1xuICBpZiAoIWhhc1hIUjIgfHwgZm9yY2VCYXNlNjQpIHtcbiAgICB0aGlzLnN1cHBvcnRzQmluYXJ5ID0gZmFsc2U7XG4gIH1cbiAgVHJhbnNwb3J0LmNhbGwodGhpcywgb3B0cyk7XG59XG5cbi8qKlxuICogSW5oZXJpdHMgZnJvbSBUcmFuc3BvcnQuXG4gKi9cblxuaW5oZXJpdChQb2xsaW5nLCBUcmFuc3BvcnQpO1xuXG4vKipcbiAqIFRyYW5zcG9ydCBuYW1lLlxuICovXG5cblBvbGxpbmcucHJvdG90eXBlLm5hbWUgPSAncG9sbGluZyc7XG5cbi8qKlxuICogT3BlbnMgdGhlIHNvY2tldCAodHJpZ2dlcnMgcG9sbGluZykuIFdlIHdyaXRlIGEgUElORyBtZXNzYWdlIHRvIGRldGVybWluZVxuICogd2hlbiB0aGUgdHJhbnNwb3J0IGlzIG9wZW4uXG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuUG9sbGluZy5wcm90b3R5cGUuZG9PcGVuID0gZnVuY3Rpb24gKCkge1xuICB0aGlzLnBvbGwoKTtcbn07XG5cbi8qKlxuICogUGF1c2VzIHBvbGxpbmcuXG4gKlxuICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2sgdXBvbiBidWZmZXJzIGFyZSBmbHVzaGVkIGFuZCB0cmFuc3BvcnQgaXMgcGF1c2VkXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5Qb2xsaW5nLnByb3RvdHlwZS5wYXVzZSA9IGZ1bmN0aW9uIChvblBhdXNlKSB7XG4gIHZhciBzZWxmID0gdGhpcztcblxuICB0aGlzLnJlYWR5U3RhdGUgPSAncGF1c2luZyc7XG5cbiAgZnVuY3Rpb24gcGF1c2UgKCkge1xuXG4gICAgc2VsZi5yZWFkeVN0YXRlID0gJ3BhdXNlZCc7XG4gICAgb25QYXVzZSgpO1xuICB9XG5cbiAgaWYgKHRoaXMucG9sbGluZyB8fCAhdGhpcy53cml0YWJsZSkge1xuICAgIHZhciB0b3RhbCA9IDA7XG5cbiAgICBpZiAodGhpcy5wb2xsaW5nKSB7XG5cbiAgICAgIHRvdGFsKys7XG4gICAgICB0aGlzLm9uY2UoJ3BvbGxDb21wbGV0ZScsIGZ1bmN0aW9uICgpIHtcblxuICAgICAgICAtLXRvdGFsIHx8IHBhdXNlKCk7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBpZiAoIXRoaXMud3JpdGFibGUpIHtcblxuICAgICAgdG90YWwrKztcbiAgICAgIHRoaXMub25jZSgnZHJhaW4nLCBmdW5jdGlvbiAoKSB7XG5cbiAgICAgICAgLS10b3RhbCB8fCBwYXVzZSgpO1xuICAgICAgfSk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHBhdXNlKCk7XG4gIH1cbn07XG5cbi8qKlxuICogU3RhcnRzIHBvbGxpbmcgY3ljbGUuXG4gKlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5Qb2xsaW5nLnByb3RvdHlwZS5wb2xsID0gZnVuY3Rpb24gKCkge1xuXG4gIHRoaXMucG9sbGluZyA9IHRydWU7XG4gIHRoaXMuZG9Qb2xsKCk7XG4gIHRoaXMuZW1pdCgncG9sbCcpO1xufTtcblxuLyoqXG4gKiBPdmVybG9hZHMgb25EYXRhIHRvIGRldGVjdCBwYXlsb2Fkcy5cbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5Qb2xsaW5nLnByb3RvdHlwZS5vbkRhdGEgPSBmdW5jdGlvbiAoZGF0YSkge1xuICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgdmFyIGNhbGxiYWNrID0gZnVuY3Rpb24gKHBhY2tldCwgaW5kZXgsIHRvdGFsKSB7XG4gICAgLy8gaWYgaXRzIHRoZSBmaXJzdCBtZXNzYWdlIHdlIGNvbnNpZGVyIHRoZSB0cmFuc3BvcnQgb3BlblxuICAgIGlmICgnb3BlbmluZycgPT09IHNlbGYucmVhZHlTdGF0ZSkge1xuICAgICAgc2VsZi5vbk9wZW4oKTtcbiAgICB9XG5cbiAgICAvLyBpZiBpdHMgYSBjbG9zZSBwYWNrZXQsIHdlIGNsb3NlIHRoZSBvbmdvaW5nIHJlcXVlc3RzXG4gICAgaWYgKCdjbG9zZScgPT09IHBhY2tldC50eXBlKSB7XG4gICAgICBzZWxmLm9uQ2xvc2UoKTtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICAvLyBvdGhlcndpc2UgYnlwYXNzIG9uRGF0YSBhbmQgaGFuZGxlIHRoZSBtZXNzYWdlXG4gICAgc2VsZi5vblBhY2tldChwYWNrZXQpO1xuICB9O1xuXG4gIC8vIGRlY29kZSBwYXlsb2FkXG4gIHBhcnNlci5kZWNvZGVQYXlsb2FkKGRhdGEsIHRoaXMuc29ja2V0LmJpbmFyeVR5cGUsIGNhbGxiYWNrKTtcblxuICAvLyBpZiBhbiBldmVudCBkaWQgbm90IHRyaWdnZXIgY2xvc2luZ1xuICBpZiAoJ2Nsb3NlZCcgIT09IHRoaXMucmVhZHlTdGF0ZSkge1xuICAgIC8vIGlmIHdlIGdvdCBkYXRhIHdlJ3JlIG5vdCBwb2xsaW5nXG4gICAgdGhpcy5wb2xsaW5nID0gZmFsc2U7XG4gICAgdGhpcy5lbWl0KCdwb2xsQ29tcGxldGUnKTtcblxuICAgIGlmICgnb3BlbicgPT09IHRoaXMucmVhZHlTdGF0ZSkge1xuICAgICAgdGhpcy5wb2xsKCk7XG4gICAgfSBlbHNlIHtcblxuICAgIH1cbiAgfVxufTtcblxuLyoqXG4gKiBGb3IgcG9sbGluZywgc2VuZCBhIGNsb3NlIHBhY2tldC5cbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5Qb2xsaW5nLnByb3RvdHlwZS5kb0Nsb3NlID0gZnVuY3Rpb24gKCkge1xuICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgZnVuY3Rpb24gY2xvc2UgKCkge1xuXG4gICAgc2VsZi53cml0ZShbeyB0eXBlOiAnY2xvc2UnIH1dKTtcbiAgfVxuXG4gIGlmICgnb3BlbicgPT09IHRoaXMucmVhZHlTdGF0ZSkge1xuXG4gICAgY2xvc2UoKTtcbiAgfSBlbHNlIHtcbiAgICAvLyBpbiBjYXNlIHdlJ3JlIHRyeWluZyB0byBjbG9zZSB3aGlsZVxuICAgIC8vIGhhbmRzaGFraW5nIGlzIGluIHByb2dyZXNzIChHSC0xNjQpXG5cbiAgICB0aGlzLm9uY2UoJ29wZW4nLCBjbG9zZSk7XG4gIH1cbn07XG5cbi8qKlxuICogV3JpdGVzIGEgcGFja2V0cyBwYXlsb2FkLlxuICpcbiAqIEBwYXJhbSB7QXJyYXl9IGRhdGEgcGFja2V0c1xuICogQHBhcmFtIHtGdW5jdGlvbn0gZHJhaW4gY2FsbGJhY2tcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblBvbGxpbmcucHJvdG90eXBlLndyaXRlID0gZnVuY3Rpb24gKHBhY2tldHMpIHtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICB0aGlzLndyaXRhYmxlID0gZmFsc2U7XG4gIHZhciBjYWxsYmFja2ZuID0gZnVuY3Rpb24gKCkge1xuICAgIHNlbGYud3JpdGFibGUgPSB0cnVlO1xuICAgIHNlbGYuZW1pdCgnZHJhaW4nKTtcbiAgfTtcblxuICBwYXJzZXIuZW5jb2RlUGF5bG9hZChwYWNrZXRzLCB0aGlzLnN1cHBvcnRzQmluYXJ5LCBmdW5jdGlvbiAoZGF0YSkge1xuICAgIHNlbGYuZG9Xcml0ZShkYXRhLCBjYWxsYmFja2ZuKTtcbiAgfSk7XG59O1xuXG4vKipcbiAqIEdlbmVyYXRlcyB1cmkgZm9yIGNvbm5lY3Rpb24uXG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuUG9sbGluZy5wcm90b3R5cGUudXJpID0gZnVuY3Rpb24gKCkge1xuICB2YXIgcXVlcnkgPSB0aGlzLnF1ZXJ5IHx8IHt9O1xuICB2YXIgc2NoZW1hID0gdGhpcy5zZWN1cmUgPyAnaHR0cHMnIDogJ2h0dHAnO1xuICB2YXIgcG9ydCA9ICcnO1xuXG4gIC8vIGNhY2hlIGJ1c3RpbmcgaXMgZm9yY2VkXG4gIGlmIChmYWxzZSAhPT0gdGhpcy50aW1lc3RhbXBSZXF1ZXN0cykge1xuICAgIHF1ZXJ5W3RoaXMudGltZXN0YW1wUGFyYW1dID0geWVhc3QoKTtcbiAgfVxuXG4gIGlmICghdGhpcy5zdXBwb3J0c0JpbmFyeSAmJiAhcXVlcnkuc2lkKSB7XG4gICAgcXVlcnkuYjY0ID0gMTtcbiAgfVxuXG4gIHF1ZXJ5ID0gcGFyc2Vxcy5lbmNvZGUocXVlcnkpO1xuXG4gIC8vIGF2b2lkIHBvcnQgaWYgZGVmYXVsdCBmb3Igc2NoZW1hXG4gIGlmICh0aGlzLnBvcnQgJiYgKCgnaHR0cHMnID09PSBzY2hlbWEgJiYgTnVtYmVyKHRoaXMucG9ydCkgIT09IDQ0MykgfHxcbiAgICAgKCdodHRwJyA9PT0gc2NoZW1hICYmIE51bWJlcih0aGlzLnBvcnQpICE9PSA4MCkpKSB7XG4gICAgcG9ydCA9ICc6JyArIHRoaXMucG9ydDtcbiAgfVxuXG4gIC8vIHByZXBlbmQgPyB0byBxdWVyeVxuICBpZiAocXVlcnkubGVuZ3RoKSB7XG4gICAgcXVlcnkgPSAnPycgKyBxdWVyeTtcbiAgfVxuXG4gIHZhciBpcHY2ID0gdGhpcy5ob3N0bmFtZS5pbmRleE9mKCc6JykgIT09IC0xO1xuICByZXR1cm4gc2NoZW1hICsgJzovLycgKyAoaXB2NiA/ICdbJyArIHRoaXMuaG9zdG5hbWUgKyAnXScgOiB0aGlzLmhvc3RuYW1lKSArIHBvcnQgKyB0aGlzLnBhdGggKyBxdWVyeTtcbn07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vZW5naW5lLmlvLWNsaWVudC9saWIvdHJhbnNwb3J0cy9wb2xsaW5nLmpzXG4vLyBtb2R1bGUgaWQgPSAxOFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKipcbiAqIE1vZHVsZSBkZXBlbmRlbmNpZXMuXG4gKi9cblxudmFyIHBhcnNlciA9IHJlcXVpcmUoJ2VuZ2luZS5pby1wYXJzZXInKTtcbnZhciBFbWl0dGVyID0gcmVxdWlyZSgnY29tcG9uZW50LWVtaXR0ZXInKTtcblxuLyoqXG4gKiBNb2R1bGUgZXhwb3J0cy5cbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IFRyYW5zcG9ydDtcblxuLyoqXG4gKiBUcmFuc3BvcnQgYWJzdHJhY3QgY29uc3RydWN0b3IuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMuXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBUcmFuc3BvcnQgKG9wdHMpIHtcbiAgdGhpcy5wYXRoID0gb3B0cy5wYXRoO1xuICB0aGlzLmhvc3RuYW1lID0gb3B0cy5ob3N0bmFtZTtcbiAgdGhpcy5wb3J0ID0gb3B0cy5wb3J0O1xuICB0aGlzLnNlY3VyZSA9IG9wdHMuc2VjdXJlO1xuICB0aGlzLnF1ZXJ5ID0gb3B0cy5xdWVyeTtcbiAgdGhpcy50aW1lc3RhbXBQYXJhbSA9IG9wdHMudGltZXN0YW1wUGFyYW07XG4gIHRoaXMudGltZXN0YW1wUmVxdWVzdHMgPSBvcHRzLnRpbWVzdGFtcFJlcXVlc3RzO1xuICB0aGlzLnJlYWR5U3RhdGUgPSAnJztcbiAgdGhpcy5hZ2VudCA9IG9wdHMuYWdlbnQgfHwgZmFsc2U7XG4gIHRoaXMuc29ja2V0ID0gb3B0cy5zb2NrZXQ7XG4gIHRoaXMuZW5hYmxlc1hEUiA9IG9wdHMuZW5hYmxlc1hEUjtcblxuICAvLyBTU0wgb3B0aW9ucyBmb3IgTm9kZS5qcyBjbGllbnRcbiAgdGhpcy5wZnggPSBvcHRzLnBmeDtcbiAgdGhpcy5rZXkgPSBvcHRzLmtleTtcbiAgdGhpcy5wYXNzcGhyYXNlID0gb3B0cy5wYXNzcGhyYXNlO1xuICB0aGlzLmNlcnQgPSBvcHRzLmNlcnQ7XG4gIHRoaXMuY2EgPSBvcHRzLmNhO1xuICB0aGlzLmNpcGhlcnMgPSBvcHRzLmNpcGhlcnM7XG4gIHRoaXMucmVqZWN0VW5hdXRob3JpemVkID0gb3B0cy5yZWplY3RVbmF1dGhvcml6ZWQ7XG4gIHRoaXMuZm9yY2VOb2RlID0gb3B0cy5mb3JjZU5vZGU7XG5cbiAgLy8gb3RoZXIgb3B0aW9ucyBmb3IgTm9kZS5qcyBjbGllbnRcbiAgdGhpcy5leHRyYUhlYWRlcnMgPSBvcHRzLmV4dHJhSGVhZGVycztcbiAgdGhpcy5sb2NhbEFkZHJlc3MgPSBvcHRzLmxvY2FsQWRkcmVzcztcbn1cblxuLyoqXG4gKiBNaXggaW4gYEVtaXR0ZXJgLlxuICovXG5cbkVtaXR0ZXIoVHJhbnNwb3J0LnByb3RvdHlwZSk7XG5cbi8qKlxuICogRW1pdHMgYW4gZXJyb3IuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHN0clxuICogQHJldHVybiB7VHJhbnNwb3J0fSBmb3IgY2hhaW5pbmdcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuVHJhbnNwb3J0LnByb3RvdHlwZS5vbkVycm9yID0gZnVuY3Rpb24gKG1zZywgZGVzYykge1xuICB2YXIgZXJyID0gbmV3IEVycm9yKG1zZyk7XG4gIGVyci50eXBlID0gJ1RyYW5zcG9ydEVycm9yJztcbiAgZXJyLmRlc2NyaXB0aW9uID0gZGVzYztcbiAgdGhpcy5lbWl0KCdlcnJvcicsIGVycik7XG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBPcGVucyB0aGUgdHJhbnNwb3J0LlxuICpcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuVHJhbnNwb3J0LnByb3RvdHlwZS5vcGVuID0gZnVuY3Rpb24gKCkge1xuICBpZiAoJ2Nsb3NlZCcgPT09IHRoaXMucmVhZHlTdGF0ZSB8fCAnJyA9PT0gdGhpcy5yZWFkeVN0YXRlKSB7XG4gICAgdGhpcy5yZWFkeVN0YXRlID0gJ29wZW5pbmcnO1xuICAgIHRoaXMuZG9PcGVuKCk7XG4gIH1cblxuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogQ2xvc2VzIHRoZSB0cmFuc3BvcnQuXG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuVHJhbnNwb3J0LnByb3RvdHlwZS5jbG9zZSA9IGZ1bmN0aW9uICgpIHtcbiAgaWYgKCdvcGVuaW5nJyA9PT0gdGhpcy5yZWFkeVN0YXRlIHx8ICdvcGVuJyA9PT0gdGhpcy5yZWFkeVN0YXRlKSB7XG4gICAgdGhpcy5kb0Nsb3NlKCk7XG4gICAgdGhpcy5vbkNsb3NlKCk7XG4gIH1cblxuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogU2VuZHMgbXVsdGlwbGUgcGFja2V0cy5cbiAqXG4gKiBAcGFyYW0ge0FycmF5fSBwYWNrZXRzXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5UcmFuc3BvcnQucHJvdG90eXBlLnNlbmQgPSBmdW5jdGlvbiAocGFja2V0cykge1xuICBpZiAoJ29wZW4nID09PSB0aGlzLnJlYWR5U3RhdGUpIHtcbiAgICB0aGlzLndyaXRlKHBhY2tldHMpO1xuICB9IGVsc2Uge1xuICAgIHRocm93IG5ldyBFcnJvcignVHJhbnNwb3J0IG5vdCBvcGVuJyk7XG4gIH1cbn07XG5cbi8qKlxuICogQ2FsbGVkIHVwb24gb3BlblxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblRyYW5zcG9ydC5wcm90b3R5cGUub25PcGVuID0gZnVuY3Rpb24gKCkge1xuICB0aGlzLnJlYWR5U3RhdGUgPSAnb3Blbic7XG4gIHRoaXMud3JpdGFibGUgPSB0cnVlO1xuICB0aGlzLmVtaXQoJ29wZW4nKTtcbn07XG5cbi8qKlxuICogQ2FsbGVkIHdpdGggZGF0YS5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gZGF0YVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuVHJhbnNwb3J0LnByb3RvdHlwZS5vbkRhdGEgPSBmdW5jdGlvbiAoZGF0YSkge1xuICB2YXIgcGFja2V0ID0gcGFyc2VyLmRlY29kZVBhY2tldChkYXRhLCB0aGlzLnNvY2tldC5iaW5hcnlUeXBlKTtcbiAgdGhpcy5vblBhY2tldChwYWNrZXQpO1xufTtcblxuLyoqXG4gKiBDYWxsZWQgd2l0aCBhIGRlY29kZWQgcGFja2V0LlxuICovXG5cblRyYW5zcG9ydC5wcm90b3R5cGUub25QYWNrZXQgPSBmdW5jdGlvbiAocGFja2V0KSB7XG4gIHRoaXMuZW1pdCgncGFja2V0JywgcGFja2V0KTtcbn07XG5cbi8qKlxuICogQ2FsbGVkIHVwb24gY2xvc2UuXG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuVHJhbnNwb3J0LnByb3RvdHlwZS5vbkNsb3NlID0gZnVuY3Rpb24gKCkge1xuICB0aGlzLnJlYWR5U3RhdGUgPSAnY2xvc2VkJztcbiAgdGhpcy5lbWl0KCdjbG9zZScpO1xufTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9lbmdpbmUuaW8tY2xpZW50L2xpYi90cmFuc3BvcnQuanNcbi8vIG1vZHVsZSBpZCA9IDE5XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qKlxuICogTW9kdWxlIGRlcGVuZGVuY2llcy5cbiAqL1xuXG52YXIga2V5cyA9IHJlcXVpcmUoJy4va2V5cycpO1xudmFyIGhhc0JpbmFyeSA9IHJlcXVpcmUoJ2hhcy1iaW5hcnkyJyk7XG52YXIgc2xpY2VCdWZmZXIgPSByZXF1aXJlKCdhcnJheWJ1ZmZlci5zbGljZScpO1xudmFyIGFmdGVyID0gcmVxdWlyZSgnYWZ0ZXInKTtcbnZhciB1dGY4ID0gcmVxdWlyZSgnLi91dGY4Jyk7XG5cbnZhciBiYXNlNjRlbmNvZGVyO1xuaWYgKGdsb2JhbCAmJiBnbG9iYWwuQXJyYXlCdWZmZXIpIHtcbiAgYmFzZTY0ZW5jb2RlciA9IHJlcXVpcmUoJ2Jhc2U2NC1hcnJheWJ1ZmZlcicpO1xufVxuXG4vKipcbiAqIENoZWNrIGlmIHdlIGFyZSBydW5uaW5nIGFuIGFuZHJvaWQgYnJvd3Nlci4gVGhhdCByZXF1aXJlcyB1cyB0byB1c2VcbiAqIEFycmF5QnVmZmVyIHdpdGggcG9sbGluZyB0cmFuc3BvcnRzLi4uXG4gKlxuICogaHR0cDovL2doaW5kYS5uZXQvanBlZy1ibG9iLWFqYXgtYW5kcm9pZC9cbiAqL1xuXG52YXIgaXNBbmRyb2lkID0gdHlwZW9mIG5hdmlnYXRvciAhPT0gJ3VuZGVmaW5lZCcgJiYgL0FuZHJvaWQvaS50ZXN0KG5hdmlnYXRvci51c2VyQWdlbnQpO1xuXG4vKipcbiAqIENoZWNrIGlmIHdlIGFyZSBydW5uaW5nIGluIFBoYW50b21KUy5cbiAqIFVwbG9hZGluZyBhIEJsb2Igd2l0aCBQaGFudG9tSlMgZG9lcyBub3Qgd29yayBjb3JyZWN0bHksIGFzIHJlcG9ydGVkIGhlcmU6XG4gKiBodHRwczovL2dpdGh1Yi5jb20vYXJpeWEvcGhhbnRvbWpzL2lzc3Vlcy8xMTM5NVxuICogQHR5cGUgYm9vbGVhblxuICovXG52YXIgaXNQaGFudG9tSlMgPSB0eXBlb2YgbmF2aWdhdG9yICE9PSAndW5kZWZpbmVkJyAmJiAvUGhhbnRvbUpTL2kudGVzdChuYXZpZ2F0b3IudXNlckFnZW50KTtcblxuLyoqXG4gKiBXaGVuIHRydWUsIGF2b2lkcyB1c2luZyBCbG9icyB0byBlbmNvZGUgcGF5bG9hZHMuXG4gKiBAdHlwZSBib29sZWFuXG4gKi9cbnZhciBkb250U2VuZEJsb2JzID0gaXNBbmRyb2lkIHx8IGlzUGhhbnRvbUpTO1xuXG4vKipcbiAqIEN1cnJlbnQgcHJvdG9jb2wgdmVyc2lvbi5cbiAqL1xuXG5leHBvcnRzLnByb3RvY29sID0gMztcblxuLyoqXG4gKiBQYWNrZXQgdHlwZXMuXG4gKi9cblxudmFyIHBhY2tldHMgPSBleHBvcnRzLnBhY2tldHMgPSB7XG4gICAgb3BlbjogICAgIDAgICAgLy8gbm9uLXdzXG4gICwgY2xvc2U6ICAgIDEgICAgLy8gbm9uLXdzXG4gICwgcGluZzogICAgIDJcbiAgLCBwb25nOiAgICAgM1xuICAsIG1lc3NhZ2U6ICA0XG4gICwgdXBncmFkZTogIDVcbiAgLCBub29wOiAgICAgNlxufTtcblxudmFyIHBhY2tldHNsaXN0ID0ga2V5cyhwYWNrZXRzKTtcblxuLyoqXG4gKiBQcmVtYWRlIGVycm9yIHBhY2tldC5cbiAqL1xuXG52YXIgZXJyID0geyB0eXBlOiAnZXJyb3InLCBkYXRhOiAncGFyc2VyIGVycm9yJyB9O1xuXG4vKipcbiAqIENyZWF0ZSBhIGJsb2IgYXBpIGV2ZW4gZm9yIGJsb2IgYnVpbGRlciB3aGVuIHZlbmRvciBwcmVmaXhlcyBleGlzdFxuICovXG5cbnZhciBCbG9iID0gcmVxdWlyZSgnYmxvYicpO1xuXG4vKipcbiAqIEVuY29kZXMgYSBwYWNrZXQuXG4gKlxuICogICAgIDxwYWNrZXQgdHlwZSBpZD4gWyA8ZGF0YT4gXVxuICpcbiAqIEV4YW1wbGU6XG4gKlxuICogICAgIDVoZWxsbyB3b3JsZFxuICogICAgIDNcbiAqICAgICA0XG4gKlxuICogQmluYXJ5IGlzIGVuY29kZWQgaW4gYW4gaWRlbnRpY2FsIHByaW5jaXBsZVxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmV4cG9ydHMuZW5jb2RlUGFja2V0ID0gZnVuY3Rpb24gKHBhY2tldCwgc3VwcG9ydHNCaW5hcnksIHV0ZjhlbmNvZGUsIGNhbGxiYWNrKSB7XG4gIGlmICh0eXBlb2Ygc3VwcG9ydHNCaW5hcnkgPT09ICdmdW5jdGlvbicpIHtcbiAgICBjYWxsYmFjayA9IHN1cHBvcnRzQmluYXJ5O1xuICAgIHN1cHBvcnRzQmluYXJ5ID0gZmFsc2U7XG4gIH1cblxuICBpZiAodHlwZW9mIHV0ZjhlbmNvZGUgPT09ICdmdW5jdGlvbicpIHtcbiAgICBjYWxsYmFjayA9IHV0ZjhlbmNvZGU7XG4gICAgdXRmOGVuY29kZSA9IG51bGw7XG4gIH1cblxuICB2YXIgZGF0YSA9IChwYWNrZXQuZGF0YSA9PT0gdW5kZWZpbmVkKVxuICAgID8gdW5kZWZpbmVkXG4gICAgOiBwYWNrZXQuZGF0YS5idWZmZXIgfHwgcGFja2V0LmRhdGE7XG5cbiAgaWYgKGdsb2JhbC5BcnJheUJ1ZmZlciAmJiBkYXRhIGluc3RhbmNlb2YgQXJyYXlCdWZmZXIpIHtcbiAgICByZXR1cm4gZW5jb2RlQXJyYXlCdWZmZXIocGFja2V0LCBzdXBwb3J0c0JpbmFyeSwgY2FsbGJhY2spO1xuICB9IGVsc2UgaWYgKEJsb2IgJiYgZGF0YSBpbnN0YW5jZW9mIGdsb2JhbC5CbG9iKSB7XG4gICAgcmV0dXJuIGVuY29kZUJsb2IocGFja2V0LCBzdXBwb3J0c0JpbmFyeSwgY2FsbGJhY2spO1xuICB9XG5cbiAgLy8gbWlnaHQgYmUgYW4gb2JqZWN0IHdpdGggeyBiYXNlNjQ6IHRydWUsIGRhdGE6IGRhdGFBc0Jhc2U2NFN0cmluZyB9XG4gIGlmIChkYXRhICYmIGRhdGEuYmFzZTY0KSB7XG4gICAgcmV0dXJuIGVuY29kZUJhc2U2NE9iamVjdChwYWNrZXQsIGNhbGxiYWNrKTtcbiAgfVxuXG4gIC8vIFNlbmRpbmcgZGF0YSBhcyBhIHV0Zi04IHN0cmluZ1xuICB2YXIgZW5jb2RlZCA9IHBhY2tldHNbcGFja2V0LnR5cGVdO1xuXG4gIC8vIGRhdGEgZnJhZ21lbnQgaXMgb3B0aW9uYWxcbiAgaWYgKHVuZGVmaW5lZCAhPT0gcGFja2V0LmRhdGEpIHtcbiAgICBlbmNvZGVkICs9IHV0ZjhlbmNvZGUgPyB1dGY4LmVuY29kZShTdHJpbmcocGFja2V0LmRhdGEpLCB7IHN0cmljdDogZmFsc2UgfSkgOiBTdHJpbmcocGFja2V0LmRhdGEpO1xuICB9XG5cbiAgcmV0dXJuIGNhbGxiYWNrKCcnICsgZW5jb2RlZCk7XG5cbn07XG5cbmZ1bmN0aW9uIGVuY29kZUJhc2U2NE9iamVjdChwYWNrZXQsIGNhbGxiYWNrKSB7XG4gIC8vIHBhY2tldCBkYXRhIGlzIGFuIG9iamVjdCB7IGJhc2U2NDogdHJ1ZSwgZGF0YTogZGF0YUFzQmFzZTY0U3RyaW5nIH1cbiAgdmFyIG1lc3NhZ2UgPSAnYicgKyBleHBvcnRzLnBhY2tldHNbcGFja2V0LnR5cGVdICsgcGFja2V0LmRhdGEuZGF0YTtcbiAgcmV0dXJuIGNhbGxiYWNrKG1lc3NhZ2UpO1xufVxuXG4vKipcbiAqIEVuY29kZSBwYWNrZXQgaGVscGVycyBmb3IgYmluYXJ5IHR5cGVzXG4gKi9cblxuZnVuY3Rpb24gZW5jb2RlQXJyYXlCdWZmZXIocGFja2V0LCBzdXBwb3J0c0JpbmFyeSwgY2FsbGJhY2spIHtcbiAgaWYgKCFzdXBwb3J0c0JpbmFyeSkge1xuICAgIHJldHVybiBleHBvcnRzLmVuY29kZUJhc2U2NFBhY2tldChwYWNrZXQsIGNhbGxiYWNrKTtcbiAgfVxuXG4gIHZhciBkYXRhID0gcGFja2V0LmRhdGE7XG4gIHZhciBjb250ZW50QXJyYXkgPSBuZXcgVWludDhBcnJheShkYXRhKTtcbiAgdmFyIHJlc3VsdEJ1ZmZlciA9IG5ldyBVaW50OEFycmF5KDEgKyBkYXRhLmJ5dGVMZW5ndGgpO1xuXG4gIHJlc3VsdEJ1ZmZlclswXSA9IHBhY2tldHNbcGFja2V0LnR5cGVdO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGNvbnRlbnRBcnJheS5sZW5ndGg7IGkrKykge1xuICAgIHJlc3VsdEJ1ZmZlcltpKzFdID0gY29udGVudEFycmF5W2ldO1xuICB9XG5cbiAgcmV0dXJuIGNhbGxiYWNrKHJlc3VsdEJ1ZmZlci5idWZmZXIpO1xufVxuXG5mdW5jdGlvbiBlbmNvZGVCbG9iQXNBcnJheUJ1ZmZlcihwYWNrZXQsIHN1cHBvcnRzQmluYXJ5LCBjYWxsYmFjaykge1xuICBpZiAoIXN1cHBvcnRzQmluYXJ5KSB7XG4gICAgcmV0dXJuIGV4cG9ydHMuZW5jb2RlQmFzZTY0UGFja2V0KHBhY2tldCwgY2FsbGJhY2spO1xuICB9XG5cbiAgdmFyIGZyID0gbmV3IEZpbGVSZWFkZXIoKTtcbiAgZnIub25sb2FkID0gZnVuY3Rpb24oKSB7XG4gICAgcGFja2V0LmRhdGEgPSBmci5yZXN1bHQ7XG4gICAgZXhwb3J0cy5lbmNvZGVQYWNrZXQocGFja2V0LCBzdXBwb3J0c0JpbmFyeSwgdHJ1ZSwgY2FsbGJhY2spO1xuICB9O1xuICByZXR1cm4gZnIucmVhZEFzQXJyYXlCdWZmZXIocGFja2V0LmRhdGEpO1xufVxuXG5mdW5jdGlvbiBlbmNvZGVCbG9iKHBhY2tldCwgc3VwcG9ydHNCaW5hcnksIGNhbGxiYWNrKSB7XG4gIGlmICghc3VwcG9ydHNCaW5hcnkpIHtcbiAgICByZXR1cm4gZXhwb3J0cy5lbmNvZGVCYXNlNjRQYWNrZXQocGFja2V0LCBjYWxsYmFjayk7XG4gIH1cblxuICBpZiAoZG9udFNlbmRCbG9icykge1xuICAgIHJldHVybiBlbmNvZGVCbG9iQXNBcnJheUJ1ZmZlcihwYWNrZXQsIHN1cHBvcnRzQmluYXJ5LCBjYWxsYmFjayk7XG4gIH1cblxuICB2YXIgbGVuZ3RoID0gbmV3IFVpbnQ4QXJyYXkoMSk7XG4gIGxlbmd0aFswXSA9IHBhY2tldHNbcGFja2V0LnR5cGVdO1xuICB2YXIgYmxvYiA9IG5ldyBCbG9iKFtsZW5ndGguYnVmZmVyLCBwYWNrZXQuZGF0YV0pO1xuXG4gIHJldHVybiBjYWxsYmFjayhibG9iKTtcbn1cblxuLyoqXG4gKiBFbmNvZGVzIGEgcGFja2V0IHdpdGggYmluYXJ5IGRhdGEgaW4gYSBiYXNlNjQgc3RyaW5nXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IHBhY2tldCwgaGFzIGB0eXBlYCBhbmQgYGRhdGFgXG4gKiBAcmV0dXJuIHtTdHJpbmd9IGJhc2U2NCBlbmNvZGVkIG1lc3NhZ2VcbiAqL1xuXG5leHBvcnRzLmVuY29kZUJhc2U2NFBhY2tldCA9IGZ1bmN0aW9uKHBhY2tldCwgY2FsbGJhY2spIHtcbiAgdmFyIG1lc3NhZ2UgPSAnYicgKyBleHBvcnRzLnBhY2tldHNbcGFja2V0LnR5cGVdO1xuICBpZiAoQmxvYiAmJiBwYWNrZXQuZGF0YSBpbnN0YW5jZW9mIGdsb2JhbC5CbG9iKSB7XG4gICAgdmFyIGZyID0gbmV3IEZpbGVSZWFkZXIoKTtcbiAgICBmci5vbmxvYWQgPSBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBiNjQgPSBmci5yZXN1bHQuc3BsaXQoJywnKVsxXTtcbiAgICAgIGNhbGxiYWNrKG1lc3NhZ2UgKyBiNjQpO1xuICAgIH07XG4gICAgcmV0dXJuIGZyLnJlYWRBc0RhdGFVUkwocGFja2V0LmRhdGEpO1xuICB9XG5cbiAgdmFyIGI2NGRhdGE7XG4gIHRyeSB7XG4gICAgYjY0ZGF0YSA9IFN0cmluZy5mcm9tQ2hhckNvZGUuYXBwbHkobnVsbCwgbmV3IFVpbnQ4QXJyYXkocGFja2V0LmRhdGEpKTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIC8vIGlQaG9uZSBTYWZhcmkgZG9lc24ndCBsZXQgeW91IGFwcGx5IHdpdGggdHlwZWQgYXJyYXlzXG4gICAgdmFyIHR5cGVkID0gbmV3IFVpbnQ4QXJyYXkocGFja2V0LmRhdGEpO1xuICAgIHZhciBiYXNpYyA9IG5ldyBBcnJheSh0eXBlZC5sZW5ndGgpO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdHlwZWQubGVuZ3RoOyBpKyspIHtcbiAgICAgIGJhc2ljW2ldID0gdHlwZWRbaV07XG4gICAgfVxuICAgIGI2NGRhdGEgPSBTdHJpbmcuZnJvbUNoYXJDb2RlLmFwcGx5KG51bGwsIGJhc2ljKTtcbiAgfVxuICBtZXNzYWdlICs9IGdsb2JhbC5idG9hKGI2NGRhdGEpO1xuICByZXR1cm4gY2FsbGJhY2sobWVzc2FnZSk7XG59O1xuXG4vKipcbiAqIERlY29kZXMgYSBwYWNrZXQuIENoYW5nZXMgZm9ybWF0IHRvIEJsb2IgaWYgcmVxdWVzdGVkLlxuICpcbiAqIEByZXR1cm4ge09iamVjdH0gd2l0aCBgdHlwZWAgYW5kIGBkYXRhYCAoaWYgYW55KVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZXhwb3J0cy5kZWNvZGVQYWNrZXQgPSBmdW5jdGlvbiAoZGF0YSwgYmluYXJ5VHlwZSwgdXRmOGRlY29kZSkge1xuICBpZiAoZGF0YSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgcmV0dXJuIGVycjtcbiAgfVxuICAvLyBTdHJpbmcgZGF0YVxuICBpZiAodHlwZW9mIGRhdGEgPT09ICdzdHJpbmcnKSB7XG4gICAgaWYgKGRhdGEuY2hhckF0KDApID09PSAnYicpIHtcbiAgICAgIHJldHVybiBleHBvcnRzLmRlY29kZUJhc2U2NFBhY2tldChkYXRhLnN1YnN0cigxKSwgYmluYXJ5VHlwZSk7XG4gICAgfVxuXG4gICAgaWYgKHV0ZjhkZWNvZGUpIHtcbiAgICAgIGRhdGEgPSB0cnlEZWNvZGUoZGF0YSk7XG4gICAgICBpZiAoZGF0YSA9PT0gZmFsc2UpIHtcbiAgICAgICAgcmV0dXJuIGVycjtcbiAgICAgIH1cbiAgICB9XG4gICAgdmFyIHR5cGUgPSBkYXRhLmNoYXJBdCgwKTtcblxuICAgIGlmIChOdW1iZXIodHlwZSkgIT0gdHlwZSB8fCAhcGFja2V0c2xpc3RbdHlwZV0pIHtcbiAgICAgIHJldHVybiBlcnI7XG4gICAgfVxuXG4gICAgaWYgKGRhdGEubGVuZ3RoID4gMSkge1xuICAgICAgcmV0dXJuIHsgdHlwZTogcGFja2V0c2xpc3RbdHlwZV0sIGRhdGE6IGRhdGEuc3Vic3RyaW5nKDEpIH07XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiB7IHR5cGU6IHBhY2tldHNsaXN0W3R5cGVdIH07XG4gICAgfVxuICB9XG5cbiAgdmFyIGFzQXJyYXkgPSBuZXcgVWludDhBcnJheShkYXRhKTtcbiAgdmFyIHR5cGUgPSBhc0FycmF5WzBdO1xuICB2YXIgcmVzdCA9IHNsaWNlQnVmZmVyKGRhdGEsIDEpO1xuICBpZiAoQmxvYiAmJiBiaW5hcnlUeXBlID09PSAnYmxvYicpIHtcbiAgICByZXN0ID0gbmV3IEJsb2IoW3Jlc3RdKTtcbiAgfVxuICByZXR1cm4geyB0eXBlOiBwYWNrZXRzbGlzdFt0eXBlXSwgZGF0YTogcmVzdCB9O1xufTtcblxuZnVuY3Rpb24gdHJ5RGVjb2RlKGRhdGEpIHtcbiAgdHJ5IHtcbiAgICBkYXRhID0gdXRmOC5kZWNvZGUoZGF0YSwgeyBzdHJpY3Q6IGZhbHNlIH0pO1xuICB9IGNhdGNoIChlKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHJldHVybiBkYXRhO1xufVxuXG4vKipcbiAqIERlY29kZXMgYSBwYWNrZXQgZW5jb2RlZCBpbiBhIGJhc2U2NCBzdHJpbmdcbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gYmFzZTY0IGVuY29kZWQgbWVzc2FnZVxuICogQHJldHVybiB7T2JqZWN0fSB3aXRoIGB0eXBlYCBhbmQgYGRhdGFgIChpZiBhbnkpXG4gKi9cblxuZXhwb3J0cy5kZWNvZGVCYXNlNjRQYWNrZXQgPSBmdW5jdGlvbihtc2csIGJpbmFyeVR5cGUpIHtcbiAgdmFyIHR5cGUgPSBwYWNrZXRzbGlzdFttc2cuY2hhckF0KDApXTtcbiAgaWYgKCFiYXNlNjRlbmNvZGVyKSB7XG4gICAgcmV0dXJuIHsgdHlwZTogdHlwZSwgZGF0YTogeyBiYXNlNjQ6IHRydWUsIGRhdGE6IG1zZy5zdWJzdHIoMSkgfSB9O1xuICB9XG5cbiAgdmFyIGRhdGEgPSBiYXNlNjRlbmNvZGVyLmRlY29kZShtc2cuc3Vic3RyKDEpKTtcblxuICBpZiAoYmluYXJ5VHlwZSA9PT0gJ2Jsb2InICYmIEJsb2IpIHtcbiAgICBkYXRhID0gbmV3IEJsb2IoW2RhdGFdKTtcbiAgfVxuXG4gIHJldHVybiB7IHR5cGU6IHR5cGUsIGRhdGE6IGRhdGEgfTtcbn07XG5cbi8qKlxuICogRW5jb2RlcyBtdWx0aXBsZSBtZXNzYWdlcyAocGF5bG9hZCkuXG4gKlxuICogICAgIDxsZW5ndGg+OmRhdGFcbiAqXG4gKiBFeGFtcGxlOlxuICpcbiAqICAgICAxMTpoZWxsbyB3b3JsZDI6aGlcbiAqXG4gKiBJZiBhbnkgY29udGVudHMgYXJlIGJpbmFyeSwgdGhleSB3aWxsIGJlIGVuY29kZWQgYXMgYmFzZTY0IHN0cmluZ3MuIEJhc2U2NFxuICogZW5jb2RlZCBzdHJpbmdzIGFyZSBtYXJrZWQgd2l0aCBhIGIgYmVmb3JlIHRoZSBsZW5ndGggc3BlY2lmaWVyXG4gKlxuICogQHBhcmFtIHtBcnJheX0gcGFja2V0c1xuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZXhwb3J0cy5lbmNvZGVQYXlsb2FkID0gZnVuY3Rpb24gKHBhY2tldHMsIHN1cHBvcnRzQmluYXJ5LCBjYWxsYmFjaykge1xuICBpZiAodHlwZW9mIHN1cHBvcnRzQmluYXJ5ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgY2FsbGJhY2sgPSBzdXBwb3J0c0JpbmFyeTtcbiAgICBzdXBwb3J0c0JpbmFyeSA9IG51bGw7XG4gIH1cblxuICB2YXIgaXNCaW5hcnkgPSBoYXNCaW5hcnkocGFja2V0cyk7XG5cbiAgaWYgKHN1cHBvcnRzQmluYXJ5ICYmIGlzQmluYXJ5KSB7XG4gICAgaWYgKEJsb2IgJiYgIWRvbnRTZW5kQmxvYnMpIHtcbiAgICAgIHJldHVybiBleHBvcnRzLmVuY29kZVBheWxvYWRBc0Jsb2IocGFja2V0cywgY2FsbGJhY2spO1xuICAgIH1cblxuICAgIHJldHVybiBleHBvcnRzLmVuY29kZVBheWxvYWRBc0FycmF5QnVmZmVyKHBhY2tldHMsIGNhbGxiYWNrKTtcbiAgfVxuXG4gIGlmICghcGFja2V0cy5sZW5ndGgpIHtcbiAgICByZXR1cm4gY2FsbGJhY2soJzA6Jyk7XG4gIH1cblxuICBmdW5jdGlvbiBzZXRMZW5ndGhIZWFkZXIobWVzc2FnZSkge1xuICAgIHJldHVybiBtZXNzYWdlLmxlbmd0aCArICc6JyArIG1lc3NhZ2U7XG4gIH1cblxuICBmdW5jdGlvbiBlbmNvZGVPbmUocGFja2V0LCBkb25lQ2FsbGJhY2spIHtcbiAgICBleHBvcnRzLmVuY29kZVBhY2tldChwYWNrZXQsICFpc0JpbmFyeSA/IGZhbHNlIDogc3VwcG9ydHNCaW5hcnksIGZhbHNlLCBmdW5jdGlvbihtZXNzYWdlKSB7XG4gICAgICBkb25lQ2FsbGJhY2sobnVsbCwgc2V0TGVuZ3RoSGVhZGVyKG1lc3NhZ2UpKTtcbiAgICB9KTtcbiAgfVxuXG4gIG1hcChwYWNrZXRzLCBlbmNvZGVPbmUsIGZ1bmN0aW9uKGVyciwgcmVzdWx0cykge1xuICAgIHJldHVybiBjYWxsYmFjayhyZXN1bHRzLmpvaW4oJycpKTtcbiAgfSk7XG59O1xuXG4vKipcbiAqIEFzeW5jIGFycmF5IG1hcCB1c2luZyBhZnRlclxuICovXG5cbmZ1bmN0aW9uIG1hcChhcnksIGVhY2gsIGRvbmUpIHtcbiAgdmFyIHJlc3VsdCA9IG5ldyBBcnJheShhcnkubGVuZ3RoKTtcbiAgdmFyIG5leHQgPSBhZnRlcihhcnkubGVuZ3RoLCBkb25lKTtcblxuICB2YXIgZWFjaFdpdGhJbmRleCA9IGZ1bmN0aW9uKGksIGVsLCBjYikge1xuICAgIGVhY2goZWwsIGZ1bmN0aW9uKGVycm9yLCBtc2cpIHtcbiAgICAgIHJlc3VsdFtpXSA9IG1zZztcbiAgICAgIGNiKGVycm9yLCByZXN1bHQpO1xuICAgIH0pO1xuICB9O1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgYXJ5Lmxlbmd0aDsgaSsrKSB7XG4gICAgZWFjaFdpdGhJbmRleChpLCBhcnlbaV0sIG5leHQpO1xuICB9XG59XG5cbi8qXG4gKiBEZWNvZGVzIGRhdGEgd2hlbiBhIHBheWxvYWQgaXMgbWF5YmUgZXhwZWN0ZWQuIFBvc3NpYmxlIGJpbmFyeSBjb250ZW50cyBhcmVcbiAqIGRlY29kZWQgZnJvbSB0aGVpciBiYXNlNjQgcmVwcmVzZW50YXRpb25cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gZGF0YSwgY2FsbGJhY2sgbWV0aG9kXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmV4cG9ydHMuZGVjb2RlUGF5bG9hZCA9IGZ1bmN0aW9uIChkYXRhLCBiaW5hcnlUeXBlLCBjYWxsYmFjaykge1xuICBpZiAodHlwZW9mIGRhdGEgIT09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIGV4cG9ydHMuZGVjb2RlUGF5bG9hZEFzQmluYXJ5KGRhdGEsIGJpbmFyeVR5cGUsIGNhbGxiYWNrKTtcbiAgfVxuXG4gIGlmICh0eXBlb2YgYmluYXJ5VHlwZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGNhbGxiYWNrID0gYmluYXJ5VHlwZTtcbiAgICBiaW5hcnlUeXBlID0gbnVsbDtcbiAgfVxuXG4gIHZhciBwYWNrZXQ7XG4gIGlmIChkYXRhID09PSAnJykge1xuICAgIC8vIHBhcnNlciBlcnJvciAtIGlnbm9yaW5nIHBheWxvYWRcbiAgICByZXR1cm4gY2FsbGJhY2soZXJyLCAwLCAxKTtcbiAgfVxuXG4gIHZhciBsZW5ndGggPSAnJywgbiwgbXNnO1xuXG4gIGZvciAodmFyIGkgPSAwLCBsID0gZGF0YS5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICB2YXIgY2hyID0gZGF0YS5jaGFyQXQoaSk7XG5cbiAgICBpZiAoY2hyICE9PSAnOicpIHtcbiAgICAgIGxlbmd0aCArPSBjaHI7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICBpZiAobGVuZ3RoID09PSAnJyB8fCAobGVuZ3RoICE9IChuID0gTnVtYmVyKGxlbmd0aCkpKSkge1xuICAgICAgLy8gcGFyc2VyIGVycm9yIC0gaWdub3JpbmcgcGF5bG9hZFxuICAgICAgcmV0dXJuIGNhbGxiYWNrKGVyciwgMCwgMSk7XG4gICAgfVxuXG4gICAgbXNnID0gZGF0YS5zdWJzdHIoaSArIDEsIG4pO1xuXG4gICAgaWYgKGxlbmd0aCAhPSBtc2cubGVuZ3RoKSB7XG4gICAgICAvLyBwYXJzZXIgZXJyb3IgLSBpZ25vcmluZyBwYXlsb2FkXG4gICAgICByZXR1cm4gY2FsbGJhY2soZXJyLCAwLCAxKTtcbiAgICB9XG5cbiAgICBpZiAobXNnLmxlbmd0aCkge1xuICAgICAgcGFja2V0ID0gZXhwb3J0cy5kZWNvZGVQYWNrZXQobXNnLCBiaW5hcnlUeXBlLCBmYWxzZSk7XG5cbiAgICAgIGlmIChlcnIudHlwZSA9PT0gcGFja2V0LnR5cGUgJiYgZXJyLmRhdGEgPT09IHBhY2tldC5kYXRhKSB7XG4gICAgICAgIC8vIHBhcnNlciBlcnJvciBpbiBpbmRpdmlkdWFsIHBhY2tldCAtIGlnbm9yaW5nIHBheWxvYWRcbiAgICAgICAgcmV0dXJuIGNhbGxiYWNrKGVyciwgMCwgMSk7XG4gICAgICB9XG5cbiAgICAgIHZhciByZXQgPSBjYWxsYmFjayhwYWNrZXQsIGkgKyBuLCBsKTtcbiAgICAgIGlmIChmYWxzZSA9PT0gcmV0KSByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gYWR2YW5jZSBjdXJzb3JcbiAgICBpICs9IG47XG4gICAgbGVuZ3RoID0gJyc7XG4gIH1cblxuICBpZiAobGVuZ3RoICE9PSAnJykge1xuICAgIC8vIHBhcnNlciBlcnJvciAtIGlnbm9yaW5nIHBheWxvYWRcbiAgICByZXR1cm4gY2FsbGJhY2soZXJyLCAwLCAxKTtcbiAgfVxuXG59O1xuXG4vKipcbiAqIEVuY29kZXMgbXVsdGlwbGUgbWVzc2FnZXMgKHBheWxvYWQpIGFzIGJpbmFyeS5cbiAqXG4gKiA8MSA9IGJpbmFyeSwgMCA9IHN0cmluZz48bnVtYmVyIGZyb20gMC05PjxudW1iZXIgZnJvbSAwLTk+Wy4uLl08bnVtYmVyXG4gKiAyNTU+PGRhdGE+XG4gKlxuICogRXhhbXBsZTpcbiAqIDEgMyAyNTUgMSAyIDMsIGlmIHRoZSBiaW5hcnkgY29udGVudHMgYXJlIGludGVycHJldGVkIGFzIDggYml0IGludGVnZXJzXG4gKlxuICogQHBhcmFtIHtBcnJheX0gcGFja2V0c1xuICogQHJldHVybiB7QXJyYXlCdWZmZXJ9IGVuY29kZWQgcGF5bG9hZFxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZXhwb3J0cy5lbmNvZGVQYXlsb2FkQXNBcnJheUJ1ZmZlciA9IGZ1bmN0aW9uKHBhY2tldHMsIGNhbGxiYWNrKSB7XG4gIGlmICghcGFja2V0cy5sZW5ndGgpIHtcbiAgICByZXR1cm4gY2FsbGJhY2sobmV3IEFycmF5QnVmZmVyKDApKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGVuY29kZU9uZShwYWNrZXQsIGRvbmVDYWxsYmFjaykge1xuICAgIGV4cG9ydHMuZW5jb2RlUGFja2V0KHBhY2tldCwgdHJ1ZSwgdHJ1ZSwgZnVuY3Rpb24oZGF0YSkge1xuICAgICAgcmV0dXJuIGRvbmVDYWxsYmFjayhudWxsLCBkYXRhKTtcbiAgICB9KTtcbiAgfVxuXG4gIG1hcChwYWNrZXRzLCBlbmNvZGVPbmUsIGZ1bmN0aW9uKGVyciwgZW5jb2RlZFBhY2tldHMpIHtcbiAgICB2YXIgdG90YWxMZW5ndGggPSBlbmNvZGVkUGFja2V0cy5yZWR1Y2UoZnVuY3Rpb24oYWNjLCBwKSB7XG4gICAgICB2YXIgbGVuO1xuICAgICAgaWYgKHR5cGVvZiBwID09PSAnc3RyaW5nJyl7XG4gICAgICAgIGxlbiA9IHAubGVuZ3RoO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbGVuID0gcC5ieXRlTGVuZ3RoO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGFjYyArIGxlbi50b1N0cmluZygpLmxlbmd0aCArIGxlbiArIDI7IC8vIHN0cmluZy9iaW5hcnkgaWRlbnRpZmllciArIHNlcGFyYXRvciA9IDJcbiAgICB9LCAwKTtcblxuICAgIHZhciByZXN1bHRBcnJheSA9IG5ldyBVaW50OEFycmF5KHRvdGFsTGVuZ3RoKTtcblxuICAgIHZhciBidWZmZXJJbmRleCA9IDA7XG4gICAgZW5jb2RlZFBhY2tldHMuZm9yRWFjaChmdW5jdGlvbihwKSB7XG4gICAgICB2YXIgaXNTdHJpbmcgPSB0eXBlb2YgcCA9PT0gJ3N0cmluZyc7XG4gICAgICB2YXIgYWIgPSBwO1xuICAgICAgaWYgKGlzU3RyaW5nKSB7XG4gICAgICAgIHZhciB2aWV3ID0gbmV3IFVpbnQ4QXJyYXkocC5sZW5ndGgpO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHAubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICB2aWV3W2ldID0gcC5jaGFyQ29kZUF0KGkpO1xuICAgICAgICB9XG4gICAgICAgIGFiID0gdmlldy5idWZmZXI7XG4gICAgICB9XG5cbiAgICAgIGlmIChpc1N0cmluZykgeyAvLyBub3QgdHJ1ZSBiaW5hcnlcbiAgICAgICAgcmVzdWx0QXJyYXlbYnVmZmVySW5kZXgrK10gPSAwO1xuICAgICAgfSBlbHNlIHsgLy8gdHJ1ZSBiaW5hcnlcbiAgICAgICAgcmVzdWx0QXJyYXlbYnVmZmVySW5kZXgrK10gPSAxO1xuICAgICAgfVxuXG4gICAgICB2YXIgbGVuU3RyID0gYWIuYnl0ZUxlbmd0aC50b1N0cmluZygpO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5TdHIubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgcmVzdWx0QXJyYXlbYnVmZmVySW5kZXgrK10gPSBwYXJzZUludChsZW5TdHJbaV0pO1xuICAgICAgfVxuICAgICAgcmVzdWx0QXJyYXlbYnVmZmVySW5kZXgrK10gPSAyNTU7XG5cbiAgICAgIHZhciB2aWV3ID0gbmV3IFVpbnQ4QXJyYXkoYWIpO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB2aWV3Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHJlc3VsdEFycmF5W2J1ZmZlckluZGV4KytdID0gdmlld1tpXTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIHJldHVybiBjYWxsYmFjayhyZXN1bHRBcnJheS5idWZmZXIpO1xuICB9KTtcbn07XG5cbi8qKlxuICogRW5jb2RlIGFzIEJsb2JcbiAqL1xuXG5leHBvcnRzLmVuY29kZVBheWxvYWRBc0Jsb2IgPSBmdW5jdGlvbihwYWNrZXRzLCBjYWxsYmFjaykge1xuICBmdW5jdGlvbiBlbmNvZGVPbmUocGFja2V0LCBkb25lQ2FsbGJhY2spIHtcbiAgICBleHBvcnRzLmVuY29kZVBhY2tldChwYWNrZXQsIHRydWUsIHRydWUsIGZ1bmN0aW9uKGVuY29kZWQpIHtcbiAgICAgIHZhciBiaW5hcnlJZGVudGlmaWVyID0gbmV3IFVpbnQ4QXJyYXkoMSk7XG4gICAgICBiaW5hcnlJZGVudGlmaWVyWzBdID0gMTtcbiAgICAgIGlmICh0eXBlb2YgZW5jb2RlZCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgdmFyIHZpZXcgPSBuZXcgVWludDhBcnJheShlbmNvZGVkLmxlbmd0aCk7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZW5jb2RlZC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIHZpZXdbaV0gPSBlbmNvZGVkLmNoYXJDb2RlQXQoaSk7XG4gICAgICAgIH1cbiAgICAgICAgZW5jb2RlZCA9IHZpZXcuYnVmZmVyO1xuICAgICAgICBiaW5hcnlJZGVudGlmaWVyWzBdID0gMDtcbiAgICAgIH1cblxuICAgICAgdmFyIGxlbiA9IChlbmNvZGVkIGluc3RhbmNlb2YgQXJyYXlCdWZmZXIpXG4gICAgICAgID8gZW5jb2RlZC5ieXRlTGVuZ3RoXG4gICAgICAgIDogZW5jb2RlZC5zaXplO1xuXG4gICAgICB2YXIgbGVuU3RyID0gbGVuLnRvU3RyaW5nKCk7XG4gICAgICB2YXIgbGVuZ3RoQXJ5ID0gbmV3IFVpbnQ4QXJyYXkobGVuU3RyLmxlbmd0aCArIDEpO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5TdHIubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgbGVuZ3RoQXJ5W2ldID0gcGFyc2VJbnQobGVuU3RyW2ldKTtcbiAgICAgIH1cbiAgICAgIGxlbmd0aEFyeVtsZW5TdHIubGVuZ3RoXSA9IDI1NTtcblxuICAgICAgaWYgKEJsb2IpIHtcbiAgICAgICAgdmFyIGJsb2IgPSBuZXcgQmxvYihbYmluYXJ5SWRlbnRpZmllci5idWZmZXIsIGxlbmd0aEFyeS5idWZmZXIsIGVuY29kZWRdKTtcbiAgICAgICAgZG9uZUNhbGxiYWNrKG51bGwsIGJsb2IpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgbWFwKHBhY2tldHMsIGVuY29kZU9uZSwgZnVuY3Rpb24oZXJyLCByZXN1bHRzKSB7XG4gICAgcmV0dXJuIGNhbGxiYWNrKG5ldyBCbG9iKHJlc3VsdHMpKTtcbiAgfSk7XG59O1xuXG4vKlxuICogRGVjb2RlcyBkYXRhIHdoZW4gYSBwYXlsb2FkIGlzIG1heWJlIGV4cGVjdGVkLiBTdHJpbmdzIGFyZSBkZWNvZGVkIGJ5XG4gKiBpbnRlcnByZXRpbmcgZWFjaCBieXRlIGFzIGEga2V5IGNvZGUgZm9yIGVudHJpZXMgbWFya2VkIHRvIHN0YXJ0IHdpdGggMC4gU2VlXG4gKiBkZXNjcmlwdGlvbiBvZiBlbmNvZGVQYXlsb2FkQXNCaW5hcnlcbiAqXG4gKiBAcGFyYW0ge0FycmF5QnVmZmVyfSBkYXRhLCBjYWxsYmFjayBtZXRob2RcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZXhwb3J0cy5kZWNvZGVQYXlsb2FkQXNCaW5hcnkgPSBmdW5jdGlvbiAoZGF0YSwgYmluYXJ5VHlwZSwgY2FsbGJhY2spIHtcbiAgaWYgKHR5cGVvZiBiaW5hcnlUeXBlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgY2FsbGJhY2sgPSBiaW5hcnlUeXBlO1xuICAgIGJpbmFyeVR5cGUgPSBudWxsO1xuICB9XG5cbiAgdmFyIGJ1ZmZlclRhaWwgPSBkYXRhO1xuICB2YXIgYnVmZmVycyA9IFtdO1xuXG4gIHdoaWxlIChidWZmZXJUYWlsLmJ5dGVMZW5ndGggPiAwKSB7XG4gICAgdmFyIHRhaWxBcnJheSA9IG5ldyBVaW50OEFycmF5KGJ1ZmZlclRhaWwpO1xuICAgIHZhciBpc1N0cmluZyA9IHRhaWxBcnJheVswXSA9PT0gMDtcbiAgICB2YXIgbXNnTGVuZ3RoID0gJyc7XG5cbiAgICBmb3IgKHZhciBpID0gMTsgOyBpKyspIHtcbiAgICAgIGlmICh0YWlsQXJyYXlbaV0gPT09IDI1NSkgYnJlYWs7XG5cbiAgICAgIC8vIDMxMCA9IGNoYXIgbGVuZ3RoIG9mIE51bWJlci5NQVhfVkFMVUVcbiAgICAgIGlmIChtc2dMZW5ndGgubGVuZ3RoID4gMzEwKSB7XG4gICAgICAgIHJldHVybiBjYWxsYmFjayhlcnIsIDAsIDEpO1xuICAgICAgfVxuXG4gICAgICBtc2dMZW5ndGggKz0gdGFpbEFycmF5W2ldO1xuICAgIH1cblxuICAgIGJ1ZmZlclRhaWwgPSBzbGljZUJ1ZmZlcihidWZmZXJUYWlsLCAyICsgbXNnTGVuZ3RoLmxlbmd0aCk7XG4gICAgbXNnTGVuZ3RoID0gcGFyc2VJbnQobXNnTGVuZ3RoKTtcblxuICAgIHZhciBtc2cgPSBzbGljZUJ1ZmZlcihidWZmZXJUYWlsLCAwLCBtc2dMZW5ndGgpO1xuICAgIGlmIChpc1N0cmluZykge1xuICAgICAgdHJ5IHtcbiAgICAgICAgbXNnID0gU3RyaW5nLmZyb21DaGFyQ29kZS5hcHBseShudWxsLCBuZXcgVWludDhBcnJheShtc2cpKTtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgLy8gaVBob25lIFNhZmFyaSBkb2Vzbid0IGxldCB5b3UgYXBwbHkgdG8gdHlwZWQgYXJyYXlzXG4gICAgICAgIHZhciB0eXBlZCA9IG5ldyBVaW50OEFycmF5KG1zZyk7XG4gICAgICAgIG1zZyA9ICcnO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHR5cGVkLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgbXNnICs9IFN0cmluZy5mcm9tQ2hhckNvZGUodHlwZWRbaV0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgYnVmZmVycy5wdXNoKG1zZyk7XG4gICAgYnVmZmVyVGFpbCA9IHNsaWNlQnVmZmVyKGJ1ZmZlclRhaWwsIG1zZ0xlbmd0aCk7XG4gIH1cblxuICB2YXIgdG90YWwgPSBidWZmZXJzLmxlbmd0aDtcbiAgYnVmZmVycy5mb3JFYWNoKGZ1bmN0aW9uKGJ1ZmZlciwgaSkge1xuICAgIGNhbGxiYWNrKGV4cG9ydHMuZGVjb2RlUGFja2V0KGJ1ZmZlciwgYmluYXJ5VHlwZSwgdHJ1ZSksIGksIHRvdGFsKTtcbiAgfSk7XG59O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2VuZ2luZS5pby1wYXJzZXIvbGliL2Jyb3dzZXIuanNcbi8vIG1vZHVsZSBpZCA9IDIwXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIlxuLyoqXG4gKiBHZXRzIHRoZSBrZXlzIGZvciBhbiBvYmplY3QuXG4gKlxuICogQHJldHVybiB7QXJyYXl9IGtleXNcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbm1vZHVsZS5leHBvcnRzID0gT2JqZWN0LmtleXMgfHwgZnVuY3Rpb24ga2V5cyAob2JqKXtcbiAgdmFyIGFyciA9IFtdO1xuICB2YXIgaGFzID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eTtcblxuICBmb3IgKHZhciBpIGluIG9iaikge1xuICAgIGlmIChoYXMuY2FsbChvYmosIGkpKSB7XG4gICAgICBhcnIucHVzaChpKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGFycjtcbn07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vZW5naW5lLmlvLXBhcnNlci9saWIva2V5cy5qc1xuLy8gbW9kdWxlIGlkID0gMjFcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLyoqXG4gKiBBbiBhYnN0cmFjdGlvbiBmb3Igc2xpY2luZyBhbiBhcnJheWJ1ZmZlciBldmVuIHdoZW5cbiAqIEFycmF5QnVmZmVyLnByb3RvdHlwZS5zbGljZSBpcyBub3Qgc3VwcG9ydGVkXG4gKlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGFycmF5YnVmZmVyLCBzdGFydCwgZW5kKSB7XG4gIHZhciBieXRlcyA9IGFycmF5YnVmZmVyLmJ5dGVMZW5ndGg7XG4gIHN0YXJ0ID0gc3RhcnQgfHwgMDtcbiAgZW5kID0gZW5kIHx8IGJ5dGVzO1xuXG4gIGlmIChhcnJheWJ1ZmZlci5zbGljZSkgeyByZXR1cm4gYXJyYXlidWZmZXIuc2xpY2Uoc3RhcnQsIGVuZCk7IH1cblxuICBpZiAoc3RhcnQgPCAwKSB7IHN0YXJ0ICs9IGJ5dGVzOyB9XG4gIGlmIChlbmQgPCAwKSB7IGVuZCArPSBieXRlczsgfVxuICBpZiAoZW5kID4gYnl0ZXMpIHsgZW5kID0gYnl0ZXM7IH1cblxuICBpZiAoc3RhcnQgPj0gYnl0ZXMgfHwgc3RhcnQgPj0gZW5kIHx8IGJ5dGVzID09PSAwKSB7XG4gICAgcmV0dXJuIG5ldyBBcnJheUJ1ZmZlcigwKTtcbiAgfVxuXG4gIHZhciBhYnYgPSBuZXcgVWludDhBcnJheShhcnJheWJ1ZmZlcik7XG4gIHZhciByZXN1bHQgPSBuZXcgVWludDhBcnJheShlbmQgLSBzdGFydCk7XG4gIGZvciAodmFyIGkgPSBzdGFydCwgaWkgPSAwOyBpIDwgZW5kOyBpKyssIGlpKyspIHtcbiAgICByZXN1bHRbaWldID0gYWJ2W2ldO1xuICB9XG4gIHJldHVybiByZXN1bHQuYnVmZmVyO1xufTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9hcnJheWJ1ZmZlci5zbGljZS9pbmRleC5qc1xuLy8gbW9kdWxlIGlkID0gMjJcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwibW9kdWxlLmV4cG9ydHMgPSBhZnRlclxuXG5mdW5jdGlvbiBhZnRlcihjb3VudCwgY2FsbGJhY2ssIGVycl9jYikge1xuICAgIHZhciBiYWlsID0gZmFsc2VcbiAgICBlcnJfY2IgPSBlcnJfY2IgfHwgbm9vcFxuICAgIHByb3h5LmNvdW50ID0gY291bnRcblxuICAgIHJldHVybiAoY291bnQgPT09IDApID8gY2FsbGJhY2soKSA6IHByb3h5XG5cbiAgICBmdW5jdGlvbiBwcm94eShlcnIsIHJlc3VsdCkge1xuICAgICAgICBpZiAocHJveHkuY291bnQgPD0gMCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdhZnRlciBjYWxsZWQgdG9vIG1hbnkgdGltZXMnKVxuICAgICAgICB9XG4gICAgICAgIC0tcHJveHkuY291bnRcblxuICAgICAgICAvLyBhZnRlciBmaXJzdCBlcnJvciwgcmVzdCBhcmUgcGFzc2VkIHRvIGVycl9jYlxuICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgICBiYWlsID0gdHJ1ZVxuICAgICAgICAgICAgY2FsbGJhY2soZXJyKVxuICAgICAgICAgICAgLy8gZnV0dXJlIGVycm9yIGNhbGxiYWNrcyB3aWxsIGdvIHRvIGVycm9yIGhhbmRsZXJcbiAgICAgICAgICAgIGNhbGxiYWNrID0gZXJyX2NiXG4gICAgICAgIH0gZWxzZSBpZiAocHJveHkuY291bnQgPT09IDAgJiYgIWJhaWwpIHtcbiAgICAgICAgICAgIGNhbGxiYWNrKG51bGwsIHJlc3VsdClcbiAgICAgICAgfVxuICAgIH1cbn1cblxuZnVuY3Rpb24gbm9vcCgpIHt9XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vYWZ0ZXIvaW5kZXguanNcbi8vIG1vZHVsZSBpZCA9IDIzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qISBodHRwczovL210aHMuYmUvdXRmOGpzIHYyLjEuMiBieSBAbWF0aGlhcyAqL1xuOyhmdW5jdGlvbihyb290KSB7XG5cblx0Ly8gRGV0ZWN0IGZyZWUgdmFyaWFibGVzIGBleHBvcnRzYFxuXHR2YXIgZnJlZUV4cG9ydHMgPSB0eXBlb2YgZXhwb3J0cyA9PSAnb2JqZWN0JyAmJiBleHBvcnRzO1xuXG5cdC8vIERldGVjdCBmcmVlIHZhcmlhYmxlIGBtb2R1bGVgXG5cdHZhciBmcmVlTW9kdWxlID0gdHlwZW9mIG1vZHVsZSA9PSAnb2JqZWN0JyAmJiBtb2R1bGUgJiZcblx0XHRtb2R1bGUuZXhwb3J0cyA9PSBmcmVlRXhwb3J0cyAmJiBtb2R1bGU7XG5cblx0Ly8gRGV0ZWN0IGZyZWUgdmFyaWFibGUgYGdsb2JhbGAsIGZyb20gTm9kZS5qcyBvciBCcm93c2VyaWZpZWQgY29kZSxcblx0Ly8gYW5kIHVzZSBpdCBhcyBgcm9vdGBcblx0dmFyIGZyZWVHbG9iYWwgPSB0eXBlb2YgZ2xvYmFsID09ICdvYmplY3QnICYmIGdsb2JhbDtcblx0aWYgKGZyZWVHbG9iYWwuZ2xvYmFsID09PSBmcmVlR2xvYmFsIHx8IGZyZWVHbG9iYWwud2luZG93ID09PSBmcmVlR2xvYmFsKSB7XG5cdFx0cm9vdCA9IGZyZWVHbG9iYWw7XG5cdH1cblxuXHQvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuXHR2YXIgc3RyaW5nRnJvbUNoYXJDb2RlID0gU3RyaW5nLmZyb21DaGFyQ29kZTtcblxuXHQvLyBUYWtlbiBmcm9tIGh0dHBzOi8vbXRocy5iZS9wdW55Y29kZVxuXHRmdW5jdGlvbiB1Y3MyZGVjb2RlKHN0cmluZykge1xuXHRcdHZhciBvdXRwdXQgPSBbXTtcblx0XHR2YXIgY291bnRlciA9IDA7XG5cdFx0dmFyIGxlbmd0aCA9IHN0cmluZy5sZW5ndGg7XG5cdFx0dmFyIHZhbHVlO1xuXHRcdHZhciBleHRyYTtcblx0XHR3aGlsZSAoY291bnRlciA8IGxlbmd0aCkge1xuXHRcdFx0dmFsdWUgPSBzdHJpbmcuY2hhckNvZGVBdChjb3VudGVyKyspO1xuXHRcdFx0aWYgKHZhbHVlID49IDB4RDgwMCAmJiB2YWx1ZSA8PSAweERCRkYgJiYgY291bnRlciA8IGxlbmd0aCkge1xuXHRcdFx0XHQvLyBoaWdoIHN1cnJvZ2F0ZSwgYW5kIHRoZXJlIGlzIGEgbmV4dCBjaGFyYWN0ZXJcblx0XHRcdFx0ZXh0cmEgPSBzdHJpbmcuY2hhckNvZGVBdChjb3VudGVyKyspO1xuXHRcdFx0XHRpZiAoKGV4dHJhICYgMHhGQzAwKSA9PSAweERDMDApIHsgLy8gbG93IHN1cnJvZ2F0ZVxuXHRcdFx0XHRcdG91dHB1dC5wdXNoKCgodmFsdWUgJiAweDNGRikgPDwgMTApICsgKGV4dHJhICYgMHgzRkYpICsgMHgxMDAwMCk7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0Ly8gdW5tYXRjaGVkIHN1cnJvZ2F0ZTsgb25seSBhcHBlbmQgdGhpcyBjb2RlIHVuaXQsIGluIGNhc2UgdGhlIG5leHRcblx0XHRcdFx0XHQvLyBjb2RlIHVuaXQgaXMgdGhlIGhpZ2ggc3Vycm9nYXRlIG9mIGEgc3Vycm9nYXRlIHBhaXJcblx0XHRcdFx0XHRvdXRwdXQucHVzaCh2YWx1ZSk7XG5cdFx0XHRcdFx0Y291bnRlci0tO1xuXHRcdFx0XHR9XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRvdXRwdXQucHVzaCh2YWx1ZSk7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHJldHVybiBvdXRwdXQ7XG5cdH1cblxuXHQvLyBUYWtlbiBmcm9tIGh0dHBzOi8vbXRocy5iZS9wdW55Y29kZVxuXHRmdW5jdGlvbiB1Y3MyZW5jb2RlKGFycmF5KSB7XG5cdFx0dmFyIGxlbmd0aCA9IGFycmF5Lmxlbmd0aDtcblx0XHR2YXIgaW5kZXggPSAtMTtcblx0XHR2YXIgdmFsdWU7XG5cdFx0dmFyIG91dHB1dCA9ICcnO1xuXHRcdHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG5cdFx0XHR2YWx1ZSA9IGFycmF5W2luZGV4XTtcblx0XHRcdGlmICh2YWx1ZSA+IDB4RkZGRikge1xuXHRcdFx0XHR2YWx1ZSAtPSAweDEwMDAwO1xuXHRcdFx0XHRvdXRwdXQgKz0gc3RyaW5nRnJvbUNoYXJDb2RlKHZhbHVlID4+PiAxMCAmIDB4M0ZGIHwgMHhEODAwKTtcblx0XHRcdFx0dmFsdWUgPSAweERDMDAgfCB2YWx1ZSAmIDB4M0ZGO1xuXHRcdFx0fVxuXHRcdFx0b3V0cHV0ICs9IHN0cmluZ0Zyb21DaGFyQ29kZSh2YWx1ZSk7XG5cdFx0fVxuXHRcdHJldHVybiBvdXRwdXQ7XG5cdH1cblxuXHRmdW5jdGlvbiBjaGVja1NjYWxhclZhbHVlKGNvZGVQb2ludCwgc3RyaWN0KSB7XG5cdFx0aWYgKGNvZGVQb2ludCA+PSAweEQ4MDAgJiYgY29kZVBvaW50IDw9IDB4REZGRikge1xuXHRcdFx0aWYgKHN0cmljdCkge1xuXHRcdFx0XHR0aHJvdyBFcnJvcihcblx0XHRcdFx0XHQnTG9uZSBzdXJyb2dhdGUgVSsnICsgY29kZVBvaW50LnRvU3RyaW5nKDE2KS50b1VwcGVyQ2FzZSgpICtcblx0XHRcdFx0XHQnIGlzIG5vdCBhIHNjYWxhciB2YWx1ZSdcblx0XHRcdFx0KTtcblx0XHRcdH1cblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9XG5cdFx0cmV0dXJuIHRydWU7XG5cdH1cblx0LyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cblx0ZnVuY3Rpb24gY3JlYXRlQnl0ZShjb2RlUG9pbnQsIHNoaWZ0KSB7XG5cdFx0cmV0dXJuIHN0cmluZ0Zyb21DaGFyQ29kZSgoKGNvZGVQb2ludCA+PiBzaGlmdCkgJiAweDNGKSB8IDB4ODApO1xuXHR9XG5cblx0ZnVuY3Rpb24gZW5jb2RlQ29kZVBvaW50KGNvZGVQb2ludCwgc3RyaWN0KSB7XG5cdFx0aWYgKChjb2RlUG9pbnQgJiAweEZGRkZGRjgwKSA9PSAwKSB7IC8vIDEtYnl0ZSBzZXF1ZW5jZVxuXHRcdFx0cmV0dXJuIHN0cmluZ0Zyb21DaGFyQ29kZShjb2RlUG9pbnQpO1xuXHRcdH1cblx0XHR2YXIgc3ltYm9sID0gJyc7XG5cdFx0aWYgKChjb2RlUG9pbnQgJiAweEZGRkZGODAwKSA9PSAwKSB7IC8vIDItYnl0ZSBzZXF1ZW5jZVxuXHRcdFx0c3ltYm9sID0gc3RyaW5nRnJvbUNoYXJDb2RlKCgoY29kZVBvaW50ID4+IDYpICYgMHgxRikgfCAweEMwKTtcblx0XHR9XG5cdFx0ZWxzZSBpZiAoKGNvZGVQb2ludCAmIDB4RkZGRjAwMDApID09IDApIHsgLy8gMy1ieXRlIHNlcXVlbmNlXG5cdFx0XHRpZiAoIWNoZWNrU2NhbGFyVmFsdWUoY29kZVBvaW50LCBzdHJpY3QpKSB7XG5cdFx0XHRcdGNvZGVQb2ludCA9IDB4RkZGRDtcblx0XHRcdH1cblx0XHRcdHN5bWJvbCA9IHN0cmluZ0Zyb21DaGFyQ29kZSgoKGNvZGVQb2ludCA+PiAxMikgJiAweDBGKSB8IDB4RTApO1xuXHRcdFx0c3ltYm9sICs9IGNyZWF0ZUJ5dGUoY29kZVBvaW50LCA2KTtcblx0XHR9XG5cdFx0ZWxzZSBpZiAoKGNvZGVQb2ludCAmIDB4RkZFMDAwMDApID09IDApIHsgLy8gNC1ieXRlIHNlcXVlbmNlXG5cdFx0XHRzeW1ib2wgPSBzdHJpbmdGcm9tQ2hhckNvZGUoKChjb2RlUG9pbnQgPj4gMTgpICYgMHgwNykgfCAweEYwKTtcblx0XHRcdHN5bWJvbCArPSBjcmVhdGVCeXRlKGNvZGVQb2ludCwgMTIpO1xuXHRcdFx0c3ltYm9sICs9IGNyZWF0ZUJ5dGUoY29kZVBvaW50LCA2KTtcblx0XHR9XG5cdFx0c3ltYm9sICs9IHN0cmluZ0Zyb21DaGFyQ29kZSgoY29kZVBvaW50ICYgMHgzRikgfCAweDgwKTtcblx0XHRyZXR1cm4gc3ltYm9sO1xuXHR9XG5cblx0ZnVuY3Rpb24gdXRmOGVuY29kZShzdHJpbmcsIG9wdHMpIHtcblx0XHRvcHRzID0gb3B0cyB8fCB7fTtcblx0XHR2YXIgc3RyaWN0ID0gZmFsc2UgIT09IG9wdHMuc3RyaWN0O1xuXG5cdFx0dmFyIGNvZGVQb2ludHMgPSB1Y3MyZGVjb2RlKHN0cmluZyk7XG5cdFx0dmFyIGxlbmd0aCA9IGNvZGVQb2ludHMubGVuZ3RoO1xuXHRcdHZhciBpbmRleCA9IC0xO1xuXHRcdHZhciBjb2RlUG9pbnQ7XG5cdFx0dmFyIGJ5dGVTdHJpbmcgPSAnJztcblx0XHR3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuXHRcdFx0Y29kZVBvaW50ID0gY29kZVBvaW50c1tpbmRleF07XG5cdFx0XHRieXRlU3RyaW5nICs9IGVuY29kZUNvZGVQb2ludChjb2RlUG9pbnQsIHN0cmljdCk7XG5cdFx0fVxuXHRcdHJldHVybiBieXRlU3RyaW5nO1xuXHR9XG5cblx0LyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cblx0ZnVuY3Rpb24gcmVhZENvbnRpbnVhdGlvbkJ5dGUoKSB7XG5cdFx0aWYgKGJ5dGVJbmRleCA+PSBieXRlQ291bnQpIHtcblx0XHRcdHRocm93IEVycm9yKCdJbnZhbGlkIGJ5dGUgaW5kZXgnKTtcblx0XHR9XG5cblx0XHR2YXIgY29udGludWF0aW9uQnl0ZSA9IGJ5dGVBcnJheVtieXRlSW5kZXhdICYgMHhGRjtcblx0XHRieXRlSW5kZXgrKztcblxuXHRcdGlmICgoY29udGludWF0aW9uQnl0ZSAmIDB4QzApID09IDB4ODApIHtcblx0XHRcdHJldHVybiBjb250aW51YXRpb25CeXRlICYgMHgzRjtcblx0XHR9XG5cblx0XHQvLyBJZiB3ZSBlbmQgdXAgaGVyZSwgaXTigJlzIG5vdCBhIGNvbnRpbnVhdGlvbiBieXRlXG5cdFx0dGhyb3cgRXJyb3IoJ0ludmFsaWQgY29udGludWF0aW9uIGJ5dGUnKTtcblx0fVxuXG5cdGZ1bmN0aW9uIGRlY29kZVN5bWJvbChzdHJpY3QpIHtcblx0XHR2YXIgYnl0ZTE7XG5cdFx0dmFyIGJ5dGUyO1xuXHRcdHZhciBieXRlMztcblx0XHR2YXIgYnl0ZTQ7XG5cdFx0dmFyIGNvZGVQb2ludDtcblxuXHRcdGlmIChieXRlSW5kZXggPiBieXRlQ291bnQpIHtcblx0XHRcdHRocm93IEVycm9yKCdJbnZhbGlkIGJ5dGUgaW5kZXgnKTtcblx0XHR9XG5cblx0XHRpZiAoYnl0ZUluZGV4ID09IGJ5dGVDb3VudCkge1xuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH1cblxuXHRcdC8vIFJlYWQgZmlyc3QgYnl0ZVxuXHRcdGJ5dGUxID0gYnl0ZUFycmF5W2J5dGVJbmRleF0gJiAweEZGO1xuXHRcdGJ5dGVJbmRleCsrO1xuXG5cdFx0Ly8gMS1ieXRlIHNlcXVlbmNlIChubyBjb250aW51YXRpb24gYnl0ZXMpXG5cdFx0aWYgKChieXRlMSAmIDB4ODApID09IDApIHtcblx0XHRcdHJldHVybiBieXRlMTtcblx0XHR9XG5cblx0XHQvLyAyLWJ5dGUgc2VxdWVuY2Vcblx0XHRpZiAoKGJ5dGUxICYgMHhFMCkgPT0gMHhDMCkge1xuXHRcdFx0Ynl0ZTIgPSByZWFkQ29udGludWF0aW9uQnl0ZSgpO1xuXHRcdFx0Y29kZVBvaW50ID0gKChieXRlMSAmIDB4MUYpIDw8IDYpIHwgYnl0ZTI7XG5cdFx0XHRpZiAoY29kZVBvaW50ID49IDB4ODApIHtcblx0XHRcdFx0cmV0dXJuIGNvZGVQb2ludDtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHRocm93IEVycm9yKCdJbnZhbGlkIGNvbnRpbnVhdGlvbiBieXRlJyk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gMy1ieXRlIHNlcXVlbmNlIChtYXkgaW5jbHVkZSB1bnBhaXJlZCBzdXJyb2dhdGVzKVxuXHRcdGlmICgoYnl0ZTEgJiAweEYwKSA9PSAweEUwKSB7XG5cdFx0XHRieXRlMiA9IHJlYWRDb250aW51YXRpb25CeXRlKCk7XG5cdFx0XHRieXRlMyA9IHJlYWRDb250aW51YXRpb25CeXRlKCk7XG5cdFx0XHRjb2RlUG9pbnQgPSAoKGJ5dGUxICYgMHgwRikgPDwgMTIpIHwgKGJ5dGUyIDw8IDYpIHwgYnl0ZTM7XG5cdFx0XHRpZiAoY29kZVBvaW50ID49IDB4MDgwMCkge1xuXHRcdFx0XHRyZXR1cm4gY2hlY2tTY2FsYXJWYWx1ZShjb2RlUG9pbnQsIHN0cmljdCkgPyBjb2RlUG9pbnQgOiAweEZGRkQ7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR0aHJvdyBFcnJvcignSW52YWxpZCBjb250aW51YXRpb24gYnl0ZScpO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIDQtYnl0ZSBzZXF1ZW5jZVxuXHRcdGlmICgoYnl0ZTEgJiAweEY4KSA9PSAweEYwKSB7XG5cdFx0XHRieXRlMiA9IHJlYWRDb250aW51YXRpb25CeXRlKCk7XG5cdFx0XHRieXRlMyA9IHJlYWRDb250aW51YXRpb25CeXRlKCk7XG5cdFx0XHRieXRlNCA9IHJlYWRDb250aW51YXRpb25CeXRlKCk7XG5cdFx0XHRjb2RlUG9pbnQgPSAoKGJ5dGUxICYgMHgwNykgPDwgMHgxMikgfCAoYnl0ZTIgPDwgMHgwQykgfFxuXHRcdFx0XHQoYnl0ZTMgPDwgMHgwNikgfCBieXRlNDtcblx0XHRcdGlmIChjb2RlUG9pbnQgPj0gMHgwMTAwMDAgJiYgY29kZVBvaW50IDw9IDB4MTBGRkZGKSB7XG5cdFx0XHRcdHJldHVybiBjb2RlUG9pbnQ7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0dGhyb3cgRXJyb3IoJ0ludmFsaWQgVVRGLTggZGV0ZWN0ZWQnKTtcblx0fVxuXG5cdHZhciBieXRlQXJyYXk7XG5cdHZhciBieXRlQ291bnQ7XG5cdHZhciBieXRlSW5kZXg7XG5cdGZ1bmN0aW9uIHV0ZjhkZWNvZGUoYnl0ZVN0cmluZywgb3B0cykge1xuXHRcdG9wdHMgPSBvcHRzIHx8IHt9O1xuXHRcdHZhciBzdHJpY3QgPSBmYWxzZSAhPT0gb3B0cy5zdHJpY3Q7XG5cblx0XHRieXRlQXJyYXkgPSB1Y3MyZGVjb2RlKGJ5dGVTdHJpbmcpO1xuXHRcdGJ5dGVDb3VudCA9IGJ5dGVBcnJheS5sZW5ndGg7XG5cdFx0Ynl0ZUluZGV4ID0gMDtcblx0XHR2YXIgY29kZVBvaW50cyA9IFtdO1xuXHRcdHZhciB0bXA7XG5cdFx0d2hpbGUgKCh0bXAgPSBkZWNvZGVTeW1ib2woc3RyaWN0KSkgIT09IGZhbHNlKSB7XG5cdFx0XHRjb2RlUG9pbnRzLnB1c2godG1wKTtcblx0XHR9XG5cdFx0cmV0dXJuIHVjczJlbmNvZGUoY29kZVBvaW50cyk7XG5cdH1cblxuXHQvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuXHR2YXIgdXRmOCA9IHtcblx0XHQndmVyc2lvbic6ICcyLjEuMicsXG5cdFx0J2VuY29kZSc6IHV0ZjhlbmNvZGUsXG5cdFx0J2RlY29kZSc6IHV0ZjhkZWNvZGVcblx0fTtcblxuXHQvLyBTb21lIEFNRCBidWlsZCBvcHRpbWl6ZXJzLCBsaWtlIHIuanMsIGNoZWNrIGZvciBzcGVjaWZpYyBjb25kaXRpb24gcGF0dGVybnNcblx0Ly8gbGlrZSB0aGUgZm9sbG93aW5nOlxuXHRpZiAoXG5cdFx0dHlwZW9mIGRlZmluZSA9PSAnZnVuY3Rpb24nICYmXG5cdFx0dHlwZW9mIGRlZmluZS5hbWQgPT0gJ29iamVjdCcgJiZcblx0XHRkZWZpbmUuYW1kXG5cdCkge1xuXHRcdGRlZmluZShmdW5jdGlvbigpIHtcblx0XHRcdHJldHVybiB1dGY4O1xuXHRcdH0pO1xuXHR9XHRlbHNlIGlmIChmcmVlRXhwb3J0cyAmJiAhZnJlZUV4cG9ydHMubm9kZVR5cGUpIHtcblx0XHRpZiAoZnJlZU1vZHVsZSkgeyAvLyBpbiBOb2RlLmpzIG9yIFJpbmdvSlMgdjAuOC4wK1xuXHRcdFx0ZnJlZU1vZHVsZS5leHBvcnRzID0gdXRmODtcblx0XHR9IGVsc2UgeyAvLyBpbiBOYXJ3aGFsIG9yIFJpbmdvSlMgdjAuNy4wLVxuXHRcdFx0dmFyIG9iamVjdCA9IHt9O1xuXHRcdFx0dmFyIGhhc093blByb3BlcnR5ID0gb2JqZWN0Lmhhc093blByb3BlcnR5O1xuXHRcdFx0Zm9yICh2YXIga2V5IGluIHV0ZjgpIHtcblx0XHRcdFx0aGFzT3duUHJvcGVydHkuY2FsbCh1dGY4LCBrZXkpICYmIChmcmVlRXhwb3J0c1trZXldID0gdXRmOFtrZXldKTtcblx0XHRcdH1cblx0XHR9XG5cdH0gZWxzZSB7IC8vIGluIFJoaW5vIG9yIGEgd2ViIGJyb3dzZXJcblx0XHRyb290LnV0ZjggPSB1dGY4O1xuXHR9XG5cbn0odGhpcykpO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2VuZ2luZS5pby1wYXJzZXIvbGliL3V0ZjguanNcbi8vIG1vZHVsZSBpZCA9IDI0XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24obW9kdWxlKSB7XHJcblx0aWYoIW1vZHVsZS53ZWJwYWNrUG9seWZpbGwpIHtcclxuXHRcdG1vZHVsZS5kZXByZWNhdGUgPSBmdW5jdGlvbigpIHt9O1xyXG5cdFx0bW9kdWxlLnBhdGhzID0gW107XHJcblx0XHQvLyBtb2R1bGUucGFyZW50ID0gdW5kZWZpbmVkIGJ5IGRlZmF1bHRcclxuXHRcdGlmKCFtb2R1bGUuY2hpbGRyZW4pIG1vZHVsZS5jaGlsZHJlbiA9IFtdO1xyXG5cdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KG1vZHVsZSwgXCJsb2FkZWRcIiwge1xyXG5cdFx0XHRlbnVtZXJhYmxlOiB0cnVlLFxyXG5cdFx0XHRnZXQ6IGZ1bmN0aW9uKCkge1xyXG5cdFx0XHRcdHJldHVybiBtb2R1bGUubDtcclxuXHRcdFx0fVxyXG5cdFx0fSk7XHJcblx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkobW9kdWxlLCBcImlkXCIsIHtcclxuXHRcdFx0ZW51bWVyYWJsZTogdHJ1ZSxcclxuXHRcdFx0Z2V0OiBmdW5jdGlvbigpIHtcclxuXHRcdFx0XHRyZXR1cm4gbW9kdWxlLmk7XHJcblx0XHRcdH1cclxuXHRcdH0pO1xyXG5cdFx0bW9kdWxlLndlYnBhY2tQb2x5ZmlsbCA9IDE7XHJcblx0fVxyXG5cdHJldHVybiBtb2R1bGU7XHJcbn07XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vICh3ZWJwYWNrKS9idWlsZGluL21vZHVsZS5qc1xuLy8gbW9kdWxlIGlkID0gNjNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLypcbiAqIGJhc2U2NC1hcnJheWJ1ZmZlclxuICogaHR0cHM6Ly9naXRodWIuY29tL25pa2xhc3ZoL2Jhc2U2NC1hcnJheWJ1ZmZlclxuICpcbiAqIENvcHlyaWdodCAoYykgMjAxMiBOaWtsYXMgdm9uIEhlcnR6ZW5cbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZS5cbiAqL1xuKGZ1bmN0aW9uKCl7XG4gIFwidXNlIHN0cmljdFwiO1xuXG4gIHZhciBjaGFycyA9IFwiQUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVphYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5ejAxMjM0NTY3ODkrL1wiO1xuXG4gIC8vIFVzZSBhIGxvb2t1cCB0YWJsZSB0byBmaW5kIHRoZSBpbmRleC5cbiAgdmFyIGxvb2t1cCA9IG5ldyBVaW50OEFycmF5KDI1Nik7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgY2hhcnMubGVuZ3RoOyBpKyspIHtcbiAgICBsb29rdXBbY2hhcnMuY2hhckNvZGVBdChpKV0gPSBpO1xuICB9XG5cbiAgZXhwb3J0cy5lbmNvZGUgPSBmdW5jdGlvbihhcnJheWJ1ZmZlcikge1xuICAgIHZhciBieXRlcyA9IG5ldyBVaW50OEFycmF5KGFycmF5YnVmZmVyKSxcbiAgICBpLCBsZW4gPSBieXRlcy5sZW5ndGgsIGJhc2U2NCA9IFwiXCI7XG5cbiAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpKz0zKSB7XG4gICAgICBiYXNlNjQgKz0gY2hhcnNbYnl0ZXNbaV0gPj4gMl07XG4gICAgICBiYXNlNjQgKz0gY2hhcnNbKChieXRlc1tpXSAmIDMpIDw8IDQpIHwgKGJ5dGVzW2kgKyAxXSA+PiA0KV07XG4gICAgICBiYXNlNjQgKz0gY2hhcnNbKChieXRlc1tpICsgMV0gJiAxNSkgPDwgMikgfCAoYnl0ZXNbaSArIDJdID4+IDYpXTtcbiAgICAgIGJhc2U2NCArPSBjaGFyc1tieXRlc1tpICsgMl0gJiA2M107XG4gICAgfVxuXG4gICAgaWYgKChsZW4gJSAzKSA9PT0gMikge1xuICAgICAgYmFzZTY0ID0gYmFzZTY0LnN1YnN0cmluZygwLCBiYXNlNjQubGVuZ3RoIC0gMSkgKyBcIj1cIjtcbiAgICB9IGVsc2UgaWYgKGxlbiAlIDMgPT09IDEpIHtcbiAgICAgIGJhc2U2NCA9IGJhc2U2NC5zdWJzdHJpbmcoMCwgYmFzZTY0Lmxlbmd0aCAtIDIpICsgXCI9PVwiO1xuICAgIH1cblxuICAgIHJldHVybiBiYXNlNjQ7XG4gIH07XG5cbiAgZXhwb3J0cy5kZWNvZGUgPSAgZnVuY3Rpb24oYmFzZTY0KSB7XG4gICAgdmFyIGJ1ZmZlckxlbmd0aCA9IGJhc2U2NC5sZW5ndGggKiAwLjc1LFxuICAgIGxlbiA9IGJhc2U2NC5sZW5ndGgsIGksIHAgPSAwLFxuICAgIGVuY29kZWQxLCBlbmNvZGVkMiwgZW5jb2RlZDMsIGVuY29kZWQ0O1xuXG4gICAgaWYgKGJhc2U2NFtiYXNlNjQubGVuZ3RoIC0gMV0gPT09IFwiPVwiKSB7XG4gICAgICBidWZmZXJMZW5ndGgtLTtcbiAgICAgIGlmIChiYXNlNjRbYmFzZTY0Lmxlbmd0aCAtIDJdID09PSBcIj1cIikge1xuICAgICAgICBidWZmZXJMZW5ndGgtLTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgYXJyYXlidWZmZXIgPSBuZXcgQXJyYXlCdWZmZXIoYnVmZmVyTGVuZ3RoKSxcbiAgICBieXRlcyA9IG5ldyBVaW50OEFycmF5KGFycmF5YnVmZmVyKTtcblxuICAgIGZvciAoaSA9IDA7IGkgPCBsZW47IGkrPTQpIHtcbiAgICAgIGVuY29kZWQxID0gbG9va3VwW2Jhc2U2NC5jaGFyQ29kZUF0KGkpXTtcbiAgICAgIGVuY29kZWQyID0gbG9va3VwW2Jhc2U2NC5jaGFyQ29kZUF0KGkrMSldO1xuICAgICAgZW5jb2RlZDMgPSBsb29rdXBbYmFzZTY0LmNoYXJDb2RlQXQoaSsyKV07XG4gICAgICBlbmNvZGVkNCA9IGxvb2t1cFtiYXNlNjQuY2hhckNvZGVBdChpKzMpXTtcblxuICAgICAgYnl0ZXNbcCsrXSA9IChlbmNvZGVkMSA8PCAyKSB8IChlbmNvZGVkMiA+PiA0KTtcbiAgICAgIGJ5dGVzW3ArK10gPSAoKGVuY29kZWQyICYgMTUpIDw8IDQpIHwgKGVuY29kZWQzID4+IDIpO1xuICAgICAgYnl0ZXNbcCsrXSA9ICgoZW5jb2RlZDMgJiAzKSA8PCA2KSB8IChlbmNvZGVkNCAmIDYzKTtcbiAgICB9XG5cbiAgICByZXR1cm4gYXJyYXlidWZmZXI7XG4gIH07XG59KSgpO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2Jhc2U2NC1hcnJheWJ1ZmZlci9saWIvYmFzZTY0LWFycmF5YnVmZmVyLmpzXG4vLyBtb2R1bGUgaWQgPSAyNlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKipcbiAqIENyZWF0ZSBhIGJsb2IgYnVpbGRlciBldmVuIHdoZW4gdmVuZG9yIHByZWZpeGVzIGV4aXN0XG4gKi9cblxudmFyIEJsb2JCdWlsZGVyID0gZ2xvYmFsLkJsb2JCdWlsZGVyXG4gIHx8IGdsb2JhbC5XZWJLaXRCbG9iQnVpbGRlclxuICB8fCBnbG9iYWwuTVNCbG9iQnVpbGRlclxuICB8fCBnbG9iYWwuTW96QmxvYkJ1aWxkZXI7XG5cbi8qKlxuICogQ2hlY2sgaWYgQmxvYiBjb25zdHJ1Y3RvciBpcyBzdXBwb3J0ZWRcbiAqL1xuXG52YXIgYmxvYlN1cHBvcnRlZCA9IChmdW5jdGlvbigpIHtcbiAgdHJ5IHtcbiAgICB2YXIgYSA9IG5ldyBCbG9iKFsnaGknXSk7XG4gICAgcmV0dXJuIGEuc2l6ZSA9PT0gMjtcbiAgfSBjYXRjaChlKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG59KSgpO1xuXG4vKipcbiAqIENoZWNrIGlmIEJsb2IgY29uc3RydWN0b3Igc3VwcG9ydHMgQXJyYXlCdWZmZXJWaWV3c1xuICogRmFpbHMgaW4gU2FmYXJpIDYsIHNvIHdlIG5lZWQgdG8gbWFwIHRvIEFycmF5QnVmZmVycyB0aGVyZS5cbiAqL1xuXG52YXIgYmxvYlN1cHBvcnRzQXJyYXlCdWZmZXJWaWV3ID0gYmxvYlN1cHBvcnRlZCAmJiAoZnVuY3Rpb24oKSB7XG4gIHRyeSB7XG4gICAgdmFyIGIgPSBuZXcgQmxvYihbbmV3IFVpbnQ4QXJyYXkoWzEsMl0pXSk7XG4gICAgcmV0dXJuIGIuc2l6ZSA9PT0gMjtcbiAgfSBjYXRjaChlKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG59KSgpO1xuXG4vKipcbiAqIENoZWNrIGlmIEJsb2JCdWlsZGVyIGlzIHN1cHBvcnRlZFxuICovXG5cbnZhciBibG9iQnVpbGRlclN1cHBvcnRlZCA9IEJsb2JCdWlsZGVyXG4gICYmIEJsb2JCdWlsZGVyLnByb3RvdHlwZS5hcHBlbmRcbiAgJiYgQmxvYkJ1aWxkZXIucHJvdG90eXBlLmdldEJsb2I7XG5cbi8qKlxuICogSGVscGVyIGZ1bmN0aW9uIHRoYXQgbWFwcyBBcnJheUJ1ZmZlclZpZXdzIHRvIEFycmF5QnVmZmVyc1xuICogVXNlZCBieSBCbG9iQnVpbGRlciBjb25zdHJ1Y3RvciBhbmQgb2xkIGJyb3dzZXJzIHRoYXQgZGlkbid0XG4gKiBzdXBwb3J0IGl0IGluIHRoZSBCbG9iIGNvbnN0cnVjdG9yLlxuICovXG5cbmZ1bmN0aW9uIG1hcEFycmF5QnVmZmVyVmlld3MoYXJ5KSB7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgYXJ5Lmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGNodW5rID0gYXJ5W2ldO1xuICAgIGlmIChjaHVuay5idWZmZXIgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlcikge1xuICAgICAgdmFyIGJ1ZiA9IGNodW5rLmJ1ZmZlcjtcblxuICAgICAgLy8gaWYgdGhpcyBpcyBhIHN1YmFycmF5LCBtYWtlIGEgY29weSBzbyB3ZSBvbmx5XG4gICAgICAvLyBpbmNsdWRlIHRoZSBzdWJhcnJheSByZWdpb24gZnJvbSB0aGUgdW5kZXJseWluZyBidWZmZXJcbiAgICAgIGlmIChjaHVuay5ieXRlTGVuZ3RoICE9PSBidWYuYnl0ZUxlbmd0aCkge1xuICAgICAgICB2YXIgY29weSA9IG5ldyBVaW50OEFycmF5KGNodW5rLmJ5dGVMZW5ndGgpO1xuICAgICAgICBjb3B5LnNldChuZXcgVWludDhBcnJheShidWYsIGNodW5rLmJ5dGVPZmZzZXQsIGNodW5rLmJ5dGVMZW5ndGgpKTtcbiAgICAgICAgYnVmID0gY29weS5idWZmZXI7XG4gICAgICB9XG5cbiAgICAgIGFyeVtpXSA9IGJ1ZjtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gQmxvYkJ1aWxkZXJDb25zdHJ1Y3RvcihhcnksIG9wdGlvbnMpIHtcbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cbiAgdmFyIGJiID0gbmV3IEJsb2JCdWlsZGVyKCk7XG4gIG1hcEFycmF5QnVmZmVyVmlld3MoYXJ5KTtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGFyeS5sZW5ndGg7IGkrKykge1xuICAgIGJiLmFwcGVuZChhcnlbaV0pO1xuICB9XG5cbiAgcmV0dXJuIChvcHRpb25zLnR5cGUpID8gYmIuZ2V0QmxvYihvcHRpb25zLnR5cGUpIDogYmIuZ2V0QmxvYigpO1xufTtcblxuZnVuY3Rpb24gQmxvYkNvbnN0cnVjdG9yKGFyeSwgb3B0aW9ucykge1xuICBtYXBBcnJheUJ1ZmZlclZpZXdzKGFyeSk7XG4gIHJldHVybiBuZXcgQmxvYihhcnksIG9wdGlvbnMgfHwge30pO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSAoZnVuY3Rpb24oKSB7XG4gIGlmIChibG9iU3VwcG9ydGVkKSB7XG4gICAgcmV0dXJuIGJsb2JTdXBwb3J0c0FycmF5QnVmZmVyVmlldyA/IGdsb2JhbC5CbG9iIDogQmxvYkNvbnN0cnVjdG9yO1xuICB9IGVsc2UgaWYgKGJsb2JCdWlsZGVyU3VwcG9ydGVkKSB7XG4gICAgcmV0dXJuIEJsb2JCdWlsZGVyQ29uc3RydWN0b3I7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgfVxufSkoKTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9ibG9iL2luZGV4LmpzXG4vLyBtb2R1bGUgaWQgPSAyN1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKipcclxuICogQ29tcGlsZXMgYSBxdWVyeXN0cmluZ1xyXG4gKiBSZXR1cm5zIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGUgb2JqZWN0XHJcbiAqXHJcbiAqIEBwYXJhbSB7T2JqZWN0fVxyXG4gKiBAYXBpIHByaXZhdGVcclxuICovXHJcblxyXG5leHBvcnRzLmVuY29kZSA9IGZ1bmN0aW9uIChvYmopIHtcclxuICB2YXIgc3RyID0gJyc7XHJcblxyXG4gIGZvciAodmFyIGkgaW4gb2JqKSB7XHJcbiAgICBpZiAob2JqLmhhc093blByb3BlcnR5KGkpKSB7XHJcbiAgICAgIGlmIChzdHIubGVuZ3RoKSBzdHIgKz0gJyYnO1xyXG4gICAgICBzdHIgKz0gZW5jb2RlVVJJQ29tcG9uZW50KGkpICsgJz0nICsgZW5jb2RlVVJJQ29tcG9uZW50KG9ialtpXSk7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICByZXR1cm4gc3RyO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIFBhcnNlcyBhIHNpbXBsZSBxdWVyeXN0cmluZyBpbnRvIGFuIG9iamVjdFxyXG4gKlxyXG4gKiBAcGFyYW0ge1N0cmluZ30gcXNcclxuICogQGFwaSBwcml2YXRlXHJcbiAqL1xyXG5cclxuZXhwb3J0cy5kZWNvZGUgPSBmdW5jdGlvbihxcyl7XHJcbiAgdmFyIHFyeSA9IHt9O1xyXG4gIHZhciBwYWlycyA9IHFzLnNwbGl0KCcmJyk7XHJcbiAgZm9yICh2YXIgaSA9IDAsIGwgPSBwYWlycy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcclxuICAgIHZhciBwYWlyID0gcGFpcnNbaV0uc3BsaXQoJz0nKTtcclxuICAgIHFyeVtkZWNvZGVVUklDb21wb25lbnQocGFpclswXSldID0gZGVjb2RlVVJJQ29tcG9uZW50KHBhaXJbMV0pO1xyXG4gIH1cclxuICByZXR1cm4gcXJ5O1xyXG59O1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vcGFyc2Vxcy9pbmRleC5qc1xuLy8gbW9kdWxlIGlkID0gMjhcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGEsIGIpe1xuICB2YXIgZm4gPSBmdW5jdGlvbigpe307XG4gIGZuLnByb3RvdHlwZSA9IGIucHJvdG90eXBlO1xuICBhLnByb3RvdHlwZSA9IG5ldyBmbjtcbiAgYS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBhO1xufTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vY29tcG9uZW50LWluaGVyaXQvaW5kZXguanNcbi8vIG1vZHVsZSBpZCA9IDI5XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIid1c2Ugc3RyaWN0JztcblxudmFyIGFscGhhYmV0ID0gJzAxMjM0NTY3ODlBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWmFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6LV8nLnNwbGl0KCcnKVxuICAsIGxlbmd0aCA9IDY0XG4gICwgbWFwID0ge31cbiAgLCBzZWVkID0gMFxuICAsIGkgPSAwXG4gICwgcHJldjtcblxuLyoqXG4gKiBSZXR1cm4gYSBzdHJpbmcgcmVwcmVzZW50aW5nIHRoZSBzcGVjaWZpZWQgbnVtYmVyLlxuICpcbiAqIEBwYXJhbSB7TnVtYmVyfSBudW0gVGhlIG51bWJlciB0byBjb252ZXJ0LlxuICogQHJldHVybnMge1N0cmluZ30gVGhlIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGUgbnVtYmVyLlxuICogQGFwaSBwdWJsaWNcbiAqL1xuZnVuY3Rpb24gZW5jb2RlKG51bSkge1xuICB2YXIgZW5jb2RlZCA9ICcnO1xuXG4gIGRvIHtcbiAgICBlbmNvZGVkID0gYWxwaGFiZXRbbnVtICUgbGVuZ3RoXSArIGVuY29kZWQ7XG4gICAgbnVtID0gTWF0aC5mbG9vcihudW0gLyBsZW5ndGgpO1xuICB9IHdoaWxlIChudW0gPiAwKTtcblxuICByZXR1cm4gZW5jb2RlZDtcbn1cblxuLyoqXG4gKiBSZXR1cm4gdGhlIGludGVnZXIgdmFsdWUgc3BlY2lmaWVkIGJ5IHRoZSBnaXZlbiBzdHJpbmcuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHN0ciBUaGUgc3RyaW5nIHRvIGNvbnZlcnQuXG4gKiBAcmV0dXJucyB7TnVtYmVyfSBUaGUgaW50ZWdlciB2YWx1ZSByZXByZXNlbnRlZCBieSB0aGUgc3RyaW5nLlxuICogQGFwaSBwdWJsaWNcbiAqL1xuZnVuY3Rpb24gZGVjb2RlKHN0cikge1xuICB2YXIgZGVjb2RlZCA9IDA7XG5cbiAgZm9yIChpID0gMDsgaSA8IHN0ci5sZW5ndGg7IGkrKykge1xuICAgIGRlY29kZWQgPSBkZWNvZGVkICogbGVuZ3RoICsgbWFwW3N0ci5jaGFyQXQoaSldO1xuICB9XG5cbiAgcmV0dXJuIGRlY29kZWQ7XG59XG5cbi8qKlxuICogWWVhc3Q6IEEgdGlueSBncm93aW5nIGlkIGdlbmVyYXRvci5cbiAqXG4gKiBAcmV0dXJucyB7U3RyaW5nfSBBIHVuaXF1ZSBpZC5cbiAqIEBhcGkgcHVibGljXG4gKi9cbmZ1bmN0aW9uIHllYXN0KCkge1xuICB2YXIgbm93ID0gZW5jb2RlKCtuZXcgRGF0ZSgpKTtcblxuICBpZiAobm93ICE9PSBwcmV2KSByZXR1cm4gc2VlZCA9IDAsIHByZXYgPSBub3c7XG4gIHJldHVybiBub3cgKycuJysgZW5jb2RlKHNlZWQrKyk7XG59XG5cbi8vXG4vLyBNYXAgZWFjaCBjaGFyYWN0ZXIgdG8gaXRzIGluZGV4LlxuLy9cbmZvciAoOyBpIDwgbGVuZ3RoOyBpKyspIG1hcFthbHBoYWJldFtpXV0gPSBpO1xuXG4vL1xuLy8gRXhwb3NlIHRoZSBgeWVhc3RgLCBgZW5jb2RlYCBhbmQgYGRlY29kZWAgZnVuY3Rpb25zLlxuLy9cbnllYXN0LmVuY29kZSA9IGVuY29kZTtcbnllYXN0LmRlY29kZSA9IGRlY29kZTtcbm1vZHVsZS5leHBvcnRzID0geWVhc3Q7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34veWVhc3QvaW5kZXguanNcbi8vIG1vZHVsZSBpZCA9IDMwXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIlxuLyoqXG4gKiBNb2R1bGUgcmVxdWlyZW1lbnRzLlxuICovXG5cbnZhciBQb2xsaW5nID0gcmVxdWlyZSgnLi9wb2xsaW5nJyk7XG52YXIgaW5oZXJpdCA9IHJlcXVpcmUoJ2NvbXBvbmVudC1pbmhlcml0Jyk7XG5cbi8qKlxuICogTW9kdWxlIGV4cG9ydHMuXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBKU09OUFBvbGxpbmc7XG5cbi8qKlxuICogQ2FjaGVkIHJlZ3VsYXIgZXhwcmVzc2lvbnMuXG4gKi9cblxudmFyIHJOZXdsaW5lID0gL1xcbi9nO1xudmFyIHJFc2NhcGVkTmV3bGluZSA9IC9cXFxcbi9nO1xuXG4vKipcbiAqIEdsb2JhbCBKU09OUCBjYWxsYmFja3MuXG4gKi9cblxudmFyIGNhbGxiYWNrcztcblxuLyoqXG4gKiBOb29wLlxuICovXG5cbmZ1bmN0aW9uIGVtcHR5ICgpIHsgfVxuXG4vKipcbiAqIEpTT05QIFBvbGxpbmcgY29uc3RydWN0b3IuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IG9wdHMuXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmZ1bmN0aW9uIEpTT05QUG9sbGluZyAob3B0cykge1xuICBQb2xsaW5nLmNhbGwodGhpcywgb3B0cyk7XG5cbiAgdGhpcy5xdWVyeSA9IHRoaXMucXVlcnkgfHwge307XG5cbiAgLy8gZGVmaW5lIGdsb2JhbCBjYWxsYmFja3MgYXJyYXkgaWYgbm90IHByZXNlbnRcbiAgLy8gd2UgZG8gdGhpcyBoZXJlIChsYXppbHkpIHRvIGF2b2lkIHVubmVlZGVkIGdsb2JhbCBwb2xsdXRpb25cbiAgaWYgKCFjYWxsYmFja3MpIHtcbiAgICAvLyB3ZSBuZWVkIHRvIGNvbnNpZGVyIG11bHRpcGxlIGVuZ2luZXMgaW4gdGhlIHNhbWUgcGFnZVxuICAgIGlmICghZ2xvYmFsLl9fX2VpbykgZ2xvYmFsLl9fX2VpbyA9IFtdO1xuICAgIGNhbGxiYWNrcyA9IGdsb2JhbC5fX19laW87XG4gIH1cblxuICAvLyBjYWxsYmFjayBpZGVudGlmaWVyXG4gIHRoaXMuaW5kZXggPSBjYWxsYmFja3MubGVuZ3RoO1xuXG4gIC8vIGFkZCBjYWxsYmFjayB0byBqc29ucCBnbG9iYWxcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICBjYWxsYmFja3MucHVzaChmdW5jdGlvbiAobXNnKSB7XG4gICAgc2VsZi5vbkRhdGEobXNnKTtcbiAgfSk7XG5cbiAgLy8gYXBwZW5kIHRvIHF1ZXJ5IHN0cmluZ1xuICB0aGlzLnF1ZXJ5LmogPSB0aGlzLmluZGV4O1xuXG4gIC8vIHByZXZlbnQgc3B1cmlvdXMgZXJyb3JzIGZyb20gYmVpbmcgZW1pdHRlZCB3aGVuIHRoZSB3aW5kb3cgaXMgdW5sb2FkZWRcbiAgaWYgKGdsb2JhbC5kb2N1bWVudCAmJiBnbG9iYWwuYWRkRXZlbnRMaXN0ZW5lcikge1xuICAgIGdsb2JhbC5hZGRFdmVudExpc3RlbmVyKCdiZWZvcmV1bmxvYWQnLCBmdW5jdGlvbiAoKSB7XG4gICAgICBpZiAoc2VsZi5zY3JpcHQpIHNlbGYuc2NyaXB0Lm9uZXJyb3IgPSBlbXB0eTtcbiAgICB9LCBmYWxzZSk7XG4gIH1cbn1cblxuLyoqXG4gKiBJbmhlcml0cyBmcm9tIFBvbGxpbmcuXG4gKi9cblxuaW5oZXJpdChKU09OUFBvbGxpbmcsIFBvbGxpbmcpO1xuXG4vKlxuICogSlNPTlAgb25seSBzdXBwb3J0cyBiaW5hcnkgYXMgYmFzZTY0IGVuY29kZWQgc3RyaW5nc1xuICovXG5cbkpTT05QUG9sbGluZy5wcm90b3R5cGUuc3VwcG9ydHNCaW5hcnkgPSBmYWxzZTtcblxuLyoqXG4gKiBDbG9zZXMgdGhlIHNvY2tldC5cbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5KU09OUFBvbGxpbmcucHJvdG90eXBlLmRvQ2xvc2UgPSBmdW5jdGlvbiAoKSB7XG4gIGlmICh0aGlzLnNjcmlwdCkge1xuICAgIHRoaXMuc2NyaXB0LnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQodGhpcy5zY3JpcHQpO1xuICAgIHRoaXMuc2NyaXB0ID0gbnVsbDtcbiAgfVxuXG4gIGlmICh0aGlzLmZvcm0pIHtcbiAgICB0aGlzLmZvcm0ucGFyZW50Tm9kZS5yZW1vdmVDaGlsZCh0aGlzLmZvcm0pO1xuICAgIHRoaXMuZm9ybSA9IG51bGw7XG4gICAgdGhpcy5pZnJhbWUgPSBudWxsO1xuICB9XG5cbiAgUG9sbGluZy5wcm90b3R5cGUuZG9DbG9zZS5jYWxsKHRoaXMpO1xufTtcblxuLyoqXG4gKiBTdGFydHMgYSBwb2xsIGN5Y2xlLlxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbkpTT05QUG9sbGluZy5wcm90b3R5cGUuZG9Qb2xsID0gZnVuY3Rpb24gKCkge1xuICB2YXIgc2VsZiA9IHRoaXM7XG4gIHZhciBzY3JpcHQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzY3JpcHQnKTtcblxuICBpZiAodGhpcy5zY3JpcHQpIHtcbiAgICB0aGlzLnNjcmlwdC5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHRoaXMuc2NyaXB0KTtcbiAgICB0aGlzLnNjcmlwdCA9IG51bGw7XG4gIH1cblxuICBzY3JpcHQuYXN5bmMgPSB0cnVlO1xuICBzY3JpcHQuc3JjID0gdGhpcy51cmkoKTtcbiAgc2NyaXB0Lm9uZXJyb3IgPSBmdW5jdGlvbiAoZSkge1xuICAgIHNlbGYub25FcnJvcignanNvbnAgcG9sbCBlcnJvcicsIGUpO1xuICB9O1xuXG4gIHZhciBpbnNlcnRBdCA9IGRvY3VtZW50LmdldEVsZW1lbnRzQnlUYWdOYW1lKCdzY3JpcHQnKVswXTtcbiAgaWYgKGluc2VydEF0KSB7XG4gICAgaW5zZXJ0QXQucGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUoc2NyaXB0LCBpbnNlcnRBdCk7XG4gIH0gZWxzZSB7XG4gICAgKGRvY3VtZW50LmhlYWQgfHwgZG9jdW1lbnQuYm9keSkuYXBwZW5kQ2hpbGQoc2NyaXB0KTtcbiAgfVxuICB0aGlzLnNjcmlwdCA9IHNjcmlwdDtcblxuICB2YXIgaXNVQWdlY2tvID0gJ3VuZGVmaW5lZCcgIT09IHR5cGVvZiBuYXZpZ2F0b3IgJiYgL2dlY2tvL2kudGVzdChuYXZpZ2F0b3IudXNlckFnZW50KTtcblxuICBpZiAoaXNVQWdlY2tvKSB7XG4gICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgaWZyYW1lID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnaWZyYW1lJyk7XG4gICAgICBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKGlmcmFtZSk7XG4gICAgICBkb2N1bWVudC5ib2R5LnJlbW92ZUNoaWxkKGlmcmFtZSk7XG4gICAgfSwgMTAwKTtcbiAgfVxufTtcblxuLyoqXG4gKiBXcml0ZXMgd2l0aCBhIGhpZGRlbiBpZnJhbWUuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IGRhdGEgdG8gc2VuZFxuICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGVkIHVwb24gZmx1c2guXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5KU09OUFBvbGxpbmcucHJvdG90eXBlLmRvV3JpdGUgPSBmdW5jdGlvbiAoZGF0YSwgZm4pIHtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gIGlmICghdGhpcy5mb3JtKSB7XG4gICAgdmFyIGZvcm0gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdmb3JtJyk7XG4gICAgdmFyIGFyZWEgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCd0ZXh0YXJlYScpO1xuICAgIHZhciBpZCA9IHRoaXMuaWZyYW1lSWQgPSAnZWlvX2lmcmFtZV8nICsgdGhpcy5pbmRleDtcbiAgICB2YXIgaWZyYW1lO1xuXG4gICAgZm9ybS5jbGFzc05hbWUgPSAnc29ja2V0aW8nO1xuICAgIGZvcm0uc3R5bGUucG9zaXRpb24gPSAnYWJzb2x1dGUnO1xuICAgIGZvcm0uc3R5bGUudG9wID0gJy0xMDAwcHgnO1xuICAgIGZvcm0uc3R5bGUubGVmdCA9ICctMTAwMHB4JztcbiAgICBmb3JtLnRhcmdldCA9IGlkO1xuICAgIGZvcm0ubWV0aG9kID0gJ1BPU1QnO1xuICAgIGZvcm0uc2V0QXR0cmlidXRlKCdhY2NlcHQtY2hhcnNldCcsICd1dGYtOCcpO1xuICAgIGFyZWEubmFtZSA9ICdkJztcbiAgICBmb3JtLmFwcGVuZENoaWxkKGFyZWEpO1xuICAgIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQoZm9ybSk7XG5cbiAgICB0aGlzLmZvcm0gPSBmb3JtO1xuICAgIHRoaXMuYXJlYSA9IGFyZWE7XG4gIH1cblxuICB0aGlzLmZvcm0uYWN0aW9uID0gdGhpcy51cmkoKTtcblxuICBmdW5jdGlvbiBjb21wbGV0ZSAoKSB7XG4gICAgaW5pdElmcmFtZSgpO1xuICAgIGZuKCk7XG4gIH1cblxuICBmdW5jdGlvbiBpbml0SWZyYW1lICgpIHtcbiAgICBpZiAoc2VsZi5pZnJhbWUpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHNlbGYuZm9ybS5yZW1vdmVDaGlsZChzZWxmLmlmcmFtZSk7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIHNlbGYub25FcnJvcignanNvbnAgcG9sbGluZyBpZnJhbWUgcmVtb3ZhbCBlcnJvcicsIGUpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHRyeSB7XG4gICAgICAvLyBpZTYgZHluYW1pYyBpZnJhbWVzIHdpdGggdGFyZ2V0PVwiXCIgc3VwcG9ydCAodGhhbmtzIENocmlzIExhbWJhY2hlcilcbiAgICAgIHZhciBodG1sID0gJzxpZnJhbWUgc3JjPVwiamF2YXNjcmlwdDowXCIgbmFtZT1cIicgKyBzZWxmLmlmcmFtZUlkICsgJ1wiPic7XG4gICAgICBpZnJhbWUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KGh0bWwpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIGlmcmFtZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2lmcmFtZScpO1xuICAgICAgaWZyYW1lLm5hbWUgPSBzZWxmLmlmcmFtZUlkO1xuICAgICAgaWZyYW1lLnNyYyA9ICdqYXZhc2NyaXB0OjAnO1xuICAgIH1cblxuICAgIGlmcmFtZS5pZCA9IHNlbGYuaWZyYW1lSWQ7XG5cbiAgICBzZWxmLmZvcm0uYXBwZW5kQ2hpbGQoaWZyYW1lKTtcbiAgICBzZWxmLmlmcmFtZSA9IGlmcmFtZTtcbiAgfVxuXG4gIGluaXRJZnJhbWUoKTtcblxuICAvLyBlc2NhcGUgXFxuIHRvIHByZXZlbnQgaXQgZnJvbSBiZWluZyBjb252ZXJ0ZWQgaW50byBcXHJcXG4gYnkgc29tZSBVQXNcbiAgLy8gZG91YmxlIGVzY2FwaW5nIGlzIHJlcXVpcmVkIGZvciBlc2NhcGVkIG5ldyBsaW5lcyBiZWNhdXNlIHVuZXNjYXBpbmcgb2YgbmV3IGxpbmVzIGNhbiBiZSBkb25lIHNhZmVseSBvbiBzZXJ2ZXItc2lkZVxuICBkYXRhID0gZGF0YS5yZXBsYWNlKHJFc2NhcGVkTmV3bGluZSwgJ1xcXFxcXG4nKTtcbiAgdGhpcy5hcmVhLnZhbHVlID0gZGF0YS5yZXBsYWNlKHJOZXdsaW5lLCAnXFxcXG4nKTtcblxuICB0cnkge1xuICAgIHRoaXMuZm9ybS5zdWJtaXQoKTtcbiAgfSBjYXRjaCAoZSkge31cblxuICBpZiAodGhpcy5pZnJhbWUuYXR0YWNoRXZlbnQpIHtcbiAgICB0aGlzLmlmcmFtZS5vbnJlYWR5c3RhdGVjaGFuZ2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICBpZiAoc2VsZi5pZnJhbWUucmVhZHlTdGF0ZSA9PT0gJ2NvbXBsZXRlJykge1xuICAgICAgICBjb21wbGV0ZSgpO1xuICAgICAgfVxuICAgIH07XG4gIH0gZWxzZSB7XG4gICAgdGhpcy5pZnJhbWUub25sb2FkID0gY29tcGxldGU7XG4gIH1cbn07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vZW5naW5lLmlvLWNsaWVudC9saWIvdHJhbnNwb3J0cy9wb2xsaW5nLWpzb25wLmpzXG4vLyBtb2R1bGUgaWQgPSAzMVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKipcbiAqIE1vZHVsZSBkZXBlbmRlbmNpZXMuXG4gKi9cblxudmFyIFRyYW5zcG9ydCA9IHJlcXVpcmUoJy4uL3RyYW5zcG9ydCcpO1xudmFyIHBhcnNlciA9IHJlcXVpcmUoJ2VuZ2luZS5pby1wYXJzZXInKTtcbnZhciBwYXJzZXFzID0gcmVxdWlyZSgncGFyc2VxcycpO1xudmFyIGluaGVyaXQgPSByZXF1aXJlKCdjb21wb25lbnQtaW5oZXJpdCcpO1xudmFyIHllYXN0ID0gcmVxdWlyZSgneWVhc3QnKTtcbnZhciBkZWJ1ZyA9IHJlcXVpcmUoJ2RlYnVnJykoJ2VuZ2luZS5pby1jbGllbnQ6d2Vic29ja2V0Jyk7XG52YXIgQnJvd3NlcldlYlNvY2tldCA9IGdsb2JhbC5XZWJTb2NrZXQgfHwgZ2xvYmFsLk1veldlYlNvY2tldDtcbnZhciBOb2RlV2ViU29ja2V0O1xuaWYgKHR5cGVvZiB3aW5kb3cgPT09ICd1bmRlZmluZWQnKSB7XG4gIHRyeSB7XG4gICAgTm9kZVdlYlNvY2tldCA9IHJlcXVpcmUoJ3dzJyk7XG4gIH0gY2F0Y2ggKGUpIHsgfVxufVxuXG4vKipcbiAqIEdldCBlaXRoZXIgdGhlIGBXZWJTb2NrZXRgIG9yIGBNb3pXZWJTb2NrZXRgIGdsb2JhbHNcbiAqIGluIHRoZSBicm93c2VyIG9yIHRyeSB0byByZXNvbHZlIFdlYlNvY2tldC1jb21wYXRpYmxlXG4gKiBpbnRlcmZhY2UgZXhwb3NlZCBieSBgd3NgIGZvciBOb2RlLWxpa2UgZW52aXJvbm1lbnQuXG4gKi9cblxudmFyIFdlYlNvY2tldCA9IEJyb3dzZXJXZWJTb2NrZXQ7XG5pZiAoIVdlYlNvY2tldCAmJiB0eXBlb2Ygd2luZG93ID09PSAndW5kZWZpbmVkJykge1xuICBXZWJTb2NrZXQgPSBOb2RlV2ViU29ja2V0O1xufVxuXG4vKipcbiAqIE1vZHVsZSBleHBvcnRzLlxuICovXG5cbm1vZHVsZS5leHBvcnRzID0gV1M7XG5cbi8qKlxuICogV2ViU29ja2V0IHRyYW5zcG9ydCBjb25zdHJ1Y3Rvci5cbiAqXG4gKiBAYXBpIHtPYmplY3R9IGNvbm5lY3Rpb24gb3B0aW9uc1xuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5mdW5jdGlvbiBXUyAob3B0cykge1xuICB2YXIgZm9yY2VCYXNlNjQgPSAob3B0cyAmJiBvcHRzLmZvcmNlQmFzZTY0KTtcbiAgaWYgKGZvcmNlQmFzZTY0KSB7XG4gICAgdGhpcy5zdXBwb3J0c0JpbmFyeSA9IGZhbHNlO1xuICB9XG4gIHRoaXMucGVyTWVzc2FnZURlZmxhdGUgPSBvcHRzLnBlck1lc3NhZ2VEZWZsYXRlO1xuICB0aGlzLnVzaW5nQnJvd3NlcldlYlNvY2tldCA9IEJyb3dzZXJXZWJTb2NrZXQgJiYgIW9wdHMuZm9yY2VOb2RlO1xuICB0aGlzLnByb3RvY29scyA9IG9wdHMucHJvdG9jb2xzO1xuICBpZiAoIXRoaXMudXNpbmdCcm93c2VyV2ViU29ja2V0KSB7XG4gICAgV2ViU29ja2V0ID0gTm9kZVdlYlNvY2tldDtcbiAgfVxuICBUcmFuc3BvcnQuY2FsbCh0aGlzLCBvcHRzKTtcbn1cblxuLyoqXG4gKiBJbmhlcml0cyBmcm9tIFRyYW5zcG9ydC5cbiAqL1xuXG5pbmhlcml0KFdTLCBUcmFuc3BvcnQpO1xuXG4vKipcbiAqIFRyYW5zcG9ydCBuYW1lLlxuICpcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuV1MucHJvdG90eXBlLm5hbWUgPSAnd2Vic29ja2V0JztcblxuLypcbiAqIFdlYlNvY2tldHMgc3VwcG9ydCBiaW5hcnlcbiAqL1xuXG5XUy5wcm90b3R5cGUuc3VwcG9ydHNCaW5hcnkgPSB0cnVlO1xuXG4vKipcbiAqIE9wZW5zIHNvY2tldC5cbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5XUy5wcm90b3R5cGUuZG9PcGVuID0gZnVuY3Rpb24gKCkge1xuICBpZiAoIXRoaXMuY2hlY2soKSkge1xuICAgIC8vIGxldCBwcm9iZSB0aW1lb3V0XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgdmFyIHVyaSA9IHRoaXMudXJpKCk7XG4gIHZhciBwcm90b2NvbHMgPSB0aGlzLnByb3RvY29scztcbiAgdmFyIG9wdHMgPSB7XG4gICAgYWdlbnQ6IHRoaXMuYWdlbnQsXG4gICAgcGVyTWVzc2FnZURlZmxhdGU6IHRoaXMucGVyTWVzc2FnZURlZmxhdGVcbiAgfTtcblxuICAvLyBTU0wgb3B0aW9ucyBmb3IgTm9kZS5qcyBjbGllbnRcbiAgb3B0cy5wZnggPSB0aGlzLnBmeDtcbiAgb3B0cy5rZXkgPSB0aGlzLmtleTtcbiAgb3B0cy5wYXNzcGhyYXNlID0gdGhpcy5wYXNzcGhyYXNlO1xuICBvcHRzLmNlcnQgPSB0aGlzLmNlcnQ7XG4gIG9wdHMuY2EgPSB0aGlzLmNhO1xuICBvcHRzLmNpcGhlcnMgPSB0aGlzLmNpcGhlcnM7XG4gIG9wdHMucmVqZWN0VW5hdXRob3JpemVkID0gdGhpcy5yZWplY3RVbmF1dGhvcml6ZWQ7XG4gIGlmICh0aGlzLmV4dHJhSGVhZGVycykge1xuICAgIG9wdHMuaGVhZGVycyA9IHRoaXMuZXh0cmFIZWFkZXJzO1xuICB9XG4gIGlmICh0aGlzLmxvY2FsQWRkcmVzcykge1xuICAgIG9wdHMubG9jYWxBZGRyZXNzID0gdGhpcy5sb2NhbEFkZHJlc3M7XG4gIH1cblxuICB0cnkge1xuICAgIHRoaXMud3MgPSB0aGlzLnVzaW5nQnJvd3NlcldlYlNvY2tldCA/IChwcm90b2NvbHMgPyBuZXcgV2ViU29ja2V0KHVyaSwgcHJvdG9jb2xzKSA6IG5ldyBXZWJTb2NrZXQodXJpKSkgOiBuZXcgV2ViU29ja2V0KHVyaSwgcHJvdG9jb2xzLCBvcHRzKTtcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgcmV0dXJuIHRoaXMuZW1pdCgnZXJyb3InLCBlcnIpO1xuICB9XG5cbiAgaWYgKHRoaXMud3MuYmluYXJ5VHlwZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgdGhpcy5zdXBwb3J0c0JpbmFyeSA9IGZhbHNlO1xuICB9XG5cbiAgaWYgKHRoaXMud3Muc3VwcG9ydHMgJiYgdGhpcy53cy5zdXBwb3J0cy5iaW5hcnkpIHtcbiAgICB0aGlzLnN1cHBvcnRzQmluYXJ5ID0gdHJ1ZTtcbiAgICB0aGlzLndzLmJpbmFyeVR5cGUgPSAnbm9kZWJ1ZmZlcic7XG4gIH0gZWxzZSB7XG4gICAgdGhpcy53cy5iaW5hcnlUeXBlID0gJ2FycmF5YnVmZmVyJztcbiAgfVxuXG4gIHRoaXMuYWRkRXZlbnRMaXN0ZW5lcnMoKTtcbn07XG5cbi8qKlxuICogQWRkcyBldmVudCBsaXN0ZW5lcnMgdG8gdGhlIHNvY2tldFxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbldTLnByb3RvdHlwZS5hZGRFdmVudExpc3RlbmVycyA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gIHRoaXMud3Mub25vcGVuID0gZnVuY3Rpb24gKCkge1xuICAgIHNlbGYub25PcGVuKCk7XG4gIH07XG4gIHRoaXMud3Mub25jbG9zZSA9IGZ1bmN0aW9uICgpIHtcbiAgICBzZWxmLm9uQ2xvc2UoKTtcbiAgfTtcbiAgdGhpcy53cy5vbm1lc3NhZ2UgPSBmdW5jdGlvbiAoZXYpIHtcbiAgICBzZWxmLm9uRGF0YShldi5kYXRhKTtcbiAgfTtcbiAgdGhpcy53cy5vbmVycm9yID0gZnVuY3Rpb24gKGUpIHtcbiAgICBzZWxmLm9uRXJyb3IoJ3dlYnNvY2tldCBlcnJvcicsIGUpO1xuICB9O1xufTtcblxuLyoqXG4gKiBXcml0ZXMgZGF0YSB0byBzb2NrZXQuXG4gKlxuICogQHBhcmFtIHtBcnJheX0gYXJyYXkgb2YgcGFja2V0cy5cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbldTLnByb3RvdHlwZS53cml0ZSA9IGZ1bmN0aW9uIChwYWNrZXRzKSB7XG4gIHZhciBzZWxmID0gdGhpcztcbiAgdGhpcy53cml0YWJsZSA9IGZhbHNlO1xuXG4gIC8vIGVuY29kZVBhY2tldCBlZmZpY2llbnQgYXMgaXQgdXNlcyBXUyBmcmFtaW5nXG4gIC8vIG5vIG5lZWQgZm9yIGVuY29kZVBheWxvYWRcbiAgdmFyIHRvdGFsID0gcGFja2V0cy5sZW5ndGg7XG4gIGZvciAodmFyIGkgPSAwLCBsID0gdG90YWw7IGkgPCBsOyBpKyspIHtcbiAgICAoZnVuY3Rpb24gKHBhY2tldCkge1xuICAgICAgcGFyc2VyLmVuY29kZVBhY2tldChwYWNrZXQsIHNlbGYuc3VwcG9ydHNCaW5hcnksIGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgICAgIGlmICghc2VsZi51c2luZ0Jyb3dzZXJXZWJTb2NrZXQpIHtcbiAgICAgICAgICAvLyBhbHdheXMgY3JlYXRlIGEgbmV3IG9iamVjdCAoR0gtNDM3KVxuICAgICAgICAgIHZhciBvcHRzID0ge307XG4gICAgICAgICAgaWYgKHBhY2tldC5vcHRpb25zKSB7XG4gICAgICAgICAgICBvcHRzLmNvbXByZXNzID0gcGFja2V0Lm9wdGlvbnMuY29tcHJlc3M7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKHNlbGYucGVyTWVzc2FnZURlZmxhdGUpIHtcbiAgICAgICAgICAgIHZhciBsZW4gPSAnc3RyaW5nJyA9PT0gdHlwZW9mIGRhdGEgPyBnbG9iYWwuQnVmZmVyLmJ5dGVMZW5ndGgoZGF0YSkgOiBkYXRhLmxlbmd0aDtcbiAgICAgICAgICAgIGlmIChsZW4gPCBzZWxmLnBlck1lc3NhZ2VEZWZsYXRlLnRocmVzaG9sZCkge1xuICAgICAgICAgICAgICBvcHRzLmNvbXByZXNzID0gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gU29tZXRpbWVzIHRoZSB3ZWJzb2NrZXQgaGFzIGFscmVhZHkgYmVlbiBjbG9zZWQgYnV0IHRoZSBicm93c2VyIGRpZG4ndFxuICAgICAgICAvLyBoYXZlIGEgY2hhbmNlIG9mIGluZm9ybWluZyB1cyBhYm91dCBpdCB5ZXQsIGluIHRoYXQgY2FzZSBzZW5kIHdpbGxcbiAgICAgICAgLy8gdGhyb3cgYW4gZXJyb3JcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBpZiAoc2VsZi51c2luZ0Jyb3dzZXJXZWJTb2NrZXQpIHtcbiAgICAgICAgICAgIC8vIFR5cGVFcnJvciBpcyB0aHJvd24gd2hlbiBwYXNzaW5nIHRoZSBzZWNvbmQgYXJndW1lbnQgb24gU2FmYXJpXG4gICAgICAgICAgICBzZWxmLndzLnNlbmQoZGF0YSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHNlbGYud3Muc2VuZChkYXRhLCBvcHRzKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcblxuICAgICAgICB9XG5cbiAgICAgICAgLS10b3RhbCB8fCBkb25lKCk7XG4gICAgICB9KTtcbiAgICB9KShwYWNrZXRzW2ldKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGRvbmUgKCkge1xuICAgIHNlbGYuZW1pdCgnZmx1c2gnKTtcblxuICAgIC8vIGZha2UgZHJhaW5cbiAgICAvLyBkZWZlciB0byBuZXh0IHRpY2sgdG8gYWxsb3cgU29ja2V0IHRvIGNsZWFyIHdyaXRlQnVmZmVyXG4gICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICBzZWxmLndyaXRhYmxlID0gdHJ1ZTtcbiAgICAgIHNlbGYuZW1pdCgnZHJhaW4nKTtcbiAgICB9LCAwKTtcbiAgfVxufTtcblxuLyoqXG4gKiBDYWxsZWQgdXBvbiBjbG9zZVxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbldTLnByb3RvdHlwZS5vbkNsb3NlID0gZnVuY3Rpb24gKCkge1xuICBUcmFuc3BvcnQucHJvdG90eXBlLm9uQ2xvc2UuY2FsbCh0aGlzKTtcbn07XG5cbi8qKlxuICogQ2xvc2VzIHNvY2tldC5cbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5XUy5wcm90b3R5cGUuZG9DbG9zZSA9IGZ1bmN0aW9uICgpIHtcbiAgaWYgKHR5cGVvZiB0aGlzLndzICE9PSAndW5kZWZpbmVkJykge1xuICAgIHRoaXMud3MuY2xvc2UoKTtcbiAgfVxufTtcblxuLyoqXG4gKiBHZW5lcmF0ZXMgdXJpIGZvciBjb25uZWN0aW9uLlxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbldTLnByb3RvdHlwZS51cmkgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBxdWVyeSA9IHRoaXMucXVlcnkgfHwge307XG4gIHZhciBzY2hlbWEgPSB0aGlzLnNlY3VyZSA/ICd3c3MnIDogJ3dzJztcbiAgdmFyIHBvcnQgPSAnJztcblxuICAvLyBhdm9pZCBwb3J0IGlmIGRlZmF1bHQgZm9yIHNjaGVtYVxuICBpZiAodGhpcy5wb3J0ICYmICgoJ3dzcycgPT09IHNjaGVtYSAmJiBOdW1iZXIodGhpcy5wb3J0KSAhPT0gNDQzKSB8fFxuICAgICgnd3MnID09PSBzY2hlbWEgJiYgTnVtYmVyKHRoaXMucG9ydCkgIT09IDgwKSkpIHtcbiAgICBwb3J0ID0gJzonICsgdGhpcy5wb3J0O1xuICB9XG5cbiAgLy8gYXBwZW5kIHRpbWVzdGFtcCB0byBVUklcbiAgaWYgKHRoaXMudGltZXN0YW1wUmVxdWVzdHMpIHtcbiAgICBxdWVyeVt0aGlzLnRpbWVzdGFtcFBhcmFtXSA9IHllYXN0KCk7XG4gIH1cblxuICAvLyBjb21tdW5pY2F0ZSBiaW5hcnkgc3VwcG9ydCBjYXBhYmlsaXRpZXNcbiAgaWYgKCF0aGlzLnN1cHBvcnRzQmluYXJ5KSB7XG4gICAgcXVlcnkuYjY0ID0gMTtcbiAgfVxuXG4gIHF1ZXJ5ID0gcGFyc2Vxcy5lbmNvZGUocXVlcnkpO1xuXG4gIC8vIHByZXBlbmQgPyB0byBxdWVyeVxuICBpZiAocXVlcnkubGVuZ3RoKSB7XG4gICAgcXVlcnkgPSAnPycgKyBxdWVyeTtcbiAgfVxuXG4gIHZhciBpcHY2ID0gdGhpcy5ob3N0bmFtZS5pbmRleE9mKCc6JykgIT09IC0xO1xuICByZXR1cm4gc2NoZW1hICsgJzovLycgKyAoaXB2NiA/ICdbJyArIHRoaXMuaG9zdG5hbWUgKyAnXScgOiB0aGlzLmhvc3RuYW1lKSArIHBvcnQgKyB0aGlzLnBhdGggKyBxdWVyeTtcbn07XG5cbi8qKlxuICogRmVhdHVyZSBkZXRlY3Rpb24gZm9yIFdlYlNvY2tldC5cbiAqXG4gKiBAcmV0dXJuIHtCb29sZWFufSB3aGV0aGVyIHRoaXMgdHJhbnNwb3J0IGlzIGF2YWlsYWJsZS5cbiAqIEBhcGkgcHVibGljXG4gKi9cblxuV1MucHJvdG90eXBlLmNoZWNrID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gISFXZWJTb2NrZXQgJiYgISgnX19pbml0aWFsaXplJyBpbiBXZWJTb2NrZXQgJiYgdGhpcy5uYW1lID09PSBXUy5wcm90b3R5cGUubmFtZSk7XG59O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2VuZ2luZS5pby1jbGllbnQvbGliL3RyYW5zcG9ydHMvd2Vic29ja2V0LmpzXG4vLyBtb2R1bGUgaWQgPSAzMlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJcbnZhciBpbmRleE9mID0gW10uaW5kZXhPZjtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihhcnIsIG9iail7XG4gIGlmIChpbmRleE9mKSByZXR1cm4gYXJyLmluZGV4T2Yob2JqKTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcnIubGVuZ3RoOyArK2kpIHtcbiAgICBpZiAoYXJyW2ldID09PSBvYmopIHJldHVybiBpO1xuICB9XG4gIHJldHVybiAtMTtcbn07XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2luZGV4b2YvaW5kZXguanNcbi8vIG1vZHVsZSBpZCA9IDM0XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qKlxyXG4gKiBKU09OIHBhcnNlLlxyXG4gKlxyXG4gKiBAc2VlIEJhc2VkIG9uIGpRdWVyeSNwYXJzZUpTT04gKE1JVCkgYW5kIEpTT04yXHJcbiAqIEBhcGkgcHJpdmF0ZVxyXG4gKi9cclxuXHJcbnZhciBydmFsaWRjaGFycyA9IC9eW1xcXSw6e31cXHNdKiQvO1xyXG52YXIgcnZhbGlkZXNjYXBlID0gL1xcXFwoPzpbXCJcXFxcXFwvYmZucnRdfHVbMC05YS1mQS1GXXs0fSkvZztcclxudmFyIHJ2YWxpZHRva2VucyA9IC9cIlteXCJcXFxcXFxuXFxyXSpcInx0cnVlfGZhbHNlfG51bGx8LT9cXGQrKD86XFwuXFxkKik/KD86W2VFXVsrXFwtXT9cXGQrKT8vZztcclxudmFyIHJ2YWxpZGJyYWNlcyA9IC8oPzpefDp8LCkoPzpcXHMqXFxbKSsvZztcclxudmFyIHJ0cmltTGVmdCA9IC9eXFxzKy87XHJcbnZhciBydHJpbVJpZ2h0ID0gL1xccyskLztcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gcGFyc2Vqc29uKGRhdGEpIHtcclxuICBpZiAoJ3N0cmluZycgIT0gdHlwZW9mIGRhdGEgfHwgIWRhdGEpIHtcclxuICAgIHJldHVybiBudWxsO1xyXG4gIH1cclxuXHJcbiAgZGF0YSA9IGRhdGEucmVwbGFjZShydHJpbUxlZnQsICcnKS5yZXBsYWNlKHJ0cmltUmlnaHQsICcnKTtcclxuXHJcbiAgLy8gQXR0ZW1wdCB0byBwYXJzZSB1c2luZyB0aGUgbmF0aXZlIEpTT04gcGFyc2VyIGZpcnN0XHJcbiAgaWYgKGdsb2JhbC5KU09OICYmIEpTT04ucGFyc2UpIHtcclxuICAgIHJldHVybiBKU09OLnBhcnNlKGRhdGEpO1xyXG4gIH1cclxuXHJcbiAgaWYgKHJ2YWxpZGNoYXJzLnRlc3QoZGF0YS5yZXBsYWNlKHJ2YWxpZGVzY2FwZSwgJ0AnKVxyXG4gICAgICAucmVwbGFjZShydmFsaWR0b2tlbnMsICddJylcclxuICAgICAgLnJlcGxhY2UocnZhbGlkYnJhY2VzLCAnJykpKSB7XHJcbiAgICByZXR1cm4gKG5ldyBGdW5jdGlvbigncmV0dXJuICcgKyBkYXRhKSkoKTtcclxuICB9XHJcbn07XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3BhcnNlanNvbi9pbmRleC5qc1xuLy8gbW9kdWxlIGlkID0gMzVcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiXG4vKipcbiAqIE1vZHVsZSBkZXBlbmRlbmNpZXMuXG4gKi9cblxudmFyIHBhcnNlciA9IHJlcXVpcmUoJ3NvY2tldC5pby1wYXJzZXInKTtcbnZhciBFbWl0dGVyID0gcmVxdWlyZSgnY29tcG9uZW50LWVtaXR0ZXInKTtcbnZhciB0b0FycmF5ID0gcmVxdWlyZSgndG8tYXJyYXknKTtcbnZhciBvbiA9IHJlcXVpcmUoJy4vb24nKTtcbnZhciBiaW5kID0gcmVxdWlyZSgnY29tcG9uZW50LWJpbmQnKTtcbnZhciBkZWJ1ZyA9IHJlcXVpcmUoJ2RlYnVnJykoJ3NvY2tldC5pby1jbGllbnQ6c29ja2V0Jyk7XG52YXIgcGFyc2VxcyA9IHJlcXVpcmUoJ3BhcnNlcXMnKTtcblxuLyoqXG4gKiBNb2R1bGUgZXhwb3J0cy5cbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHMgPSBTb2NrZXQ7XG5cbi8qKlxuICogSW50ZXJuYWwgZXZlbnRzIChibGFja2xpc3RlZCkuXG4gKiBUaGVzZSBldmVudHMgY2FuJ3QgYmUgZW1pdHRlZCBieSB0aGUgdXNlci5cbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG52YXIgZXZlbnRzID0ge1xuICBjb25uZWN0OiAxLFxuICBjb25uZWN0X2Vycm9yOiAxLFxuICBjb25uZWN0X3RpbWVvdXQ6IDEsXG4gIGNvbm5lY3Rpbmc6IDEsXG4gIGRpc2Nvbm5lY3Q6IDEsXG4gIGVycm9yOiAxLFxuICByZWNvbm5lY3Q6IDEsXG4gIHJlY29ubmVjdF9hdHRlbXB0OiAxLFxuICByZWNvbm5lY3RfZmFpbGVkOiAxLFxuICByZWNvbm5lY3RfZXJyb3I6IDEsXG4gIHJlY29ubmVjdGluZzogMSxcbiAgcGluZzogMSxcbiAgcG9uZzogMVxufTtcblxuLyoqXG4gKiBTaG9ydGN1dCB0byBgRW1pdHRlciNlbWl0YC5cbiAqL1xuXG52YXIgZW1pdCA9IEVtaXR0ZXIucHJvdG90eXBlLmVtaXQ7XG5cbi8qKlxuICogYFNvY2tldGAgY29uc3RydWN0b3IuXG4gKlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5mdW5jdGlvbiBTb2NrZXQgKGlvLCBuc3AsIG9wdHMpIHtcbiAgdGhpcy5pbyA9IGlvO1xuICB0aGlzLm5zcCA9IG5zcDtcbiAgdGhpcy5qc29uID0gdGhpczsgLy8gY29tcGF0XG4gIHRoaXMuaWRzID0gMDtcbiAgdGhpcy5hY2tzID0ge307XG4gIHRoaXMucmVjZWl2ZUJ1ZmZlciA9IFtdO1xuICB0aGlzLnNlbmRCdWZmZXIgPSBbXTtcbiAgdGhpcy5jb25uZWN0ZWQgPSBmYWxzZTtcbiAgdGhpcy5kaXNjb25uZWN0ZWQgPSB0cnVlO1xuICBpZiAob3B0cyAmJiBvcHRzLnF1ZXJ5KSB7XG4gICAgdGhpcy5xdWVyeSA9IG9wdHMucXVlcnk7XG4gIH1cbiAgaWYgKHRoaXMuaW8uYXV0b0Nvbm5lY3QpIHRoaXMub3BlbigpO1xufVxuXG4vKipcbiAqIE1peCBpbiBgRW1pdHRlcmAuXG4gKi9cblxuRW1pdHRlcihTb2NrZXQucHJvdG90eXBlKTtcblxuLyoqXG4gKiBTdWJzY3JpYmUgdG8gb3BlbiwgY2xvc2UgYW5kIHBhY2tldCBldmVudHNcbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5Tb2NrZXQucHJvdG90eXBlLnN1YkV2ZW50cyA9IGZ1bmN0aW9uICgpIHtcbiAgaWYgKHRoaXMuc3VicykgcmV0dXJuO1xuXG4gIHZhciBpbyA9IHRoaXMuaW87XG4gIHRoaXMuc3VicyA9IFtcbiAgICBvbihpbywgJ29wZW4nLCBiaW5kKHRoaXMsICdvbm9wZW4nKSksXG4gICAgb24oaW8sICdwYWNrZXQnLCBiaW5kKHRoaXMsICdvbnBhY2tldCcpKSxcbiAgICBvbihpbywgJ2Nsb3NlJywgYmluZCh0aGlzLCAnb25jbG9zZScpKVxuICBdO1xufTtcblxuLyoqXG4gKiBcIk9wZW5zXCIgdGhlIHNvY2tldC5cbiAqXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cblNvY2tldC5wcm90b3R5cGUub3BlbiA9XG5Tb2NrZXQucHJvdG90eXBlLmNvbm5lY3QgPSBmdW5jdGlvbiAoKSB7XG4gIGlmICh0aGlzLmNvbm5lY3RlZCkgcmV0dXJuIHRoaXM7XG5cbiAgdGhpcy5zdWJFdmVudHMoKTtcbiAgdGhpcy5pby5vcGVuKCk7IC8vIGVuc3VyZSBvcGVuXG4gIGlmICgnb3BlbicgPT09IHRoaXMuaW8ucmVhZHlTdGF0ZSkgdGhpcy5vbm9wZW4oKTtcbiAgdGhpcy5lbWl0KCdjb25uZWN0aW5nJyk7XG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBTZW5kcyBhIGBtZXNzYWdlYCBldmVudC5cbiAqXG4gKiBAcmV0dXJuIHtTb2NrZXR9IHNlbGZcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuU29ja2V0LnByb3RvdHlwZS5zZW5kID0gZnVuY3Rpb24gKCkge1xuICB2YXIgYXJncyA9IHRvQXJyYXkoYXJndW1lbnRzKTtcbiAgYXJncy51bnNoaWZ0KCdtZXNzYWdlJyk7XG4gIHRoaXMuZW1pdC5hcHBseSh0aGlzLCBhcmdzKTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIE92ZXJyaWRlIGBlbWl0YC5cbiAqIElmIHRoZSBldmVudCBpcyBpbiBgZXZlbnRzYCwgaXQncyBlbWl0dGVkIG5vcm1hbGx5LlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBldmVudCBuYW1lXG4gKiBAcmV0dXJuIHtTb2NrZXR9IHNlbGZcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuU29ja2V0LnByb3RvdHlwZS5lbWl0ID0gZnVuY3Rpb24gKGV2KSB7XG4gIGlmIChldmVudHMuaGFzT3duUHJvcGVydHkoZXYpKSB7XG4gICAgZW1pdC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgdmFyIGFyZ3MgPSB0b0FycmF5KGFyZ3VtZW50cyk7XG4gIHZhciBwYWNrZXQgPSB7IHR5cGU6IHBhcnNlci5FVkVOVCwgZGF0YTogYXJncyB9O1xuXG4gIHBhY2tldC5vcHRpb25zID0ge307XG4gIHBhY2tldC5vcHRpb25zLmNvbXByZXNzID0gIXRoaXMuZmxhZ3MgfHwgZmFsc2UgIT09IHRoaXMuZmxhZ3MuY29tcHJlc3M7XG5cbiAgLy8gZXZlbnQgYWNrIGNhbGxiYWNrXG4gIGlmICgnZnVuY3Rpb24nID09PSB0eXBlb2YgYXJnc1thcmdzLmxlbmd0aCAtIDFdKSB7XG5cbiAgICB0aGlzLmFja3NbdGhpcy5pZHNdID0gYXJncy5wb3AoKTtcbiAgICBwYWNrZXQuaWQgPSB0aGlzLmlkcysrO1xuICB9XG5cbiAgaWYgKHRoaXMuY29ubmVjdGVkKSB7XG4gICAgdGhpcy5wYWNrZXQocGFja2V0KTtcbiAgfSBlbHNlIHtcbiAgICB0aGlzLnNlbmRCdWZmZXIucHVzaChwYWNrZXQpO1xuICB9XG5cbiAgZGVsZXRlIHRoaXMuZmxhZ3M7XG5cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIFNlbmRzIGEgcGFja2V0LlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBwYWNrZXRcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblNvY2tldC5wcm90b3R5cGUucGFja2V0ID0gZnVuY3Rpb24gKHBhY2tldCkge1xuICBwYWNrZXQubnNwID0gdGhpcy5uc3A7XG4gIHRoaXMuaW8ucGFja2V0KHBhY2tldCk7XG59O1xuXG4vKipcbiAqIENhbGxlZCB1cG9uIGVuZ2luZSBgb3BlbmAuXG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuU29ja2V0LnByb3RvdHlwZS5vbm9wZW4gPSBmdW5jdGlvbiAoKSB7XG5cblxuICAvLyB3cml0ZSBjb25uZWN0IHBhY2tldCBpZiBuZWNlc3NhcnlcbiAgaWYgKCcvJyAhPT0gdGhpcy5uc3ApIHtcbiAgICBpZiAodGhpcy5xdWVyeSkge1xuICAgICAgdmFyIHF1ZXJ5ID0gdHlwZW9mIHRoaXMucXVlcnkgPT09ICdvYmplY3QnID8gcGFyc2Vxcy5lbmNvZGUodGhpcy5xdWVyeSkgOiB0aGlzLnF1ZXJ5O1xuXG4gICAgICB0aGlzLnBhY2tldCh7dHlwZTogcGFyc2VyLkNPTk5FQ1QsIHF1ZXJ5OiBxdWVyeX0pO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnBhY2tldCh7dHlwZTogcGFyc2VyLkNPTk5FQ1R9KTtcbiAgICB9XG4gIH1cbn07XG5cbi8qKlxuICogQ2FsbGVkIHVwb24gZW5naW5lIGBjbG9zZWAuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHJlYXNvblxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuU29ja2V0LnByb3RvdHlwZS5vbmNsb3NlID0gZnVuY3Rpb24gKHJlYXNvbikge1xuXG4gIHRoaXMuY29ubmVjdGVkID0gZmFsc2U7XG4gIHRoaXMuZGlzY29ubmVjdGVkID0gdHJ1ZTtcbiAgZGVsZXRlIHRoaXMuaWQ7XG4gIHRoaXMuZW1pdCgnZGlzY29ubmVjdCcsIHJlYXNvbik7XG59O1xuXG4vKipcbiAqIENhbGxlZCB3aXRoIHNvY2tldCBwYWNrZXQuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IHBhY2tldFxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuU29ja2V0LnByb3RvdHlwZS5vbnBhY2tldCA9IGZ1bmN0aW9uIChwYWNrZXQpIHtcbiAgaWYgKHBhY2tldC5uc3AgIT09IHRoaXMubnNwKSByZXR1cm47XG5cbiAgc3dpdGNoIChwYWNrZXQudHlwZSkge1xuICAgIGNhc2UgcGFyc2VyLkNPTk5FQ1Q6XG4gICAgICB0aGlzLm9uY29ubmVjdCgpO1xuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlIHBhcnNlci5FVkVOVDpcbiAgICAgIHRoaXMub25ldmVudChwYWNrZXQpO1xuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlIHBhcnNlci5CSU5BUllfRVZFTlQ6XG4gICAgICB0aGlzLm9uZXZlbnQocGFja2V0KTtcbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSBwYXJzZXIuQUNLOlxuICAgICAgdGhpcy5vbmFjayhwYWNrZXQpO1xuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlIHBhcnNlci5CSU5BUllfQUNLOlxuICAgICAgdGhpcy5vbmFjayhwYWNrZXQpO1xuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlIHBhcnNlci5ESVNDT05ORUNUOlxuICAgICAgdGhpcy5vbmRpc2Nvbm5lY3QoKTtcbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSBwYXJzZXIuRVJST1I6XG4gICAgICB0aGlzLmVtaXQoJ2Vycm9yJywgcGFja2V0LmRhdGEpO1xuICAgICAgYnJlYWs7XG4gIH1cbn07XG5cbi8qKlxuICogQ2FsbGVkIHVwb24gYSBzZXJ2ZXIgZXZlbnQuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IHBhY2tldFxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuU29ja2V0LnByb3RvdHlwZS5vbmV2ZW50ID0gZnVuY3Rpb24gKHBhY2tldCkge1xuICB2YXIgYXJncyA9IHBhY2tldC5kYXRhIHx8IFtdO1xuXG5cbiAgaWYgKG51bGwgIT0gcGFja2V0LmlkKSB7XG5cbiAgICBhcmdzLnB1c2godGhpcy5hY2socGFja2V0LmlkKSk7XG4gIH1cblxuICBpZiAodGhpcy5jb25uZWN0ZWQpIHtcbiAgICBlbWl0LmFwcGx5KHRoaXMsIGFyZ3MpO1xuICB9IGVsc2Uge1xuICAgIHRoaXMucmVjZWl2ZUJ1ZmZlci5wdXNoKGFyZ3MpO1xuICB9XG59O1xuXG4vKipcbiAqIFByb2R1Y2VzIGFuIGFjayBjYWxsYmFjayB0byBlbWl0IHdpdGggYW4gZXZlbnQuXG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuU29ja2V0LnByb3RvdHlwZS5hY2sgPSBmdW5jdGlvbiAoaWQpIHtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICB2YXIgc2VudCA9IGZhbHNlO1xuICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgIC8vIHByZXZlbnQgZG91YmxlIGNhbGxiYWNrc1xuICAgIGlmIChzZW50KSByZXR1cm47XG4gICAgc2VudCA9IHRydWU7XG4gICAgdmFyIGFyZ3MgPSB0b0FycmF5KGFyZ3VtZW50cyk7XG5cblxuICAgIHNlbGYucGFja2V0KHtcbiAgICAgIHR5cGU6IHBhcnNlci5BQ0ssXG4gICAgICBpZDogaWQsXG4gICAgICBkYXRhOiBhcmdzXG4gICAgfSk7XG4gIH07XG59O1xuXG4vKipcbiAqIENhbGxlZCB1cG9uIGEgc2VydmVyIGFja25vd2xlZ2VtZW50LlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBwYWNrZXRcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblNvY2tldC5wcm90b3R5cGUub25hY2sgPSBmdW5jdGlvbiAocGFja2V0KSB7XG4gIHZhciBhY2sgPSB0aGlzLmFja3NbcGFja2V0LmlkXTtcbiAgaWYgKCdmdW5jdGlvbicgPT09IHR5cGVvZiBhY2spIHtcblxuICAgIGFjay5hcHBseSh0aGlzLCBwYWNrZXQuZGF0YSk7XG4gICAgZGVsZXRlIHRoaXMuYWNrc1twYWNrZXQuaWRdO1xuICB9IGVsc2Uge1xuXG4gIH1cbn07XG5cbi8qKlxuICogQ2FsbGVkIHVwb24gc2VydmVyIGNvbm5lY3QuXG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuU29ja2V0LnByb3RvdHlwZS5vbmNvbm5lY3QgPSBmdW5jdGlvbiAoKSB7XG4gIHRoaXMuY29ubmVjdGVkID0gdHJ1ZTtcbiAgdGhpcy5kaXNjb25uZWN0ZWQgPSBmYWxzZTtcbiAgdGhpcy5lbWl0KCdjb25uZWN0Jyk7XG4gIHRoaXMuZW1pdEJ1ZmZlcmVkKCk7XG59O1xuXG4vKipcbiAqIEVtaXQgYnVmZmVyZWQgZXZlbnRzIChyZWNlaXZlZCBhbmQgZW1pdHRlZCkuXG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuU29ja2V0LnByb3RvdHlwZS5lbWl0QnVmZmVyZWQgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBpO1xuICBmb3IgKGkgPSAwOyBpIDwgdGhpcy5yZWNlaXZlQnVmZmVyLmxlbmd0aDsgaSsrKSB7XG4gICAgZW1pdC5hcHBseSh0aGlzLCB0aGlzLnJlY2VpdmVCdWZmZXJbaV0pO1xuICB9XG4gIHRoaXMucmVjZWl2ZUJ1ZmZlciA9IFtdO1xuXG4gIGZvciAoaSA9IDA7IGkgPCB0aGlzLnNlbmRCdWZmZXIubGVuZ3RoOyBpKyspIHtcbiAgICB0aGlzLnBhY2tldCh0aGlzLnNlbmRCdWZmZXJbaV0pO1xuICB9XG4gIHRoaXMuc2VuZEJ1ZmZlciA9IFtdO1xufTtcblxuLyoqXG4gKiBDYWxsZWQgdXBvbiBzZXJ2ZXIgZGlzY29ubmVjdC5cbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5Tb2NrZXQucHJvdG90eXBlLm9uZGlzY29ubmVjdCA9IGZ1bmN0aW9uICgpIHtcblxuICB0aGlzLmRlc3Ryb3koKTtcbiAgdGhpcy5vbmNsb3NlKCdpbyBzZXJ2ZXIgZGlzY29ubmVjdCcpO1xufTtcblxuLyoqXG4gKiBDYWxsZWQgdXBvbiBmb3JjZWQgY2xpZW50L3NlcnZlciBzaWRlIGRpc2Nvbm5lY3Rpb25zLFxuICogdGhpcyBtZXRob2QgZW5zdXJlcyB0aGUgbWFuYWdlciBzdG9wcyB0cmFja2luZyB1cyBhbmRcbiAqIHRoYXQgcmVjb25uZWN0aW9ucyBkb24ndCBnZXQgdHJpZ2dlcmVkIGZvciB0aGlzLlxuICpcbiAqIEBhcGkgcHJpdmF0ZS5cbiAqL1xuXG5Tb2NrZXQucHJvdG90eXBlLmRlc3Ryb3kgPSBmdW5jdGlvbiAoKSB7XG4gIGlmICh0aGlzLnN1YnMpIHtcbiAgICAvLyBjbGVhbiBzdWJzY3JpcHRpb25zIHRvIGF2b2lkIHJlY29ubmVjdGlvbnNcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuc3Vicy5sZW5ndGg7IGkrKykge1xuICAgICAgdGhpcy5zdWJzW2ldLmRlc3Ryb3koKTtcbiAgICB9XG4gICAgdGhpcy5zdWJzID0gbnVsbDtcbiAgfVxuXG4gIHRoaXMuaW8uZGVzdHJveSh0aGlzKTtcbn07XG5cbi8qKlxuICogRGlzY29ubmVjdHMgdGhlIHNvY2tldCBtYW51YWxseS5cbiAqXG4gKiBAcmV0dXJuIHtTb2NrZXR9IHNlbGZcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuU29ja2V0LnByb3RvdHlwZS5jbG9zZSA9XG5Tb2NrZXQucHJvdG90eXBlLmRpc2Nvbm5lY3QgPSBmdW5jdGlvbiAoKSB7XG4gIGlmICh0aGlzLmNvbm5lY3RlZCkge1xuXG4gICAgdGhpcy5wYWNrZXQoeyB0eXBlOiBwYXJzZXIuRElTQ09OTkVDVCB9KTtcbiAgfVxuXG4gIC8vIHJlbW92ZSBzb2NrZXQgZnJvbSBwb29sXG4gIHRoaXMuZGVzdHJveSgpO1xuXG4gIGlmICh0aGlzLmNvbm5lY3RlZCkge1xuICAgIC8vIGZpcmUgZXZlbnRzXG4gICAgdGhpcy5vbmNsb3NlKCdpbyBjbGllbnQgZGlzY29ubmVjdCcpO1xuICB9XG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBTZXRzIHRoZSBjb21wcmVzcyBmbGFnLlxuICpcbiAqIEBwYXJhbSB7Qm9vbGVhbn0gaWYgYHRydWVgLCBjb21wcmVzc2VzIHRoZSBzZW5kaW5nIGRhdGFcbiAqIEByZXR1cm4ge1NvY2tldH0gc2VsZlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5Tb2NrZXQucHJvdG90eXBlLmNvbXByZXNzID0gZnVuY3Rpb24gKGNvbXByZXNzKSB7XG4gIHRoaXMuZmxhZ3MgPSB0aGlzLmZsYWdzIHx8IHt9O1xuICB0aGlzLmZsYWdzLmNvbXByZXNzID0gY29tcHJlc3M7XG4gIHJldHVybiB0aGlzO1xufTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL2xpYi9zb2NrZXQuanMiLCJtb2R1bGUuZXhwb3J0cyA9IHRvQXJyYXlcblxuZnVuY3Rpb24gdG9BcnJheShsaXN0LCBpbmRleCkge1xuICAgIHZhciBhcnJheSA9IFtdXG5cbiAgICBpbmRleCA9IGluZGV4IHx8IDBcblxuICAgIGZvciAodmFyIGkgPSBpbmRleCB8fCAwOyBpIDwgbGlzdC5sZW5ndGg7IGkrKykge1xuICAgICAgICBhcnJheVtpIC0gaW5kZXhdID0gbGlzdFtpXVxuICAgIH1cblxuICAgIHJldHVybiBhcnJheVxufVxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3RvLWFycmF5L2luZGV4LmpzXG4vLyBtb2R1bGUgaWQgPSAzN1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJcbi8qKlxuICogTW9kdWxlIGV4cG9ydHMuXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBvbjtcblxuLyoqXG4gKiBIZWxwZXIgZm9yIHN1YnNjcmlwdGlvbnMuXG4gKlxuICogQHBhcmFtIHtPYmplY3R8RXZlbnRFbWl0dGVyfSBvYmogd2l0aCBgRW1pdHRlcmAgbWl4aW4gb3IgYEV2ZW50RW1pdHRlcmBcbiAqIEBwYXJhbSB7U3RyaW5nfSBldmVudCBuYW1lXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFja1xuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5mdW5jdGlvbiBvbiAob2JqLCBldiwgZm4pIHtcbiAgb2JqLm9uKGV2LCBmbik7XG4gIHJldHVybiB7XG4gICAgZGVzdHJveTogZnVuY3Rpb24gKCkge1xuICAgICAgb2JqLnJlbW92ZUxpc3RlbmVyKGV2LCBmbik7XG4gICAgfVxuICB9O1xufVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbGliL29uLmpzIiwiLyoqXG4gKiBTbGljZSByZWZlcmVuY2UuXG4gKi9cblxudmFyIHNsaWNlID0gW10uc2xpY2U7XG5cbi8qKlxuICogQmluZCBgb2JqYCB0byBgZm5gLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmpcbiAqIEBwYXJhbSB7RnVuY3Rpb258U3RyaW5nfSBmbiBvciBzdHJpbmdcbiAqIEByZXR1cm4ge0Z1bmN0aW9ufVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKG9iaiwgZm4pe1xuICBpZiAoJ3N0cmluZycgPT0gdHlwZW9mIGZuKSBmbiA9IG9ialtmbl07XG4gIGlmICgnZnVuY3Rpb24nICE9IHR5cGVvZiBmbikgdGhyb3cgbmV3IEVycm9yKCdiaW5kKCkgcmVxdWlyZXMgYSBmdW5jdGlvbicpO1xuICB2YXIgYXJncyA9IHNsaWNlLmNhbGwoYXJndW1lbnRzLCAyKTtcbiAgcmV0dXJuIGZ1bmN0aW9uKCl7XG4gICAgcmV0dXJuIGZuLmFwcGx5KG9iaiwgYXJncy5jb25jYXQoc2xpY2UuY2FsbChhcmd1bWVudHMpKSk7XG4gIH1cbn07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vY29tcG9uZW50LWJpbmQvaW5kZXguanNcbi8vIG1vZHVsZSBpZCA9IDM5XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIlxuLyoqXG4gKiBFeHBvc2UgYEJhY2tvZmZgLlxuICovXG5cbm1vZHVsZS5leHBvcnRzID0gQmFja29mZjtcblxuLyoqXG4gKiBJbml0aWFsaXplIGJhY2tvZmYgdGltZXIgd2l0aCBgb3B0c2AuXG4gKlxuICogLSBgbWluYCBpbml0aWFsIHRpbWVvdXQgaW4gbWlsbGlzZWNvbmRzIFsxMDBdXG4gKiAtIGBtYXhgIG1heCB0aW1lb3V0IFsxMDAwMF1cbiAqIC0gYGppdHRlcmAgWzBdXG4gKiAtIGBmYWN0b3JgIFsyXVxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRzXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmZ1bmN0aW9uIEJhY2tvZmYob3B0cykge1xuICBvcHRzID0gb3B0cyB8fCB7fTtcbiAgdGhpcy5tcyA9IG9wdHMubWluIHx8IDEwMDtcbiAgdGhpcy5tYXggPSBvcHRzLm1heCB8fCAxMDAwMDtcbiAgdGhpcy5mYWN0b3IgPSBvcHRzLmZhY3RvciB8fCAyO1xuICB0aGlzLmppdHRlciA9IG9wdHMuaml0dGVyID4gMCAmJiBvcHRzLmppdHRlciA8PSAxID8gb3B0cy5qaXR0ZXIgOiAwO1xuICB0aGlzLmF0dGVtcHRzID0gMDtcbn1cblxuLyoqXG4gKiBSZXR1cm4gdGhlIGJhY2tvZmYgZHVyYXRpb24uXG4gKlxuICogQHJldHVybiB7TnVtYmVyfVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5CYWNrb2ZmLnByb3RvdHlwZS5kdXJhdGlvbiA9IGZ1bmN0aW9uKCl7XG4gIHZhciBtcyA9IHRoaXMubXMgKiBNYXRoLnBvdyh0aGlzLmZhY3RvciwgdGhpcy5hdHRlbXB0cysrKTtcbiAgaWYgKHRoaXMuaml0dGVyKSB7XG4gICAgdmFyIHJhbmQgPSAgTWF0aC5yYW5kb20oKTtcbiAgICB2YXIgZGV2aWF0aW9uID0gTWF0aC5mbG9vcihyYW5kICogdGhpcy5qaXR0ZXIgKiBtcyk7XG4gICAgbXMgPSAoTWF0aC5mbG9vcihyYW5kICogMTApICYgMSkgPT0gMCAgPyBtcyAtIGRldmlhdGlvbiA6IG1zICsgZGV2aWF0aW9uO1xuICB9XG4gIHJldHVybiBNYXRoLm1pbihtcywgdGhpcy5tYXgpIHwgMDtcbn07XG5cbi8qKlxuICogUmVzZXQgdGhlIG51bWJlciBvZiBhdHRlbXB0cy5cbiAqXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbkJhY2tvZmYucHJvdG90eXBlLnJlc2V0ID0gZnVuY3Rpb24oKXtcbiAgdGhpcy5hdHRlbXB0cyA9IDA7XG59O1xuXG4vKipcbiAqIFNldCB0aGUgbWluaW11bSBkdXJhdGlvblxuICpcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuQmFja29mZi5wcm90b3R5cGUuc2V0TWluID0gZnVuY3Rpb24obWluKXtcbiAgdGhpcy5tcyA9IG1pbjtcbn07XG5cbi8qKlxuICogU2V0IHRoZSBtYXhpbXVtIGR1cmF0aW9uXG4gKlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5CYWNrb2ZmLnByb3RvdHlwZS5zZXRNYXggPSBmdW5jdGlvbihtYXgpe1xuICB0aGlzLm1heCA9IG1heDtcbn07XG5cbi8qKlxuICogU2V0IHRoZSBqaXR0ZXJcbiAqXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbkJhY2tvZmYucHJvdG90eXBlLnNldEppdHRlciA9IGZ1bmN0aW9uKGppdHRlcil7XG4gIHRoaXMuaml0dGVyID0gaml0dGVyO1xufTtcblxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2JhY2tvMi9pbmRleC5qc1xuLy8gbW9kdWxlIGlkID0gNDBcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiIFx0Ly8gVGhlIG1vZHVsZSBjYWNoZVxuIFx0dmFyIGluc3RhbGxlZE1vZHVsZXMgPSB7fTtcblxuIFx0Ly8gVGhlIHJlcXVpcmUgZnVuY3Rpb25cbiBcdGZ1bmN0aW9uIF9fd2VicGFja19yZXF1aXJlX18obW9kdWxlSWQpIHtcblxuIFx0XHQvLyBDaGVjayBpZiBtb2R1bGUgaXMgaW4gY2FjaGVcbiBcdFx0aWYoaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0pIHtcbiBcdFx0XHRyZXR1cm4gaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0uZXhwb3J0cztcbiBcdFx0fVxuIFx0XHQvLyBDcmVhdGUgYSBuZXcgbW9kdWxlIChhbmQgcHV0IGl0IGludG8gdGhlIGNhY2hlKVxuIFx0XHR2YXIgbW9kdWxlID0gaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0gPSB7XG4gXHRcdFx0aTogbW9kdWxlSWQsXG4gXHRcdFx0bDogZmFsc2UsXG4gXHRcdFx0ZXhwb3J0czoge31cbiBcdFx0fTtcblxuIFx0XHQvLyBFeGVjdXRlIHRoZSBtb2R1bGUgZnVuY3Rpb25cbiBcdFx0bW9kdWxlc1ttb2R1bGVJZF0uY2FsbChtb2R1bGUuZXhwb3J0cywgbW9kdWxlLCBtb2R1bGUuZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXyk7XG5cbiBcdFx0Ly8gRmxhZyB0aGUgbW9kdWxlIGFzIGxvYWRlZFxuIFx0XHRtb2R1bGUubCA9IHRydWU7XG5cbiBcdFx0Ly8gUmV0dXJuIHRoZSBleHBvcnRzIG9mIHRoZSBtb2R1bGVcbiBcdFx0cmV0dXJuIG1vZHVsZS5leHBvcnRzO1xuIFx0fVxuXG5cbiBcdC8vIGV4cG9zZSB0aGUgbW9kdWxlcyBvYmplY3QgKF9fd2VicGFja19tb2R1bGVzX18pXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLm0gPSBtb2R1bGVzO1xuXG4gXHQvLyBleHBvc2UgdGhlIG1vZHVsZSBjYWNoZVxuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5jID0gaW5zdGFsbGVkTW9kdWxlcztcblxuIFx0Ly8gaWRlbnRpdHkgZnVuY3Rpb24gZm9yIGNhbGxpbmcgaGFybW9ueSBpbXBvcnRzIHdpdGggdGhlIGNvcnJlY3QgY29udGV4dFxuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5pID0gZnVuY3Rpb24odmFsdWUpIHsgcmV0dXJuIHZhbHVlOyB9O1xuXG4gXHQvLyBkZWZpbmUgZ2V0dGVyIGZ1bmN0aW9uIGZvciBoYXJtb255IGV4cG9ydHNcbiBcdF9fd2VicGFja19yZXF1aXJlX18uZCA9IGZ1bmN0aW9uKGV4cG9ydHMsIG5hbWUsIGdldHRlcikge1xuIFx0XHRpZighX193ZWJwYWNrX3JlcXVpcmVfXy5vKGV4cG9ydHMsIG5hbWUpKSB7XG4gXHRcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIG5hbWUsIHtcbiBcdFx0XHRcdGNvbmZpZ3VyYWJsZTogZmFsc2UsXG4gXHRcdFx0XHRlbnVtZXJhYmxlOiB0cnVlLFxuIFx0XHRcdFx0Z2V0OiBnZXR0ZXJcbiBcdFx0XHR9KTtcbiBcdFx0fVxuIFx0fTtcblxuIFx0Ly8gZ2V0RGVmYXVsdEV4cG9ydCBmdW5jdGlvbiBmb3IgY29tcGF0aWJpbGl0eSB3aXRoIG5vbi1oYXJtb255IG1vZHVsZXNcbiBcdF9fd2VicGFja19yZXF1aXJlX18ubiA9IGZ1bmN0aW9uKG1vZHVsZSkge1xuIFx0XHR2YXIgZ2V0dGVyID0gbW9kdWxlICYmIG1vZHVsZS5fX2VzTW9kdWxlID9cbiBcdFx0XHRmdW5jdGlvbiBnZXREZWZhdWx0KCkgeyByZXR1cm4gbW9kdWxlWydkZWZhdWx0J107IH0gOlxuIFx0XHRcdGZ1bmN0aW9uIGdldE1vZHVsZUV4cG9ydHMoKSB7IHJldHVybiBtb2R1bGU7IH07XG4gXHRcdF9fd2VicGFja19yZXF1aXJlX18uZChnZXR0ZXIsICdhJywgZ2V0dGVyKTtcbiBcdFx0cmV0dXJuIGdldHRlcjtcbiBcdH07XG5cbiBcdC8vIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbFxuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5vID0gZnVuY3Rpb24ob2JqZWN0LCBwcm9wZXJ0eSkgeyByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdCwgcHJvcGVydHkpOyB9O1xuXG4gXHQvLyBfX3dlYnBhY2tfcHVibGljX3BhdGhfX1xuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5wID0gXCJcIjtcblxuIFx0Ly8gTG9hZCBlbnRyeSBtb2R1bGUgYW5kIHJldHVybiBleHBvcnRzXG4gXHRyZXR1cm4gX193ZWJwYWNrX3JlcXVpcmVfXyhfX3dlYnBhY2tfcmVxdWlyZV9fLnMgPSAzMyk7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gd2VicGFjay9ib290c3RyYXAgNmNhYWZhMDkzNDBkOGI3NzJjOGYiLCIndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLnN0cmluZyA9IGV4cG9ydHMub2JqZWN0ID0gZXhwb3J0cy5EaXNwb3NhYmxlID0gZXhwb3J0cy5hc3luYyA9IGV4cG9ydHMuYXJyYXkgPSB1bmRlZmluZWQ7XG5cbnZhciBfY29yZSA9IHJlcXVpcmUoJy4vY29yZScpO1xuXG5PYmplY3Qua2V5cyhfY29yZSkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gIGlmIChrZXkgPT09IFwiZGVmYXVsdFwiIHx8IGtleSA9PT0gXCJfX2VzTW9kdWxlXCIpIHJldHVybjtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIGtleSwge1xuICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICByZXR1cm4gX2NvcmVba2V5XTtcbiAgICB9XG4gIH0pO1xufSk7XG5cbnZhciBfY29yZTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9jb3JlKTtcblxudmFyIF9hcnJheSA9IHJlcXVpcmUoJy4vYXJyYXkvYXJyYXknKTtcblxudmFyIF9hcnJheTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9hcnJheSk7XG5cbnZhciBfYXN5bmMgPSByZXF1aXJlKCcuL2FzeW5jL2FzeW5jJyk7XG5cbnZhciBfYXN5bmMyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfYXN5bmMpO1xuXG52YXIgX0Rpc3Bvc2FibGUgPSByZXF1aXJlKCcuL2Rpc3Bvc2FibGUvRGlzcG9zYWJsZScpO1xuXG52YXIgX0Rpc3Bvc2FibGUyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfRGlzcG9zYWJsZSk7XG5cbnZhciBfb2JqZWN0ID0gcmVxdWlyZSgnLi9vYmplY3Qvb2JqZWN0Jyk7XG5cbnZhciBfb2JqZWN0MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX29iamVjdCk7XG5cbnZhciBfc3RyaW5nID0gcmVxdWlyZSgnLi9zdHJpbmcvc3RyaW5nJyk7XG5cbnZhciBfc3RyaW5nMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3N0cmluZyk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbmV4cG9ydHMuYXJyYXkgPSBfYXJyYXkyLmRlZmF1bHQ7XG5leHBvcnRzLmFzeW5jID0gX2FzeW5jMi5kZWZhdWx0O1xuZXhwb3J0cy5EaXNwb3NhYmxlID0gX0Rpc3Bvc2FibGUyLmRlZmF1bHQ7XG5leHBvcnRzLm9iamVjdCA9IF9vYmplY3QyLmRlZmF1bHQ7XG5leHBvcnRzLnN0cmluZyA9IF9zdHJpbmcyLmRlZmF1bHQ7XG5leHBvcnRzLmRlZmF1bHQgPSBfY29yZTIuZGVmYXVsdDtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vbWV0YWwvbGliL21ldGFsLmpzXG4vLyBtb2R1bGUgaWQgPSAwXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBDbGFzcyByZXNwb25zaWJsZSBmb3Igc3RvcmluZyBhbiBvYmplY3QgdGhhdCB3aWxsIGJlIHByaW50ZWQgYXMgSlNPTlxuICogd2hlbiB0aGUgYHRvU3RyaW5nYCBtZXRob2QgaXMgY2FsbGVkLlxuICovXG5jbGFzcyBFbWJvZGllZCB7XG4gIC8qKlxuXHQgKiBDb25zdHJ1Y3RzIGEgRW1ib2RpZWQgaW5zdGFuY2UuXG5cdCAqIEBjb25zdHJ1Y3RvclxuXHQgKi9cbiAgY29uc3RydWN0b3IoKSB7XG4gICAgdGhpcy5ib2R5XyA9IHt9O1xuICB9XG5cbiAgLyoqXG5cdCAqIEdldHMgdGhlIGpzb24gb2JqZWN0IHRoYXQgcmVwcmVzZW50cyB0aGlzIGluc3RhbmNlLlxuXHQgKiBAcmV0dXJuIHshT2JqZWN0fVxuXHQgKi9cbiAgYm9keSgpIHtcbiAgICByZXR1cm4gdGhpcy5ib2R5XztcbiAgfVxuXG4gIC8qKlxuXHQgKiBJZiB0aGUgZ2l2ZW4gb2JqZWN0IGlzIGFuIGluc3RhbmNlIG9mIEVtYm9kaWVkLCB0aGlzIHdpbGxcblx0ICogcmV0dXJuIGl0cyBib2R5IGNvbnRlbnQuIE90aGVyd2lzZSB0aGlzIHdpbGwgcmV0dXJuIHRoZVxuXHQgKiBvcmlnaW5hbCBvYmplY3QuXG5cdCAqIEBwYXJhbSB7Kn0gb2JqXG5cdCAqIEByZXR1cm4geyp9XG5cdCAqIEBzdGF0aWNcblx0ICovXG4gIHN0YXRpYyB0b0JvZHkob2JqKSB7XG4gICAgcmV0dXJuIG9iaiBpbnN0YW5jZW9mIEVtYm9kaWVkID8gb2JqLmJvZHkoKSA6IG9iajtcbiAgfVxuXG4gIC8qKlxuXHQgKiBHZXRzIHRoZSBqc29uIHN0cmluZyB0aGF0IHJlcHJlc2VudHMgdGhpcyBpbnN0YW5jZS5cblx0ICogQHJldHVybiB7c3RyaW5nfVxuXHQgKi9cbiAgdG9TdHJpbmcoKSB7XG4gICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KHRoaXMuYm9keSgpKTtcbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBFbWJvZGllZDtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy9hcGktcXVlcnkvRW1ib2RpZWQuanMiLCIndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLlRyZWVOb2RlID0gZXhwb3J0cy5NdWx0aU1hcCA9IHVuZGVmaW5lZDtcblxudmFyIF9NdWx0aU1hcCA9IHJlcXVpcmUoJy4uL011bHRpTWFwJyk7XG5cbnZhciBfTXVsdGlNYXAyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfTXVsdGlNYXApO1xuXG52YXIgX1RyZWVOb2RlID0gcmVxdWlyZSgnLi4vVHJlZU5vZGUnKTtcblxudmFyIF9UcmVlTm9kZTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9UcmVlTm9kZSk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbmV4cG9ydHMuTXVsdGlNYXAgPSBfTXVsdGlNYXAyLmRlZmF1bHQ7XG5leHBvcnRzLlRyZWVOb2RlID0gX1RyZWVOb2RlMi5kZWZhdWx0O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9tZXRhbC1zdHJ1Y3RzL2xpYi9hbGwvc3RydWN0cy5qc1xuLy8gbW9kdWxlIGlkID0gMlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIndXNlIHN0cmljdCc7XG5cbmltcG9ydCB7Y29yZX0gZnJvbSAnbWV0YWwnO1xuaW1wb3J0IGdsb2JhbHMgZnJvbSAnLi4vZ2xvYmFscy9nbG9iYWxzJztcbmltcG9ydCBVcmkgZnJvbSAnbWV0YWwtdXJpJztcblxuLyoqXG4gKiBUaHJvd3MgYW4gZXhjZXB0aW9uIGlmIHRoZSBjdXJyZW50IGVudmlyb25tZW50IGlzIG5vdCBhIGJyb3dzZXIuXG4gKi9cbmZ1bmN0aW9uIGFzc2VydEJyb3dzZXJFbnZpcm9ubWVudCgpIHtcbiAgaWYgKCFnbG9iYWxzLndpbmRvdykge1xuICAgIHRocm93IG5ldyBFcnJvcignU2lnbi1pbiB0eXBlIG5vdCBzdXBwb3J0ZWQgaW4gdGhpcyBlbnZpcm9ubWVudCcpO1xuICB9XG59XG5cbi8qKlxuICogVGhyb3dzIGFuIGV4Y2VwdGlvbiBpZiBnaXZlbiB2YWx1ZSBpcyB1bmRlZmluZWQgb3IgbnVsbC5cbiAqIEBwYXJhbSB7ISp9IHZhbHVlIFRoZSB2YWx1ZSB0byBiZSBjaGVja2VkLlxuICogQHBhcmFtIHshc3RyaW5nfSBlcnJvck1lc3NhZ2UgVGhlIG1lc3NhZ2UgdG8gYmUgcHJvdmlkZWQgdG8gdGhlIGV4Y2VwdGlvbi5cbiAqL1xuZnVuY3Rpb24gYXNzZXJ0RGVmQW5kTm90TnVsbCh2YWx1ZSwgZXJyb3JNZXNzYWdlKSB7XG4gIGlmICghY29yZS5pc0RlZkFuZE5vdE51bGwodmFsdWUpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGVycm9yTWVzc2FnZSk7XG4gIH1cbn1cblxuLyoqXG4gKiBUaHJvd3MgYW4gZXhjZXB0aW9uIGlmIGdpdmVuIHZhbHVlIGlzIG51bGwuXG4gKiBAcGFyYW0geyEqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gYmUgY2hlY2tlZC5cbiAqIEBwYXJhbSB7IXN0cmluZ30gZXJyb3JNZXNzYWdlIFRoZSBtZXNzYWdlIHRvIGJlIHByb3ZpZGVkIHRvIHRoZSBleGNlcHRpb24uXG4gKi9cbmZ1bmN0aW9uIGFzc2VydE5vdE51bGwodmFsdWUsIGVycm9yTWVzc2FnZSkge1xuICBpZiAoY29yZS5pc051bGwodmFsdWUpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGVycm9yTWVzc2FnZSk7XG4gIH1cbn1cblxuLyoqXG4gKiBUaHJvd3MgYW4gZXhjZXB0aW9uIGlmIGdpdmVuIHZhbHVlIGlzIG5vdCBhIGZ1bmN0aW9uLlxuICogQHBhcmFtIHshKn0gdmFsdWUgVGhlIHZhbHVlIHRvIGJlIGNoZWNrZWQuXG4gKiBAcGFyYW0geyFzdHJpbmd9IGVycm9yTWVzc2FnZSBUaGUgbWVzc2FnZSB0byBiZSBwcm92aWRlZCB0byB0aGUgZXhjZXB0aW9uLlxuICovXG5mdW5jdGlvbiBhc3NlcnRGdW5jdGlvbih2YWx1ZSwgZXJyb3JNZXNzYWdlKSB7XG4gIGlmICghY29yZS5pc0Z1bmN0aW9uKHZhbHVlKSkge1xuICAgIHRocm93IG5ldyBFcnJvcihlcnJvck1lc3NhZ2UpO1xuICB9XG59XG5cbi8qKlxuICogVGhyb3dzIGFuIGV4Y2VwdGlvbiBpZiBnaXZlbiB2YWx1ZSBpcyBub3QgYW4gb2JqZWN0LlxuICogQHBhcmFtIHshKn0gdmFsdWUgVGhlIHZhbHVlIHRvIGJlIGNoZWNrZWQuXG4gKiBAcGFyYW0geyFzdHJpbmd9IGVycm9yTWVzc2FnZSBUaGUgbWVzc2FnZSB0byBiZSBwcm92aWRlZCB0byB0aGUgZXhjZXB0aW9uLlxuICovXG5mdW5jdGlvbiBhc3NlcnRPYmplY3QodmFsdWUsIGVycm9yTWVzc2FnZSkge1xuICBpZiAoIWNvcmUuaXNPYmplY3QodmFsdWUpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGVycm9yTWVzc2FnZSk7XG4gIH1cbn1cblxuLyoqXG4gKiBDaGVja3MgaWYgYSByZXNwb25zZSBoYXMgc3VjY2VlZGVkLiBUaGUgZnVuY3Rpb24gY2hlY2tzIGlmIHRoZSBgc3VjY2VlZGVkYFxuICogbWV0aG9kIG9mIHJlc3BvbnNlIG9iamVjdCByZXR1cm5zIHRydWUuIFRocm93cyBhbiBleGNlcHRpb24gaWYgdGhlIHJldHVybmVkXG4gKiB2YWx1ZSBpcyBmYWxzZS5cbiAqIEBwYXJhbSB7IU9iamVjdH0gcmVzcG9uc2UgVGhlIHJlc3BvbnNlIHRvIGJlIGNoZWNrZWQuXG4gKiBAcmV0dXJuIHtPYmplY3R9IFRoZSByZXNwb25zZSBpdHNlbGYgaWYgdmFsaWQuIE90aGVyd2lzZSB0aHJvd3MgYW4gZXhjZXB0aW9uLlxuICovXG5mdW5jdGlvbiBhc3NlcnRSZXNwb25zZVN1Y2NlZWRlZChyZXNwb25zZSkge1xuICBpZiAoIXJlc3BvbnNlLnN1Y2NlZWRlZCgpKSB7XG4gICAgdGhyb3cgcmVzcG9uc2UuYm9keSgpO1xuICB9XG4gIHJldHVybiByZXNwb25zZTtcbn1cblxuLyoqXG4gKiBDaGVja3MgaWYgYSB2YWxpZCB1c2VyIGlzIHByb3ZpZGVkIHRvIHRoZSBmdW5jdGlvbi4gVGhyb3dzIGFuIGV4Y2VwdGlvblxuICogaW4gY2FzZSBvZiBhbiBpbnZhbGlkIHVzZXIuXG4gKiBAcGFyYW0geyFPYmplY3R9IHVzZXIgVGhlIHVzZXIgdG8gYmUgY2hlY2tlZC5cbiAqL1xuZnVuY3Rpb24gYXNzZXJ0VXNlclNpZ25lZEluKHVzZXIpIHtcbiAgaWYgKCFjb3JlLmlzRGVmQW5kTm90TnVsbCh1c2VyKSkge1xuICAgIHRocm93IG5ldyBFcnJvcignWW91IG11c3QgYmUgc2lnbmVkLWluIHRvIHBlcmZvcm0gdGhpcyBvcGVyYXRpb24nKTtcbiAgfVxufVxuXG4vKipcbiAqIENoZWNrcyBpZiBhbiBVUkwgd2l0aCBhIHZhbGlkIHBhdGggaXMgcHJvdmlkZWQuIFRocm93cyBhbiBleGNlcHRpb25cbiAqIGlmIHRoZSBwcm92aWRlZCBVUkwgZG9lc24ndCBoYXZlIGEgdmFsaWQgcGF0aC5cbiAqIEBwYXJhbSB7IXN0cmluZ30gdXJsIFRoZSBVUkwgdG8gYmUgY2hlY2tlZC5cbiAqIEBwYXJhbSB7IXN0cmluZ30gZXJyb3JNZXNzYWdlIFRoZSBtZXNzYWdlIHRvIGJlIHByb3ZpZGVkIHRvIHRoZSBleGNlcHRpb24uXG4gKi9cbmZ1bmN0aW9uIGFzc2VydFVyaVdpdGhOb1BhdGgodXJsLCBlcnJvck1lc3NhZ2UpIHtcbiAgbGV0IHVyaSA9IG5ldyBVcmkodXJsKTtcbiAgaWYgKHVyaS5nZXRQYXRobmFtZSgpLmxlbmd0aCA+IDEpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoZXJyb3JNZXNzYWdlKTtcbiAgfVxufVxuXG5leHBvcnQge1xuICBhc3NlcnRCcm93c2VyRW52aXJvbm1lbnQsXG4gIGFzc2VydERlZkFuZE5vdE51bGwsXG4gIGFzc2VydE5vdE51bGwsXG4gIGFzc2VydEZ1bmN0aW9uLFxuICBhc3NlcnRPYmplY3QsXG4gIGFzc2VydFJlc3BvbnNlU3VjY2VlZGVkLFxuICBhc3NlcnRVc2VyU2lnbmVkSW4sXG4gIGFzc2VydFVyaVdpdGhOb1BhdGgsXG59O1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL2FwaS9hc3NlcnRpb25zLmpzIiwiJ3VzZSBzdHJpY3QnO1xuXG5pbXBvcnQge2NvcmV9IGZyb20gJ21ldGFsJztcbmltcG9ydCBFbWJvZGllZCBmcm9tICcuL0VtYm9kaWVkJztcbmltcG9ydCBGaWx0ZXJCb2R5IGZyb20gJy4vRmlsdGVyQm9keSc7XG5pbXBvcnQgR2VvIGZyb20gJy4vR2VvJztcbmltcG9ydCBSYW5nZSBmcm9tICcuL1JhbmdlJztcblxuLyoqXG4gKiBDbGFzcyByZXNwb25zaWJsZSBmb3IgYnVpbGRpbmcgZmlsdGVycy5cbiAqIEBleHRlbmRzIHtFbWJvZGllZH1cbiAqL1xuY2xhc3MgRmlsdGVyIGV4dGVuZHMgRW1ib2RpZWQge1xuICAvKipcblx0ICogQ29uc3RydWN0cyBhIHtAbGluayBGaWx0ZXJ9IGluc3RhbmNlLlxuXHQgKiBAcGFyYW0ge3N0cmluZ30gZmllbGQgVGhlIG5hbWUgb2YgdGhlIGZpZWxkIHRvIGZpbHRlciBieS5cblx0ICogQHBhcmFtIHsqfSBvcGVyYXRvck9yVmFsdWUgSWYgYSB0aGlyZCBwYXJhbSBpcyBnaXZlbiwgdGhpcyBzaG91bGRcblx0ICogICBiZSB0aGUgZmlsdGVyJ3Mgb3BlcmF0b3IgKGxpa2UgXCI+PVwiKS4gT3RoZXJ3aXNlLCB0aGlzIHdpbGwgYmVcblx0ICogICB1c2VkIGFzIHRoZSBmaWx0ZXIncyB2YWx1ZSwgYW5kIHRoZSBmaWx0ZXIncyBvcGVyYXRvciB3aWxsIGJlIFwiPVwiLlxuXHQgKiBAcGFyYW0geyo9fSBvcHRfdmFsdWUgVGhlIGZpbHRlcidzIHZhbHVlLlxuXHQgKiBAY29uc3RydWN0b3Jcblx0ICovXG4gIGNvbnN0cnVjdG9yKGZpZWxkLCBvcGVyYXRvck9yVmFsdWUsIG9wdF92YWx1ZSkge1xuICAgIHN1cGVyKCk7XG4gICAgdGhpcy5ib2R5XyA9IG5ldyBGaWx0ZXJCb2R5KGZpZWxkLCBvcGVyYXRvck9yVmFsdWUsIG9wdF92YWx1ZSk7XG4gIH1cblxuICAvKipcblx0ICogQWRkcyBhIGZpbHRlciB0byBiZSBjb21wb3NlZCB3aXRoIHRoaXMgZmlsdGVyIHVzaW5nIHRoZSBnaXZlbiBvcGVyYXRvci5cblx0ICogQHBhcmFtIHtzdHJpbmd9IG9wZXJhdG9yXG5cdCAqIEBwYXJhbSB7IUZpbHRlcnxzdHJpbmd9IGZpZWxkT3JGaWx0ZXIgRWl0aGVyIGEge0BsaW5rIEZpbHRlcn0gaW5zdGFuY2Ugb3Jcblx0ICogICB0aGUgbmFtZSBvZiB0aGUgZmllbGQgdG8gZmlsdGVyIGJ5LlxuXHQgKiBAcGFyYW0geyo9fSBvcHRfb3BlcmF0b3JPclZhbHVlIEVpdGhlciB0aGUgZmllbGQncyBvcGVyYXRvciBvciBpdHMgdmFsdWUuXG5cdCAqIEBwYXJhbSB7Kj19IG9wdF92YWx1ZSBUaGUgZmlsdGVyJ3MgdmFsdWUuXG5cdCAqIEByZXR1cm4ge0ZpbHRlcn0gUmV0dXJucyB0aGUge0BsaW5rIEZpbHRlcn0gb2JqZWN0IGl0c2VsZiwgc28gY2FsbHMgY2FuIGJlXG5cdCAqICAgY2hhaW5lZC5cblx0ICogQGNoYWluYWJsZVxuXHQgKi9cbiAgYWRkKG9wZXJhdG9yLCBmaWVsZE9yRmlsdGVyLCBvcHRfb3BlcmF0b3JPclZhbHVlLCBvcHRfdmFsdWUpIHtcbiAgICBsZXQgZmlsdGVyID0gZmllbGRPckZpbHRlclxuICAgICAgPyBGaWx0ZXIudG9GaWx0ZXIoZmllbGRPckZpbHRlciwgb3B0X29wZXJhdG9yT3JWYWx1ZSwgb3B0X3ZhbHVlKVxuICAgICAgOiBudWxsO1xuICAgIHRoaXMuYm9keV8uYWRkKG9wZXJhdG9yLCBmaWx0ZXIpO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLyoqXG5cdCAqIEFkZHMgZmlsdGVycyB0byBiZSBjb21wb3NlZCB3aXRoIHRoaXMgZmlsdGVyIHVzaW5nIHRoZSBnaXZlbiBvcGVyYXRvci5cblx0ICogQHBhcmFtIHtzdHJpbmd9IG9wZXJhdG9yXG5cdCAqIEBwYXJhbSB7Li4uKn0gZmlsdGVycyBBIHZhcmlhYmxlIGFtb3VudCBvZiBmaWx0ZXJzIHRvIGJlIGNvbXBvc2VkLlxuXHQgKiBAcmV0dXJuIHtGaWx0ZXJ9IFJldHVybnMgdGhlIHtAbGluayBGaWx0ZXJ9IG9iamVjdCBpdHNlbGYsIHNvIGNhbGxzIGNhbiBiZVxuXHQgKiAgIGNoYWluZWQuXG5cdCAqIEBjaGFpbmFibGVcblx0ICovXG4gIGFkZE1hbnkob3BlcmF0b3IsIC4uLmZpbHRlcnMpIHtcbiAgICB0aGlzLmJvZHlfLmFkZE1hbnkob3BlcmF0b3IsIC4uLmZpbHRlcnMpO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLyoqXG5cdCAqIEFkZHMgYSBmaWx0ZXIgdG8gYmUgY29tcG9zZWQgd2l0aCB0aGlzIGZpbHRlciB1c2luZyB0aGUgXCJhbmRcIiBvcGVyYXRvci5cblx0ICogQHBhcmFtIHshRmlsdGVyfHN0cmluZ30gZmllbGRPckZpbHRlciBFaXRoZXIgYSB7QGxpbmsgRmlsdGVyfSBpbnN0YW5jZSBvclxuXHQgKiAgIHRoZSBuYW1lIG9mIHRoZSBmaWVsZCB0byBmaWx0ZXIgYnkuXG5cdCAqIEBwYXJhbSB7Kj19IG9wdF9vcGVyYXRvck9yVmFsdWUgRWl0aGVyIHRoZSBmaWVsZCdzIG9wZXJhdG9yIG9yIGl0cyB2YWx1ZS5cblx0ICogQHBhcmFtIHsqPX0gb3B0X3ZhbHVlIFRoZSBmaWx0ZXIncyB2YWx1ZS5cblx0ICogQHJldHVybiB7RmlsdGVyfSBSZXR1cm5zIHRoZSB7QGxpbmsgRmlsdGVyfSBvYmplY3QgaXRzZWxmLCBzbyBjYWxscyBjYW4gYmVcblx0ICogICBjaGFpbmVkLlxuXHQgKiBAY2hhaW5hYmxlXG5cdCAqL1xuICBhbmQoZmllbGRPckZpbHRlciwgb3B0X29wZXJhdG9yT3JWYWx1ZSwgb3B0X3ZhbHVlKSB7XG4gICAgcmV0dXJuIHRoaXMuYWRkKCdhbmQnLCBmaWVsZE9yRmlsdGVyLCBvcHRfb3BlcmF0b3JPclZhbHVlLCBvcHRfdmFsdWUpO1xuICB9XG5cbiAgLyoqXG5cdCAqIFJldHVybnMgYSB7QGxpbmsgRmlsdGVyfSBpbnN0YW5jZSB0aGF0IHVzZXMgdGhlIFwiYW55XCIgb3BlcmF0b3IuXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBmaWVsZCBUaGUgbmFtZSBvZiB0aGUgZmllbGQgdG8gZmlsdGVyIGJ5LlxuXHQgKiBAcGFyYW0ge0FycmF5fCp9IHZhbHVlcyBBIHZhcmlhYmxlIGFtb3VudCBvZiB2YWx1ZXMgdG8gYmUgdXNlZCB3aXRoXG5cdCAqICAgdGhlIFwiYW55XCIgb3BlcmF0b3IuIENhbiBiZSBwYXNzZWQgZWl0aGVyIGFzIGEgc2luZ2xlIGFycmF5IG9yIGFzXG5cdCAqICAgc2VwYXJhdGUgcGFyYW1zLlxuXHQgKiBAcmV0dXJuIHshRmlsdGVyfVxuXHQgKiBAc3RhdGljXG5cdCAqL1xuICBzdGF0aWMgYW55KGZpZWxkLCAuLi52YWx1ZXMpIHtcbiAgICBpZiAodmFsdWVzLmxlbmd0aCA9PT0gMSAmJiBBcnJheS5pc0FycmF5KHZhbHVlc1swXSkpIHtcbiAgICAgIHZhbHVlcyA9IHZhbHVlc1swXTtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBGaWx0ZXIoZmllbGQsICdhbnknLCB2YWx1ZXMpO1xuICB9XG5cbiAgLyoqXG5cdCAqIFJldHVybnMgYSB7QGxpbmsgRmlsdGVyfSBpbnN0YW5jZSB0aGF0IHVzZXMgdGhlIFwiZ3BcIiBvcGVyYXRvci5cblx0ICogVGhpcyBpcyBhIHNwZWNpYWwgdXNlIGNhc2Ugb2YgYEZpbHRlci5wb2x5Z29uYCBmb3IgYm91bmRpbmdcblx0ICogYm94ZXMuXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBmaWVsZCBUaGUgZmllbGQncyBuYW1lLlxuXHQgKiBAcGFyYW0geyp9IGJveE9yVXBwZXJMZWZ0IEVpdGhlciBhIGBHZW8uQm91bmRpbmdCb3hgIGluc3RhbmNlLCBvclxuXHQgKiAgIGEgYm91bmRpbmcgYm94J3MgdXBwZXIgbGVmdCBjb29yZGluYXRlLlxuXHQgKiBAcGFyYW0geyo9fSBvcHRfbG93ZXJSaWdodCBBIGJvdW5kaW5nIGJveCdzIGxvd2VyIHJpZ2h0IGNvb3JkaW5hdGUuXG5cdCAqIEByZXR1cm4geyFGaWx0ZXJ9XG5cdCAqIEBzdGF0aWNcblx0ICovXG4gIHN0YXRpYyBib3VuZGluZ0JveChmaWVsZCwgYm94T3JVcHBlckxlZnQsIG9wdF9sb3dlclJpZ2h0KSB7XG4gICAgaWYgKGJveE9yVXBwZXJMZWZ0IGluc3RhbmNlb2YgR2VvLkJvdW5kaW5nQm94KSB7XG4gICAgICByZXR1cm4gRmlsdGVyLnBvbHlnb24oZmllbGQsIC4uLmJveE9yVXBwZXJMZWZ0LmdldFBvaW50cygpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIEZpbHRlci5wb2x5Z29uKGZpZWxkLCBib3hPclVwcGVyTGVmdCwgb3B0X2xvd2VyUmlnaHQpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuXHQgKiBHZXRzIHRoZSBqc29uIG9iamVjdCB0aGF0IHJlcHJlc2VudHMgdGhpcyBmaWx0ZXIuXG5cdCAqIEByZXR1cm4geyFPYmplY3R9XG5cdCAqL1xuICBib2R5KCkge1xuICAgIHJldHVybiB0aGlzLmJvZHlfLmdldE9iamVjdCgpO1xuICB9XG5cbiAgLyoqXG5cdCAqIFJldHVybnMgYSB7QGxpbmsgRmlsdGVyfSBpbnN0YW5jZSB0aGF0IHVzZXMgdGhlIFwiZ2RcIiBvcGVyYXRvci5cblx0ICogQHBhcmFtIHtzdHJpbmd9IGZpZWxkIFRoZSBmaWVsZCdzIG5hbWUuXG5cdCAqIEBwYXJhbSB7Kn0gbG9jYXRpb25PckNpcmNsZSBFaXRoZXIgYSBgR2VvLkNpcmNsZWAgaW5zdGFuY2Ugb3IgYSBjb29yZGluYXRlLlxuXHQgKiBAcGFyYW0ge1JhbmdlfHN0cmluZz19IG9wdF9yYW5nZU9yRGlzdGFuY2UgRWl0aGVyIGEgYFJhbmdlYCBpbnN0YW5jZSBvclxuXHQgKiAgIHRoZSBkaXN0YW5jZSB2YWx1ZS5cblx0ICogQHJldHVybiB7IUZpbHRlcn1cblx0ICogQHN0YXRpY1xuXHQgKi9cbiAgc3RhdGljIGRpc3RhbmNlKGZpZWxkLCBsb2NhdGlvbk9yQ2lyY2xlLCBvcHRfcmFuZ2VPckRpc3RhbmNlKSB7XG4gICAgbGV0IGxvY2F0aW9uID0gbG9jYXRpb25PckNpcmNsZTtcbiAgICBsZXQgcmFuZ2UgPSBvcHRfcmFuZ2VPckRpc3RhbmNlO1xuICAgIGlmIChsb2NhdGlvbk9yQ2lyY2xlIGluc3RhbmNlb2YgR2VvLkNpcmNsZSkge1xuICAgICAgbG9jYXRpb24gPSBsb2NhdGlvbk9yQ2lyY2xlLmdldENlbnRlcigpO1xuICAgICAgcmFuZ2UgPSBSYW5nZS50byhsb2NhdGlvbk9yQ2lyY2xlLmdldFJhZGl1cygpKTtcbiAgICB9IGVsc2UgaWYgKCEob3B0X3JhbmdlT3JEaXN0YW5jZSBpbnN0YW5jZW9mIFJhbmdlKSkge1xuICAgICAgcmFuZ2UgPSBSYW5nZS50byhvcHRfcmFuZ2VPckRpc3RhbmNlKTtcbiAgICB9XG4gICAgcmV0dXJuIEZpbHRlci5kaXN0YW5jZUludGVybmFsXyhmaWVsZCwgbG9jYXRpb24sIHJhbmdlKTtcbiAgfVxuXG4gIC8qKlxuXHQgKiBSZXR1cm5zIGEge0BsaW5rIEZpbHRlcn0gaW5zdGFuY2UgdGhhdCB1c2VzIHRoZSBcImdkXCIgb3BlcmF0b3IuIFRoaXNcblx0ICogaXMganVzdCBhbiBpbnRlcm5hbCBoZWxwZXIgdXNlZCBieSBgRmlsdGVyLmRpc3RhbmNlYC5cblx0ICogQHBhcmFtIHtzdHJpbmd9IGZpZWxkIFRoZSBmaWVsZCdzIG5hbWUuXG5cdCAqIEBwYXJhbSB7Kn0gbG9jYXRpb24gQSBsb2NhdGlvbiBjb29yZGluYXRlLlxuXHQgKiBAcGFyYW0ge1JhbmdlfSByYW5nZSBBIGBSYW5nZWAgaW5zdGFuY2UuXG5cdCAqIEByZXR1cm4geyFGaWx0ZXJ9XG5cdCAqIEBwcm90ZWN0ZWRcblx0ICogQHN0YXRpY1xuXHQgKi9cbiAgc3RhdGljIGRpc3RhbmNlSW50ZXJuYWxfKGZpZWxkLCBsb2NhdGlvbiwgcmFuZ2UpIHtcbiAgICBsZXQgdmFsdWUgPSB7XG4gICAgICBsb2NhdGlvbjogRW1ib2RpZWQudG9Cb2R5KGxvY2F0aW9uKSxcbiAgICB9O1xuICAgIHJhbmdlID0gcmFuZ2UuYm9keSgpO1xuICAgIGlmIChyYW5nZS5mcm9tKSB7XG4gICAgICB2YWx1ZS5taW4gPSByYW5nZS5mcm9tO1xuICAgIH1cbiAgICBpZiAocmFuZ2UudG8pIHtcbiAgICAgIHZhbHVlLm1heCA9IHJhbmdlLnRvO1xuICAgIH1cbiAgICByZXR1cm4gRmlsdGVyLmZpZWxkKGZpZWxkLCAnZ2QnLCB2YWx1ZSk7XG4gIH1cblxuICAvKipcblx0ICogUmV0dXJucyBhIHtAbGluayBGaWx0ZXJ9IGluc3RhbmNlIHRoYXQgdXNlcyB0aGUgXCI9XCIgb3BlcmF0b3IuXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBmaWVsZCBUaGUgbmFtZSBvZiB0aGUgZmllbGQgdG8gZmlsdGVyIGJ5LlxuXHQgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSBmaWx0ZXIncyB2YWx1ZS5cblx0ICogQHJldHVybiB7IUZpbHRlcn1cblx0ICogQHN0YXRpY1xuXHQgKi9cbiAgc3RhdGljIGVxdWFsKGZpZWxkLCB2YWx1ZSkge1xuICAgIHJldHVybiBuZXcgRmlsdGVyKGZpZWxkLCAnPScsIHZhbHVlKTtcbiAgfVxuXG4gIC8qKlxuXHQgKiBSZXR1cm5zIGEge0BsaW5rIEZpbHRlcn0gaW5zdGFuY2UgdGhhdCB1c2VzIHRoZSBcImV4aXN0c1wiIG9wZXJhdG9yLlxuXHQgKiBAcGFyYW0ge3N0cmluZ30gZmllbGQgVGhlIGZpZWxkJ3MgbmFtZS5cblx0ICogQHJldHVybiB7IUZpbHRlcn1cblx0ICogQHN0YXRpY1xuXHQgKi9cbiAgc3RhdGljIGV4aXN0cyhmaWVsZCkge1xuICAgIHJldHVybiBGaWx0ZXIuZmllbGQoZmllbGQsICdleGlzdHMnLCBudWxsKTtcbiAgfVxuXG4gIC8qKlxuXHQgKiBSZXR1cm5zIGEge0BsaW5rIEZpbHRlcn0gaW5zdGFuY2UgdGhhdCB1c2VzIHRoZSBcImZ1enp5XCIgb3BlcmF0b3IuXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBmaWVsZE9yUXVlcnkgSWYgbm8gc2Vjb25kIHN0cmluZyBhcmd1bWVudCBpcyBnaXZlbiwgdGhpc1xuXHQgKiAgIHNob3VsZCBiZSB0aGUgcXVlcnkgc3RyaW5nLCBpbiB3aGljaCBjYXNlIGFsbCBmaWVsZHMgd2lsbCBiZSBtYXRjaGVkLlxuXHQgKiAgIE90aGVyd2lzZSwgdGhpcyBzaG91bGQgYmUgdGhlIG5hbWUgb2YgdGhlIGZpZWxkIHRvIG1hdGNoLlxuXHQgKiBAcGFyYW0ge3N0cmluZ3xudW1iZXI9fSBvcHRfcXVlcnlPckZ1enppbmVzcyBJZiB0aGlzIGlzIGEgc3RyaW5nLCBpdCBzaG91bGRcblx0ICogICBiZSB0aGUgcXVlcnksIG90aGVyd2lzZSBpdCBzaG91bGQgYmUgdGhlIGZ1enppbmVzcyB2YWx1ZS5cblx0ICogQHBhcmFtIHtudW1iZXI9fSBvcHRfZnV6emluZXNzIFRoZSBmdXp6aW5lc3MgdmFsdWUuXG5cdCAqIEByZXR1cm4geyFGaWx0ZXJ9XG5cdCAqIEBzdGF0aWNcblx0ICovXG4gIHN0YXRpYyBmdXp6eShmaWVsZE9yUXVlcnksIG9wdF9xdWVyeU9yRnV6emluZXNzLCBvcHRfZnV6emluZXNzKSB7XG4gICAgcmV0dXJuIEZpbHRlci5mdXp6eUludGVybmFsXyhcbiAgICAgICdmdXp6eScsXG4gICAgICBmaWVsZE9yUXVlcnksXG4gICAgICBvcHRfcXVlcnlPckZ1enppbmVzcyxcbiAgICAgIG9wdF9mdXp6aW5lc3NcbiAgICApO1xuICB9XG5cbiAgLyoqXG5cdCAqIFJldHVybnMgYSB7QGxpbmsgRmlsdGVyfSBpbnN0YW5jZSB0aGF0IHVzZXMgdGhlIGdpdmVuIGZ1enp5IG9wZXJhdG9yLiBUaGlzXG5cdCAqIGlzIGFuIGludGVybmFsIGltcGxlbWVudGF0aW9uIHVzZWQgYnkgdGhlIGBGaWx0ZXIuZnV6enlgIG1ldGhvZC5cblx0ICogQHBhcmFtIHtzdHJpbmd9IG9wZXJhdG9yIFRoZSBmdXp6eSBvcGVyYXRvci5cblx0ICogQHBhcmFtIHtzdHJpbmd9IGZpZWxkT3JRdWVyeSBJZiBubyBzZWNvbmQgc3RyaW5nIGFyZ3VtZW50IGlzIGdpdmVuLCB0aGlzXG5cdCAqICAgc2hvdWxkIGJlIHRoZSBxdWVyeSBzdHJpbmcsIGluIHdoaWNoIGNhc2UgYWxsIGZpZWxkcyB3aWxsIGJlIG1hdGNoZWQuXG5cdCAqICAgT3RoZXJ3aXNlLCB0aGlzIHNob3VsZCBiZSB0aGUgbmFtZSBvZiB0aGUgZmllbGQgdG8gbWF0Y2guXG5cdCAqIEBwYXJhbSB7c3RyaW5nfG51bWJlcj19IG9wdF9xdWVyeU9yRnV6emluZXNzIElmIHRoaXMgaXMgYSBzdHJpbmcsIGl0IHNob3VsZFxuXHQgKiAgIGJlIHRoZSBxdWVyeSwgb3RoZXJ3aXNlIGl0IHNob3VsZCBiZSB0aGUgZnV6emluZXNzIHZhbHVlLlxuXHQgKiBAcGFyYW0ge251bWJlcj19IG9wdF9mdXp6aW5lc3MgVGhlIGZ1enppbmVzcyB2YWx1ZS5cblx0ICogQHJldHVybiB7IUZpbHRlcn1cblx0ICogQHByb3RlY3RlZFxuXHQgKiBAc3RhdGljXG5cdCAqL1xuICBzdGF0aWMgZnV6enlJbnRlcm5hbF8oXG4gICAgb3BlcmF0b3IsXG4gICAgZmllbGRPclF1ZXJ5LFxuICAgIG9wdF9xdWVyeU9yRnV6emluZXNzLFxuICAgIG9wdF9mdXp6aW5lc3NcbiAgKSB7XG4gICAgbGV0IGFyZzJJc1N0cmluZyA9IGNvcmUuaXNTdHJpbmcob3B0X3F1ZXJ5T3JGdXp6aW5lc3MpO1xuXG4gICAgbGV0IHZhbHVlID0ge1xuICAgICAgcXVlcnk6IGFyZzJJc1N0cmluZyA/IG9wdF9xdWVyeU9yRnV6emluZXNzIDogZmllbGRPclF1ZXJ5LFxuICAgIH07XG4gICAgbGV0IGZ1enppbmVzcyA9IGFyZzJJc1N0cmluZyA/IG9wdF9mdXp6aW5lc3MgOiBvcHRfcXVlcnlPckZ1enppbmVzcztcbiAgICBpZiAoZnV6emluZXNzKSB7XG4gICAgICB2YWx1ZS5mdXp6aW5lc3MgPSBmdXp6aW5lc3M7XG4gICAgfVxuXG4gICAgbGV0IGZpZWxkID0gYXJnMklzU3RyaW5nID8gZmllbGRPclF1ZXJ5IDogRmlsdGVyLkFMTDtcbiAgICByZXR1cm4gRmlsdGVyLmZpZWxkKGZpZWxkLCBvcGVyYXRvciwgdmFsdWUpO1xuICB9XG5cbiAgLyoqXG5cdCAqIFJldHVybnMgYSB7QGxpbmsgRmlsdGVyfSBpbnN0YW5jZSB0aGF0IHVzZXMgdGhlIFwiPlwiIG9wZXJhdG9yLlxuXHQgKiBAcGFyYW0ge3N0cmluZ30gZmllbGQgVGhlIG5hbWUgb2YgdGhlIGZpZWxkIHRvIGZpbHRlciBieS5cblx0ICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgZmlsdGVyJ3MgdmFsdWUuXG5cdCAqIEByZXR1cm4geyFGaWx0ZXJ9XG5cdCAqIEBzdGF0aWNcblx0ICovXG4gIHN0YXRpYyBndChmaWVsZCwgdmFsdWUpIHtcbiAgICByZXR1cm4gbmV3IEZpbHRlcihmaWVsZCwgJz4nLCB2YWx1ZSk7XG4gIH1cblxuICAvKipcblx0ICogUmV0dXJucyBhIHtAbGluayBGaWx0ZXJ9IGluc3RhbmNlIHRoYXQgdXNlcyB0aGUgXCI+PVwiIG9wZXJhdG9yLlxuXHQgKiBAcGFyYW0ge3N0cmluZ30gZmllbGQgVGhlIG5hbWUgb2YgdGhlIGZpZWxkIHRvIGZpbHRlciBieS5cblx0ICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgZmlsdGVyJ3MgdmFsdWUuXG5cdCAqIEByZXR1cm4geyFGaWx0ZXJ9XG5cdCAqIEBzdGF0aWNcblx0ICovXG4gIHN0YXRpYyBndGUoZmllbGQsIHZhbHVlKSB7XG4gICAgcmV0dXJuIG5ldyBGaWx0ZXIoZmllbGQsICc+PScsIHZhbHVlKTtcbiAgfVxuXG4gIC8qKlxuXHQgKiBSZXR1cm5zIGEge0BsaW5rIEZpbHRlcn0gaW5zdGFuY2UgdGhhdCB1c2VzIHRoZSBcIm1hdGNoXCIgb3BlcmF0b3IuXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBmaWVsZE9yUXVlcnkgSWYgbm8gc2Vjb25kIHN0cmluZyBhcmd1bWVudCBpcyBnaXZlbiwgdGhpc1xuXHQgKiAgIHNob3VsZCBiZSB0aGUgcXVlcnkgc3RyaW5nLCBpbiB3aGljaCBjYXNlIGFsbCBmaWVsZHMgd2lsbCBiZSBtYXRjaGVkLlxuXHQgKiAgIE90aGVyd2lzZSwgdGhpcyBzaG91bGQgYmUgdGhlIG5hbWUgb2YgdGhlIGZpZWxkIHRvIG1hdGNoLlxuXHQgKiBAcGFyYW0ge3N0cmluZz19IG9wdF9xdWVyeSBUaGUgcXVlcnkgc3RyaW5nLlxuXHQgKiBAcmV0dXJuIHshRmlsdGVyfVxuXHQgKiBAc3RhdGljXG5cdCAqL1xuICBzdGF0aWMgbWF0Y2goZmllbGRPclF1ZXJ5LCBvcHRfcXVlcnkpIHtcbiAgICBsZXQgZmllbGQgPSBjb3JlLmlzU3RyaW5nKG9wdF9xdWVyeSkgPyBmaWVsZE9yUXVlcnkgOiBGaWx0ZXIuQUxMO1xuICAgIGxldCBxdWVyeSA9IGNvcmUuaXNTdHJpbmcob3B0X3F1ZXJ5KSA/IG9wdF9xdWVyeSA6IGZpZWxkT3JRdWVyeTtcbiAgICByZXR1cm4gRmlsdGVyLmZpZWxkKGZpZWxkLCAnbWF0Y2gnLCBxdWVyeSk7XG4gIH1cblxuICAvKipcblx0ICogUmV0dXJucyBhIHtAbGluayBGaWx0ZXJ9IGluc3RhbmNlIHRoYXQgdXNlcyB0aGUgXCJtaXNzaW5nXCIgb3BlcmF0b3IuXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBmaWVsZCBUaGUgZmllbGQncyBuYW1lLlxuXHQgKiBAcmV0dXJuIHshRmlsdGVyfVxuXHQgKiBAc3RhdGljXG5cdCAqL1xuICBzdGF0aWMgbWlzc2luZyhmaWVsZCkge1xuICAgIHJldHVybiBGaWx0ZXIuZmllbGQoZmllbGQsICdtaXNzaW5nJywgbnVsbCk7XG4gIH1cblxuICAvKipcblx0ICogUmV0dXJucyBhIHtAbGluayBGaWx0ZXJ9IGluc3RhbmNlIHRoYXQgdXNlcyB0aGUgXCJwaHJhc2VcIiBvcGVyYXRvci5cblx0ICogQHBhcmFtIHtzdHJpbmd9IGZpZWxkT3JRdWVyeSBJZiBubyBzZWNvbmQgc3RyaW5nIGFyZ3VtZW50IGlzIGdpdmVuLCB0aGlzXG5cdCAqICAgc2hvdWxkIGJlIHRoZSBxdWVyeSBzdHJpbmcsIGluIHdoaWNoIGNhc2UgYWxsIGZpZWxkcyB3aWxsIGJlIG1hdGNoZWQuXG5cdCAqICAgT3RoZXJ3aXNlLCB0aGlzIHNob3VsZCBiZSB0aGUgbmFtZSBvZiB0aGUgZmllbGQgdG8gbWF0Y2guXG5cdCAqIEBwYXJhbSB7c3RyaW5nPX0gb3B0X3F1ZXJ5IFRoZSBxdWVyeSBzdHJpbmcuXG5cdCAqIEByZXR1cm4geyFGaWx0ZXJ9XG5cdCAqIEBzdGF0aWNcblx0ICovXG4gIHN0YXRpYyBwaHJhc2UoZmllbGRPclF1ZXJ5LCBvcHRfcXVlcnkpIHtcbiAgICBsZXQgZmllbGQgPSBjb3JlLmlzU3RyaW5nKG9wdF9xdWVyeSkgPyBmaWVsZE9yUXVlcnkgOiBGaWx0ZXIuQUxMO1xuICAgIGxldCBxdWVyeSA9IGNvcmUuaXNTdHJpbmcob3B0X3F1ZXJ5KSA/IG9wdF9xdWVyeSA6IGZpZWxkT3JRdWVyeTtcbiAgICByZXR1cm4gRmlsdGVyLmZpZWxkKGZpZWxkLCAncGhyYXNlJywgcXVlcnkpO1xuICB9XG5cbiAgLyoqXG5cdCAqIFJldHVybnMgYSB7QGxpbmsgRmlsdGVyfSBpbnN0YW5jZSB0aGF0IHVzZXMgdGhlIFwiZ3BcIiBvcGVyYXRvci5cblx0ICogQHBhcmFtIHtzdHJpbmd9IGZpZWxkIFRoZSBuYW1lIG9mIHRoZSBmaWVsZC5cblx0ICogQHBhcmFtIHsuLi4hT2JqZWN0fSBwb2ludHMgT2JqZWN0cyByZXByZXNlbnRpbmcgcG9pbnRzIGluIHRoZSBwb2x5Z29uLlxuXHQgKiBAcmV0dXJuIHshRmlsdGVyfVxuXHQgKiBAc3RhdGljXG5cdCAqL1xuICBzdGF0aWMgcG9seWdvbihmaWVsZCwgLi4ucG9pbnRzKSB7XG4gICAgcG9pbnRzID0gcG9pbnRzLm1hcChwb2ludCA9PiBFbWJvZGllZC50b0JvZHkocG9pbnQpKTtcbiAgICByZXR1cm4gRmlsdGVyLmZpZWxkKGZpZWxkLCAnZ3AnLCBwb2ludHMpO1xuICB9XG5cbiAgLyoqXG5cdCAqIFJldHVybnMgYSB7QGxpbmsgRmlsdGVyfSBpbnN0YW5jZSB0aGF0IHVzZXMgdGhlIFwicHJlZml4XCIgb3BlcmF0b3IuXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBmaWVsZE9yUXVlcnkgSWYgbm8gc2Vjb25kIGFyZ3VtZW50IGlzIGdpdmVuLCB0aGlzIHNob3VsZFxuXHQgKiAgIGJlIHRoZSBxdWVyeSBzdHJpbmcsIGluIHdoaWNoIGNhc2UgYWxsIGZpZWxkcyB3aWxsIGJlIG1hdGNoZWQuIE90aGVyd2lzZSxcblx0ICogICB0aGlzIHNob3VsZCBiZSB0aGUgbmFtZSBvZiB0aGUgZmllbGQgdG8gbWF0Y2guXG5cdCAqIEBwYXJhbSB7c3RyaW5nPX0gb3B0X3F1ZXJ5IFRoZSBxdWVyeSBzdHJpbmcuXG5cdCAqIEByZXR1cm4geyFGaWx0ZXJ9XG5cdCAqIEBzdGF0aWNcblx0ICovXG4gIHN0YXRpYyBwcmVmaXgoZmllbGRPclF1ZXJ5LCBvcHRfcXVlcnkpIHtcbiAgICBsZXQgZmllbGQgPSBjb3JlLmlzRGVmQW5kTm90TnVsbChvcHRfcXVlcnkpID8gZmllbGRPclF1ZXJ5IDogRmlsdGVyLkFMTDtcbiAgICBsZXQgcXVlcnkgPSBjb3JlLmlzRGVmQW5kTm90TnVsbChvcHRfcXVlcnkpID8gb3B0X3F1ZXJ5IDogZmllbGRPclF1ZXJ5O1xuICAgIHJldHVybiBGaWx0ZXIuZmllbGQoZmllbGQsICdwcmVmaXgnLCBxdWVyeSk7XG4gIH1cblxuICAvKipcblx0ICogUmV0dXJucyBhIHtAbGluayBGaWx0ZXJ9IGluc3RhbmNlIHRoYXQgdXNlcyB0aGUgXCJyYW5nZVwiIG9wZXJhdG9yLlxuXHQgKiBAcGFyYW0ge3N0cmluZ30gZmllbGQgVGhlIGZpZWxkJ3MgbmFtZS5cblx0ICogQHBhcmFtIHsqfSByYW5nZU9yTWluIEVpdGhlciBhIGBSYW5nZWAgaW5zdGFuY2Ugb3IgYSB0aGUgcmFuZ2UncyBtaW4gdmFsdWUuXG5cdCAqIEBwYXJhbSB7Kj19IG9wdF9tYXggVGhlIHJhbmdlJ3MgbWF4IHZhbHVlLlxuXHQgKiBAcmV0dXJuIHshRmlsdGVyfVxuXHQgKiBAc3RhdGljXG5cdCAqL1xuICBzdGF0aWMgcmFuZ2UoZmllbGQsIHJhbmdlT3JNaW4sIG9wdF9tYXgpIHtcbiAgICBsZXQgcmFuZ2UgPSByYW5nZU9yTWluO1xuICAgIGlmICghKHJhbmdlIGluc3RhbmNlb2YgUmFuZ2UpKSB7XG4gICAgICByYW5nZSA9IFJhbmdlLnJhbmdlKHJhbmdlT3JNaW4sIG9wdF9tYXgpO1xuICAgIH1cbiAgICByZXR1cm4gRmlsdGVyLmZpZWxkKGZpZWxkLCAncmFuZ2UnLCByYW5nZSk7XG4gIH1cblxuICAvKipcblx0ICogUmV0dXJucyBhIHtAbGluayBGaWx0ZXJ9IGluc3RhbmNlIHRoYXQgdXNlcyB0aGUgXCJ+XCIgb3BlcmF0b3IuXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBmaWVsZCBUaGUgbmFtZSBvZiB0aGUgZmllbGQgdG8gZmlsdGVyIGJ5LlxuXHQgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSBmaWx0ZXIncyB2YWx1ZS5cblx0ICogQHJldHVybiB7IUZpbHRlcn1cblx0ICogQHN0YXRpY1xuXHQgKi9cbiAgc3RhdGljIHJlZ2V4KGZpZWxkLCB2YWx1ZSkge1xuICAgIHJldHVybiBuZXcgRmlsdGVyKGZpZWxkLCAnficsIHZhbHVlKTtcbiAgfVxuXG4gIC8qKlxuXHQgKiBSZXR1cm5zIGEge0BsaW5rIEZpbHRlcn0gaW5zdGFuY2UgdGhhdCB1c2VzIHRoZSBcImdzXCIgb3BlcmF0b3IuXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBmaWVsZCBUaGUgZmllbGQncyBuYW1lLlxuXHQgKiBAcGFyYW0gey4uLiFPYmplY3R9IHNoYXBlcyBPYmplY3RzIHJlcHJlc2VudGluZyBzaGFwZXMuXG5cdCAqIEByZXR1cm4geyFGaWx0ZXJ9XG5cdCAqIEBzdGF0aWNcblx0ICovXG4gIHN0YXRpYyBzaGFwZShmaWVsZCwgLi4uc2hhcGVzKSB7XG4gICAgc2hhcGVzID0gc2hhcGVzLm1hcChzaGFwZSA9PiBFbWJvZGllZC50b0JvZHkoc2hhcGUpKTtcbiAgICBsZXQgdmFsdWUgPSB7XG4gICAgICB0eXBlOiAnZ2VvbWV0cnljb2xsZWN0aW9uJyxcbiAgICAgIGdlb21ldHJpZXM6IHNoYXBlcyxcbiAgICB9O1xuICAgIHJldHVybiBGaWx0ZXIuZmllbGQoZmllbGQsICdncycsIHZhbHVlKTtcbiAgfVxuXG4gIC8qKlxuXHQgKiBSZXR1cm5zIGEge0BsaW5rIEZpbHRlcn0gaW5zdGFuY2UgdGhhdCB1c2VzIHRoZSBcInNpbWlsYXJcIiBvcGVyYXRvci5cblx0ICogQHBhcmFtIHtzdHJpbmd9IGZpZWxkT3JRdWVyeSBJZiBubyBzZWNvbmQgc3RyaW5nIGFyZ3VtZW50IGlzIGdpdmVuLCB0aGlzXG5cdCAqICAgc2hvdWxkIGJlIHRoZSBxdWVyeSBzdHJpbmcsIGluIHdoaWNoIGNhc2UgYWxsIGZpZWxkcyB3aWxsIGJlIG1hdGNoZWQuXG5cdCAqICAgT3RoZXJ3aXNlLCB0aGlzIHNob3VsZCBiZSB0aGUgbmFtZSBvZiB0aGUgZmllbGQgdG8gbWF0Y2guXG5cdCAqIEBwYXJhbSB7P3N0cmluZ30gcXVlcnkgVGhlIHF1ZXJ5IHN0cmluZy5cblx0ICogQHJldHVybiB7IUZpbHRlcn1cblx0ICogQHN0YXRpY1xuXHQgKi9cbiAgc3RhdGljIHNpbWlsYXIoZmllbGRPclF1ZXJ5LCBxdWVyeSkge1xuICAgIGxldCBmaWVsZCA9IGNvcmUuaXNTdHJpbmcocXVlcnkpID8gZmllbGRPclF1ZXJ5IDogRmlsdGVyLkFMTDtcbiAgICBsZXQgdmFsdWUgPSB7XG4gICAgICBxdWVyeTogY29yZS5pc1N0cmluZyhxdWVyeSkgPyBxdWVyeSA6IGZpZWxkT3JRdWVyeSxcbiAgICB9O1xuICAgIHJldHVybiBGaWx0ZXIuZmllbGQoZmllbGQsICdzaW1pbGFyJywgdmFsdWUpO1xuICB9XG5cbiAgLyoqXG5cdCAqIFJldHVybnMgYSB7QGxpbmsgRmlsdGVyfSBpbnN0YW5jZSB0aGF0IHVzZXMgdGhlIFwiPFwiIG9wZXJhdG9yLlxuXHQgKiBAcGFyYW0ge3N0cmluZ30gZmllbGQgVGhlIG5hbWUgb2YgdGhlIGZpZWxkIHRvIGZpbHRlciBieS5cblx0ICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgZmlsdGVyJ3MgdmFsdWUuXG5cdCAqIEByZXR1cm4geyFGaWx0ZXJ9XG5cdCAqIEBzdGF0aWNcblx0ICovXG4gIHN0YXRpYyBsdChmaWVsZCwgdmFsdWUpIHtcbiAgICByZXR1cm4gbmV3IEZpbHRlcihmaWVsZCwgJzwnLCB2YWx1ZSk7XG4gIH1cblxuICAvKipcblx0ICogUmV0dXJucyBhIHtAbGluayBGaWx0ZXJ9IGluc3RhbmNlIHRoYXQgdXNlcyB0aGUgXCI8PVwiIG9wZXJhdG9yLlxuXHQgKiBAcGFyYW0ge3N0cmluZ30gZmllbGQgVGhlIG5hbWUgb2YgdGhlIGZpZWxkIHRvIGZpbHRlciBieS5cblx0ICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgZmlsdGVyJ3MgdmFsdWUuXG5cdCAqIEByZXR1cm4geyFGaWx0ZXJ9XG5cdCAqIEBzdGF0aWNcblx0ICovXG4gIHN0YXRpYyBsdGUoZmllbGQsIHZhbHVlKSB7XG4gICAgcmV0dXJuIG5ldyBGaWx0ZXIoZmllbGQsICc8PScsIHZhbHVlKTtcbiAgfVxuXG4gIC8qKlxuXHQgKiBSZXR1cm5zIGEge0BsaW5rIEZpbHRlcn0gaW5zdGFuY2UgdGhhdCB1c2VzIHRoZSBcIm5vbmVcIiBvcGVyYXRvci5cblx0ICogQHBhcmFtIHtzdHJpbmd9IGZpZWxkIFRoZSBuYW1lIG9mIHRoZSBmaWVsZCB0byBmaWx0ZXIgYnkuXG5cdCAqIEBwYXJhbSB7IShBcnJheXwqKX0gdmFsdWUgQSB2YXJpYWJsZSBhbW91bnQgb2YgdmFsdWVzIHRvIGJlIHVzZWQgd2l0aFxuXHQgKiB0aGUgXCJub25lXCIgb3BlcmF0b3IuIENhbiBiZSBwYXNzZWQgZWl0aGVyIGFzIGEgc2luZ2xlIGFycmF5IG9yIGFzXG5cdCAqIHNlcGFyYXRlIHBhcmFtcy5cblx0ICogQHJldHVybiB7IUZpbHRlcn1cblx0ICogQHN0YXRpY1xuXHQgKi9cbiAgc3RhdGljIG5vbmUoZmllbGQsIC4uLnZhbHVlcykge1xuICAgIGlmICh2YWx1ZXMubGVuZ3RoID09PSAxICYmIEFycmF5LmlzQXJyYXkodmFsdWVzWzBdKSkge1xuICAgICAgdmFsdWVzID0gdmFsdWVzWzBdO1xuICAgIH1cbiAgICByZXR1cm4gbmV3IEZpbHRlcihmaWVsZCwgJ25vbmUnLCB2YWx1ZXMpO1xuICB9XG5cbiAgLyoqXG5cdCAqIFJldHVybnMgYSB7QGxpbmsgRmlsdGVyfSBpbnN0YW5jZSB0aGF0IHVzZXMgdGhlIFwiIT1cIiBvcGVyYXRvci5cblx0ICogQHBhcmFtIHtzdHJpbmd9IGZpZWxkIFRoZSBuYW1lIG9mIHRoZSBmaWVsZCB0byBmaWx0ZXIgYnkuXG5cdCAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIGZpbHRlcidzIHZhbHVlLlxuXHQgKiBAcmV0dXJuIHshRmlsdGVyfVxuXHQgKiBAc3RhdGljXG5cdCAqL1xuICBzdGF0aWMgbm90RXF1YWwoZmllbGQsIHZhbHVlKSB7XG4gICAgcmV0dXJuIG5ldyBGaWx0ZXIoZmllbGQsICchPScsIHZhbHVlKTtcbiAgfVxuXG4gIC8qKlxuXHQgKiBSZXR1cm5zIGEge0BsaW5rIEZpbHRlcn0gaW5zdGFuY2UgdGhhdCB1c2VzIHRoZSBcIm5vdFwiIG9wZXJhdG9yLlxuXHQgKiBAcGFyYW0geyFGaWx0ZXJ8c3RyaW5nfSBmaWVsZE9yRmlsdGVyIEVpdGhlciBhIHtAbGluayBGaWx0ZXJ9IGluc3RhbmNlIG9yXG5cdCAqIHRoZSBuYW1lIG9mIHRoZSBmaWVsZCB0byBmaWx0ZXIgYnkuXG5cdCAqIEBwYXJhbSB7Kj19IG9wdF9vcGVyYXRvck9yVmFsdWUgRWl0aGVyIHRoZSBmaWVsZCdzIG9wZXJhdG9yIG9yIGl0cyB2YWx1ZS5cblx0ICogQHBhcmFtIHsqPX0gb3B0X3ZhbHVlIFRoZSBmaWx0ZXIncyB2YWx1ZS5cblx0ICogQHJldHVybiB7IUZpbHRlcn1cblx0ICogQHN0YXRpY1xuXHQgKi9cbiAgc3RhdGljIG5vdChmaWVsZE9yRmlsdGVyLCBvcHRfb3BlcmF0b3JPclZhbHVlLCBvcHRfdmFsdWUpIHtcbiAgICByZXR1cm4gRmlsdGVyLnRvRmlsdGVyKGZpZWxkT3JGaWx0ZXIsIG9wdF9vcGVyYXRvck9yVmFsdWUsIG9wdF92YWx1ZSkuYWRkKFxuICAgICAgJ25vdCdcbiAgICApO1xuICB9XG5cbiAgLyoqXG5cdCAqIFJldHVybnMgYSB7QGxpbmsgRmlsdGVyfSBpbnN0YW5jZS5cblx0ICogQHBhcmFtIHtzdHJpbmd9IGZpZWxkIFRoZSBuYW1lIG9mIHRoZSBmaWVsZCB0byBmaWx0ZXIgYnkuXG5cdCAqIEBwYXJhbSB7Kn0gb3BlcmF0b3JPclZhbHVlIElmIGEgdGhpcmQgcGFyYW0gaXMgZ2l2ZW4sIHRoaXMgc2hvdWxkIGJlIHRoZVxuXHQgKiBmaWx0ZXIncyBvcGVyYXRvciAobGlrZSBcIj49XCIpLiBPdGhlcndpc2UsIHRoaXMgd2lsbCBiZSB1c2VkIGFzIHRoZVxuXHQgKiBmaWx0ZXIncyB2YWx1ZSwgYW5kIHRoZSBmaWx0ZXIncyBvcGVyYXRvciB3aWxsIGJlIFwiPVwiLlxuXHQgKiBAcGFyYW0geyo9fSBvcHRfdmFsdWUgVGhlIGZpbHRlcidzIHZhbHVlLlxuXHQgKiBAcmV0dXJuIHshRmlsdGVyfVxuXHQgKiBAc3RhdGljXG5cdCAqL1xuICBzdGF0aWMgZmllbGQoZmllbGQsIG9wZXJhdG9yT3JWYWx1ZSwgb3B0X3ZhbHVlKSB7XG4gICAgcmV0dXJuIG5ldyBGaWx0ZXIoZmllbGQsIG9wZXJhdG9yT3JWYWx1ZSwgb3B0X3ZhbHVlKTtcbiAgfVxuXG4gIC8qKlxuXHQgKiBBZGRzIGEgZmlsdGVyIHRvIGJlIGNvbXBvc2VkIHdpdGggdGhpcyBmaWx0ZXIgdXNpbmcgdGhlIFwib3JcIiBvcGVyYXRvci5cblx0ICogQHBhcmFtIHshRmlsdGVyfHN0cmluZ30gZmllbGRPckZpbHRlciBFaXRoZXIgYSB7QGxpbmsgRmlsdGVyfSBpbnN0YW5jZSBvclxuXHQgKiB0aGUgbmFtZSBvZiB0aGUgZmllbGQgdG8gZmlsdGVyIGJ5LlxuXHQgKiBAcGFyYW0geyo9fSBvcHRfb3BlcmF0b3JPclZhbHVlIEVpdGhlciB0aGUgZmllbGQncyBvcGVyYXRvciBvciBpdHMgdmFsdWUuXG5cdCAqIEBwYXJhbSB7Kj19IG9wdF92YWx1ZSBUaGUgZmlsdGVyJ3MgdmFsdWUuXG5cdCAqIEByZXR1cm4ge0ZpbHRlcn0gUmV0dXJucyB0aGUge0BsaW5rIEZpbHRlcn0gb2JqZWN0IGl0c2VsZiwgc28gY2FsbHMgY2FuIGJlXG5cdCAqICAgY2hhaW5lZC5cblx0ICogQGNoYWluYWJsZVxuXHQgKi9cbiAgb3IoZmllbGRPckZpbHRlciwgb3B0X29wZXJhdG9yT3JWYWx1ZSwgb3B0X3ZhbHVlKSB7XG4gICAgcmV0dXJuIHRoaXMuYWRkKCdvcicsIGZpZWxkT3JGaWx0ZXIsIG9wdF9vcGVyYXRvck9yVmFsdWUsIG9wdF92YWx1ZSk7XG4gIH1cblxuICAvKipcblx0ICogQ29udmVydHMgdGhlIGdpdmVuIGFyZ3VtZW50cyBpbnRvIGEge0BsaW5rIEZpbHRlcn0gaW5zdGFuY2UuXG5cdCAqIEBwYXJhbSB7IUZpbHRlcnxzdHJpbmd9IGZpZWxkT3JGaWx0ZXIgRWl0aGVyIGEge0BsaW5rIEZpbHRlcn0gaW5zdGFuY2Ugb3Jcblx0ICogdGhlIG5hbWUgb2YgdGhlIGZpZWxkIHRvIGZpbHRlciBieS5cblx0ICogQHBhcmFtIHsqPX0gb3B0X29wZXJhdG9yT3JWYWx1ZSBFaXRoZXIgdGhlIGZpZWxkJ3Mgb3BlcmF0b3Igb3IgaXRzIHZhbHVlLlxuXHQgKiBAcGFyYW0geyo9fSBvcHRfdmFsdWUgVGhlIGZpbHRlcidzIHZhbHVlLlxuXHQgKiBAcmV0dXJuIHshRmlsdGVyfVxuXHQgKi9cbiAgc3RhdGljIHRvRmlsdGVyKGZpZWxkT3JGaWx0ZXIsIG9wdF9vcGVyYXRvck9yVmFsdWUsIG9wdF92YWx1ZSkge1xuICAgIGxldCBmaWx0ZXIgPSBmaWVsZE9yRmlsdGVyO1xuICAgIGlmICghKGZpbHRlciBpbnN0YW5jZW9mIEZpbHRlcikpIHtcbiAgICAgIGZpbHRlciA9IEZpbHRlci5maWVsZChmaWVsZE9yRmlsdGVyLCBvcHRfb3BlcmF0b3JPclZhbHVlLCBvcHRfdmFsdWUpO1xuICAgIH1cbiAgICByZXR1cm4gZmlsdGVyO1xuICB9XG59XG5cbi8qKlxuICogU3RyaW5nIGNvbnN0YW50IHRoYXQgcmVwcmVzZW50cyBhbGwgZmllbGRzLlxuICogQHR5cGUge3N0cmluZ31cbiAqIEBzdGF0aWNcbiAqL1xuRmlsdGVyLkFMTCA9ICcqJztcblxuZXhwb3J0IGRlZmF1bHQgRmlsdGVyO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL2FwaS1xdWVyeS9GaWx0ZXIuanMiLCJsZXQgZ2xvYmFscyA9IHt9O1xuXG5pZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgZ2xvYmFscy53aW5kb3cgPSB3aW5kb3c7XG59XG5cbmlmICh0eXBlb2YgZG9jdW1lbnQgIT09ICd1bmRlZmluZWQnKSB7XG4gIGdsb2JhbHMuZG9jdW1lbnQgPSBkb2N1bWVudDtcbn1cblxuZXhwb3J0IGRlZmF1bHQgZ2xvYmFscztcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy9nbG9iYWxzL2dsb2JhbHMuanMiLCIndXNlIHN0cmljdCc7XG5cbnZhciBVcmkgPSByZXF1aXJlKCcuL2xpYi9VcmknKS5kZWZhdWx0O1xuXG5pZiAodHlwZW9mIFVSTCA9PT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIHJlcXVpcmUgIT09ICd1bmRlZmluZWQnKSB7XG5cdC8vIElmIHRoZXJlIGlzIG5vIFwiZG9jdW1lbnRcIiwgdGhlbiB0aGlzIHNob3VsZCBiZSBydW5uaW5nIGluIE5vZGVKUyBvciBpbiBSZWFjdE5hdGl2ZSBlbnYgYW5kXG5cdC8vIGluIHRoaXMgY2FzZSB3ZSBzaG91bGQgdXNlIHRoZSBcInVybFwiIE5QTSBtb2R1bGUgYXMgdGhlIHBhcnNlIGZ1bmN0aW9uLlxuXHQvLyBJbiBSZWFjdE5hdGl2ZSBlbnYgXCJwYXRoXCIgd2lsbCBiZSByZXBsYWNlZCB3aXRoIFwicGF0aC1icm93c2VyaWZ5XCIuXG5cblx0dmFyIHBhdGggPSByZXF1aXJlKCdwYXRoJyk7XG5cdHZhciB1cmwgPSByZXF1aXJlKCd1cmwnKTtcblxuXHRVcmkuc2V0UGFyc2VGbihmdW5jdGlvbih1cmxTdHIpIHtcblx0XHR2YXIgcGFyc2VkID0gdXJsLnBhcnNlKHVybFN0cik7XG5cdFx0cGFyc2VkLnBhdGhuYW1lID0gcGF0aC5ub3JtYWxpemUocGFyc2VkLnBhdGhuYW1lKTtcblx0XHRyZXR1cm4gcGFyc2VkO1xuXHR9KTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBVcmk7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vbWV0YWwtdXJpL25vZGUuanNcbi8vIG1vZHVsZSBpZCA9IDZcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiJ3VzZSBzdHJpY3QnO1xuXG5pbXBvcnQge2NvcmV9IGZyb20gJ21ldGFsJztcbmltcG9ydCBFbWJvZGllZCBmcm9tICcuL0VtYm9kaWVkJztcbmltcG9ydCBGaWx0ZXIgZnJvbSAnLi9GaWx0ZXInO1xuaW1wb3J0IEFnZ3JlZ2F0aW9uIGZyb20gJy4vQWdncmVnYXRpb24nO1xuXG4vKipcbiAqIENsYXNzIHJlc3BvbnNpYmxlIGZvciBidWlsZGluZyBxdWVyaWVzLlxuICogQGV4dGVuZHMge0VtYm9kaWVkfVxuICovXG5jbGFzcyBRdWVyeSBleHRlbmRzIEVtYm9kaWVkIHtcbiAgLyoqXG5cdCAqIEFkZHMgYW4gYWdncmVnYXRpb24gdG8gdGhpcyB7QGxpbmsgUXVlcnl9IGluc3RhbmNlLlxuXHQgKiBAcGFyYW0ge3N0cmluZ30gbmFtZSBUaGUgYWdncmVnYXRpb24gbmFtZS5cblx0ICogQHBhcmFtIHshQWdncmVnYXRpb258c3RyaW5nfSBhZ2dyZWdhdGlvbk9yRmllbGQgRWl0aGVyIGFuXG5cdCAqICAge0BsaW5rIEFnZ3JlZ2F0aW9ufSBpbnN0YW5jZSBvciB0aGUgbmFtZSBvZiB0aGUgYWdncmVnYXRpb24gZmllbGQuXG5cdCAqIEBwYXJhbSB7c3RyaW5nPX0gb3B0X29wZXJhdG9yIFRoZSBhZ2dyZWdhdGlvbiBvcGVyYXRvci5cblx0ICogQHJldHVybiB7IVF1ZXJ5fVxuXHQgKiBAc3RhdGljXG5cdCAqL1xuICBzdGF0aWMgYWdncmVnYXRlKG5hbWUsIGFnZ3JlZ2F0aW9uT3JGaWVsZCwgb3B0X29wZXJhdG9yKSB7XG4gICAgcmV0dXJuIG5ldyBRdWVyeSgpLmFnZ3JlZ2F0ZShuYW1lLCBhZ2dyZWdhdGlvbk9yRmllbGQsIG9wdF9vcGVyYXRvcik7XG4gIH1cblxuICAvKipcblx0ICogU2V0cyB0aGlzIHF1ZXJ5J3MgdHlwZSB0byBcImNvdW50XCIuXG5cdCAqIEByZXR1cm4geyFRdWVyeX1cblx0ICogQHN0YXRpY1xuXHQgKi9cbiAgc3RhdGljIGNvdW50KCkge1xuICAgIHJldHVybiBuZXcgUXVlcnkoKS50eXBlKCdjb3VudCcpO1xuICB9XG5cbiAgLyoqXG5cdCAqIFNldHMgdGhpcyBxdWVyeSdzIHR5cGUgdG8gXCJmZXRjaFwiLlxuXHQgKiBAcmV0dXJuIHshUXVlcnl9XG5cdCAqIEBzdGF0aWNcblx0ICovXG4gIHN0YXRpYyBmZXRjaCgpIHtcbiAgICByZXR1cm4gbmV3IFF1ZXJ5KCkudHlwZSgnZmV0Y2gnKTtcbiAgfVxuXG4gIC8qKlxuXHQgKiBBZGRzIGEgZmlsdGVyIHRvIHRoaXMgUXVlcnkuXG5cdCAqIEBwYXJhbSB7IUZpbHRlcnxzdHJpbmd9IGZpZWxkT3JGaWx0ZXIgRWl0aGVyIGEge0BsaW5rIEZpbHRlcn0gb3IgdGhlXG5cdCAqICAgbmFtZSBvZiB0aGUgZmllbGQgdG8gZmlsdGVyIGJ5LlxuXHQgKiBAcGFyYW0geyo9fSBvcHRfb3BlcmF0b3JPclZhbHVlIEVpdGhlciB0aGUgZmllbGQncyBvcGVyYXRvciBvciBpdHMgdmFsdWUuXG5cdCAqIEBwYXJhbSB7Kj19IG9wdF92YWx1ZSBUaGUgZmlsdGVyJ3MgdmFsdWUuXG5cdCAqIEByZXR1cm4geyFRdWVyeX1cblx0ICogQHN0YXRpY1xuXHQgKi9cbiAgc3RhdGljIGZpbHRlcihmaWVsZE9yRmlsdGVyLCBvcHRfb3BlcmF0b3JPclZhbHVlLCBvcHRfdmFsdWUpIHtcbiAgICByZXR1cm4gbmV3IFF1ZXJ5KCkuZmlsdGVyKGZpZWxkT3JGaWx0ZXIsIG9wdF9vcGVyYXRvck9yVmFsdWUsIG9wdF92YWx1ZSk7XG4gIH1cblxuICAvKipcblx0ICogU2V0cyB0aGUgcXVlcnkgb2Zmc2V0LlxuXHQgKiBAcGFyYW0ge251bWJlcn0gb2Zmc2V0IFRoZSBpbmRleCBvZiB0aGUgZmlyc3QgZW50cnkgdGhhdCBzaG91bGQgYmUgcmV0dXJuZWRcblx0ICogICBieSB0aGlzIHF1ZXJ5LlxuXHQgKiBAcmV0dXJuIHshUXVlcnl9XG5cdCAqIEBzdGF0aWNcblx0ICovXG4gIHN0YXRpYyBvZmZzZXQob2Zmc2V0KSB7XG4gICAgcmV0dXJuIG5ldyBRdWVyeSgpLm9mZnNldChvZmZzZXQpO1xuICB9XG5cbiAgLyoqXG5cdCAqIEFkZHMgYSBoaWdobGlnaHQgZW50cnkgdG8gdGhpcyB7QGxpbmsgUXVlcnl9IGluc3RhbmNlLlxuXHQgKiBAcGFyYW0ge3N0cmluZ30gZmllbGQgVGhlIGZpZWxkJ3MgbmFtZS5cblx0ICogQHJldHVybiB7IVF1ZXJ5fVxuXHQgKiBAc3RhdGljXG5cdCAqL1xuICBzdGF0aWMgaGlnaGxpZ2h0KGZpZWxkKSB7XG4gICAgcmV0dXJuIG5ldyBRdWVyeSgpLmhpZ2hsaWdodChmaWVsZCk7XG4gIH1cblxuICAvKipcblx0ICogU2V0cyB0aGUgcXVlcnkgbGltaXQuXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBsaW1pdCBUaGUgbWF4IGFtb3VudCBvZiBlbnRyaWVzIHRoYXQgdGhpcyBxdWVyeSBzaG91bGRcblx0ICogICByZXR1cm4uXG5cdCAqIEByZXR1cm4geyFRdWVyeX1cblx0ICogQHN0YXRpY1xuXHQgKi9cbiAgc3RhdGljIGxpbWl0KGxpbWl0KSB7XG4gICAgcmV0dXJuIG5ldyBRdWVyeSgpLmxpbWl0KGxpbWl0KTtcbiAgfVxuXG4gIC8qKlxuXHQgKiBBZGRzIGEgc2VhcmNoIHRvIHRoaXMge0BsaW5rIFF1ZXJ5fSBpbnN0YW5jZS5cblx0ICogQHBhcmFtIHshRmlsdGVyfHN0cmluZ30gZmlsdGVyT3JUZXh0T3JGaWVsZCBJZiBubyBvdGhlciBhcmd1bWVudHNcblx0ICogICBhcmUgcGFzc2VkIHRvIHRoaXMgZnVuY3Rpb24sIHRoaXMgc2hvdWxkIGJlIGVpdGhlciBhIHtAbGluayBGaWx0ZXJ9XG5cdCAqICAgaW5zdGFuY2Ugb3IgYSB0ZXh0IHRvIGJlIHVzZWQgaW4gYSBtYXRjaCBmaWx0ZXIuIEluIGJvdGggY2FzZXNcblx0ICogICB0aGUgZmlsdGVyIHdpbGwgYmUgYXBwbGllZCB0byBhbGwgZmllbGRzLiBBbm90aGVyIG9wdGlvbiBpcyB0b1xuXHQgKiAgIHBhc3MgdGhpcyBhcyBhIGZpZWxkIG5hbWUgaW5zdGVhZCwgdG9nZXRoZXIgd2l0aCBvdGhlciBhcmd1bWVudHNcblx0ICogICBzbyB0aGUgZmlsdGVyIGNhbiBiZSBjcmVhdGVkLlxuXHQgKiBAcGFyYW0ge3N0cmluZz19IG9wdF90ZXh0T3JPcGVyYXRvciBFaXRoZXIgYSB0ZXh0IHRvIGJlIHVzZWQgaW4gYVxuXHQgKiAgIG1hdGNoIGZpbHRlciwgb3IgdGhlIG9wZXJhdG9yIHRoYXQgc2hvdWxkIGJlIHVzZWQuXG5cdCAqIEBwYXJhbSB7Kj19IG9wdF92YWx1ZSBUaGUgdmFsdWUgdG8gYmUgdXNlZCBieSB0aGUgZmlsdGVyLiBTaG91bGRcblx0ICogICBvbmx5IGJlIHBhc3NlZCBpZiBhbiBvcGVyYXRvciB3YXMgcGFzc2VkIGFzIHRoZSBzZWNvbmQgYXJndW1lbnQuXG5cdCAqIEByZXR1cm4geyFRdWVyeX1cblx0ICogQHN0YXRpY1xuXHQgKi9cbiAgc3RhdGljIHNlYXJjaChmaWx0ZXJPclRleHRPckZpZWxkLCBvcHRfdGV4dE9yT3BlcmF0b3IsIG9wdF92YWx1ZSkge1xuICAgIHJldHVybiBuZXcgUXVlcnkoKS5zZWFyY2goXG4gICAgICBmaWx0ZXJPclRleHRPckZpZWxkLFxuICAgICAgb3B0X3RleHRPck9wZXJhdG9yLFxuICAgICAgb3B0X3ZhbHVlXG4gICAgKTtcbiAgfVxuXG4gIC8qKlxuXHQgKiBBZGRzIGEgc29ydCBlbnRyeSB0byB0aGlzIHF1ZXJ5LCBzcGVjaWZ5aW5nIHRoZSBmaWVsZCB0aGlzIHF1ZXJ5IHNob3VsZCBiZVxuXHQgKiBzb3J0ZWQgYnkgYW5kLCBvcHRpb25hbGx5LCB0aGUgc29ydCBkaXJlY3Rpb24uXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBmaWVsZCBUaGUgZmllbGQgdGhhdCB0aGUgcXVlcnkgc2hvdWxkIGJlIHNvcnRlZCBieS5cblx0ICogQHBhcmFtIHtzdHJpbmc9fSBvcHRfZGlyZWN0aW9uIFRoZSBkaXJlY3Rpb24gdGhlIHNvcnQgb3BlcmF0aW9uIHNob3VsZCB1c2UuXG5cdCAqICAgSWYgbm9uZSBpcyBnaXZlbiwgXCJhc2NcIiBpcyB1c2VkIGJ5IGRlZmF1bHQuXG5cdCAqIEByZXR1cm4geyFRdWVyeX1cblx0ICogQHN0YXRpY1xuXHQgKi9cbiAgc3RhdGljIHNvcnQoZmllbGQsIG9wdF9kaXJlY3Rpb24pIHtcbiAgICByZXR1cm4gbmV3IFF1ZXJ5KCkuc29ydChmaWVsZCwgb3B0X2RpcmVjdGlvbik7XG4gIH1cblxuICAvKipcblx0ICogU2V0cyB0aGUgcXVlcnkgdHlwZS5cblx0ICogQHBhcmFtIHtzdHJpbmd9IHR5cGUgVGhlIHF1ZXJ5J3MgdHlwZS4gRm9yIGV4YW1wbGU6IFwiY291bnRcIiwgXCJmZXRjaFwiLlxuXHQgKiBAcmV0dXJuIHshUXVlcnl9XG5cdCAqIEBzdGF0aWNcblx0ICovXG4gIHN0YXRpYyB0eXBlKHR5cGUpIHtcbiAgICByZXR1cm4gbmV3IFF1ZXJ5KCkudHlwZSh0eXBlKTtcbiAgfVxuXG4gIC8qKlxuXHQgKiBBZGRzIGFuIGFnZ3JlZ2F0aW9uIHRvIHRoaXMge0BsaW5rIFF1ZXJ5fSBpbnN0YW5jZS5cblx0ICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgVGhlIGFnZ3JlZ2F0aW9uIG5hbWUuXG5cdCAqIEBwYXJhbSB7IUFnZ3JlZ2F0aW9ufHN0cmluZ30gYWdncmVnYXRpb25PckZpZWxkIEVpdGhlciBhblxuXHQgKiAgIHtAbGluayBBZ2dyZWdhdGlvbn0gaW5zdGFuY2Ugb3IgdGhlIG5hbWUgb2YgdGhlIGFnZ3JlZ2F0aW9uIGZpZWxkLlxuXHQgKiBAcGFyYW0ge3N0cmluZz19IG9wdF9vcGVyYXRvciBUaGUgYWdncmVnYXRpb24gb3BlcmF0b3IuXG5cdCAqIEByZXR1cm4ge1F1ZXJ5fSBSZXR1cm5zIHRoZSB7QGxpbmsgUXVlcnl9IG9iamVjdCBpdHNlbGYsIHNvIGNhbGxzIGNhbiBiZVxuXHQgKiAgIGNoYWluZWQuXG5cdCAqIEBjaGFpbm5hYmxlXG5cdCAqL1xuICBhZ2dyZWdhdGUobmFtZSwgYWdncmVnYXRpb25PckZpZWxkLCBvcHRfb3BlcmF0b3IpIHtcbiAgICBsZXQgYWdncmVnYXRpb24gPSBhZ2dyZWdhdGlvbk9yRmllbGQ7XG4gICAgaWYgKCEoYWdncmVnYXRpb24gaW5zdGFuY2VvZiBBZ2dyZWdhdGlvbikpIHtcbiAgICAgIGFnZ3JlZ2F0aW9uID0gQWdncmVnYXRpb24uZmllbGQoYWdncmVnYXRpb25PckZpZWxkLCBvcHRfb3BlcmF0b3IpO1xuICAgIH1cblxuICAgIGxldCBmaWVsZCA9IGFnZ3JlZ2F0aW9uLmdldEZpZWxkKCk7XG4gICAgbGV0IHZhbHVlID0ge307XG4gICAgdmFsdWVbZmllbGRdID0ge1xuICAgICAgbmFtZTogbmFtZSxcbiAgICAgIG9wZXJhdG9yOiBhZ2dyZWdhdGlvbi5nZXRPcGVyYXRvcigpLFxuICAgIH07XG4gICAgaWYgKGNvcmUuaXNEZWZBbmROb3ROdWxsKGFnZ3JlZ2F0aW9uLmdldFZhbHVlKCkpKSB7XG4gICAgICB2YWx1ZVtmaWVsZF0udmFsdWUgPSBhZ2dyZWdhdGlvbi5nZXRWYWx1ZSgpO1xuICAgIH1cblxuICAgIGlmICghdGhpcy5ib2R5Xy5hZ2dyZWdhdGlvbikge1xuICAgICAgdGhpcy5ib2R5Xy5hZ2dyZWdhdGlvbiA9IFtdO1xuICAgIH1cbiAgICB0aGlzLmJvZHlfLmFnZ3JlZ2F0aW9uLnB1c2godmFsdWUpO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLyoqXG5cdCAqIFNldHMgdGhpcyBxdWVyeSdzIHR5cGUgdG8gXCJjb3VudFwiLlxuXHQgKiBAcmV0dXJuIHtRdWVyeX0gUmV0dXJucyB0aGUge0BsaW5rIFF1ZXJ5fSBvYmplY3QgaXRzZWxmLCBzbyBjYWxscyBjYW4gYmVcblx0ICogICBjaGFpbmVkLlxuXHQgKiBAY2hhaW5uYWJsZVxuXHQgKi9cbiAgY291bnQoKSB7XG4gICAgcmV0dXJuIHRoaXMudHlwZSgnY291bnQnKTtcbiAgfVxuXG4gIC8qKlxuXHQgKiBTZXRzIHRoaXMgcXVlcnkncyB0eXBlIHRvIFwiZmV0Y2hcIi5cblx0ICogQHJldHVybiB7UXVlcnl9IFJldHVybnMgdGhlIHtAbGluayBRdWVyeX0gb2JqZWN0IGl0c2VsZiwgc28gY2FsbHMgY2FuIGJlXG5cdCAqICAgY2hhaW5lZC5cblx0ICogQGNoYWlubmFibGVcblx0ICovXG4gIGZldGNoKCkge1xuICAgIHJldHVybiB0aGlzLnR5cGUoJ2ZldGNoJyk7XG4gIH1cblxuICAvKipcblx0ICogQWRkcyBhIGZpbHRlciB0byB0aGlzIFF1ZXJ5LlxuXHQgKiBAcGFyYW0geyFGaWx0ZXJ8c3RyaW5nfSBmaWVsZE9yRmlsdGVyIEVpdGhlciBhIHtAbGluayBGaWx0ZXJ9IG9yIHRoZVxuXHQgKiAgIG5hbWUgb2YgdGhlIGZpZWxkIHRvIGZpbHRlciBieS5cblx0ICogQHBhcmFtIHsqPX0gb3B0X29wZXJhdG9yT3JWYWx1ZSBFaXRoZXIgdGhlIGZpZWxkJ3Mgb3BlcmF0b3Igb3IgaXRzIHZhbHVlLlxuXHQgKiBAcGFyYW0geyo9fSBvcHRfdmFsdWUgVGhlIGZpbHRlcidzIHZhbHVlLlxuXHQgKiBAcmV0dXJuIHtRdWVyeX0gUmV0dXJucyB0aGUge0BsaW5rIFF1ZXJ5fSBvYmplY3QgaXRzZWxmLCBzbyBjYWxscyBjYW4gYmVcblx0ICogICBjaGFpbmVkLlxuXHQgKiBAY2hhaW5uYWJsZVxuXHQgKi9cbiAgZmlsdGVyKGZpZWxkT3JGaWx0ZXIsIG9wdF9vcGVyYXRvck9yVmFsdWUsIG9wdF92YWx1ZSkge1xuICAgIGxldCBmaWx0ZXIgPSBGaWx0ZXIudG9GaWx0ZXIoZmllbGRPckZpbHRlciwgb3B0X29wZXJhdG9yT3JWYWx1ZSwgb3B0X3ZhbHVlKTtcbiAgICBpZiAoIXRoaXMuYm9keV8uZmlsdGVyKSB7XG4gICAgICB0aGlzLmJvZHlfLmZpbHRlciA9IFtdO1xuICAgIH1cbiAgICB0aGlzLmJvZHlfLmZpbHRlci5wdXNoKGZpbHRlci5ib2R5KCkpO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLyoqXG5cdCAqIFNldHMgdGhlIHF1ZXJ5IG9mZnNldC5cblx0ICogQHBhcmFtIHtudW1iZXJ9IG9mZnNldCBUaGUgaW5kZXggb2YgdGhlIGZpcnN0IGVudHJ5IHRoYXQgc2hvdWxkIGJlIHJldHVybmVkXG5cdCAqICAgYnkgdGhpcyBxdWVyeS5cblx0ICogQHJldHVybiB7UXVlcnl9IFJldHVybnMgdGhlIHtAbGluayBRdWVyeX0gb2JqZWN0IGl0c2VsZiwgc28gY2FsbHMgY2FuIGJlXG5cdCAqICAgY2hhaW5lZC5cblx0ICogQGNoYWlubmFibGVcblx0ICovXG4gIG9mZnNldChvZmZzZXQpIHtcbiAgICB0aGlzLmJvZHlfLm9mZnNldCA9IG9mZnNldDtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8qKlxuXHQgKiBBZGRzIGEgaGlnaGxpZ2h0IGVudHJ5IHRvIHRoaXMge0BsaW5rIFF1ZXJ5fSBpbnN0YW5jZS5cblx0ICogQHBhcmFtIHtzdHJpbmd9IGZpZWxkIFRoZSBmaWVsZCdzIG5hbWUuXG5cdCAqIEByZXR1cm4ge1F1ZXJ5fSBSZXR1cm5zIHRoZSB7QGxpbmsgUXVlcnl9IG9iamVjdCBpdHNlbGYsIHNvIGNhbGxzIGNhbiBiZVxuXHQgKiAgIGNoYWluZWQuXG5cdCAqIEBjaGFpbm5hYmxlXG5cdCAqL1xuICBoaWdobGlnaHQoZmllbGQpIHtcbiAgICBpZiAoIXRoaXMuYm9keV8uaGlnaGxpZ2h0KSB7XG4gICAgICB0aGlzLmJvZHlfLmhpZ2hsaWdodCA9IFtdO1xuICAgIH1cblxuICAgIHRoaXMuYm9keV8uaGlnaGxpZ2h0LnB1c2goZmllbGQpO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLyoqXG5cdCAqIFNldHMgdGhlIHF1ZXJ5IGxpbWl0LlxuXHQgKiBAcGFyYW0ge251bWJlcn0gbGltaXQgVGhlIG1heCBhbW91bnQgb2YgZW50cmllcyB0aGF0IHRoaXMgcXVlcnkgc2hvdWxkXG5cdCAqICAgcmV0dXJuLlxuXHQgKiBAcmV0dXJuIHtRdWVyeX0gUmV0dXJucyB0aGUge0BsaW5rIFF1ZXJ5fSBvYmplY3QgaXRzZWxmLCBzbyBjYWxscyBjYW4gYmVcblx0ICogICBjaGFpbmVkLlxuXHQgKiBAY2hhaW5uYWJsZVxuXHQgKi9cbiAgbGltaXQobGltaXQpIHtcbiAgICB0aGlzLmJvZHlfLmxpbWl0ID0gbGltaXQ7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICAvKipcblx0ICogQWRkcyBhIHNlYXJjaCB0byB0aGlzIHtAbGluayBRdWVyeX0gaW5zdGFuY2UuXG5cdCAqIEBwYXJhbSB7IUZpbHRlcnxzdHJpbmc9fSBmaWx0ZXJPclRleHRPckZpZWxkIElmIG5vIG90aGVyIGFyZ3VtZW50c1xuXHQgKiAgIGFyZSBwYXNzZWQgdG8gdGhpcyBmdW5jdGlvbiwgdGhpcyBzaG91bGQgYmUgZWl0aGVyIGEge0BsaW5rIEZpbHRlcn1cblx0ICogICBpbnN0YW5jZSBvciBhIHRleHQgdG8gYmUgdXNlZCBpbiBhIG1hdGNoIGZpbHRlci4gSW4gYm90aCBjYXNlc1xuXHQgKiAgIHRoZSBmaWx0ZXIgd2lsbCBiZSBhcHBsaWVkIHRvIGFsbCBmaWVsZHMuIEFub3RoZXIgb3B0aW9uIGlzIHRvXG5cdCAqICAgcGFzcyB0aGlzIGFzIGEgZmllbGQgbmFtZSBpbnN0ZWFkLCB0b2dldGhlciB3aXRoIG90aGVyIGFyZ3VtZW50c1xuXHQgKiAgIHNvIHRoZSBmaWx0ZXIgY2FuIGJlIGNyZWF0ZWQuIElmIHRoZSB2YWx1ZSBvZiB0aGlzIHBhcmFtZXRlciBpc1xuXHQgKiAgIHVuZGVmaW5lZCBvciBudWxsLCBubyBmaWx0ZXIgd2lsbCBiZSBwcm92aWRlZCB0byB0aGUgc2VhcmNoIHF1ZXJ5LlxuXHQgKiBAcGFyYW0ge3N0cmluZz19IG9wdF90ZXh0T3JPcGVyYXRvciBFaXRoZXIgYSB0ZXh0IHRvIGJlIHVzZWQgaW4gYVxuXHQgKiAgIG1hdGNoIGZpbHRlciwgb3IgdGhlIG9wZXJhdG9yIHRoYXQgc2hvdWxkIGJlIHVzZWQuXG5cdCAqIEBwYXJhbSB7Kj19IG9wdF92YWx1ZSBUaGUgdmFsdWUgdG8gYmUgdXNlZCBieSB0aGUgZmlsdGVyLiBTaG91bGRcblx0ICogICBvbmx5IGJlIHBhc3NlZCBpZiBhbiBvcGVyYXRvciB3YXMgcGFzc2VkIGFzIHRoZSBzZWNvbmQgYXJndW1lbnQuXG5cdCAqIEByZXR1cm4ge1F1ZXJ5fSBSZXR1cm5zIHRoZSB7QGxpbmsgUXVlcnl9IG9iamVjdCBpdHNlbGYsIHNvIGNhbGxzIGNhbiBiZVxuXHQgKiAgIGNoYWluZWQuXG5cdCAqIEBjaGFpbm5hYmxlXG5cdCAqL1xuICBzZWFyY2goZmlsdGVyT3JUZXh0T3JGaWVsZCwgb3B0X3RleHRPck9wZXJhdG9yLCBvcHRfdmFsdWUpIHtcbiAgICBsZXQgZmlsdGVyID0gZmlsdGVyT3JUZXh0T3JGaWVsZDtcblxuICAgIGlmIChvcHRfdmFsdWUpIHtcbiAgICAgIGZpbHRlciA9IEZpbHRlci5maWVsZChmaWx0ZXJPclRleHRPckZpZWxkLCBvcHRfdGV4dE9yT3BlcmF0b3IsIG9wdF92YWx1ZSk7XG4gICAgfSBlbHNlIGlmIChvcHRfdGV4dE9yT3BlcmF0b3IpIHtcbiAgICAgIGZpbHRlciA9IEZpbHRlci5tYXRjaChmaWx0ZXJPclRleHRPckZpZWxkLCBvcHRfdGV4dE9yT3BlcmF0b3IpO1xuICAgIH0gZWxzZSBpZiAoZmlsdGVyICYmICEoZmlsdGVyIGluc3RhbmNlb2YgRmlsdGVyKSkge1xuICAgICAgZmlsdGVyID0gRmlsdGVyLm1hdGNoKGZpbHRlck9yVGV4dE9yRmllbGQpO1xuICAgIH1cblxuICAgIHRoaXMudHlwZSgnc2VhcmNoJyk7XG5cbiAgICBpZiAoZmlsdGVyKSB7XG4gICAgICB0aGlzLmZpbHRlcihmaWx0ZXIpO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLyoqXG5cdCAqIEFkZHMgYSBzb3J0IGVudHJ5IHRvIHRoaXMgcXVlcnksIHNwZWNpZnlpbmcgdGhlIGZpZWxkIHRoaXMgcXVlcnkgc2hvdWxkIGJlXG5cdCAqIHNvcnRlZCBieSBhbmQsIG9wdGlvbmFsbHksIHRoZSBzb3J0IGRpcmVjdGlvbi5cblx0ICogQHBhcmFtIHtzdHJpbmd9IGZpZWxkIFRoZSBmaWVsZCB0aGF0IHRoZSBxdWVyeSBzaG91bGQgYmUgc29ydGVkIGJ5LlxuXHQgKiBAcGFyYW0ge3N0cmluZz19IG9wdF9kaXJlY3Rpb24gVGhlIGRpcmVjdGlvbiB0aGUgc29ydCBvcGVyYXRpb24gc2hvdWxkIHVzZS5cblx0ICogICBJZiBub25lIGlzIGdpdmVuLCBcImFzY1wiIGlzIHVzZWQgYnkgZGVmYXVsdC5cblx0ICogQHJldHVybiB7UXVlcnl9IFJldHVybnMgdGhlIHtAbGluayBRdWVyeX0gb2JqZWN0IGl0c2VsZiwgc28gY2FsbHMgY2FuIGJlXG5cdCAqICAgY2hhaW5lZC5cblx0ICogQGNoYWlubmFibGVcblx0ICovXG4gIHNvcnQoZmllbGQsIG9wdF9kaXJlY3Rpb24pIHtcbiAgICBpZiAoIXRoaXMuYm9keV8uc29ydCkge1xuICAgICAgdGhpcy5ib2R5Xy5zb3J0ID0gW107XG4gICAgfVxuICAgIGxldCBzb3J0RW50cnkgPSB7fTtcbiAgICBzb3J0RW50cnlbZmllbGRdID0gb3B0X2RpcmVjdGlvbiB8fCAnYXNjJztcbiAgICB0aGlzLmJvZHlfLnNvcnQucHVzaChzb3J0RW50cnkpO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLyoqXG5cdCAqIFNldHMgdGhlIHF1ZXJ5IHR5cGUuXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSB0eXBlIFRoZSBxdWVyeSdzIHR5cGUuIEZvciBleGFtcGxlOiBcImNvdW50XCIsIFwiZmV0Y2hcIi5cblx0ICogQHJldHVybiB7UXVlcnl9IFJldHVybnMgdGhlIHtAbGluayBRdWVyeX0gb2JqZWN0IGl0c2VsZiwgc28gY2FsbHMgY2FuIGJlXG5cdCAqICAgY2hhaW5lZC5cblx0ICogQGNoYWlubmFibGVcblx0ICovXG4gIHR5cGUodHlwZSkge1xuICAgIHRoaXMuYm9keV8udHlwZSA9IHR5cGU7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgUXVlcnk7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zcmMvYXBpLXF1ZXJ5L1F1ZXJ5LmpzIiwiJ3VzZSBzdHJpY3QnO1xuXG5pbXBvcnQge2NvcmV9IGZyb20gJ21ldGFsJztcbmltcG9ydCBFbWJvZGllZCBmcm9tICcuL0VtYm9kaWVkJztcblxuLyoqXG4gKiBDbGFzcyByZXNwb25zaWJsZSBmb3IgYnVpbGRpbmcgcmFuZ2Ugb2JqZWN0cyB0byBiZSB1c2VkIGJ5IGBGaWx0ZXJgLlxuICogQGV4dGVuZHMge0VtYm9kaWVkfVxuICovXG5jbGFzcyBSYW5nZSBleHRlbmRzIEVtYm9kaWVkIHtcbiAgLyoqXG5cdCAqIENvbnN0cnVjdHMgYSB7QGxpbmsgUmFuZ2V9IGluc3RhbmNlLlxuXHQgKiBAcGFyYW0geyp9IGZyb21cblx0ICogQHBhcmFtIHsqfSBvcHRfdG9cblx0ICogQGNvbnN0cnVjdG9yXG5cdCAqL1xuICBjb25zdHJ1Y3Rvcihmcm9tLCBvcHRfdG8pIHtcbiAgICBzdXBlcigpO1xuICAgIGlmIChjb3JlLmlzRGVmQW5kTm90TnVsbChmcm9tKSkge1xuICAgICAgdGhpcy5ib2R5Xy5mcm9tID0gZnJvbTtcbiAgICB9XG4gICAgaWYgKGNvcmUuaXNEZWZBbmROb3ROdWxsKG9wdF90bykpIHtcbiAgICAgIHRoaXMuYm9keV8udG8gPSBvcHRfdG87XG4gICAgfVxuICB9XG5cbiAgLyoqXG5cdCAqIENvbnN0cnVjdHMgYSB7QGxpbmsgUmFuZ2V9IGluc3RhbmNlLlxuXHQgKiBAcGFyYW0geyp9IGZyb21cblx0ICogQHJldHVybiB7IVJhbmdlfVxuXHQgKiBAc3RhdGljXG5cdCAqL1xuICBzdGF0aWMgZnJvbShmcm9tKSB7XG4gICAgcmV0dXJuIG5ldyBSYW5nZShmcm9tKTtcbiAgfVxuXG4gIC8qKlxuXHQgKiBDb25zdHJ1Y3RzIGEge0BsaW5rIFJhbmdlfSBpbnN0YW5jZS5cblx0ICogQHBhcmFtIHsqfSBmcm9tXG5cdCAqIEBwYXJhbSB7Kn0gdG9cblx0ICogQHJldHVybiB7IVJhbmdlfVxuXHQgKiBAc3RhdGljXG5cdCAqL1xuICBzdGF0aWMgcmFuZ2UoZnJvbSwgdG8pIHtcbiAgICByZXR1cm4gbmV3IFJhbmdlKGZyb20sIHRvKTtcbiAgfVxuXG4gIC8qKlxuXHQgKiBDb25zdHJ1Y3RzIGEge0BsaW5rIFJhbmdlfSBpbnN0YW5jZS5cblx0ICogQHBhcmFtIHsqfSB0b1xuXHQgKiBAcmV0dXJuIHshUmFuZ2V9XG5cdCAqIEBzdGF0aWNcblx0ICovXG4gIHN0YXRpYyB0byh0bykge1xuICAgIHJldHVybiBuZXcgUmFuZ2UobnVsbCwgdG8pO1xuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IFJhbmdlO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL2FwaS1xdWVyeS9SYW5nZS5qcyIsIid1c2Ugc3RyaWN0JztcblxuaW1wb3J0IHthc3NlcnREZWZBbmROb3ROdWxsfSBmcm9tICcuL2Fzc2VydGlvbnMnO1xuaW1wb3J0IHtNdWx0aU1hcH0gZnJvbSAnbWV0YWwtc3RydWN0cyc7XG5pbXBvcnQgQXV0aCBmcm9tICcuL2F1dGgvQXV0aCc7XG5cbi8qKlxuICogQ2xhc3MgcmVzcG9uc2libGUgZm9yIGVuY2Fwc3VsYXRpbmcgQVBJIGNhbGxzLlxuICovXG5jbGFzcyBBcGlIZWxwZXIge1xuICAvKipcblx0ICogQ29uc3RydWN0cyBhbiB7QGxpbmsgQXBpSGVscGVyfSBpbnN0YW5jZS5cblx0ICogQHBhcmFtIHshV2VEZXBsb3l9IHdlZGVwbG95Q2xpZW50IHtAbGluayBXZURlcGxveX0gY2xpZW50IHJlZmVyZW5jZS5cblx0ICogQGNvbnN0cnVjdG9yXG5cdCAqL1xuICBjb25zdHJ1Y3Rvcih3ZWRlcGxveUNsaWVudCkge1xuICAgIGFzc2VydERlZkFuZE5vdE51bGwoXG4gICAgICB3ZWRlcGxveUNsaWVudCxcbiAgICAgICdXZURlcGxveSBjbGllbnQgcmVmZXJlbmNlIG11c3QgYmUgc3BlY2lmaWVkJ1xuICAgICk7XG4gICAgdGhpcy53ZWRlcGxveUNsaWVudCA9IHdlZGVwbG95Q2xpZW50O1xuICAgIHRoaXMuaGVhZGVyc18gPSBuZXcgTXVsdGlNYXAoKTtcbiAgfVxuXG4gIC8qKlxuXHQgKiBBZGRzIGEgaGVhZGVyLiBJZiBhIGhlYWRlciB3aXRoIHRoZSBzYW1lIG5hbWUgYWxyZWFkeSBleGlzdHMsIGl0IHdpbGwgbm90XG5cdCAqIGJlIG92ZXJ3cml0dGVuLCBidXQgdGhlIG5ldyB2YWx1ZSB3aWxsIGJlIHN0b3JlZCBhcyB3ZWxsLiBUaGUgb3JkZXIgaXNcblx0ICogcHJlc2VydmVkLlxuXHQgKiBAcGFyYW0ge3N0cmluZ30gbmFtZVxuXHQgKiBAcGFyYW0ge3N0cmluZ30gdmFsdWVcblx0ICogQHJldHVybiB7IUNsaWVudE1lc3NhZ2V9IFJldHVybnMgdGhlIHtAbGluayBDbGllbnRNZXNzYWdlfVxuXHQgKiAgIG9iamVjdCBpdHNlbGYsIHNvIGNhbGxzIGNhbiBiZSBjaGFpbmVkLlxuXHQgKiBAY2hhaW5hYmxlXG5cdCAqL1xuICBoZWFkZXIobmFtZSwgdmFsdWUpIHtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCAhPT0gMikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGFyZ3VtZW50cycpO1xuICAgIH1cbiAgICB0aGlzLmhlYWRlcnNfLnNldChuYW1lLCB2YWx1ZSk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICAvKipcblx0ICogQWRkcyBhdXRob3JpemF0aW9uIGluZm9ybWF0aW9uIHRvIHRoaXMgcmVxdWVzdC5cblx0ICogQHBhcmFtIHshQXV0aHxzdHJpbmd9IGF1dGhPclRva2VuT3JFbWFpbCBFaXRoZXIgYW4ge0BsaW5rIEF1dGh9IGluc3RhbmNlLFxuXHQgKiBhbiBhdXRob3JpemF0aW9uIHRva2VuLCBvciB0aGUgZW1haWwuXG5cdCAqIEBwYXJhbSB7c3RyaW5nPX0gb3B0X3Bhc3N3b3JkIElmIGEgZW1haWwgaXMgZ2l2ZW4gYXMgdGhlIGZpcnN0IHBhcmFtLFxuXHQgKiB0aGlzIHNob3VsZCBiZSB0aGUgcGFzc3dvcmQuXG5cdCAqIEByZXR1cm4ge0FwaUhlbHBlcn1cblx0ICogQGNoYWluYWJsZVxuXHQgKi9cbiAgYXV0aChhdXRoT3JUb2tlbk9yRW1haWwsIG9wdF9wYXNzd29yZCkge1xuICAgIHRoaXMuaGVscGVyQXV0aFNjb3BlID0gQXV0aC5jcmVhdGUoYXV0aE9yVG9rZW5PckVtYWlsLCBvcHRfcGFzc3dvcmQpO1xuICAgIHRoaXMuaGVscGVyQXV0aFNjb3BlLndlZGVwbG95Q2xpZW50ID0gdGhpcy53ZWRlcGxveUNsaWVudDtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBBcGlIZWxwZXI7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zcmMvYXBpL0FwaUhlbHBlci5qcyIsIid1c2Ugc3RyaWN0JztcblxuaW1wb3J0IHtjb3JlLCBpc0RlZiwgaXNEZWZBbmROb3ROdWxsLCBpc09iamVjdCwgaXNTdHJpbmd9IGZyb20gJ21ldGFsJztcbmltcG9ydCB7TXVsdGlNYXB9IGZyb20gJ21ldGFsLXN0cnVjdHMnO1xuXG5pbXBvcnQge1xuICBhc3NlcnREZWZBbmROb3ROdWxsLFxuICBhc3NlcnRPYmplY3QsXG4gIGFzc2VydFJlc3BvbnNlU3VjY2VlZGVkLFxufSBmcm9tICcuLi9hc3NlcnRpb25zJztcblxuLyoqXG4gKiBDbGFzcyByZXNwb25zaWJsZSBmb3Igc3RvcmluZyBhdXRob3JpemF0aW9uIGluZm9ybWF0aW9uLlxuICovXG5jbGFzcyBBdXRoIHtcbiAgLyoqXG5cdCAqIENvbnN0cnVjdHMgYW4ge0BsaW5rIEF1dGh9IGluc3RhbmNlLlxuXHQgKiBAcGFyYW0ge3N0cmluZ30gdG9rZW5PckVtYWlsIEVpdGhlciB0aGUgYXV0aG9yaXphdGlvbiB0b2tlbiwgb3Jcblx0ICogICB0aGUgdXNlcm5hbWUuXG5cdCAqIEBwYXJhbSB7c3RyaW5nPX0gb3B0X3Bhc3N3b3JkIElmIGEgdXNlcm5hbWUgaXMgZ2l2ZW4gYXMgdGhlIGZpcnN0IHBhcmFtLFxuXHQgKiAgIHRoaXMgc2hvdWxkIGJlIHRoZSBwYXNzd29yZC5cblx0ICogQGNvbnN0cnVjdG9yXG5cdCAqL1xuICBjb25zdHJ1Y3Rvcih0b2tlbk9yRW1haWwsIG9wdF9wYXNzd29yZCA9IG51bGwpIHtcbiAgICB0aGlzLnRva2VuID0gY29yZS5pc1N0cmluZyhvcHRfcGFzc3dvcmQpID8gbnVsbCA6IHRva2VuT3JFbWFpbDtcbiAgICB0aGlzLmVtYWlsID0gY29yZS5pc1N0cmluZyhvcHRfcGFzc3dvcmQpID8gdG9rZW5PckVtYWlsIDogbnVsbDtcbiAgICB0aGlzLnBhc3N3b3JkID0gb3B0X3Bhc3N3b3JkO1xuXG4gICAgdGhpcy5jcmVhdGVkQXQgPSBudWxsO1xuICAgIHRoaXMuaWQgPSBudWxsO1xuICAgIHRoaXMubmFtZSA9IG51bGw7XG4gICAgdGhpcy5waG90b1VybCA9IG51bGw7XG4gICAgdGhpcy5zdXBwb3J0ZWRTY29wZXMgPSBbXTtcbiAgICB0aGlzLndlZGVwbG95Q2xpZW50ID0gbnVsbDtcbiAgICB0aGlzLmhlYWRlcnNfID0gbmV3IE11bHRpTWFwKCk7XG4gIH1cblxuICAvKipcblx0ICogQ29uc3RydWN0cyBhbiB7QGxpbmsgQXV0aH0gaW5zdGFuY2UuXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBhdXRoT3JUb2tlbk9yRW1haWwgRWl0aGVyIGFuIGF1dGggaW5zdGFuY2UsIHRoZVxuXHQgKiAgIGF1dGhvcml6YXRpb24gdG9rZW4sIG9yIHRoZSB1c2VybmFtZS5cblx0ICogQHBhcmFtIHtzdHJpbmc9fSBvcHRfcGFzc3dvcmQgSWYgYSB1c2VybmFtZSBpcyBnaXZlbiBhcyB0aGUgZmlyc3QgcGFyYW0sXG5cdCAqICAgdGhpcyBzaG91bGQgYmUgdGhlIHBhc3N3b3JkLlxuXHQgKiBAcmV0dXJuIHshQXV0aH1cblx0ICovXG4gIHN0YXRpYyBjcmVhdGUoYXV0aE9yVG9rZW5PckVtYWlsLCBvcHRfcGFzc3dvcmQpIHtcbiAgICBpZiAoYXV0aE9yVG9rZW5PckVtYWlsIGluc3RhbmNlb2YgQXV0aCkge1xuICAgICAgcmV0dXJuIGF1dGhPclRva2VuT3JFbWFpbDtcbiAgICB9IGVsc2UgaWYgKGlzU3RyaW5nKGF1dGhPclRva2VuT3JFbWFpbCkgJiYgaXNTdHJpbmcob3B0X3Bhc3N3b3JkKSkge1xuICAgICAgcmV0dXJuIG5ldyBBdXRoKGF1dGhPclRva2VuT3JFbWFpbCwgb3B0X3Bhc3N3b3JkKTtcbiAgICB9IGVsc2UgaWYgKGlzU3RyaW5nKGF1dGhPclRva2VuT3JFbWFpbCkgJiYgIWlzRGVmKG9wdF9wYXNzd29yZCkpIHtcbiAgICAgIHJldHVybiBuZXcgQXV0aChhdXRoT3JUb2tlbk9yRW1haWwpO1xuICAgIH0gZWxzZSBpZiAoXG4gICAgICBpc0RlZkFuZE5vdE51bGwoYXV0aE9yVG9rZW5PckVtYWlsKSAmJlxuICAgICAgaXNPYmplY3QoYXV0aE9yVG9rZW5PckVtYWlsKVxuICAgICkge1xuICAgICAgcmV0dXJuIEF1dGguY3JlYXRlRnJvbURhdGEoYXV0aE9yVG9rZW5PckVtYWlsKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIG5ldyBBdXRoKCk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG5cdCAqIE1ha2VzIHVzZXIgQXV0aCBmcm9tIGRhdGEgb2JqZWN0LlxuXHQgKiBAcGFyYW0ge09iamVjdH0gZGF0YVxuXHQgKiBAcmV0dXJuIHtBdXRofVxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqL1xuICBzdGF0aWMgY3JlYXRlRnJvbURhdGEoZGF0YSkge1xuICAgIGxldCBhdXRoID0gbmV3IEF1dGgoKTtcbiAgICBpZiAoaXNPYmplY3QoZGF0YSkpIHtcbiAgICAgIGxldCBwcm9wZXJ0aWVzID0ge307XG4gICAgICBPYmplY3Qua2V5cyhkYXRhKS5mb3JFYWNoKGtleSA9PiB7XG4gICAgICAgIHByb3BlcnRpZXNba2V5XSA9IHtcbiAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgIHZhbHVlOiBkYXRhW2tleV0sXG4gICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgIH07XG4gICAgICB9KTtcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKGF1dGgsIHByb3BlcnRpZXMpO1xuICAgIH1cbiAgICBhdXRoLnNldFdlZGVwbG95Q2xpZW50KHRoaXMud2VkZXBsb3lDbGllbnQpO1xuICAgIHJldHVybiBhdXRoO1xuICB9XG5cbiAgLyoqXG5cdCAqIEdldHMgdGhlIGNyZWF0ZWQgYXQgZGF0ZS5cblx0ICogQHJldHVybiB7c3RyaW5nfVxuXHQgKi9cbiAgZ2V0Q3JlYXRlZEF0KCkge1xuICAgIHJldHVybiB0aGlzLmNyZWF0ZWRBdDtcbiAgfVxuXG4gIC8qKlxuXHQgKiBHZXRzIHRoZSBlbWFpbC5cblx0ICogQHJldHVybiB7c3RyaW5nfVxuXHQgKi9cbiAgZ2V0RW1haWwoKSB7XG4gICAgcmV0dXJuIHRoaXMuZW1haWw7XG4gIH1cblxuICAvKipcblx0ICogR2V0cyB0aGUgaWQuXG5cdCAqIEByZXR1cm4ge3N0cmluZ31cblx0ICovXG4gIGdldElkKCkge1xuICAgIHJldHVybiB0aGlzLmlkO1xuICB9XG5cbiAgLyoqXG5cdCAqIEdldHMgdGhlIG5hbWUuXG5cdCAqIEByZXR1cm4ge3N0cmluZ31cblx0ICovXG4gIGdldE5hbWUoKSB7XG4gICAgcmV0dXJuIHRoaXMubmFtZTtcbiAgfVxuXG4gIC8qKlxuXHQgKiBHZXRzIHRoZSBwYXNzd29yZC5cblx0ICogQHJldHVybiB7c3RyaW5nfVxuXHQgKi9cbiAgZ2V0UGFzc3dvcmQoKSB7XG4gICAgcmV0dXJuIHRoaXMucGFzc3dvcmQ7XG4gIH1cblxuICAvKipcblx0ICogR2V0cyB0aGUgcGhvdG8gdXJsLlxuXHQgKiBAcmV0dXJuIHtzdHJpbmd9XG5cdCAqL1xuICBnZXRQaG90b1VybCgpIHtcbiAgICByZXR1cm4gdGhpcy5waG90b1VybDtcbiAgfVxuXG4gIC8qKlxuXHQgKiBHZXRzIHRoZSBzdXBwb3J0ZWQgc2NvcGVzLlxuXHQgKiBAcmV0dXJuIHthcnJheS48c3RyaW5nPn1cblx0ICovXG4gIGdldFN1cHBvcnRlZFNjb3BlcygpIHtcbiAgICByZXR1cm4gdGhpcy5zdXBwb3J0ZWRTY29wZXM7XG4gIH1cblxuICAvKipcblx0ICogR2V0cyB0aGUgdG9rZW4uXG5cdCAqIEByZXR1cm4ge3N0cmluZ31cblx0ICovXG4gIGdldFRva2VuKCkge1xuICAgIHJldHVybiB0aGlzLnRva2VuO1xuICB9XG5cbiAgLyoqXG5cdCAqIENoZWNrcyBpZiBjcmVhdGVkIGF0IGlzIHNldC5cblx0ICogQHJldHVybiB7Ym9vbGVhbn1cblx0ICovXG4gIGhhc0NyZWF0ZWRBdCgpIHtcbiAgICByZXR1cm4gY29yZS5pc0RlZkFuZE5vdE51bGwodGhpcy5jcmVhdGVkQXQpO1xuICB9XG5cbiAgLyoqXG5cdCAqIENoZWNrcyBpZiB0aGUgZW1haWwgaXMgc2V0LlxuXHQgKiBAcmV0dXJuIHtib29sZWFufVxuXHQgKi9cbiAgaGFzRW1haWwoKSB7XG4gICAgcmV0dXJuIGNvcmUuaXNEZWZBbmROb3ROdWxsKHRoaXMuZW1haWwpO1xuICB9XG5cbiAgLyoqXG5cdCAqIENoZWNrcyBpZiB0aGUgaWQgaXMgc2V0LlxuXHQgKiBAcmV0dXJuIHtib29sZWFufVxuXHQgKi9cbiAgaGFzSWQoKSB7XG4gICAgcmV0dXJuIGNvcmUuaXNEZWZBbmROb3ROdWxsKHRoaXMuaWQpO1xuICB9XG5cbiAgLyoqXG5cdCAqIENoZWNrcyBpZiB0aGUgbmFtZSBpcyBzZXQuXG5cdCAqIEByZXR1cm4ge2Jvb2xlYW59XG5cdCAqL1xuICBoYXNOYW1lKCkge1xuICAgIHJldHVybiBjb3JlLmlzRGVmQW5kTm90TnVsbCh0aGlzLm5hbWUpO1xuICB9XG5cbiAgLyoqXG5cdCAqIENoZWNrcyBpZiB0aGUgcGFzc3dvcmQgaXMgc2V0LlxuXHQgKiBAcmV0dXJuIHtib29sZWFufVxuXHQgKi9cbiAgaGFzUGFzc3dvcmQoKSB7XG4gICAgcmV0dXJuIGNvcmUuaXNEZWZBbmROb3ROdWxsKHRoaXMucGFzc3dvcmQpO1xuICB9XG5cbiAgLyoqXG5cdCAqIENoZWNrcyBpZiB0aGUgcGhvdG8gdXJsIGlzIHNldC5cblx0ICogQHJldHVybiB7Ym9vbGVhbn1cblx0ICovXG4gIGhhc1Bob3RvVXJsKCkge1xuICAgIHJldHVybiBjb3JlLmlzRGVmQW5kTm90TnVsbCh0aGlzLnBob3RvVXJsKTtcbiAgfVxuXG4gIC8qKlxuXHQgKiBDaGVja3MgaWYgdGhlIHVzZXIgaGFzIHNjb3Blcy5cblx0ICogQHBhcmFtIHtzdHJpbmd8YXJyYXkuPHN0cmluZz59IHNjb3BlcyBTY29wZSBvciBhcnJheSBvZiBzY29wZXMgdG8gY2hlY2suXG5cdCAqIEByZXR1cm4ge2Jvb2xlYW59XG5cdCAqL1xuICBoYXNTdXBwb3J0ZWRTY29wZXMoc2NvcGVzKSB7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkoc2NvcGVzKSkge1xuICAgICAgcmV0dXJuIHNjb3Blcy5ldmVyeSh2YWwgPT4gdGhpcy5zdXBwb3J0ZWRTY29wZXMuaW5kZXhPZih2YWwpID4gLTEpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gdGhpcy5zdXBwb3J0ZWRTY29wZXMuaW5kZXhPZihzY29wZXMpID4gLTE7XG4gICAgfVxuICB9XG5cbiAgLyoqXG5cdCAqIENoZWNrcyBpZiB0aGUgdG9rZW4gaXMgc2V0LlxuXHQgKiBAcmV0dXJuIHtib29sZWFufVxuXHQgKi9cbiAgaGFzVG9rZW4oKSB7XG4gICAgcmV0dXJuIGNvcmUuaXNEZWZBbmROb3ROdWxsKHRoaXMudG9rZW4pO1xuICB9XG5cbiAgLyoqXG5cdCAqIFNldHMgY3JlYXRlZCBhdC5cblx0ICogQHBhcmFtIHtzdHJpbmd9IGNyZWF0ZWRBdFxuXHQgKi9cbiAgc2V0Q3JlYXRlZEF0KGNyZWF0ZWRBdCkge1xuICAgIHRoaXMuY3JlYXRlZEF0ID0gY3JlYXRlZEF0O1xuICB9XG5cbiAgLyoqXG5cdCAqIFNldHMgdGhlIGVtYWlsLlxuXHQgKiBAcGFyYW0ge3N0cmluZ30gZW1haWxcblx0ICovXG4gIHNldEVtYWlsKGVtYWlsKSB7XG4gICAgdGhpcy5lbWFpbCA9IGVtYWlsO1xuICB9XG5cbiAgLyoqXG5cdCAqIFNldHMgdGhlIGhlYWRlcnMuXG5cdCAqIEBwYXJhbSB7IU11bHRpTWFwfE9iamVjdH0gaGVhZGVycyBUaGUgaGVhZGVycyB0byBiZSBzZXRcblx0ICovXG4gIHNldEhlYWRlcnMoaGVhZGVycykge1xuICAgIGlmICghKGhlYWRlcnMgaW5zdGFuY2VvZiBNdWx0aU1hcCkpIHtcbiAgICAgIGhlYWRlcnMgPSBNdWx0aU1hcC5mcm9tT2JqZWN0KGhlYWRlcnMpO1xuICAgIH1cblxuICAgIGhlYWRlcnMubmFtZXMoKS5mb3JFYWNoKG5hbWUgPT4ge1xuICAgICAgY29uc3QgdmFsdWVzID0gaGVhZGVycy5nZXRBbGwobmFtZSk7XG5cbiAgICAgIHZhbHVlcy5mb3JFYWNoKHZhbHVlID0+IHtcbiAgICAgICAgdGhpcy5oZWFkZXJzXy5zZXQobmFtZSwgdmFsdWUpO1xuICAgICAgfSk7XG4gICAgfSk7XG4gIH1cblxuICAvKipcblx0ICogU2V0cyB0aGUgaWQuXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBpZFxuXHQgKi9cbiAgc2V0SWQoaWQpIHtcbiAgICB0aGlzLmlkID0gaWQ7XG4gIH1cblxuICAvKipcblx0ICogU2V0cyB0aGUgbmFtZS5cblx0ICogQHBhcmFtIHtzdHJpbmd9IG5hbWVcblx0ICovXG4gIHNldE5hbWUobmFtZSkge1xuICAgIHRoaXMubmFtZSA9IG5hbWU7XG4gIH1cblxuICAvKipcblx0ICogU2V0cyB0aGUgcGFzc3dvcmQuXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBwYXNzd29yZFxuXHQgKi9cbiAgc2V0UGFzc3dvcmQocGFzc3dvcmQpIHtcbiAgICB0aGlzLnBhc3N3b3JkID0gcGFzc3dvcmQ7XG4gIH1cblxuICAvKipcblx0ICogU2V0cyB0aGUgcGhvdG8gdXJsLlxuXHQgKiBAcGFyYW0ge3N0cmluZ30gcGhvdG9Vcmxcblx0ICovXG4gIHNldFBob3RvVXJsKHBob3RvVXJsKSB7XG4gICAgdGhpcy5waG90b1VybCA9IHBob3RvVXJsO1xuICB9XG5cbiAgLyoqXG5cdCAqIFNldHMgc3VwcG9ydGVkIHNjb3Blcy5cblx0ICogQHBhcmFtIHthcnJheS48c3RyaW5nPn0gc3VwcG9ydGVkU2NvcGVzXG5cdCAqL1xuICBzZXRTdXBwb3J0ZWRTY29wZXMoc3VwcG9ydGVkU2NvcGVzKSB7XG4gICAgdGhpcy5zdXBwb3J0ZWRTY29wZXMgPSBzdXBwb3J0ZWRTY29wZXM7XG4gIH1cblxuICAvKipcblx0ICogU2V0cyB0aGUgdG9rZW4uXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSB0b2tlblxuXHQgKi9cbiAgc2V0VG9rZW4odG9rZW4pIHtcbiAgICB0aGlzLnRva2VuID0gdG9rZW47XG4gIH1cblxuICAvKipcblx0ICogU2V0cyB0aGUgV2VEZXBsb3kgY2xpZW50LlxuXHQgKiBAcGFyYW0ge09iamVjdH0gd2VkZXBsb3lDbGllbnRcblx0ICovXG4gIHNldFdlZGVwbG95Q2xpZW50KHdlZGVwbG95Q2xpZW50KSB7XG4gICAgdGhpcy53ZWRlcGxveUNsaWVudCA9IHdlZGVwbG95Q2xpZW50O1xuICB9XG5cbiAgLyoqXG5cdCAqIFVwZGF0ZXMgdGhlIHVzZXIuXG5cdCAqIEBwYXJhbSB7IU9iamVjdH0gZGF0YVxuXHQgKiBAcmV0dXJuIHtDb21wbGV0YWJsZUZ1dHVyZX1cblx0ICovXG4gIHVwZGF0ZVVzZXIoZGF0YSkge1xuICAgIGFzc2VydE9iamVjdChkYXRhLCAnVXNlciBkYXRhIG11c3QgYmUgc3BlY2lmaWVkIGFzIG9iamVjdCcpO1xuICAgIHJldHVybiB0aGlzLmJ1aWxkVXJsXygpXG4gICAgICAucGF0aCgnL3VzZXJzJywgdGhpcy5nZXRJZCgpLnRvU3RyaW5nKCkpXG4gICAgICAuYXV0aCh0aGlzKVxuICAgICAgLnBhdGNoKGRhdGEpXG4gICAgICAudGhlbihyZXNwb25zZSA9PiBhc3NlcnRSZXNwb25zZVN1Y2NlZWRlZChyZXNwb25zZSkpO1xuICB9XG5cbiAgLyoqXG5cdCAqIERlbGV0ZXMgdGhlIGN1cnJlbnQgdXNlci5cblx0ICogQHJldHVybiB7Q29tcGxldGFibGVGdXR1cmV9XG5cdCAqL1xuICBkZWxldGVVc2VyKCkge1xuICAgIGFzc2VydERlZkFuZE5vdE51bGwodGhpcy5nZXRJZCgpLCAnQ2Fubm90IGRlbGV0ZSB1c2VyIHdpdGhvdXQgaWQnKTtcbiAgICByZXR1cm4gdGhpcy5idWlsZFVybF8oKVxuICAgICAgLnBhdGgoJy91c2VycycsIHRoaXMuZ2V0SWQoKS50b1N0cmluZygpKVxuICAgICAgLmF1dGgodGhpcylcbiAgICAgIC5kZWxldGUoKVxuICAgICAgLnRoZW4ocmVzcG9uc2UgPT4gYXNzZXJ0UmVzcG9uc2VTdWNjZWVkZWQocmVzcG9uc2UpKTtcbiAgfVxuXG4gIC8qKlxuXHQgKiBCdWlsZHMgVVJMIGJ5IGpvaW5pbmcgdGhlIGhlYWRlcnMuXG5cdCAqIEByZXR1cm4ge1dlRGVwbG95fSBSZXR1cm5zIHRoZSB7QGxpbmsgV2VEZXBsb3l9IG9iamVjdCBpdHNlbGYsIHNvIGNhbGxzIGNhblxuXHQgKiAgIGJlIGNoYWluZWQuXG5cdCAqIEBjaGFpbmFibGVcblx0ICovXG4gIGJ1aWxkVXJsXygpIHtcbiAgICByZXR1cm4gdGhpcy53ZWRlcGxveUNsaWVudFxuICAgICAgLnVybCh0aGlzLndlZGVwbG95Q2xpZW50LmF1dGhVcmxfKVxuICAgICAgLmhlYWRlcnModGhpcy5oZWFkZXJzXyk7XG4gIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgQXV0aDtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy9hcGkvYXV0aC9BdXRoLmpzIiwiJ3VzZSBzdHJpY3QnO1xuXG5pbXBvcnQgVXJpIGZyb20gJ21ldGFsLXVyaSc7XG5pbXBvcnQge2NvcmV9IGZyb20gJ21ldGFsJztcblxuLyoqXG4gKiBDbGFzcyByZXNwb25zaWJsZSBmb3IgZW5jYXBzdWxhdGUgcHJvdmlkZXIgaW5mb3JtYXRpb24uXG4gKi9cbmNsYXNzIEF1dGhQcm92aWRlciB7XG4gIC8qKlxuXHQgKiBDb25zdHJ1Y3RzIGFuIHtAbGluayBBdXRoUHJvdmlkZXJ9IGluc3RhbmNlLlxuXHQgKiBAY29uc3RydWN0b3Jcblx0ICovXG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHRoaXMucHJvdmlkZXIgPSBudWxsO1xuICAgIHRoaXMucHJvdmlkZXJTY29wZSA9IG51bGw7XG4gICAgdGhpcy5yZWRpcmVjdFVyaSA9IG51bGw7XG4gICAgdGhpcy5zY29wZSA9IG51bGw7XG4gIH1cblxuICAvKipcblx0ICogQ2hlY2tzIGlmIHByb3ZpZGVyIGlzIGRlZmluZWQgYW5kIG5vdCBudWxsLlxuXHQgKiBAcmV0dXJuIHtib29sZWFufVxuXHQgKi9cbiAgaGFzUHJvdmlkZXIoKSB7XG4gICAgcmV0dXJuIGNvcmUuaXNEZWZBbmROb3ROdWxsKHRoaXMucHJvdmlkZXIpO1xuICB9XG5cbiAgLyoqXG5cdCAqIENoZWNrcyBpZiBzY29wZSBpcyBkZWZpbmVkIGFuZCBub3QgbnVsbC5cblx0ICogQHJldHVybiB7Ym9vbGVhbn1cblx0ICovXG4gIGhhc1Byb3ZpZGVyU2NvcGUoKSB7XG4gICAgcmV0dXJuIGNvcmUuaXNEZWZBbmROb3ROdWxsKHRoaXMucHJvdmlkZXJTY29wZSk7XG4gIH1cblxuICAvKipcblx0ICogQ2hlY2tzIGlmIHJlZGlyZWN0IHVyaSBpcyBkZWZpbmVkIGFuZCBub3QgbnVsbC5cblx0ICogQHJldHVybiB7Ym9vbGVhbn1cblx0ICovXG4gIGhhc1JlZGlyZWN0VXJpKCkge1xuICAgIHJldHVybiBjb3JlLmlzRGVmQW5kTm90TnVsbCh0aGlzLnJlZGlyZWN0VXJpKTtcbiAgfVxuXG4gIC8qKlxuXHQgKiBDaGVja3MgaWYgc2NvcGUgaXMgZGVmaW5lZCBhbmQgbm90IG51bGwuXG5cdCAqIEByZXR1cm4ge2Jvb2xlYW59XG5cdCAqL1xuICBoYXNTY29wZSgpIHtcbiAgICByZXR1cm4gY29yZS5pc0RlZkFuZE5vdE51bGwodGhpcy5zY29wZSk7XG4gIH1cblxuICAvKipcblx0ICogTWFrZXMgYXV0aG9yaXphdGlvbiB1cmwuIEFuIG9wdGlvbmFsIGF1dGhvcml6YXRpb24gVVJMIG1pZ2h0IGJlIHByb3ZpZGVkLlxuXHQgKiBAcGFyYW0ge3N0cmluZ30gb3B0X2F1dGhVcmwgT3B0aW9uYWwgYXV0aG9yaXphdGlvbiBVUkwuXG5cdCAqIEByZXR1cm4ge3N0cmluZ30gTm9ybWFsaXplZCBhdXRob3JpemF0aW9uIFVSTC5cblx0ICovXG4gIG1ha2VBdXRob3JpemF0aW9uVXJsKG9wdF9hdXRoVXJsKSB7XG4gICAgbGV0IHVyaSA9IG5ldyBVcmkob3B0X2F1dGhVcmwpO1xuXG4gICAgdXJpLnNldFBhdGhuYW1lKCcvb2F1dGgvYXV0aG9yaXplJyk7XG5cbiAgICBpZiAodGhpcy5oYXNQcm92aWRlcigpKSB7XG4gICAgICB1cmkuc2V0UGFyYW1ldGVyVmFsdWUoJ3Byb3ZpZGVyJywgdGhpcy5nZXRQcm92aWRlcigpKTtcbiAgICB9XG4gICAgaWYgKHRoaXMuaGFzUHJvdmlkZXJTY29wZSgpKSB7XG4gICAgICB1cmkuc2V0UGFyYW1ldGVyVmFsdWUoJ3Byb3ZpZGVyX3Njb3BlJywgdGhpcy5nZXRQcm92aWRlclNjb3BlKCkpO1xuICAgIH1cbiAgICBpZiAodGhpcy5oYXNSZWRpcmVjdFVyaSgpKSB7XG4gICAgICB1cmkuc2V0UGFyYW1ldGVyVmFsdWUoJ3JlZGlyZWN0X3VyaScsIHRoaXMuZ2V0UmVkaXJlY3RVcmkoKSk7XG4gICAgfVxuICAgIGlmICh0aGlzLmhhc1Njb3BlKCkpIHtcbiAgICAgIHVyaS5zZXRQYXJhbWV0ZXJWYWx1ZSgnc2NvcGUnLCB0aGlzLmdldFNjb3BlKCkpO1xuICAgIH1cblxuICAgIHJldHVybiB1cmkudG9TdHJpbmcoKTtcbiAgfVxuXG4gIC8qKlxuXHQgKiBHZXRzIHByb3ZpZGVyIG5hbWUuXG5cdCAqIEByZXR1cm4ge3N0cmluZ30gUHJvdmlkZXIgbmFtZS5cblx0ICovXG4gIGdldFByb3ZpZGVyKCkge1xuICAgIHJldHVybiB0aGlzLnByb3ZpZGVyO1xuICB9XG5cbiAgLyoqXG5cdCAqIEdldHMgcHJvdmlkZXIgc2NvcGUuXG5cdCAqIEByZXR1cm4ge3N0cmluZ30gU3RyaW5nIHdpdGggc2NvcGVzLlxuXHQgKi9cbiAgZ2V0UHJvdmlkZXJTY29wZSgpIHtcbiAgICByZXR1cm4gdGhpcy5wcm92aWRlclNjb3BlO1xuICB9XG5cbiAgLyoqXG5cdCAqIEdldHMgcmVkaXJlY3QgdXJpLlxuXHQgKiBAcmV0dXJuIHtzdHJpbmd9LlxuXHQgKi9cbiAgZ2V0UmVkaXJlY3RVcmkoKSB7XG4gICAgcmV0dXJuIHRoaXMucmVkaXJlY3RVcmk7XG4gIH1cblxuICAvKipcblx0ICogR2V0cyBzY29wZS5cblx0ICogQHJldHVybiB7c3RyaW5nfSBTdHJpbmcgd2l0aCBzY29wZXMuXG5cdCAqL1xuICBnZXRTY29wZSgpIHtcbiAgICByZXR1cm4gdGhpcy5zY29wZTtcbiAgfVxuXG4gIC8qKlxuXHQgKiBTZXRzIHByb3ZpZGVyIHNjb3BlLlxuXHQgKiBAcGFyYW0ge3N0cmluZz19IHByb3ZpZGVyU2NvcGUgU2NvcGUgc3RyaW5nLiBTZXBhcmF0ZSBieSBzcGFjZSBmb3IgbXVsdGlwbGVcblx0ICogICBzY29wZXMsIGUuZy4gXCJzY29wZTEgc2NvcGUyXCIuXG5cdCAqL1xuICBzZXRQcm92aWRlclNjb3BlKHByb3ZpZGVyU2NvcGUpIHtcbiAgICBhc3NlcnRTdHJpbmdJZkRlZkFuZE5vdE51bGwoXG4gICAgICBwcm92aWRlclNjb3BlLFxuICAgICAgJ1Byb3ZpZGVyIHNjb3BlIG11c3QgYmUgYSBzdHJpbmcnXG4gICAgKTtcbiAgICB0aGlzLnByb3ZpZGVyU2NvcGUgPSBwcm92aWRlclNjb3BlO1xuICB9XG5cbiAgLyoqXG5cdCAqIFNldHMgcmVkaXJlY3QgdXJpLlxuXHQgKiBAcGFyYW0ge3N0cmluZ30gcmVkaXJlY3RVcmkgVGhlIHJlZGlyZWN0IFVSSSB0byBiZSBzZXQgdG8gdGhlIGN1cnJlbnRcblx0ICogICBpbnN0YW5jZS5cblx0ICovXG4gIHNldFJlZGlyZWN0VXJpKHJlZGlyZWN0VXJpKSB7XG4gICAgYXNzZXJ0U3RyaW5nSWZEZWZBbmROb3ROdWxsKHJlZGlyZWN0VXJpLCAnUmVkaXJlY3QgdXJpIG11c3QgYmUgYSBzdHJpbmcnKTtcbiAgICB0aGlzLnJlZGlyZWN0VXJpID0gcmVkaXJlY3RVcmk7XG4gIH1cblxuICAvKipcblx0ICogU2V0cyBzY29wZS5cblx0ICogQHBhcmFtIHtzdHJpbmc9fSBzY29wZSBTY29wZSBzdHJpbmcuIFNlcGFyYXRlIGJ5IHNwYWNlIGZvciBtdWx0aXBsZVxuXHQgKiAgIHNjb3BlcywgZS5nLiBcInNjb3BlMSBzY29wZTJcIi5cblx0ICovXG4gIHNldFNjb3BlKHNjb3BlKSB7XG4gICAgYXNzZXJ0U3RyaW5nSWZEZWZBbmROb3ROdWxsKHNjb3BlLCAnU2NvcGUgbXVzdCBiZSBhIHN0cmluZycpO1xuICAgIHRoaXMuc2NvcGUgPSBzY29wZTtcbiAgfVxufVxuXG4vKipcbiAqIFRocm93cyBhbiBleGNlcHRpb24gaWYgdGhlIHByb3ZpZGVkIHZhbHVlIGlzIGRlZmluZWQgYW5kIG5vdCBudWxsLCBidXQgbm90IGFcbiAqICAgc3RyaW5nLlxuICogQHBhcmFtIHshKn0gdmFsdWUgVGhlIHZhbHVlIHRvIGJlIGNoZWNrZWQuXG4gKiBAcGFyYW0geyFzdHJpbmd9IGVycm9yTWVzc2FnZSBUaGUgbWVzc2FnZSB0byBiZSBwcm92aWRlZCB0byB0aGUgZXhjZXB0aW9uLlxuICovXG5mdW5jdGlvbiBhc3NlcnRTdHJpbmdJZkRlZkFuZE5vdE51bGwodmFsdWUsIGVycm9yTWVzc2FnZSkge1xuICBpZiAoY29yZS5pc0RlZkFuZE5vdE51bGwodmFsdWUpICYmICFjb3JlLmlzU3RyaW5nKHZhbHVlKSkge1xuICAgIHRocm93IG5ldyBFcnJvcihlcnJvck1lc3NhZ2UpO1xuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IEF1dGhQcm92aWRlcjtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy9hcGkvYXV0aC9BdXRoUHJvdmlkZXIuanMiLCIndXNlIHN0cmljdCc7XG5cbi8qIGpzaGludCBpZ25vcmU6c3RhcnQgKi9cblxuLyoqXG4gKiBBYnN0cmFjdCBpbnRlcmZhY2UgZm9yIHN0b3JpbmcgYW5kIHJldHJpZXZpbmcgZGF0YSB1c2luZyBzb21lIHBlcnNpc3RlbmNlXG4gKiBtZWNoYW5pc20uXG4gKiBAY29uc3RydWN0b3JcbiAqL1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcblx0dmFsdWU6IHRydWVcbn0pO1xuXG52YXIgX2NyZWF0ZUNsYXNzID0gZnVuY3Rpb24gKCkgeyBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH0gcmV0dXJuIGZ1bmN0aW9uIChDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfTsgfSgpO1xuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG52YXIgU3RvcmFnZU1lY2hhbmlzbSA9IGZ1bmN0aW9uICgpIHtcblx0ZnVuY3Rpb24gU3RvcmFnZU1lY2hhbmlzbSgpIHtcblx0XHRfY2xhc3NDYWxsQ2hlY2sodGhpcywgU3RvcmFnZU1lY2hhbmlzbSk7XG5cdH1cblxuXHRfY3JlYXRlQ2xhc3MoU3RvcmFnZU1lY2hhbmlzbSwgW3tcblx0XHRrZXk6ICdjbGVhcicsXG5cblx0XHQvKipcbiAgICogQ2xlYXIgYWxsIGl0ZW1zIGZyb20gdGhlIGRhdGEgc3RvcmFnZS5cbiAgICovXG5cdFx0dmFsdWU6IGZ1bmN0aW9uIGNsZWFyKCkge1xuXHRcdFx0dGhyb3cgRXJyb3IoJ1VuaW1wbGVtZW50ZWQgYWJzdHJhY3QgbWV0aG9kJyk7XG5cdFx0fVxuXG5cdFx0LyoqXG4gICAqIFNldHMgYW4gaXRlbSBpbiB0aGUgZGF0YSBzdG9yYWdlLlxuICAgKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgdG8gc2V0LlxuICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBzZXJpYWxpemUgdG8gYSBzdHJpbmcgYW5kIHNhdmUuXG4gICAqL1xuXG5cdH0sIHtcblx0XHRrZXk6ICdzZXQnLFxuXHRcdHZhbHVlOiBmdW5jdGlvbiBzZXQoa2V5LCB2YWx1ZSkge1xuXHRcdFx0dGhyb3cgRXJyb3IoJ1VuaW1wbGVtZW50ZWQgYWJzdHJhY3QgbWV0aG9kJyk7XG5cdFx0fVxuXG5cdFx0LyoqXG4gICAqIEdldHMgYW4gaXRlbSBmcm9tIHRoZSBkYXRhIHN0b3JhZ2UuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSB0byBnZXQuXG4gICAqIEByZXR1cm4geyp9IERlc2VyaWFsaXplZCB2YWx1ZSBvciB1bmRlZmluZWQgaWYgbm90IGZvdW5kLlxuICAgKi9cblxuXHR9LCB7XG5cdFx0a2V5OiAnZ2V0Jyxcblx0XHR2YWx1ZTogZnVuY3Rpb24gZ2V0KGtleSkge1xuXHRcdFx0dGhyb3cgRXJyb3IoJ1VuaW1wbGVtZW50ZWQgYWJzdHJhY3QgbWV0aG9kJyk7XG5cdFx0fVxuXG5cdFx0LyoqXG4gICAqIENoZWNrcyBpZiB0aGlzIG1lY2hhbmlzbSBpcyBzdXBwb3J0ZWQgaW4gdGhlIGN1cnJlbnQgZW52aXJvbm1lbnQuXG4gICAqIFN1YmNsYXNzZXMgc2hvdWxkIG92ZXJyaWRlIHRoaXMgd2hlbiBuZWNlc3NhcnkuXG4gICAqL1xuXG5cdH0sIHtcblx0XHRrZXk6ICdrZXlzJyxcblxuXG5cdFx0LyoqXG4gICAqIFJldHVybnMgdGhlIGxpc3Qgb2Yga2V5cyBzdG9yZWQgaW4gdGhlIFN0b3JhZ2Ugb2JqZWN0LlxuICAgKiBAcGFyYW0geyFBcnJheTxzdHJpbmc+fSBrZXlzXG4gICAqL1xuXHRcdHZhbHVlOiBmdW5jdGlvbiBrZXlzKCkge1xuXHRcdFx0dGhyb3cgRXJyb3IoJ1VuaW1wbGVtZW50ZWQgYWJzdHJhY3QgbWV0aG9kJyk7XG5cdFx0fVxuXG5cdFx0LyoqXG4gICAqIFJlbW92ZXMgYW4gaXRlbSBmcm9tIHRoZSBkYXRhIHN0b3JhZ2UuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSB0byByZW1vdmUuXG4gICAqL1xuXG5cdH0sIHtcblx0XHRrZXk6ICdyZW1vdmUnLFxuXHRcdHZhbHVlOiBmdW5jdGlvbiByZW1vdmUoa2V5KSB7XG5cdFx0XHR0aHJvdyBFcnJvcignVW5pbXBsZW1lbnRlZCBhYnN0cmFjdCBtZXRob2QnKTtcblx0XHR9XG5cblx0XHQvKipcbiAgICogUmV0dXJucyB0aGUgbnVtYmVyIG9mIGRhdGEgaXRlbXMgc3RvcmVkIGluIHRoZSBTdG9yYWdlIG9iamVjdC5cbiAgICogQHJldHVybiB7bnVtYmVyfVxuICAgKi9cblxuXHR9LCB7XG5cdFx0a2V5OiAnc2l6ZScsXG5cdFx0dmFsdWU6IGZ1bmN0aW9uIHNpemUoKSB7XG5cdFx0XHR0aHJvdyBFcnJvcignVW5pbXBsZW1lbnRlZCBhYnN0cmFjdCBtZXRob2QnKTtcblx0XHR9XG5cdH1dLCBbe1xuXHRcdGtleTogJ2lzU3VwcG9ydGVkJyxcblx0XHR2YWx1ZTogZnVuY3Rpb24gaXNTdXBwb3J0ZWQoKSB7XG5cdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHR9XG5cdH1dKTtcblxuXHRyZXR1cm4gU3RvcmFnZU1lY2hhbmlzbTtcbn0oKTtcblxuZXhwb3J0cy5kZWZhdWx0ID0gU3RvcmFnZU1lY2hhbmlzbTtcblxuLyoganNoaW50IGlnbm9yZTplbmQgKi9cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vbWV0YWwtc3RvcmFnZS9saWIvbWVjaGFuaXNtL1N0b3JhZ2VNZWNoYW5pc20uanNcbi8vIG1vZHVsZSBpZCA9IDEyXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8vIHNoaW0gZm9yIHVzaW5nIHByb2Nlc3MgaW4gYnJvd3NlclxudmFyIHByb2Nlc3MgPSBtb2R1bGUuZXhwb3J0cyA9IHt9O1xuXG4vLyBjYWNoZWQgZnJvbSB3aGF0ZXZlciBnbG9iYWwgaXMgcHJlc2VudCBzbyB0aGF0IHRlc3QgcnVubmVycyB0aGF0IHN0dWIgaXRcbi8vIGRvbid0IGJyZWFrIHRoaW5ncy4gIEJ1dCB3ZSBuZWVkIHRvIHdyYXAgaXQgaW4gYSB0cnkgY2F0Y2ggaW4gY2FzZSBpdCBpc1xuLy8gd3JhcHBlZCBpbiBzdHJpY3QgbW9kZSBjb2RlIHdoaWNoIGRvZXNuJ3QgZGVmaW5lIGFueSBnbG9iYWxzLiAgSXQncyBpbnNpZGUgYVxuLy8gZnVuY3Rpb24gYmVjYXVzZSB0cnkvY2F0Y2hlcyBkZW9wdGltaXplIGluIGNlcnRhaW4gZW5naW5lcy5cblxudmFyIGNhY2hlZFNldFRpbWVvdXQ7XG52YXIgY2FjaGVkQ2xlYXJUaW1lb3V0O1xuXG5mdW5jdGlvbiBkZWZhdWx0U2V0VGltb3V0KCkge1xuICAgIHRocm93IG5ldyBFcnJvcignc2V0VGltZW91dCBoYXMgbm90IGJlZW4gZGVmaW5lZCcpO1xufVxuZnVuY3Rpb24gZGVmYXVsdENsZWFyVGltZW91dCAoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdjbGVhclRpbWVvdXQgaGFzIG5vdCBiZWVuIGRlZmluZWQnKTtcbn1cbihmdW5jdGlvbiAoKSB7XG4gICAgdHJ5IHtcbiAgICAgICAgaWYgKHR5cGVvZiBzZXRUaW1lb3V0ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBjYWNoZWRTZXRUaW1lb3V0ID0gc2V0VGltZW91dDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNhY2hlZFNldFRpbWVvdXQgPSBkZWZhdWx0U2V0VGltb3V0O1xuICAgICAgICB9XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBjYWNoZWRTZXRUaW1lb3V0ID0gZGVmYXVsdFNldFRpbW91dDtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgICAgaWYgKHR5cGVvZiBjbGVhclRpbWVvdXQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIGNhY2hlZENsZWFyVGltZW91dCA9IGNsZWFyVGltZW91dDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNhY2hlZENsZWFyVGltZW91dCA9IGRlZmF1bHRDbGVhclRpbWVvdXQ7XG4gICAgICAgIH1cbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGNhY2hlZENsZWFyVGltZW91dCA9IGRlZmF1bHRDbGVhclRpbWVvdXQ7XG4gICAgfVxufSAoKSlcbmZ1bmN0aW9uIHJ1blRpbWVvdXQoZnVuKSB7XG4gICAgaWYgKGNhY2hlZFNldFRpbWVvdXQgPT09IHNldFRpbWVvdXQpIHtcbiAgICAgICAgLy9ub3JtYWwgZW52aXJvbWVudHMgaW4gc2FuZSBzaXR1YXRpb25zXG4gICAgICAgIHJldHVybiBzZXRUaW1lb3V0KGZ1biwgMCk7XG4gICAgfVxuICAgIC8vIGlmIHNldFRpbWVvdXQgd2Fzbid0IGF2YWlsYWJsZSBidXQgd2FzIGxhdHRlciBkZWZpbmVkXG4gICAgaWYgKChjYWNoZWRTZXRUaW1lb3V0ID09PSBkZWZhdWx0U2V0VGltb3V0IHx8ICFjYWNoZWRTZXRUaW1lb3V0KSAmJiBzZXRUaW1lb3V0KSB7XG4gICAgICAgIGNhY2hlZFNldFRpbWVvdXQgPSBzZXRUaW1lb3V0O1xuICAgICAgICByZXR1cm4gc2V0VGltZW91dChmdW4sIDApO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgICAvLyB3aGVuIHdoZW4gc29tZWJvZHkgaGFzIHNjcmV3ZWQgd2l0aCBzZXRUaW1lb3V0IGJ1dCBubyBJLkUuIG1hZGRuZXNzXG4gICAgICAgIHJldHVybiBjYWNoZWRTZXRUaW1lb3V0KGZ1biwgMCk7XG4gICAgfSBjYXRjaChlKXtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIC8vIFdoZW4gd2UgYXJlIGluIEkuRS4gYnV0IHRoZSBzY3JpcHQgaGFzIGJlZW4gZXZhbGVkIHNvIEkuRS4gZG9lc24ndCB0cnVzdCB0aGUgZ2xvYmFsIG9iamVjdCB3aGVuIGNhbGxlZCBub3JtYWxseVxuICAgICAgICAgICAgcmV0dXJuIGNhY2hlZFNldFRpbWVvdXQuY2FsbChudWxsLCBmdW4sIDApO1xuICAgICAgICB9IGNhdGNoKGUpe1xuICAgICAgICAgICAgLy8gc2FtZSBhcyBhYm92ZSBidXQgd2hlbiBpdCdzIGEgdmVyc2lvbiBvZiBJLkUuIHRoYXQgbXVzdCBoYXZlIHRoZSBnbG9iYWwgb2JqZWN0IGZvciAndGhpcycsIGhvcGZ1bGx5IG91ciBjb250ZXh0IGNvcnJlY3Qgb3RoZXJ3aXNlIGl0IHdpbGwgdGhyb3cgYSBnbG9iYWwgZXJyb3JcbiAgICAgICAgICAgIHJldHVybiBjYWNoZWRTZXRUaW1lb3V0LmNhbGwodGhpcywgZnVuLCAwKTtcbiAgICAgICAgfVxuICAgIH1cblxuXG59XG5mdW5jdGlvbiBydW5DbGVhclRpbWVvdXQobWFya2VyKSB7XG4gICAgaWYgKGNhY2hlZENsZWFyVGltZW91dCA9PT0gY2xlYXJUaW1lb3V0KSB7XG4gICAgICAgIC8vbm9ybWFsIGVudmlyb21lbnRzIGluIHNhbmUgc2l0dWF0aW9uc1xuICAgICAgICByZXR1cm4gY2xlYXJUaW1lb3V0KG1hcmtlcik7XG4gICAgfVxuICAgIC8vIGlmIGNsZWFyVGltZW91dCB3YXNuJ3QgYXZhaWxhYmxlIGJ1dCB3YXMgbGF0dGVyIGRlZmluZWRcbiAgICBpZiAoKGNhY2hlZENsZWFyVGltZW91dCA9PT0gZGVmYXVsdENsZWFyVGltZW91dCB8fCAhY2FjaGVkQ2xlYXJUaW1lb3V0KSAmJiBjbGVhclRpbWVvdXQpIHtcbiAgICAgICAgY2FjaGVkQ2xlYXJUaW1lb3V0ID0gY2xlYXJUaW1lb3V0O1xuICAgICAgICByZXR1cm4gY2xlYXJUaW1lb3V0KG1hcmtlcik7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICAgIC8vIHdoZW4gd2hlbiBzb21lYm9keSBoYXMgc2NyZXdlZCB3aXRoIHNldFRpbWVvdXQgYnV0IG5vIEkuRS4gbWFkZG5lc3NcbiAgICAgICAgcmV0dXJuIGNhY2hlZENsZWFyVGltZW91dChtYXJrZXIpO1xuICAgIH0gY2F0Y2ggKGUpe1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgLy8gV2hlbiB3ZSBhcmUgaW4gSS5FLiBidXQgdGhlIHNjcmlwdCBoYXMgYmVlbiBldmFsZWQgc28gSS5FLiBkb2Vzbid0ICB0cnVzdCB0aGUgZ2xvYmFsIG9iamVjdCB3aGVuIGNhbGxlZCBub3JtYWxseVxuICAgICAgICAgICAgcmV0dXJuIGNhY2hlZENsZWFyVGltZW91dC5jYWxsKG51bGwsIG1hcmtlcik7XG4gICAgICAgIH0gY2F0Y2ggKGUpe1xuICAgICAgICAgICAgLy8gc2FtZSBhcyBhYm92ZSBidXQgd2hlbiBpdCdzIGEgdmVyc2lvbiBvZiBJLkUuIHRoYXQgbXVzdCBoYXZlIHRoZSBnbG9iYWwgb2JqZWN0IGZvciAndGhpcycsIGhvcGZ1bGx5IG91ciBjb250ZXh0IGNvcnJlY3Qgb3RoZXJ3aXNlIGl0IHdpbGwgdGhyb3cgYSBnbG9iYWwgZXJyb3IuXG4gICAgICAgICAgICAvLyBTb21lIHZlcnNpb25zIG9mIEkuRS4gaGF2ZSBkaWZmZXJlbnQgcnVsZXMgZm9yIGNsZWFyVGltZW91dCB2cyBzZXRUaW1lb3V0XG4gICAgICAgICAgICByZXR1cm4gY2FjaGVkQ2xlYXJUaW1lb3V0LmNhbGwodGhpcywgbWFya2VyKTtcbiAgICAgICAgfVxuICAgIH1cblxuXG5cbn1cbnZhciBxdWV1ZSA9IFtdO1xudmFyIGRyYWluaW5nID0gZmFsc2U7XG52YXIgY3VycmVudFF1ZXVlO1xudmFyIHF1ZXVlSW5kZXggPSAtMTtcblxuZnVuY3Rpb24gY2xlYW5VcE5leHRUaWNrKCkge1xuICAgIGlmICghZHJhaW5pbmcgfHwgIWN1cnJlbnRRdWV1ZSkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGRyYWluaW5nID0gZmFsc2U7XG4gICAgaWYgKGN1cnJlbnRRdWV1ZS5sZW5ndGgpIHtcbiAgICAgICAgcXVldWUgPSBjdXJyZW50UXVldWUuY29uY2F0KHF1ZXVlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBxdWV1ZUluZGV4ID0gLTE7XG4gICAgfVxuICAgIGlmIChxdWV1ZS5sZW5ndGgpIHtcbiAgICAgICAgZHJhaW5RdWV1ZSgpO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gZHJhaW5RdWV1ZSgpIHtcbiAgICBpZiAoZHJhaW5pbmcpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB2YXIgdGltZW91dCA9IHJ1blRpbWVvdXQoY2xlYW5VcE5leHRUaWNrKTtcbiAgICBkcmFpbmluZyA9IHRydWU7XG5cbiAgICB2YXIgbGVuID0gcXVldWUubGVuZ3RoO1xuICAgIHdoaWxlKGxlbikge1xuICAgICAgICBjdXJyZW50UXVldWUgPSBxdWV1ZTtcbiAgICAgICAgcXVldWUgPSBbXTtcbiAgICAgICAgd2hpbGUgKCsrcXVldWVJbmRleCA8IGxlbikge1xuICAgICAgICAgICAgaWYgKGN1cnJlbnRRdWV1ZSkge1xuICAgICAgICAgICAgICAgIGN1cnJlbnRRdWV1ZVtxdWV1ZUluZGV4XS5ydW4oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBxdWV1ZUluZGV4ID0gLTE7XG4gICAgICAgIGxlbiA9IHF1ZXVlLmxlbmd0aDtcbiAgICB9XG4gICAgY3VycmVudFF1ZXVlID0gbnVsbDtcbiAgICBkcmFpbmluZyA9IGZhbHNlO1xuICAgIHJ1bkNsZWFyVGltZW91dCh0aW1lb3V0KTtcbn1cblxucHJvY2Vzcy5uZXh0VGljayA9IGZ1bmN0aW9uIChmdW4pIHtcbiAgICB2YXIgYXJncyA9IG5ldyBBcnJheShhcmd1bWVudHMubGVuZ3RoIC0gMSk7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPiAxKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBhcmdzW2kgLSAxXSA9IGFyZ3VtZW50c1tpXTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBxdWV1ZS5wdXNoKG5ldyBJdGVtKGZ1biwgYXJncykpO1xuICAgIGlmIChxdWV1ZS5sZW5ndGggPT09IDEgJiYgIWRyYWluaW5nKSB7XG4gICAgICAgIHJ1blRpbWVvdXQoZHJhaW5RdWV1ZSk7XG4gICAgfVxufTtcblxuLy8gdjggbGlrZXMgcHJlZGljdGlibGUgb2JqZWN0c1xuZnVuY3Rpb24gSXRlbShmdW4sIGFycmF5KSB7XG4gICAgdGhpcy5mdW4gPSBmdW47XG4gICAgdGhpcy5hcnJheSA9IGFycmF5O1xufVxuSXRlbS5wcm90b3R5cGUucnVuID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuZnVuLmFwcGx5KG51bGwsIHRoaXMuYXJyYXkpO1xufTtcbnByb2Nlc3MudGl0bGUgPSAnYnJvd3Nlcic7XG5wcm9jZXNzLmJyb3dzZXIgPSB0cnVlO1xucHJvY2Vzcy5lbnYgPSB7fTtcbnByb2Nlc3MuYXJndiA9IFtdO1xucHJvY2Vzcy52ZXJzaW9uID0gJyc7IC8vIGVtcHR5IHN0cmluZyB0byBhdm9pZCByZWdleHAgaXNzdWVzXG5wcm9jZXNzLnZlcnNpb25zID0ge307XG5cbmZ1bmN0aW9uIG5vb3AoKSB7fVxuXG5wcm9jZXNzLm9uID0gbm9vcDtcbnByb2Nlc3MuYWRkTGlzdGVuZXIgPSBub29wO1xucHJvY2Vzcy5vbmNlID0gbm9vcDtcbnByb2Nlc3Mub2ZmID0gbm9vcDtcbnByb2Nlc3MucmVtb3ZlTGlzdGVuZXIgPSBub29wO1xucHJvY2Vzcy5yZW1vdmVBbGxMaXN0ZW5lcnMgPSBub29wO1xucHJvY2Vzcy5lbWl0ID0gbm9vcDtcbnByb2Nlc3MucHJlcGVuZExpc3RlbmVyID0gbm9vcDtcbnByb2Nlc3MucHJlcGVuZE9uY2VMaXN0ZW5lciA9IG5vb3A7XG5cbnByb2Nlc3MubGlzdGVuZXJzID0gZnVuY3Rpb24gKG5hbWUpIHsgcmV0dXJuIFtdIH1cblxucHJvY2Vzcy5iaW5kaW5nID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3Byb2Nlc3MuYmluZGluZyBpcyBub3Qgc3VwcG9ydGVkJyk7XG59O1xuXG5wcm9jZXNzLmN3ZCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuICcvJyB9O1xucHJvY2Vzcy5jaGRpciA9IGZ1bmN0aW9uIChkaXIpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3Byb2Nlc3MuY2hkaXIgaXMgbm90IHN1cHBvcnRlZCcpO1xufTtcbnByb2Nlc3MudW1hc2sgPSBmdW5jdGlvbigpIHsgcmV0dXJuIDA7IH07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vcHJvY2Vzcy9icm93c2VyLmpzXG4vLyBtb2R1bGUgaWQgPSAxM1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgZztcclxuXHJcbi8vIFRoaXMgd29ya3MgaW4gbm9uLXN0cmljdCBtb2RlXHJcbmcgPSAoZnVuY3Rpb24oKSB7XHJcblx0cmV0dXJuIHRoaXM7XHJcbn0pKCk7XHJcblxyXG50cnkge1xyXG5cdC8vIFRoaXMgd29ya3MgaWYgZXZhbCBpcyBhbGxvd2VkIChzZWUgQ1NQKVxyXG5cdGcgPSBnIHx8IEZ1bmN0aW9uKFwicmV0dXJuIHRoaXNcIikoKSB8fCAoMSxldmFsKShcInRoaXNcIik7XHJcbn0gY2F0Y2goZSkge1xyXG5cdC8vIFRoaXMgd29ya3MgaWYgdGhlIHdpbmRvdyByZWZlcmVuY2UgaXMgYXZhaWxhYmxlXHJcblx0aWYodHlwZW9mIHdpbmRvdyA9PT0gXCJvYmplY3RcIilcclxuXHRcdGcgPSB3aW5kb3c7XHJcbn1cclxuXHJcbi8vIGcgY2FuIHN0aWxsIGJlIHVuZGVmaW5lZCwgYnV0IG5vdGhpbmcgdG8gZG8gYWJvdXQgaXQuLi5cclxuLy8gV2UgcmV0dXJuIHVuZGVmaW5lZCwgaW5zdGVhZCBvZiBub3RoaW5nIGhlcmUsIHNvIGl0J3NcclxuLy8gZWFzaWVyIHRvIGhhbmRsZSB0aGlzIGNhc2UuIGlmKCFnbG9iYWwpIHsgLi4ufVxyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBnO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAod2VicGFjaykvYnVpbGRpbi9nbG9iYWwuanNcbi8vIG1vZHVsZSBpZCA9IDE0XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIid1c2Ugc3RyaWN0JztcblxuaW1wb3J0IEVtYm9kaWVkIGZyb20gJy4vRW1ib2RpZWQnO1xuXG4vKipcbiAqIENsYXNzIHJlc3BvbnNpYmxlIGZvciBidWlsZGluZyBkaWZmZXJlbnQgdHlwZXMgb2YgZ2VvbWV0cmljXG4gKiBzaGFwZXMuXG4gKi9cbmNsYXNzIEdlbyB7XG4gIC8qKlxuXHQgKiBDcmVhdGVzIGEgbmV3IHtAbGluayBCb3VuZGluZ0JveH0gaW5zdGFuY2UuXG5cdCAqIEBwYXJhbSB7Kn0gdXBwZXJMZWZ0IFRoZSB1cHBlciBsZWZ0IHBvaW50LlxuXHQgKiBAcGFyYW0geyp9IGxvd2VyUmlnaHQgVGhlIGxvd2VyIHJpZ2h0IHBvaW50LlxuXHQgKiBAcmV0dXJuIHshQm91bmRpbmdCb3h9XG5cdCAqIEBzdGF0aWNcblx0ICovXG4gIHN0YXRpYyBib3VuZGluZ0JveCh1cHBlckxlZnQsIGxvd2VyUmlnaHQpIHtcbiAgICByZXR1cm4gbmV3IEdlby5Cb3VuZGluZ0JveCh1cHBlckxlZnQsIGxvd2VyUmlnaHQpO1xuICB9XG5cbiAgLyoqXG5cdCAqIENyZWF0ZXMgYSBuZXcge0BsaW5rIENpcmNsZX0gaW5zdGFuY2UuXG5cdCAqIEBwYXJhbSB7Kn0gY2VudGVyIFRoZSBjaXJjbGUncyBjZW50ZXIgY29vcmRpbmF0ZS5cblx0ICogQHBhcmFtIHtzdHJpbmd9IHJhZGl1cyBUaGUgY2lyY2xlJ3MgcmFkaXVzLlxuXHQgKiBAcmV0dXJuIHshQ2lyY2xlfVxuXHQgKiBAc3RhdGljXG5cdCAqL1xuICBzdGF0aWMgY2lyY2xlKGNlbnRlciwgcmFkaXVzKSB7XG4gICAgcmV0dXJuIG5ldyBHZW8uQ2lyY2xlKGNlbnRlciwgcmFkaXVzKTtcbiAgfVxuXG4gIC8qKlxuXHQgKiBDcmVhdGVzIGEgbmV3IHtAbGluayBMaW5lfSBpbnN0YW5jZS5cblx0ICogQHBhcmFtIHsuLi4qfSBwb2ludHMgVGhpcyBsaW5lJ3MgcG9pbnRzLlxuXHQgKiBAcmV0dXJuIHshTGluZX1cblx0ICogQHN0YXRpY1xuXHQgKi9cbiAgc3RhdGljIGxpbmUoLi4ucG9pbnRzKSB7XG4gICAgcmV0dXJuIG5ldyBHZW8uTGluZSguLi5wb2ludHMpO1xuICB9XG5cbiAgLyoqXG5cdCAqIENyZWF0ZXMgYSBuZXcge0BsaW5rIFBvaW50fSBpbnN0YW5jZS5cblx0ICogQHBhcmFtIHtudW1iZXJ9IGxhdCBUaGUgbGF0aXR1ZGUgY29vcmRpbmF0ZVxuXHQgKiBAcGFyYW0ge251bWJlcn0gbG9uIFRoZSBsb25naXR1ZGUgY29vcmRpbmF0ZVxuXHQgKiBAcmV0dXJuIHshUG9pbnR9XG5cdCAqIEBzdGF0aWNcblx0ICovXG4gIHN0YXRpYyBwb2ludChsYXQsIGxvbikge1xuICAgIHJldHVybiBuZXcgR2VvLlBvaW50KGxhdCwgbG9uKTtcbiAgfVxuXG4gIC8qKlxuXHQgKiBDcmVhdGVzIGEgbmV3IHtAbGluayBQb2x5Z29ufSBpbnN0YW5jZS5cblx0ICogQHBhcmFtIHsuLi4qfSBwb2ludHMgVGhpcyBwb2x5Z29uJ3MgcG9pbnRzLlxuXHQgKiBAcmV0dXJuIHshUG9seWdvbn1cblx0ICogQHN0YXRpY1xuXHQgKi9cbiAgc3RhdGljIHBvbHlnb24oLi4ucG9pbnRzKSB7XG4gICAgcmV0dXJuIG5ldyBHZW8uUG9seWdvbiguLi5wb2ludHMpO1xuICB9XG59XG5cbi8qKlxuICogQ2xhc3MgdGhhdCByZXByZXNlbnRzIGEgcG9pbnQgY29vcmRpbmF0ZS5cbiAqIEBleHRlbmRzIHtFbWJvZGllZH1cbiAqL1xuY2xhc3MgUG9pbnQgZXh0ZW5kcyBFbWJvZGllZCB7XG4gIC8qKlxuXHQgKiBDb25zdHJ1Y3RzIGEge0BsaW5rIFBvaW50fSBpbnN0YW5jZS5cblx0ICogQHBhcmFtIHtudW1iZXJ9IGxhdCBUaGUgbGF0aXR1ZGUgY29vcmRpbmF0ZVxuXHQgKiBAcGFyYW0ge251bWJlcn0gbG9uIFRoZSBsb25naXR1ZGUgY29vcmRpbmF0ZVxuXHQgKiBAY29uc3RydWN0b3Jcblx0ICovXG4gIGNvbnN0cnVjdG9yKGxhdCwgbG9uKSB7XG4gICAgc3VwZXIoKTtcbiAgICB0aGlzLmJvZHlfID0gW2xhdCwgbG9uXTtcbiAgfVxufVxuR2VvLlBvaW50ID0gUG9pbnQ7XG5cbi8qKlxuICogQ2xhc3MgdGhhdCByZXByZXNlbnRzIGEgbGluZS5cbiAqIEBleHRlbmRzIHtFbWJvZGllZH1cbiAqL1xuY2xhc3MgTGluZSBleHRlbmRzIEVtYm9kaWVkIHtcbiAgLyoqXG5cdCAqIENvbnN0cnVjdHMgYSB7QGxpbmsgTGluZX0gaW5zdGFuY2UuXG5cdCAqIEBwYXJhbSB7Li4uKn0gcG9pbnRzIFRoaXMgbGluZSdzIHBvaW50cy5cblx0ICogQGNvbnN0cnVjdG9yXG5cdCAqL1xuICBjb25zdHJ1Y3RvciguLi5wb2ludHMpIHtcbiAgICBzdXBlcigpO1xuICAgIHRoaXMuYm9keV8gPSB7XG4gICAgICB0eXBlOiAnbGluZXN0cmluZycsXG4gICAgICBjb29yZGluYXRlczogcG9pbnRzLm1hcChwb2ludCA9PiBFbWJvZGllZC50b0JvZHkocG9pbnQpKSxcbiAgICB9O1xuICB9XG59XG5HZW8uTGluZSA9IExpbmU7XG5cbi8qKlxuICogQ2xhc3MgdGhhdCByZXByZXNlbnRzIGEgYm91bmRpbmcgYm94LlxuICogQGV4dGVuZHMge0VtYm9kaWVkfVxuICovXG5jbGFzcyBCb3VuZGluZ0JveCBleHRlbmRzIEVtYm9kaWVkIHtcbiAgLyoqXG5cdCAqIENvbnN0cnVjdHMgYSB7QGxpbmsgQm91bmRpbmdCb3h9IGluc3RhbmNlLlxuXHQgKiBAcGFyYW0geyp9IHVwcGVyTGVmdCBUaGUgdXBwZXIgbGVmdCBwb2ludC5cblx0ICogQHBhcmFtIHsqfSBsb3dlclJpZ2h0IFRoZSBsb3dlciByaWdodCBwb2ludC5cblx0ICogQGNvbnN0cnVjdG9yXG5cdCAqL1xuICBjb25zdHJ1Y3Rvcih1cHBlckxlZnQsIGxvd2VyUmlnaHQpIHtcbiAgICBzdXBlcigpO1xuICAgIHRoaXMuYm9keV8gPSB7XG4gICAgICB0eXBlOiAnZW52ZWxvcGUnLFxuICAgICAgY29vcmRpbmF0ZXM6IFtFbWJvZGllZC50b0JvZHkodXBwZXJMZWZ0KSwgRW1ib2RpZWQudG9Cb2R5KGxvd2VyUmlnaHQpXSxcbiAgICB9O1xuICB9XG5cbiAgLyoqXG5cdCAqIEdldHMgdGhpcyBib3VuZGluZyBib3gncyBwb2ludHMuXG5cdCAqIEByZXR1cm4geyFBcnJheX1cblx0ICovXG4gIGdldFBvaW50cygpIHtcbiAgICByZXR1cm4gdGhpcy5ib2R5Xy5jb29yZGluYXRlcztcbiAgfVxufVxuR2VvLkJvdW5kaW5nQm94ID0gQm91bmRpbmdCb3g7XG5cbi8qKlxuICogQ2xhc3MgdGhhdCByZXByZXNlbnRzIGEgY2lyY2xlLlxuICogQGV4dGVuZHMge0VtYm9kaWVkfVxuICovXG5jbGFzcyBDaXJjbGUgZXh0ZW5kcyBFbWJvZGllZCB7XG4gIC8qKlxuXHQgKiBDb25zdHJ1Y3RzIGEge0BsaW5rIENpcmNsZX0gaW5zdGFuY2UuXG5cdCAqIEBwYXJhbSB7Kn0gY2VudGVyIFRoZSBjaXJjbGUncyBjZW50ZXIgY29vcmRpbmF0ZS5cblx0ICogQHBhcmFtIHtzdHJpbmd9IHJhZGl1cyBUaGUgY2lyY2xlJ3MgcmFkaXVzLlxuXHQgKiBAY29uc3RydWN0b3Jcblx0ICovXG4gIGNvbnN0cnVjdG9yKGNlbnRlciwgcmFkaXVzKSB7XG4gICAgc3VwZXIoKTtcbiAgICB0aGlzLmJvZHlfID0ge1xuICAgICAgdHlwZTogJ2NpcmNsZScsXG4gICAgICBjb29yZGluYXRlczogRW1ib2RpZWQudG9Cb2R5KGNlbnRlciksXG4gICAgICByYWRpdXM6IHJhZGl1cyxcbiAgICB9O1xuICB9XG5cbiAgLyoqXG5cdCAqIEdldHMgdGhpcyBjaXJjbGUncyBjZW50ZXIgY29vcmRpbmF0ZS5cblx0ICogQHJldHVybiB7Kn1cblx0ICovXG4gIGdldENlbnRlcigpIHtcbiAgICByZXR1cm4gdGhpcy5ib2R5Xy5jb29yZGluYXRlcztcbiAgfVxuXG4gIC8qKlxuXHQgKiBHZXRzIHRoaXMgY2lyY2xlJ3MgcmFkaXVzLlxuXHQgKiBAcmV0dXJuIHtzdHJpbmd9XG5cdCAqL1xuICBnZXRSYWRpdXMoKSB7XG4gICAgcmV0dXJuIHRoaXMuYm9keV8ucmFkaXVzO1xuICB9XG59XG5HZW8uQ2lyY2xlID0gQ2lyY2xlO1xuXG4vKipcbiAqIENsYXNzIHRoYXQgcmVwcmVzZW50cyBhIHBvbHlnb24uXG4gKiBAZXh0ZW5kcyB7RW1ib2RpZWR9XG4gKi9cbmNsYXNzIFBvbHlnb24gZXh0ZW5kcyBFbWJvZGllZCB7XG4gIC8qKlxuXHQgKiBDb25zdHJ1Y3RzIGEge0BsaW5rIFBvbHlnb259IGluc3RhbmNlLlxuXHQgKiBAcGFyYW0gey4uLip9IHBvaW50cyBUaGlzIHBvbHlnb24ncyBwb2ludHMuXG5cdCAqIEBjb25zdHJ1Y3RvclxuXHQgKi9cbiAgY29uc3RydWN0b3IoLi4ucG9pbnRzKSB7XG4gICAgc3VwZXIoKTtcbiAgICB0aGlzLmJvZHlfID0ge1xuICAgICAgdHlwZTogJ3BvbHlnb24nLFxuICAgICAgY29vcmRpbmF0ZXM6IFtdLFxuICAgIH07XG4gICAgdGhpcy5hZGRDb29yZGluYXRlc18oLi4ucG9pbnRzKTtcbiAgfVxuXG4gIC8qKlxuXHQgKiBBZGRzIHRoZSBnaXZlbiBwb2ludHMgYXMgY29vcmRpbmF0ZXMgZm9yIHRoaXMgcG9seWdvbi5cblx0ICogQHBhcmFtIHsuLi4qfSBwb2ludHNcblx0ICogQHByb3RlY3RlZFxuXHQgKi9cbiAgYWRkQ29vcmRpbmF0ZXNfKC4uLnBvaW50cykge1xuICAgIHRoaXMuYm9keV8uY29vcmRpbmF0ZXMucHVzaChwb2ludHMubWFwKHBvaW50ID0+IEVtYm9kaWVkLnRvQm9keShwb2ludCkpKTtcbiAgfVxuXG4gIC8qKlxuXHQgKiBBZGRzIHRoZSBnaXZlbiBwb2ludHMgYXMgYSBob2xlIGluc2lkZSB0aGlzIHBvbHlnb24uXG5cdCAqIEBwYXJhbSB7Li4uKn0gcG9pbnRzXG5cdCAqIEByZXR1cm4ge1BvbHlnb259IFJldHVybnMgdGhlIHtAbGluayBQb2x5Z29ufSBvYmplY3QgaXRzZWxmLCBzbyBjYWxscyBjYW5cblx0ICogICBiZSBjaGFpbmVkLlxuXHQgKiBAY2hhaW5hYmxlXG5cdCAqL1xuICBob2xlKC4uLnBvaW50cykge1xuICAgIHRoaXMuYWRkQ29vcmRpbmF0ZXNfKC4uLnBvaW50cyk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbn1cbkdlby5Qb2x5Z29uID0gUG9seWdvbjtcblxuZXhwb3J0IGRlZmF1bHQgR2VvO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL2FwaS1xdWVyeS9HZW8uanMiLCIndXNlIHN0cmljdCc7XG5cbmltcG9ydCB7Y29yZX0gZnJvbSAnbWV0YWwnO1xuaW1wb3J0IHtNdWx0aU1hcH0gZnJvbSAnbWV0YWwtc3RydWN0cyc7XG5cbi8qKlxuICogUmVwcmVzZW50cyBhIGNsaWVudCBtZXNzYWdlIChlLmcuIGEgcmVxdWVzdCBvciBhIHJlc3BvbnNlKS5cbiAqL1xuY2xhc3MgQ2xpZW50TWVzc2FnZSB7XG4gIC8qKlxuXHQgKiBDb25zdHJ1Y3RzIGFuIHtAbGluayBDbGllbnRNZXNzYWdlfSBpbnN0YW5jZS5cblx0ICogQGNvbnN0cnVjdG9yXG5cdCAqL1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICB0aGlzLmhlYWRlcnNfID0gbmV3IE11bHRpTWFwKCk7XG4gIH1cblxuICAvKipcblx0ICogRmx1ZW50IGdldHRlciBhbmQgc2V0dGVyIGZvciByZXF1ZXN0IGJvZHkuXG5cdCAqIEBwYXJhbSB7Kj19IG9wdF9ib2R5IFJlcXVlc3QgYm9keSB0byBiZSBzZXQuIElmIG5vbmUgaXMgZ2l2ZW4sXG5cdCAqICAgdGhlIGN1cnJlbnQgdmFsdWUgb2YgdGhlIGJvZHkgd2lsbCBiZSByZXR1cm5lZC5cblx0ICogQHJldHVybiB7Kn0gUmV0dXJucyByZXF1ZXN0IGJvZHkgaWYgbm8gYm9keSB2YWx1ZSB3YXMgZ2l2ZW4uIE90aGVyd2lzZVxuXHQgKiAgIHJldHVybnMgdGhlIHtAbGluayBDbGllbnRNZXNzYWdlfSBvYmplY3QgaXRzZWxmLCBzbyBjYWxscyBjYW4gYmUgY2hhaW5lZC5cblx0ICogQGNoYWluYWJsZSBDaGFpbmFibGUgd2hlbiB1c2VkIGFzIHNldHRlci5cblx0ICovXG4gIGJvZHkob3B0X2JvZHkpIHtcbiAgICBpZiAoY29yZS5pc0RlZihvcHRfYm9keSkpIHtcbiAgICAgIHRoaXMuYm9keV8gPSBvcHRfYm9keTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5ib2R5XztcbiAgfVxuXG4gIC8qKlxuXHQgKiBBZGRzIGEgaGVhZGVyLiBJZiBhIGhlYWRlciB3aXRoIHRoZSBzYW1lIG5hbWUgYWxyZWFkeSBleGlzdHMsIGl0IHdpbGwgbm90XG5cdCAqIGJlIG92ZXJ3cml0dGVuLCBidXQgdGhlIG5ldyB2YWx1ZSB3aWxsIGJlIHN0b3JlZCBhcyB3ZWxsLiBUaGUgb3JkZXIgaXNcblx0ICogcHJlc2VydmVkLlxuXHQgKiBAcGFyYW0ge3N0cmluZ30gbmFtZVxuXHQgKiBAcGFyYW0ge3N0cmluZ30gdmFsdWVcblx0ICogQHJldHVybiB7IUNsaWVudE1lc3NhZ2V9IFJldHVybnMgdGhlIHtAbGluayBDbGllbnRNZXNzYWdlfVxuXHQgKiAgIG9iamVjdCBpdHNlbGYsIHNvIGNhbGxzIGNhbiBiZSBjaGFpbmVkLlxuXHQgKiBAY2hhaW5hYmxlXG5cdCAqL1xuICBoZWFkZXIobmFtZSwgdmFsdWUpIHtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCAhPT0gMikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGFyZ3VtZW50cycpO1xuICAgIH1cbiAgICB0aGlzLmhlYWRlcnNfLnNldChuYW1lLCB2YWx1ZSk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICAvKipcblx0ICogRmx1ZW50IGdldHRlciBhbmQgc2V0dGVyIGZvciByZXF1ZXN0IGhlYWRlcnMuXG5cdCAqIEBwYXJhbSB7TXVsdGlNYXB8T2JqZWN0PX0gb3B0X2hlYWRlcnMgUmVxdWVzdCBoZWFkZXJzIGxpc3QgdG9cblx0ICogICBiZSBzZXQuIElmIG5vbmUgaXMgZ2l2ZW4gdGhlIGN1cnJlbnQgdmFsdWUgb2YgdGhlIGhlYWRlcnMgd2lsbFxuXHQgKiAgIGJlIHJldHVybmVkLlxuXHQgKiBAcmV0dXJuIHshTXVsdGlNYXB8Q2xpZW50TWVzc2FnZX0gUmV0dXJucyBtYXAgb2YgcmVxdWVzdCBoZWFkZXJzXG5cdCAqICAgaWYgbm8gbmV3IHZhbHVlIHdhcyBnaXZlbi4gT3RoZXJ3aXNlIHJldHVybnMgdGhlIHtAbGluayBDbGllbnRNZXNzYWdlfVxuXHQgKiAgIG9iamVjdCBpdHNlbGYsIHNvIGNhbGxzIGNhbiBiZSBjaGFpbmVkLlxuXHQgKiBAY2hhaW5hYmxlIENoYWluYWJsZSB3aGVuIHVzZWQgYXMgc2V0dGVyLlxuXHQgKi9cbiAgaGVhZGVycyhvcHRfaGVhZGVycykge1xuICAgIGlmIChjb3JlLmlzRGVmKG9wdF9oZWFkZXJzKSkge1xuICAgICAgaWYgKG9wdF9oZWFkZXJzIGluc3RhbmNlb2YgTXVsdGlNYXApIHtcbiAgICAgICAgdGhpcy5oZWFkZXJzXyA9IG9wdF9oZWFkZXJzO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5oZWFkZXJzXy52YWx1ZXMgPSBvcHRfaGVhZGVycztcbiAgICAgIH1cbiAgICAgIHJldHVybiBvcHRfaGVhZGVycztcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuaGVhZGVyc187XG4gIH1cblxuICAvKipcblx0ICogUmVtb3ZlcyB0aGUgYm9keS5cblx0ICovXG4gIHJlbW92ZUJvZHkoKSB7XG4gICAgdGhpcy5ib2R5XyA9IHVuZGVmaW5lZDtcbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBDbGllbnRNZXNzYWdlO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL2FwaS9DbGllbnRNZXNzYWdlLmpzIiwiJ3VzZSBzdHJpY3QnO1xuXG4vLyBUaGlzIGZpbGUgZXhpc3RzIGp1c3QgZm9yIGJhY2t3YXJkcyBjb21wYXRpYmlsaXR5LCBtYWtpbmcgc3VyZSB0aGF0IG9sZFxuLy8gZGVmYXVsdCBpbXBvcnRzIGZvciB0aGlzIGZpbGUgc3RpbGwgd29yay4gSXQncyBiZXN0IHRvIHVzZSB0aGUgbmFtZWQgZXhwb3J0c1xuLy8gZm9yIGVhY2ggZnVuY3Rpb24gaW5zdGVhZCB0aG91Z2gsIHNpbmNlIHRoYXQgYWxsb3dzIGJ1bmRsZXJzIGxpa2UgUm9sbHVwIHRvXG4vLyByZWR1Y2UgdGhlIGJ1bmRsZSBzaXplIGJ5IHJlbW92aW5nIHVudXNlZCBjb2RlLlxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5jb3JlID0gdW5kZWZpbmVkO1xuXG52YXIgX2NvcmVOYW1lZCA9IHJlcXVpcmUoJy4vY29yZU5hbWVkJyk7XG5cbk9iamVjdC5rZXlzKF9jb3JlTmFtZWQpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICBpZiAoa2V5ID09PSBcImRlZmF1bHRcIiB8fCBrZXkgPT09IFwiX19lc01vZHVsZVwiKSByZXR1cm47XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBrZXksIHtcbiAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgcmV0dXJuIF9jb3JlTmFtZWRba2V5XTtcbiAgICB9XG4gIH0pO1xufSk7XG5cbnZhciBjb3JlID0gX2ludGVyb3BSZXF1aXJlV2lsZGNhcmQoX2NvcmVOYW1lZCk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkKG9iaikgeyBpZiAob2JqICYmIG9iai5fX2VzTW9kdWxlKSB7IHJldHVybiBvYmo7IH0gZWxzZSB7IHZhciBuZXdPYmogPSB7fTsgaWYgKG9iaiAhPSBudWxsKSB7IGZvciAodmFyIGtleSBpbiBvYmopIHsgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIGtleSkpIG5ld09ialtrZXldID0gb2JqW2tleV07IH0gfSBuZXdPYmouZGVmYXVsdCA9IG9iajsgcmV0dXJuIG5ld09iajsgfSB9XG5cbmV4cG9ydHMuZGVmYXVsdCA9IGNvcmU7XG5leHBvcnRzLmNvcmUgPSBjb3JlO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9tZXRhbC9saWIvY29yZS5qc1xuLy8gbW9kdWxlIGlkID0gMTdcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiJ3VzZSBzdHJpY3QnO1xuXG5pbXBvcnQgZ2xvYmFscyBmcm9tICcuLi9nbG9iYWxzL2dsb2JhbHMnO1xuaW1wb3J0IHtjb3JlfSBmcm9tICdtZXRhbCc7XG5pbXBvcnQgQXV0aCBmcm9tICcuL2F1dGgvQXV0aCc7XG5pbXBvcnQgQXV0aEFwaUhlbHBlciBmcm9tICcuL2F1dGgvQXV0aEFwaUhlbHBlcic7XG5pbXBvcnQgRGF0YUFwaUhlbHBlciBmcm9tICcuL2RhdGEvRGF0YUFwaUhlbHBlcic7XG5pbXBvcnQgRW1haWxBcGlIZWxwZXIgZnJvbSAnLi9lbWFpbC9FbWFpbEFwaUhlbHBlcic7XG5pbXBvcnQgQmFzZTY0IGZyb20gJy4uL2NyeXB0L0Jhc2U2NCc7XG5pbXBvcnQgRW1ib2RpZWQgZnJvbSAnLi4vYXBpLXF1ZXJ5L0VtYm9kaWVkJztcbmltcG9ydCBRdWVyeSBmcm9tICcuLi9hcGktcXVlcnkvUXVlcnknO1xuaW1wb3J0IEZpbHRlciBmcm9tICcuLi9hcGktcXVlcnkvRmlsdGVyJztcbmltcG9ydCBUcmFuc3BvcnRGYWN0b3J5IGZyb20gJy4vVHJhbnNwb3J0RmFjdG9yeSc7XG5pbXBvcnQgQ2xpZW50UmVxdWVzdCBmcm9tICcuL0NsaWVudFJlcXVlc3QnO1xuaW1wb3J0IHtNdWx0aU1hcH0gZnJvbSAnbWV0YWwtc3RydWN0cyc7XG5pbXBvcnQgVXJpIGZyb20gJ21ldGFsLXVyaSc7XG5pbXBvcnQge2Fzc2VydFVyaVdpdGhOb1BhdGh9IGZyb20gJy4vYXNzZXJ0aW9ucyc7XG5cbmxldCBpbztcbmxldCBGb3JtRGF0YUltcGw7XG5cbi8vIE9wdGltaXN0aWMgaW5pdGlhbGl6YXRpb24gb2YgYGlvYCByZWZlcmVuY2UgZnJvbSBnbG9iYWwgYGdsb2JhbHMud2luZG93LmlvYC5cbmlmICh0eXBlb2YgZ2xvYmFscy53aW5kb3cgIT09ICd1bmRlZmluZWQnKSB7XG4gIGlvID0gZ2xvYmFscy53aW5kb3cuaW87XG59XG5cbi8vIE9wdGltaXN0aWMgaW5pdGlhbGl6YXRpb24gb2YgYEZvcm1EYXRhYCByZWZlcmVuY2UgZnJvbSBnbG9iYWxcbi8vIGBnbG9iYWxzLndpbmRvdy5Gb3JtRGF0YWAuXG5pZiAodHlwZW9mIGdsb2JhbHMud2luZG93ICE9PSAndW5kZWZpbmVkJykge1xuICBGb3JtRGF0YUltcGwgPSBnbG9iYWxzLndpbmRvdy5Gb3JtRGF0YTtcbn1cblxuLyoqXG4gKiBUaGUgbWFpbiBjbGFzcyBmb3IgbWFraW5nIGFwaSByZXF1ZXN0cy4gU2VuZGluZyByZXF1ZXN0cyByZXR1cm5zIGEgcHJvbWlzZVxuICogdGhhdCBpcyByZXNvbHZlZCB3aGVuIHRoZSByZXNwb25zZSBhcnJpdmVzLiBVc2FnZSBleGFtcGxlOlxuICogYGBgamF2YXNjcmlwdFxuICogV2VEZXBsb3lcbiAqICAgLnVybCgnL2RhdGEvdGFza3MnKVxuICogICAucG9zdCh7ZGVzYzogJ0J1eSBtaWxrJ30pXG4gKiAgIC50aGVuKGZ1bmN0aW9uKHJlc3BvbnNlKSB7XG4gKiAgICAgLy8gSGFuZGxlIHJlc3BvbnNlIGhlcmUuXG4gKiAgICAgY29uc29sZS5sb2cocmVzcG9uc2UuYm9keSgpKVxuICogICB9KTtcbiAqIGBgYFxuICovXG5jbGFzcyBXZURlcGxveSB7XG4gIC8qKlxuXHQgKiBXZURlcGxveSBjb25zdHJ1Y3RvciBmdW5jdGlvbi5cblx0ICogQHBhcmFtIHtzdHJpbmd9IHVybCBUaGUgYmFzZSB1cmwuXG5cdCAqIEBwYXJhbSB7Li4uc3RyaW5nfSBwYXRocyBBbnkgYW1vdW50IG9mIHBhdGhzIHRvIGJlIGFwcGVuZGVkIHRvIHRoZSBiYXNlXG5cdCAqIHVybC5cblx0ICogQGNvbnN0cnVjdG9yXG5cdCAqL1xuICBjb25zdHJ1Y3Rvcih1cmwsIC4uLnBhdGhzKSB7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDApIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBhcmd1bWVudHMsIHRyeSBgbmV3IFdlRGVwbG95KGJhc2VVcmwsIHVybClgJyk7XG4gICAgfVxuXG4gICAgdGhpcy5hdXRoXyA9IG51bGw7XG4gICAgdGhpcy5kYXRhXyA9IG51bGw7XG4gICAgdGhpcy5ib2R5XyA9IG51bGw7XG4gICAgdGhpcy51cmxfID0gVXJpLmpvaW5QYXRocyh1cmwgfHwgJycsIC4uLnBhdGhzKTtcbiAgICB0aGlzLmhlYWRlcnNfID0gbmV3IE11bHRpTWFwKCk7XG4gICAgdGhpcy5wYXJhbXNfID0gbmV3IE11bHRpTWFwKCk7XG4gICAgdGhpcy53aXRoQ3JlZGVudGlhbHNfID0gdHJ1ZTtcblxuICAgIHRoaXMuaGVhZGVyKCdDb250ZW50LVR5cGUnLCAnYXBwbGljYXRpb24vanNvbicpO1xuICAgIHRoaXMuaGVhZGVyKCdYLVJlcXVlc3RlZC1XaXRoJywgJ1hNTEh0dHBSZXF1ZXN0Jyk7XG4gIH1cblxuICAvKipcblx0ICogU3RhdGljIGZhY3RvcnkgZm9yIGNyZWF0aW5nIFdlRGVwbG95IGRhdGEgZm9yIHRoZSBnaXZlbiB1cmwuXG5cdCAqIEBwYXJhbSB7c3RyaW5nPX0gb3B0X2RhdGFVcmwgVGhlIHVybCB0aGF0IHBvaW50cyB0byB0aGUgZGF0YSBzZXJ2aWNlcy5cblx0ICogQHJldHVybiB7ZGF0YX0gV2VEZXBsb3kgZGF0YSBpbnN0YW5jZS5cblx0ICovXG4gIHN0YXRpYyBkYXRhKG9wdF9kYXRhVXJsKSB7XG4gICAgYXNzZXJ0VXJpV2l0aE5vUGF0aChvcHRfZGF0YVVybCwgJ1RoZSBkYXRhIHVybCBzaG91bGQgbm90IGhhdmUgYSBwYXRoJyk7XG5cbiAgICBpZiAoY29yZS5pc1N0cmluZyhvcHRfZGF0YVVybCkpIHtcbiAgICAgIFdlRGVwbG95LmRhdGFVcmxfID0gb3B0X2RhdGFVcmw7XG4gICAgfVxuICAgIGlmICghV2VEZXBsb3kuZGF0YV8pIHtcbiAgICAgIFdlRGVwbG95LmRhdGFfID0gbmV3IERhdGFBcGlIZWxwZXIoV2VEZXBsb3kpO1xuICAgIH1cbiAgICBXZURlcGxveS5kYXRhXy5hdXRoKFdlRGVwbG95LmF1dGgoKS5jdXJyZW50VXNlcik7XG4gICAgcmV0dXJuIFdlRGVwbG95LmRhdGFfO1xuICB9XG5cbiAgLyoqXG5cdCAqIFN0YXRpYyBmYWN0b3J5IGZvciBjcmVhdGluZyBXZURlcGxveSBlbWFpbCBmb3IgdGhlIGdpdmVuIHVybC5cblx0ICogQHBhcmFtIHtzdHJpbmc9fSBvcHRfZW1haWxVcmwgVGhlIHVybCB0aGF0IHBvaW50cyB0byB0aGUgZW1haWwgc2VydmljZXMuXG5cdCAqIEByZXR1cm4ge2RhdGF9IFdlRGVwbG95IGVtYWlsIGluc3RhbmNlLlxuXHQgKi9cbiAgc3RhdGljIGVtYWlsKG9wdF9lbWFpbFVybCkge1xuICAgIGFzc2VydFVyaVdpdGhOb1BhdGgob3B0X2VtYWlsVXJsLCAnVGhlIGVtYWlsIHVybCBzaG91bGQgbm90IGhhdmUgYSBwYXRoJyk7XG5cbiAgICBpZiAoY29yZS5pc1N0cmluZyhvcHRfZW1haWxVcmwpKSB7XG4gICAgICBXZURlcGxveS5lbWFpbFVybF8gPSBvcHRfZW1haWxVcmw7XG4gICAgfVxuICAgIGlmICghV2VEZXBsb3kuZW1haWxfKSB7XG4gICAgICBXZURlcGxveS5lbWFpbF8gPSBuZXcgRW1haWxBcGlIZWxwZXIoV2VEZXBsb3kpO1xuICAgIH1cbiAgICBXZURlcGxveS5lbWFpbF8uYXV0aChXZURlcGxveS5hdXRoKCkuY3VycmVudFVzZXIpO1xuICAgIHJldHVybiBXZURlcGxveS5lbWFpbF87XG4gIH1cblxuICAvKipcblx0ICogQWRkcyBhdXRob3JpemF0aW9uIGluZm9ybWF0aW9uIHRvIHRoaXMgcmVxdWVzdC5cblx0ICogQHBhcmFtIHshQXV0aHxzdHJpbmd9IGF1dGhPclRva2VuT3JFbWFpbCBFaXRoZXIgYW4ge0BsaW5rIEF1dGh9IGluc3RhbmNlLFxuXHQgKiBhbiBhdXRob3JpemF0aW9uIHRva2VuLCBvciB0aGUgZW1haWwuXG5cdCAqIEBwYXJhbSB7c3RyaW5nPX0gb3B0X3Bhc3N3b3JkIElmIGEgZW1haWwgaXMgZ2l2ZW4gYXMgdGhlIGZpcnN0IHBhcmFtLFxuXHQgKiB0aGlzIHNob3VsZCBiZSB0aGUgcGFzc3dvcmQuXG5cdCAqIEByZXR1cm4ge1dlRGVwbG95fSBSZXR1cm5zIHRoZSB7QGxpbmsgV2VEZXBsb3l9IG9iamVjdCBpdHNlbGYsIHNvIGNhbGxzIGNhblxuXHQgKiAgIGJlIGNoYWluZWQuXG5cdCAqIEBjaGFpbmFibGVcblx0ICovXG4gIGF1dGgoYXV0aE9yVG9rZW5PckVtYWlsLCBvcHRfcGFzc3dvcmQpIHtcbiAgICB0aGlzLmF1dGhfID0gQXV0aC5jcmVhdGUoYXV0aE9yVG9rZW5PckVtYWlsLCBvcHRfcGFzc3dvcmQpO1xuICAgIHRoaXMuYXV0aF8uc2V0V2VkZXBsb3lDbGllbnQoV2VEZXBsb3kpO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLyoqXG5cdCAqIFN0YXRpYyBmYWN0b3J5IGZvciBjcmVhdGluZyBXZURlcGxveSBhdXRoIGZvciB0aGUgZ2l2ZW4gdXJsLlxuXHQgKiBAcGFyYW0ge3N0cmluZz19IG9wdF9hdXRoVXJsIFRoZSB1cmwgdGhhdCBwb2ludHMgdG8gdGhlIGF1dGggc2VydmljZS5cblx0ICogQHJldHVybiB7IUF1dGh9IFJldHVybnMgYW4ge0BsaW5rIEF1dGh9IGluc3RhbmNlLlxuXHQgKi9cbiAgc3RhdGljIGF1dGgob3B0X2F1dGhVcmwpIHtcbiAgICBpZiAoY29yZS5pc1N0cmluZyhvcHRfYXV0aFVybCkpIHtcbiAgICAgIFdlRGVwbG95LmF1dGhVcmxfID0gb3B0X2F1dGhVcmw7XG4gICAgfVxuICAgIGlmICghV2VEZXBsb3kuYXV0aF8pIHtcbiAgICAgIFdlRGVwbG95LmF1dGhfID0gbmV3IEF1dGhBcGlIZWxwZXIoV2VEZXBsb3kpO1xuICAgIH1cbiAgICByZXR1cm4gV2VEZXBsb3kuYXV0aF87XG4gIH1cblxuICAvKipcblx0ICogU2V0cyB0aGUgYm9keSB0aGF0IHdpbGwgYmUgc2VudCB3aXRoIHRoaXMgcmVxdWVzdC5cblx0ICogQHBhcmFtIHsqfSBib2R5XG5cdCAqIEByZXR1cm4ge1dlRGVwbG95fSBSZXR1cm5zIHRoZSB7QGxpbmsgV2VEZXBsb3l9IG9iamVjdCBpdHNlbGYsIHNvIGNhbGxzIGNhblxuXHQgKiAgIGJlIGNoYWluZWQuXG5cdCAqIEBjaGFpbmFibGVcblx0ICovXG4gIGJvZHkoYm9keSkge1xuICAgIHRoaXMuYm9keV8gPSBib2R5O1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLyoqXG5cdCAqIENvbnZlcnRzIHRoZSBnaXZlbiBib2R5IG9iamVjdCB0byBxdWVyeSBwYXJhbXMuXG5cdCAqIEBwYXJhbSB7IUNsaWVudFJlcXVlc3R9IGNsaWVudFJlcXVlc3QgQ2xpZW50IHJlcXVlc3QuXG5cdCAqIEBwYXJhbSB7Kn0gYm9keVxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqL1xuICBjb252ZXJ0Qm9keVRvUGFyYW1zXyhjbGllbnRSZXF1ZXN0LCBib2R5KSB7XG4gICAgaWYgKGNvcmUuaXNTdHJpbmcoYm9keSkpIHtcbiAgICAgIGJvZHkgPSB7XG4gICAgICAgIGJvZHk6IGJvZHksXG4gICAgICB9O1xuICAgIH0gZWxzZSBpZiAoYm9keSBpbnN0YW5jZW9mIEVtYm9kaWVkKSB7XG4gICAgICBib2R5ID0gYm9keS5ib2R5KCk7XG4gICAgfVxuICAgIE9iamVjdC5rZXlzKGJvZHkgfHwge30pLmZvckVhY2gobmFtZSA9PlxuICAgICAgY2xpZW50UmVxdWVzdC5wYXJhbShuYW1lLCBib2R5W25hbWVdKVxuICAgICk7XG4gIH1cblxuICAvKipcblx0ICogQ3JlYXRlcyBjbGllbnQgcmVxdWVzdCBhbmQgZW5jb2RlLlxuXHQgKiBAcGFyYW0ge3N0cmluZ30gbWV0aG9kXG5cdCAqIEBwYXJhbSB7Kn0gYm9keVxuXHQgKiBAcmV0dXJuIHshQ2xpZW50UmVxdWVzdH0gQ2xpZW50IHJlcXVlc3QuXG5cdCAqIEBwcm90ZWN0ZWRcblx0ICovXG4gIGNyZWF0ZUNsaWVudFJlcXVlc3RfKG1ldGhvZCwgYm9keSkge1xuICAgIGNvbnN0IGNsaWVudFJlcXVlc3QgPSBuZXcgQ2xpZW50UmVxdWVzdCgpO1xuXG4gICAgY2xpZW50UmVxdWVzdC5ib2R5KGJvZHkgfHwgdGhpcy5ib2R5Xyk7XG5cbiAgICBpZiAoIWNvcmUuaXNEZWZBbmROb3ROdWxsKGNsaWVudFJlcXVlc3QuYm9keSgpKSkge1xuICAgICAgaWYgKHRoaXMuZm9ybURhdGFfKSB7XG4gICAgICAgIGNsaWVudFJlcXVlc3QuYm9keSh0aGlzLmZvcm1EYXRhXyk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgY2xpZW50UmVxdWVzdC5tZXRob2QobWV0aG9kKTtcbiAgICBjbGllbnRSZXF1ZXN0LmhlYWRlcnModGhpcy5oZWFkZXJzKCkpO1xuICAgIGNsaWVudFJlcXVlc3QucGFyYW1zKHRoaXMucGFyYW1zKCkpO1xuICAgIGNsaWVudFJlcXVlc3QudXJsKHRoaXMudXJsKCkpO1xuICAgIGNsaWVudFJlcXVlc3Qud2l0aENyZWRlbnRpYWxzKHRoaXMud2l0aENyZWRlbnRpYWxzXyk7XG5cbiAgICB0aGlzLmVuY29kZShjbGllbnRSZXF1ZXN0KTtcblxuICAgIHJldHVybiBjbGllbnRSZXF1ZXN0O1xuICB9XG5cbiAgLyoqXG5cdCAqIERlY29kZXMgY2xpZW50UmVzcG9uc2UgYm9keSwgcGFyc2luZyB0aGUgYm9keSBmb3IgZXhhbXBsZS5cblx0ICogQHBhcmFtIHshQ2xpZW50UmVzcG9uc2V9IGNsaWVudFJlc3BvbnNlIFRoZSByZXNwb25zZSBvYmplY3QgdG8gYmVcblx0ICogZGVjb2RlZC5cblx0ICogQHJldHVybiB7IUNsaWVudFJlc3BvbnNlfSBUaGUgZGVjb2RlZCByZXNwb25zZS5cblx0ICovXG4gIGRlY29kZShjbGllbnRSZXNwb25zZSkge1xuICAgIGlmIChXZURlcGxveS5pc0NvbnRlbnRUeXBlSnNvbihjbGllbnRSZXNwb25zZSkpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGNsaWVudFJlc3BvbnNlLmJvZHkoSlNPTi5wYXJzZShjbGllbnRSZXNwb25zZS5ib2R5KCkpKTtcbiAgICAgIH0gY2F0Y2ggKGVycikge31cbiAgICB9XG4gICAgcmV0dXJuIGNsaWVudFJlc3BvbnNlO1xuICB9XG5cbiAgLyoqXG5cdCAqIFNlbmRzIG1lc3NhZ2Ugd2l0aCB0aGUgREVMRVRFIGh0dHAgdmVyYi5cblx0ICogQHBhcmFtIHtzdHJpbmc9fSBvcHRfYm9keSBDb250ZW50IHRvIGJlIHNlbnQgYXMgdGhlIHJlcXVlc3QncyBib2R5LlxuXHQgKiBAcmV0dXJuIHshQ2FuY2VsbGFibGVQcm9taXNlfVxuXHQgKi9cbiAgZGVsZXRlKG9wdF9ib2R5KSB7XG4gICAgcmV0dXJuIHRoaXMuc2VuZEFzeW5jKCdERUxFVEUnLCBvcHRfYm9keSk7XG4gIH1cblxuICAvKipcblx0ICogRW5jb2RlcyB0aGUgZ2l2ZW4ge0BsaW5rIENsaWVudFJlcXVlc3R9LCBjb252ZXJ0aW5nIGl0cyBib2R5IHRvIGFuXG5cdCAqIGFwcHJvcHJpYXRlIGZvcm1hdCBmb3IgZXhhbXBsZS5cblx0ICogQHBhcmFtIHshQ2xpZW50UmVxdWVzdH0gY2xpZW50UmVxdWVzdCBUaGUgcmVxdWVzdCBvYmplY3QgdG8gZW5jb2RlLlxuXHQgKiBAcmV0dXJuIHshQ2xpZW50UmVxdWVzdH0gVGhlIGVuY29kZWQgcmVxdWVzdC5cblx0ICovXG4gIGVuY29kZShjbGllbnRSZXF1ZXN0KSB7XG4gICAgbGV0IGJvZHkgPSBjbGllbnRSZXF1ZXN0LmJvZHkoKTtcblxuICAgIGlmIChjb3JlLmlzRWxlbWVudChib2R5KSkge1xuICAgICAgYm9keSA9IG5ldyBGb3JtRGF0YUltcGwoYm9keSk7XG4gICAgICBjbGllbnRSZXF1ZXN0LmJvZHkoYm9keSk7XG4gICAgfVxuXG4gICAgYm9keSA9IHRoaXMubWF5YmVXcmFwV2l0aFF1ZXJ5Xyhib2R5KTtcbiAgICBpZiAoY2xpZW50UmVxdWVzdC5tZXRob2QoKSA9PT0gJ0dFVCcpIHtcbiAgICAgIHRoaXMuY29udmVydEJvZHlUb1BhcmFtc18oY2xpZW50UmVxdWVzdCwgYm9keSk7XG4gICAgICBjbGllbnRSZXF1ZXN0LnJlbW92ZUJvZHkoKTtcbiAgICAgIGJvZHkgPSBudWxsO1xuICAgIH1cblxuICAgIGlmICh0eXBlb2YgRm9ybURhdGFJbXBsICE9PSAndW5kZWZpbmVkJyAmJiBib2R5IGluc3RhbmNlb2YgRm9ybURhdGFJbXBsKSB7XG4gICAgICBjbGllbnRSZXF1ZXN0LmhlYWRlcnMoKS5yZW1vdmUoJ2NvbnRlbnQtdHlwZScpO1xuICAgIH0gZWxzZSBpZiAoYm9keSBpbnN0YW5jZW9mIEVtYm9kaWVkKSB7XG4gICAgICBjbGllbnRSZXF1ZXN0LmJvZHkoYm9keS50b1N0cmluZygpKTtcbiAgICB9IGVsc2UgaWYgKFdlRGVwbG95LmlzQ29udGVudFR5cGVKc29uKGNsaWVudFJlcXVlc3QpKSB7XG4gICAgICBsZXQgYm9keSA9IGNsaWVudFJlcXVlc3QuYm9keSgpO1xuICAgICAgaWYgKGNvcmUuaXNEZWZBbmROb3ROdWxsKGJvZHkpKSB7XG4gICAgICAgIGJvZHkgPSBKU09OLnN0cmluZ2lmeShib2R5KTtcbiAgICAgICAgY2xpZW50UmVxdWVzdC5ib2R5KGJvZHkpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHRoaXMuZW5jb2RlUGFyYW1zXyhjbGllbnRSZXF1ZXN0KTtcbiAgICB0aGlzLnJlc29sdmVBdXRoZW50aWNhdGlvbl8oY2xpZW50UmVxdWVzdCk7XG5cbiAgICByZXR1cm4gY2xpZW50UmVxdWVzdDtcbiAgfVxuXG4gIC8qKlxuXHQgKiBFbmNvZGVzIHRoZSBwYXJhbXMgZm9yIHRoZSBnaXZlbiByZXF1ZXN0LCBhY2NvcmRpbmcgdG8gdGhlaXIgdHlwZXMuXG5cdCAqIEBwYXJhbSB7IUNsaWVudFJlcXVlc3R9IGNsaWVudFJlcXVlc3Rcblx0ICogQHByb3RlY3RlZFxuXHQgKi9cbiAgZW5jb2RlUGFyYW1zXyhjbGllbnRSZXF1ZXN0KSB7XG4gICAgbGV0IHBhcmFtcyA9IGNsaWVudFJlcXVlc3QucGFyYW1zKCk7XG4gICAgcGFyYW1zLm5hbWVzKCkuZm9yRWFjaChmdW5jdGlvbihuYW1lKSB7XG4gICAgICBsZXQgdmFsdWVzID0gcGFyYW1zLmdldEFsbChuYW1lKTtcbiAgICAgIHZhbHVlcy5mb3JFYWNoKGZ1bmN0aW9uKHZhbHVlLCBpbmRleCkge1xuICAgICAgICBpZiAodmFsdWUgaW5zdGFuY2VvZiBFbWJvZGllZCkge1xuICAgICAgICAgIHZhbHVlID0gdmFsdWUudG9TdHJpbmcoKTtcbiAgICAgICAgfSBlbHNlIGlmIChjb3JlLmlzT2JqZWN0KHZhbHVlKSB8fCB2YWx1ZSBpbnN0YW5jZW9mIEFycmF5KSB7XG4gICAgICAgICAgdmFsdWUgPSBKU09OLnN0cmluZ2lmeSh2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgdmFsdWVzW2luZGV4XSA9IHZhbHVlO1xuICAgICAgfSk7XG4gICAgfSk7XG4gIH1cblxuICAvKipcblx0ICogQWRkcyBhIGtleS92YWx1ZSBwYWlyIHRvIGJlIHNlbnQgdmlhIHRoZSBib2R5IGluIGEgYG11bHRpcGFydC9mb3JtLWRhdGFgXG5cdCAqIGZvcm1hdC5cblx0ICogSWYgdGhlIGJvZHkgaXMgc2V0IGJ5IG90aGVyIG1lYW5zIChmb3IgZXhhbXBsZSwgdGhyb3VnaCB0aGUgYGJvZHlgIG1ldGhvZCksXG5cdCAqIHRoaXMgd2lsbCBiZSBpZ25vcmVkLlxuXHQgKiBAcGFyYW0ge3N0cmluZ30gbmFtZVxuXHQgKiBAcGFyYW0geyp9IHZhbHVlXG5cdCAqIEByZXR1cm4ge1dlRGVwbG95fSBSZXR1cm5zIHRoZSB7QGxpbmsgV2VEZXBsb3l9IG9iamVjdCBpdHNlbGYsIHNvIGNhbGxzIGNhblxuXHQgKiAgIGJlIGNoYWluZWQuXG5cdCAqIEBjaGFpbmFibGVcblx0ICovXG4gIGZvcm0obmFtZSwgdmFsdWUpIHtcbiAgICBpZiAodHlwZW9mIEZvcm1EYXRhSW1wbCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgJ2Zvcm0oKSBpcyBvbmx5IGF2YWlsYWJsZSB3aGVuIEZvcm1EYXRhIEFQSSBpcyBhdmFpbGFibGUuJ1xuICAgICAgKTtcbiAgICB9XG5cbiAgICBpZiAoIXRoaXMuZm9ybURhdGFfKSB7XG4gICAgICB0aGlzLmZvcm1EYXRhXyA9IG5ldyBGb3JtRGF0YUltcGwoKTtcbiAgICB9XG4gICAgdGhpcy5mb3JtRGF0YV8uYXBwZW5kKG5hbWUsIHZhbHVlKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8qKlxuXHQgKiBTZW5kcyBtZXNzYWdlIHdpdGggdGhlIEdFVCBodHRwIHZlcmIuXG5cdCAqIEBwYXJhbSB7Kj19IG9wdF9wYXJhbXMgUGFyYW1zIHRvIGJlIGFkZGVkIHRvIHRoZSByZXF1ZXN0IHVybC5cblx0ICogQHJldHVybiB7IUNhbmNlbGxhYmxlUHJvbWlzZX1cblx0ICovXG4gIGdldChvcHRfcGFyYW1zKSB7XG4gICAgcmV0dXJuIHRoaXMuc2VuZEFzeW5jKCdHRVQnLCBvcHRfcGFyYW1zKTtcbiAgfVxuXG4gIC8qKlxuXHQgKiBBZGRzIGEgaGVhZGVyLiBJZiB0aGUgaGVhZGVyIHdpdGggdGhlIHNhbWUgbmFtZSBhbHJlYWR5IGV4aXN0cywgaXQgd2lsbFxuXHQgKiBub3QgYmUgb3ZlcndyaXR0ZW4sIGJ1dCBuZXcgdmFsdWUgd2lsbCBiZSBzdG9yZWQuIFRoZSBvcmRlciBpcyBwcmVzZXJ2ZWQuXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIEhlYWRlciBrZXkuXG5cdCAqIEBwYXJhbSB7Kn0gdmFsdWUgSGVhZGVyIHZhbHVlLlxuXHQgKiBAcmV0dXJuIHtXZURlcGxveX0gUmV0dXJucyB0aGUge0BsaW5rIFdlRGVwbG95fSBvYmplY3QgaXRzZWxmLCBzbyBjYWxscyBjYW5cblx0ICogICBiZSBjaGFpbmVkLlxuXHQgKiBAY2hhaW5hYmxlXG5cdCAqL1xuICBoZWFkZXIobmFtZSwgdmFsdWUpIHtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCAhPT0gMikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGFyZ3VtZW50cycpO1xuICAgIH1cbiAgICB0aGlzLmhlYWRlcnNfLnNldChuYW1lLCB2YWx1ZSk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICAvKipcblx0ICogR2V0cyBvciBzZXRzIHRoZSBoZWFkZXJzLiBJZiBoZWFkZXJzIGFyZSBwYXNzZWQgdG8gdGhlIGZ1bmN0aW9uIGFzXG4gICAqIHBhcmFtZXRlciwgdGhleSB3aWxsIGJlIHNldCBhcyBpbnRlcm5hbCBoZWFkZXJzLCBvdmVyd3JpdGluZyB0aGUgZXhpc3RpbmdcbiAgICogb25lcy4gT3RoZXJ3aXNlLCB0aGUgY3VycmVudGx5IHNldCBoZWFkZXJzIHdpbGwgYmUgcmV0dXJuZWQuXG4gICAqIEBwYXJhbSB7TXVsdGlNYXB8T2JqZWN0PX0gb3B0X2hlYWRlcnMgSGVhZGVycyB0byBiZSBzZXRcblx0ICogQHJldHVybiB7V2VEZXBsb3l8TXVsdGlNYXB9IElmIGhlYWRlcnMgd2VyZSBwYXNzZWQgdG8gdGUgZnVuY3Rpb24sXG4gICAqICAgdGhlIHJldHVybmVkIHJlc3VsdCB3aWxsIGJlIHRoZSB7QGxpbmsgV2VEZXBsb3l9IG9iamVjdCBpdHNlbGYsIHNvIGNhbGxzXG4gICAqICAgY2FuIGJlIGNoYWluZWQuIElmIGhlYWRlcnMgd2VyZSBub3QgcGFzc2VkIHRvIHRoZSBmdW5jdGlvbiwgdGhlIHJldHVybmVkXG4gICAqICAgcmVzdWx0IHdpbGwgYmUgdGhlIGN1cnJlbnQgaGVhZGVycy5cbiAgICogQGNoYWluYWJsZSBDaGFpbmFibGUgd2hlbiB1c2VkIGFzIHNldHRlci5cbiAgICovXG4gIGhlYWRlcnMob3B0X2hlYWRlcnMpIHtcbiAgICBpZiAoY29yZS5pc0RlZkFuZE5vdE51bGwob3B0X2hlYWRlcnMpKSB7XG4gICAgICBpZiAoIShvcHRfaGVhZGVycyBpbnN0YW5jZW9mIE11bHRpTWFwKSkge1xuICAgICAgICBvcHRfaGVhZGVycyA9IE11bHRpTWFwLmZyb21PYmplY3Qob3B0X2hlYWRlcnMpO1xuICAgICAgfVxuXG4gICAgICBvcHRfaGVhZGVycy5uYW1lcygpLmZvckVhY2gobmFtZSA9PiB7XG4gICAgICAgIGNvbnN0IHZhbHVlcyA9IG9wdF9oZWFkZXJzLmdldEFsbChuYW1lKTtcblxuICAgICAgICB2YWx1ZXMuZm9yRWFjaCh2YWx1ZSA9PiB7XG4gICAgICAgICAgdGhpcy5oZWFkZXJzXy5zZXQobmFtZSwgdmFsdWUpO1xuICAgICAgICB9KTtcbiAgICAgIH0pO1xuXG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHRoaXMuaGVhZGVyc187XG4gICAgfVxuICB9XG5cbiAgLyoqXG5cdCAqIENoZWNrIGlmIGNsaWVudE1lc3NhZ2UgY29udGVudCB0eXBlIGlzIGFwcGxpY2F0aW9uL2pzb24uXG5cdCAqIEBwYXJhbSB7Q2xpZW50TWVzc2FnZX0gY2xpZW50TWVzc2FnZSBDbGllbnQgbWVzc2FnZS5cblx0ICogQHJldHVybiB7Ym9vbGVhbn1cblx0ICovXG4gIHN0YXRpYyBpc0NvbnRlbnRUeXBlSnNvbihjbGllbnRNZXNzYWdlKSB7XG4gICAgY29uc3QgY29udGVudFR5cGUgPSBjbGllbnRNZXNzYWdlLmhlYWRlcnMoKS5nZXQoJ2NvbnRlbnQtdHlwZScpIHx8ICcnO1xuICAgIHJldHVybiBjb250ZW50VHlwZS5pbmRleE9mKCdhcHBsaWNhdGlvbi9qc29uJykgPT09IDA7XG4gIH1cblxuICAvKipcblx0ICogV3JhcHMgdGhlIGdpdmVuIGBFbWJvZGllZGAgaW5zdGFuY2Ugd2l0aCBhIHtAbGluayBRdWVyeX0gaW5zdGFuY2UgaWZcblx0ICogbmVlZGVkLlxuXHQgKiBAcGFyYW0ge0VtYm9kaWVkfSBlbWJvZGllZFxuXHQgKiBAcmV0dXJuIHtFbWJvZGllZH1cblx0ICogQHByb3RlY3RlZFxuXHQgKi9cbiAgbWF5YmVXcmFwV2l0aFF1ZXJ5XyhlbWJvZGllZCkge1xuICAgIGlmIChlbWJvZGllZCBpbnN0YW5jZW9mIEZpbHRlcikge1xuICAgICAgZW1ib2RpZWQgPSBRdWVyeS5maWx0ZXIoZW1ib2RpZWQpO1xuICAgIH1cbiAgICByZXR1cm4gZW1ib2RpZWQ7XG4gIH1cblxuICAvKipcblx0ICogQWRkcyBhIHF1ZXJ5LiBJZiB0aGUgcXVlcnkgd2l0aCB0aGUgc2FtZSBuYW1lIGFscmVhZHkgZXhpc3RzLCBpdCB3aWxsIG5vdFxuXHQgKiBiZSBvdmVyd3JpdHRlbiwgYnV0IG5ldyB2YWx1ZSB3aWxsIGJlIHN0b3JlZC4gVGhlIG9yZGVyIGlzIHByZXNlcnZlZC5cblx0ICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgUGFyYW0ga2V5LlxuXHQgKiBAcGFyYW0geyp9IHZhbHVlIFBhcmFtIHZhbHVlLlxuXHQgKiBAcmV0dXJuIHtXZURlcGxveX0gUmV0dXJucyB0aGUge0BsaW5rIFdlRGVwbG95fSBvYmplY3QgaXRzZWxmLCBzbyBjYWxscyBjYW5cblx0ICogICBiZSBjaGFpbmVkLlxuXHQgKiBAY2hhaW5hYmxlXG5cdCAqL1xuICBwYXJhbShuYW1lLCB2YWx1ZSkge1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoICE9PSAyKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgYXJndW1lbnRzJyk7XG4gICAgfVxuICAgIHRoaXMucGFyYW1zXy5zZXQobmFtZSwgdmFsdWUpO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLyoqXG5cdCAqIEdldHMgdGhlIHF1ZXJ5IHN0cmluZ3MgbWFwLlxuXHQgKiBAcmV0dXJuIHshTXVsdGlNYXB9XG5cdCAqL1xuICBwYXJhbXMoKSB7XG4gICAgcmV0dXJuIHRoaXMucGFyYW1zXztcbiAgfVxuXG4gIC8qKlxuXHQgKiBTZW5kcyBtZXNzYWdlIHdpdGggdGhlIFBBVENIIGh0dHAgdmVyYi5cblx0ICogQHBhcmFtIHtzdHJpbmc9fSBvcHRfYm9keSBDb250ZW50IHRvIGJlIHNlbnQgYXMgdGhlIHJlcXVlc3QncyBib2R5LlxuXHQgKiBAcmV0dXJuIHshQ2FuY2VsbGFibGVQcm9taXNlfVxuXHQgKi9cbiAgcGF0Y2gob3B0X2JvZHkpIHtcbiAgICByZXR1cm4gdGhpcy5zZW5kQXN5bmMoJ1BBVENIJywgb3B0X2JvZHkpO1xuICB9XG5cbiAgLyoqXG5cdCAqIENyZWF0ZXMgYSBuZXcge0BsaW5rIFdlRGVwbG95fSBpbnN0YW5jZSBmb3IgaGFuZGxpbmcgdGhlIHVybCByZXN1bHRpbmcgaW5cblx0ICogdGhlIHVuaW9uIG9mIHRoZSBjdXJyZW50IHVybCB3aXRoIHRoZSBnaXZlbiBwYXRocy5cblx0ICogQHBhcmFtIHsuLi5zdHJpbmd9IHBhdGhzIEFueSBudW1iZXIgb2YgcGF0aHMuXG5cdCAqIEByZXR1cm4geyFXZURlcGxveX0gQSBuZXcge0BsaW5rIFdlRGVwbG95fSBpbnN0YW5jZSBmb3IgaGFuZGxpbmcgdGhlIGdpdmVuXG5cdCAqICAgcGF0aHMuXG5cdCAqL1xuICBwYXRoKC4uLnBhdGhzKSB7XG4gICAgbGV0IHdlZGVwbG95Q2xpZW50ID0gbmV3IFdlRGVwbG95KHRoaXMudXJsKCksIC4uLnBhdGhzKTtcblxuICAgIGlmIChjb3JlLmlzRGVmQW5kTm90TnVsbCh0aGlzLmF1dGhfKSkge1xuICAgICAgd2VkZXBsb3lDbGllbnQuYXV0aCh0aGlzLmF1dGhfKTtcbiAgICB9XG5cbiAgICB3ZWRlcGxveUNsaWVudC5oZWFkZXJzKHRoaXMuaGVhZGVyc18pO1xuXG4gICAgcmV0dXJuIHdlZGVwbG95Q2xpZW50LnVzZSh0aGlzLmN1c3RvbVRyYW5zcG9ydF8pO1xuICB9XG5cbiAgLyoqXG5cdCAqIFNlbmRzIG1lc3NhZ2Ugd2l0aCB0aGUgUE9TVCBodHRwIHZlcmIuXG5cdCAqIEBwYXJhbSB7c3RyaW5nPX0gb3B0X2JvZHkgQ29udGVudCB0byBiZSBzZW50IGFzIHRoZSByZXF1ZXN0J3MgYm9keS5cblx0ICogQHJldHVybiB7IUNhbmNlbGxhYmxlUHJvbWlzZX1cblx0ICovXG4gIHBvc3Qob3B0X2JvZHkpIHtcbiAgICByZXR1cm4gdGhpcy5zZW5kQXN5bmMoJ1BPU1QnLCBvcHRfYm9keSk7XG4gIH1cblxuICAvKipcblx0ICogU2VuZHMgbWVzc2FnZSB3aXRoIHRoZSBQVVQgaHR0cCB2ZXJiLlxuXHQgKiBAcGFyYW0ge3N0cmluZz19IG9wdF9ib2R5IENvbnRlbnQgdG8gYmUgc2VudCBhcyB0aGUgcmVxdWVzdCdzIGJvZHkuXG5cdCAqIEByZXR1cm4geyFDYW5jZWxsYWJsZVByb21pc2V9XG5cdCAqL1xuICBwdXQob3B0X2JvZHkpIHtcbiAgICByZXR1cm4gdGhpcy5zZW5kQXN5bmMoJ1BVVCcsIG9wdF9ib2R5KTtcbiAgfVxuXG4gIC8qKlxuXHQgKiBBZGRzIHRoZSBhdXRoZW50aWNhdGlvbiBpbmZvcm1hdGlvbiB0byB0aGUgcmVxdWVzdC5cblx0ICogQHBhcmFtIHshQ2xpZW50UmVxdWVzdH0gY2xpZW50UmVxdWVzdFxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqL1xuICByZXNvbHZlQXV0aGVudGljYXRpb25fKGNsaWVudFJlcXVlc3QpIHtcbiAgICBpZiAoIXRoaXMuYXV0aF8pIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKHRoaXMuYXV0aF8uaGFzVG9rZW4oKSkge1xuICAgICAgY2xpZW50UmVxdWVzdC5oZWFkZXIoJ0F1dGhvcml6YXRpb24nLCAnQmVhcmVyICcgKyB0aGlzLmF1dGhfLnRva2VuKTtcbiAgICB9IGVsc2UgaWYgKHRoaXMuYXV0aF8uaGFzRW1haWwoKSAmJiB0aGlzLmF1dGhfLmhhc1Bhc3N3b3JkKCkpIHtcbiAgICAgIGNvbnN0IGNyZWRlbnRpYWxzID0gdGhpcy5hdXRoXy5lbWFpbCArICc6JyArIHRoaXMuYXV0aF8ucGFzc3dvcmQ7XG4gICAgICBjbGllbnRSZXF1ZXN0LmhlYWRlcihcbiAgICAgICAgJ0F1dGhvcml6YXRpb24nLFxuICAgICAgICAnQmFzaWMgJyArIEJhc2U2NC5lbmNvZGVTdHJpbmcoY3JlZGVudGlhbHMpXG4gICAgICApO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuXHQgKiBVc2VzIHRyYW5zcG9ydCB0byBzZW5kIHJlcXVlc3Qgd2l0aCBnaXZlbiBtZXRob2QgbmFtZSBhbmQgYm9keVxuXHQgKiBhc3luY2hyb25vdXNseS5cblx0ICogQHBhcmFtIHtzdHJpbmd9IG1ldGhvZCBUaGUgSFRUUCBtZXRob2QgdG8gYmUgdXNlZCB3aGVuIHNlbmRpbmcgZGF0YS5cblx0ICogQHBhcmFtIHtzdHJpbmd9IGJvZHkgQ29udGVudCB0byBiZSBzZW50IGFzIHRoZSByZXF1ZXN0J3MgYm9keS5cblx0ICogQHJldHVybiB7IUNhbmNlbGxhYmxlUHJvbWlzZX0gRGVmZXJyZWQgcmVxdWVzdC5cblx0ICovXG4gIHNlbmRBc3luYyhtZXRob2QsIGJvZHkpIHtcbiAgICBjb25zdCB0cmFuc3BvcnQgPVxuICAgICAgdGhpcy5jdXN0b21UcmFuc3BvcnRfIHx8IFRyYW5zcG9ydEZhY3RvcnkuaW5zdGFuY2UoKS5nZXREZWZhdWx0KCk7XG5cbiAgICBjb25zdCBjbGllbnRSZXF1ZXN0ID0gdGhpcy5jcmVhdGVDbGllbnRSZXF1ZXN0XyhtZXRob2QsIGJvZHkpO1xuXG4gICAgcmV0dXJuIHRyYW5zcG9ydC5zZW5kKGNsaWVudFJlcXVlc3QpLnRoZW4odGhpcy5kZWNvZGUpO1xuICB9XG5cbiAgLyoqXG5cdCAqIFNldHMgdGhlIHNvY2tldCB0cmFuc3BvcnRcblx0ICogQHBhcmFtIHtPYmplY3R9IHNvY2tldCBpbXBsZW1lbnRhdGlvbiBvYmplY3QuXG5cdCAqL1xuICBzdGF0aWMgc29ja2V0KHNvY2tldCkge1xuICAgIGlvID0gc29ja2V0O1xuICB9XG5cbiAgLyoqXG5cdCAqIFNldHMgdGhlIEZvcm1EYXRhXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBmb3JtRGF0YSBpbXBsZW1lbnRhdGlvbiBvYmplY3QuXG5cdCAqL1xuICBzdGF0aWMgZm9ybURhdGEoZm9ybURhdGEpIHtcbiAgICBGb3JtRGF0YUltcGwgPSBmb3JtRGF0YTtcbiAgfVxuXG4gIC8qKlxuXHQgKiBTdGF0aWMgZmFjdG9yeSBmb3IgY3JlYXRpbmcgV2VEZXBsb3kgY2xpZW50IGZvciB0aGUgZ2l2ZW4gdXJsLlxuXHQgKiBAcGFyYW0ge3N0cmluZ30gdXJsIFRoZSB1cmwgdGhhdCB0aGUgY2xpZW50IHNob3VsZCB1c2UgZm9yIHNlbmRpbmdcblx0ICogICByZXF1ZXN0cy5cblx0ICogQHJldHVybiB7V2VEZXBsb3l9IFJldHVybnMgdGhlIHtAbGluayBXZURlcGxveX0gb2JqZWN0IGl0c2VsZiwgc28gY2FsbHMgY2FuXG5cdCAqICAgYmUgY2hhaW5lZC5cblx0ICovXG4gIHN0YXRpYyB1cmwodXJsKSB7XG4gICAgcmV0dXJuIG5ldyBXZURlcGxveSh1cmwpLnVzZSh0aGlzLmN1c3RvbVRyYW5zcG9ydF8pO1xuICB9XG5cbiAgLyoqXG5cdCAqIFJldHVybnMgdGhlIFVSTCB1c2VkIGJ5IHRoaXMgY2xpZW50LlxuXHQgKiBAcmV0dXJuIHshc3RyaW5nfVxuXHQgKi9cbiAgdXJsKCkge1xuICAgIHJldHVybiB0aGlzLnVybF87XG4gIH1cblxuICAvKipcblx0ICogU3BlY2lmaWVzIHtAbGluayBUcmFuc3BvcnR9IGltcGxlbWVudGF0aW9uLlxuXHQgKiBAcGFyYW0geyFUcmFuc3BvcnR9IHRyYW5zcG9ydCBUaGUgdHJhbnNwb3J0IGltcGxlbWVudGF0aW9uIHRoYXQgc2hvdWxkIGJlXG5cdCAqIHVzZWQuXG5cdCAqIEByZXR1cm4ge1dlRGVwbG95fSBSZXR1cm5zIHRoZSB7QGxpbmsgV2VEZXBsb3l9IG9iamVjdCBpdHNlbGYsIHNvIGNhbGxzIGNhblxuXHQgKiAgIGJlIGNoYWluZWQuXG5cdCAqL1xuICB1c2UodHJhbnNwb3J0KSB7XG4gICAgdGhpcy5jdXN0b21UcmFuc3BvcnRfID0gdHJhbnNwb3J0O1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLyoqXG5cdCAqIENyZWF0ZXMgbmV3IHNvY2tldC5pbyBpbnN0YW5jZS4gVGhlIHBhcmFtZXRlcnMgcGFzc2VkIHRvIHNvY2tldC5pb1xuXHQgKiBjb25zdHJ1Y3RvciB3aWxsIGJlIHByb3ZpZGVkOlxuXHQgKlxuXHQgKiBgYGBqYXZhc2NyaXB0XG5cdCAqIFdlRGVwbG95LnVybCgnaHR0cDovL2RvbWFpbjo4MDgwL3BhdGgvYScpLndhdGNoKHtpZDogJ215SWQnfSwge2ZvbzogdHJ1ZX0pO1xuXHQgKiAvLyBFcXVhbHM6XG5cdCAqIGlvKCdkb21haW46ODA4MC8/dXJsPXBhdGglMkZhJTNGaWQlM0RteUlkJywge2ZvbzogdHJ1ZX0pO1xuXHQgKiBgYGBcblx0ICpcblx0ICogQHBhcmFtIHtPYmplY3Q9fSBvcHRfcGFyYW1zIFBhcmFtcyB0byBiZSBzZW50IHdpdGggdGhlIFNvY2tldCBJTyByZXF1ZXN0LlxuXHQgKiBAcGFyYW0ge09iamVjdD19IG9wdF9vcHRpb25zIE9iamVjdCB3aXRoIFNvY2tldCBJTyBvcHRpb25zLlxuXHQgKiBAcmV0dXJuIHshaW99IFNvY2tldCBJTyByZWZlcmVuY2UuIFNlcnZlciBldmVudHMgY2FuIGJlIGxpc3RlbmVkIG9uIGl0LlxuXHQgKi9cbiAgd2F0Y2gob3B0X3BhcmFtcywgb3B0X29wdGlvbnMpIHtcbiAgICBpZiAodHlwZW9mIGlvID09PSAndW5kZWZpbmVkJykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdTb2NrZXQuaW8gY2xpZW50IG5vdCBsb2FkZWQnKTtcbiAgICB9XG5cbiAgICBjb25zdCBjbGllbnRSZXF1ZXN0ID0gdGhpcy5jcmVhdGVDbGllbnRSZXF1ZXN0XygnR0VUJywgb3B0X3BhcmFtcyk7XG4gICAgY29uc3QgdXJpID0gbmV3IFVyaShjbGllbnRSZXF1ZXN0LnVybCgpKTtcbiAgICB1cmkuYWRkUGFyYW1ldGVyc0Zyb21NdWx0aU1hcChjbGllbnRSZXF1ZXN0LnBhcmFtcygpKTtcblxuICAgIGNvbnN0IGpzb25wID1cbiAgICAgIHR5cGVvZiBuYXZpZ2F0b3IgPT09ICd1bmRlZmluZWQnIHx8IG5hdmlnYXRvci5wcm9kdWN0ICE9PSAnUmVhY3ROYXRpdmUnO1xuXG4gICAgb3B0X29wdGlvbnMgPSBvcHRfb3B0aW9ucyB8fCB7XG4gICAgICBmb3JjZU5ldzogdHJ1ZSxcbiAgICAgIGpzb25wOiBqc29ucCxcbiAgICB9O1xuICAgIG9wdF9vcHRpb25zLnF1ZXJ5ID1cbiAgICAgICd1cmw9JyArIGVuY29kZVVSSUNvbXBvbmVudCh1cmkuZ2V0UGF0aG5hbWUoKSArIHVyaS5nZXRTZWFyY2goKSk7XG4gICAgb3B0X29wdGlvbnMucGF0aCA9IG9wdF9vcHRpb25zLnBhdGggfHwgdXJpLmdldFBhdGhuYW1lKCk7XG4gICAgb3B0X29wdGlvbnMgPSB0aGlzLnJlc29sdmVUcmFuc3BvcnRPcHRpb25zXyhvcHRfb3B0aW9ucyk7XG5cbiAgICByZXR1cm4gaW8odXJpLmdldFByb3RvY29sKCkgKyAnLy8nICsgdXJpLmdldEhvc3QoKSwgb3B0X29wdGlvbnMpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJlc29sdmVzIHRoZSBwb2xsaW5nIG9wdGlvbnMgb2JqZWN0IGJ5IGFkZGluZyBBdXRob3JpemF0aW9uIGhlYWRlciBpZiB0aGVcbiAgICogICBjdXJyZW50IGF1dGggb2JqZWN0IGhhcyB0b2tlbiwgb3IgaXQgaGFzIGJvdGggZW1haWwgYW5kIHBhc3N3b3JkLlxuICAgKiBAcGFyYW0geyFPYmplY3R9IG9wdGlvbnMgVGhlIG9iamVjdCB3aGVyZSB0cmFuc3BvcnQgb3B0aW9ucyBzaG91bGQgYmUgYWRkZWRcbiAgICogQHJldHVybiB7T2JqZWN0fSBSZXR1cm5zIHRoZSBtb2RpZmllZCBvcHRpb25zIG9iamVjdFxuICAgKi9cbiAgcmVzb2x2ZVRyYW5zcG9ydE9wdGlvbnNfKG9wdGlvbnMpIHtcbiAgICBpZiAoIXRoaXMuYXV0aF8pIHtcbiAgICAgIHJldHVybiBvcHRpb25zO1xuICAgIH1cblxuICAgIGlmICh0aGlzLmF1dGhfLmhhc1Rva2VuKCkpIHtcbiAgICAgIG9wdGlvbnMudHJhbnNwb3J0T3B0aW9ucyA9IHtcbiAgICAgICAgcG9sbGluZzoge1xuICAgICAgICAgIGV4dHJhSGVhZGVyczoge1xuICAgICAgICAgICAgQXV0aG9yaXphdGlvbjogYEJlYXJlciAke3RoaXMuYXV0aF8uZ2V0VG9rZW4oKX1gLFxuICAgICAgICAgIH0sXG4gICAgICAgIH0sXG4gICAgICB9O1xuICAgIH0gZWxzZSBpZiAodGhpcy5hdXRoXy5oYXNFbWFpbCgpICYmIHRoaXMuYXV0aF8uaGFzUGFzc3dvcmQoKSkge1xuICAgICAgY29uc3QgY3JlZGVudGlhbHMgPVxuICAgICAgICB0aGlzLmF1dGhfLmdldEVtYWlsKCkgKyAnOicgKyB0aGlzLmF1dGhfLmdldFBhc3N3b3JkKCk7XG4gICAgICBvcHRpb25zLnRyYW5zcG9ydE9wdGlvbnMgPSB7XG4gICAgICAgIHBvbGxpbmc6IHtcbiAgICAgICAgICBleHRyYUhlYWRlcnM6IHtcbiAgICAgICAgICAgIEF1dGhvcml6YXRpb246IGBCYXNpYyAke0Jhc2U2NC5lbmNvZGVTdHJpbmcoY3JlZGVudGlhbHMpfWAsXG4gICAgICAgICAgfSxcbiAgICAgICAgfSxcbiAgICAgIH07XG4gICAgfVxuXG4gICAgcmV0dXJuIG9wdGlvbnM7XG4gIH1cblxuICAvKipcblx0ICogQXNzaWducyB0aGUgcGFzc2VkIHZhbHVlIHRvIHRoZSBpbnRlcm5hbCB3aXRoIGNyZWRlbnRpYWxzIG9wdGlvbi5cblx0ICogQHBhcmFtIHtib29sZWFufSB3aXRoQ3JlZGVudGlhbHNcblx0ICogQHJldHVybiB7V2VEZXBsb3l9IFJldHVybnMgdGhlIHtAbGluayBXZURlcGxveX0gb2JqZWN0IGl0c2VsZiwgc28gY2FsbHMgY2FuXG5cdCAqICAgYmUgY2hhaW5lZC5cblx0ICovXG4gIHdpdGhDcmVkZW50aWFscyh3aXRoQ3JlZGVudGlhbHMpIHtcbiAgICB0aGlzLndpdGhDcmVkZW50aWFsc18gPSAhIXdpdGhDcmVkZW50aWFscztcbiAgICByZXR1cm4gdGhpcztcbiAgfVxufVxuXG5XZURlcGxveS5hdXRoXyA9IG51bGw7XG5XZURlcGxveS5kYXRhXyA9IG51bGw7XG5XZURlcGxveS5lbWFpbF8gPSBudWxsO1xuV2VEZXBsb3kuYXV0aFVybF8gPSAnJztcbldlRGVwbG95LmRhdGFVcmxfID0gJyc7XG5XZURlcGxveS5lbWFpbFVybF8gPSAnJztcblxuZXhwb3J0IGRlZmF1bHQgV2VEZXBsb3k7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zcmMvYXBpL1dlRGVwbG95LmpzIiwiJ3VzZSBzdHJpY3QnO1xuXG5pbXBvcnQgRW1ib2RpZWQgZnJvbSAnLi9FbWJvZGllZCc7XG5pbXBvcnQgUmFuZ2UgZnJvbSAnLi9SYW5nZSc7XG5cbi8qKlxuICogQ2xhc3MgdGhhdCByZXByZXNlbnRzIGEgc2VhcmNoIGFnZ3JlZ2F0aW9uLlxuICovXG5jbGFzcyBBZ2dyZWdhdGlvbiB7XG4gIC8qKlxuXHQgKiBDb25zdHJ1Y3RzIGFuIHtAbGluayBBZ2dyZWdhdGlvbn0gaW5zdGFuY2UuXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBmaWVsZCBUaGUgYWdncmVnYXRpb24gZmllbGQuXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBvcGVyYXRvciBUaGUgYWdncmVnYXRpb24gb3BlcmF0b3IuXG5cdCAqIEBwYXJhbSB7Kj19IG9wdF92YWx1ZSBUaGUgYWdncmVnYXRpb24gdmFsdWUuXG5cdCAqIEBjb25zdHJ1Y3RvclxuXHQgKi9cbiAgY29uc3RydWN0b3IoZmllbGQsIG9wZXJhdG9yLCBvcHRfdmFsdWUpIHtcbiAgICB0aGlzLmZpZWxkXyA9IGZpZWxkO1xuICAgIHRoaXMub3BlcmF0b3JfID0gb3BlcmF0b3I7XG4gICAgdGhpcy52YWx1ZV8gPSBvcHRfdmFsdWU7XG4gIH1cblxuICAvKipcblx0ICogQ3JlYXRlcyBhbiB7QGxpbmsgQWdncmVnYXRpb259IGluc3RhbmNlIHdpdGggdGhlIFwiYXZnXCIgb3BlcmF0b3IuXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBmaWVsZCBUaGUgYWdncmVnYXRpb24gZmllbGQuXG5cdCAqIEByZXR1cm4geyFBZ2dyZWdhdGlvbn1cblx0ICogQHN0YXRpY1xuXHQgKi9cbiAgc3RhdGljIGF2ZyhmaWVsZCkge1xuICAgIHJldHVybiBBZ2dyZWdhdGlvbi5maWVsZChmaWVsZCwgJ2F2ZycpO1xuICB9XG5cbiAgLyoqXG5cdCAqIENyZWF0ZXMgYW4ge0BsaW5rIEFnZ3JlZ2F0aW9ufSBpbnN0YW5jZSB3aXRoIHRoZSBcImNvdW50XCIgb3BlcmF0b3IuXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBmaWVsZCBUaGUgYWdncmVnYXRpb24gZmllbGQuXG5cdCAqIEByZXR1cm4geyFBZ2dyZWdhdGlvbn1cblx0ICogQHN0YXRpY1xuXHQgKi9cbiAgc3RhdGljIGNvdW50KGZpZWxkKSB7XG4gICAgcmV0dXJuIEFnZ3JlZ2F0aW9uLmZpZWxkKGZpZWxkLCAnY291bnQnKTtcbiAgfVxuXG4gIC8qKlxuXHQgKiBDcmVhdGVzIGFuIHtAbGluayBEaXN0YW5jZUFnZ3JlZ2F0aW9ufSBpbnN0YW5jZSB3aXRoIHRoZSBcImdlb0Rpc3RhbmNlXCJcblx0ICogb3BlcmF0b3IuXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBmaWVsZCBUaGUgYWdncmVnYXRpb24gZmllbGQuXG5cdCAqIEBwYXJhbSB7Kn0gbG9jYXRpb24gVGhlIGFnZ3JlZ2F0aW9uIGxvY2F0aW9uLlxuXHQgKiBAcGFyYW0gey4uLiFSYW5nZX0gcmFuZ2VzIFRoZSBhZ2dyZWdhdGlvbiByYW5nZXMuXG5cdCAqIEByZXR1cm4geyFEaXN0YW5jZUFnZ3JlZ2F0aW9ufVxuXHQgKiBAc3RhdGljXG5cdCAqL1xuICBzdGF0aWMgZGlzdGFuY2UoZmllbGQsIGxvY2F0aW9uLCAuLi5yYW5nZXMpIHtcbiAgICByZXR1cm4gbmV3IEFnZ3JlZ2F0aW9uLkRpc3RhbmNlQWdncmVnYXRpb24oZmllbGQsIGxvY2F0aW9uLCAuLi5yYW5nZXMpO1xuICB9XG5cbiAgLyoqXG5cdCAqIENyZWF0ZXMgYW4ge0BsaW5rIEFnZ3JlZ2F0aW9ufSBpbnN0YW5jZSB3aXRoIHRoZSBcImV4dGVuZGVkU3RhdHNcIiBvcGVyYXRvci5cblx0ICogQHBhcmFtIHtzdHJpbmd9IGZpZWxkIFRoZSBhZ2dyZWdhdGlvbiBmaWVsZC5cblx0ICogQHJldHVybiB7IUFnZ3JlZ2F0aW9ufVxuXHQgKiBAc3RhdGljXG5cdCAqL1xuICBzdGF0aWMgZXh0ZW5kZWRTdGF0cyhmaWVsZCkge1xuICAgIHJldHVybiBBZ2dyZWdhdGlvbi5maWVsZChmaWVsZCwgJ2V4dGVuZGVkU3RhdHMnKTtcbiAgfVxuXG4gIC8qKlxuXHQgKiBHZXRzIHRoaXMgYWdncmVnYXRpb24ncyBmaWVsZC5cblx0ICogQHJldHVybiB7c3RyaW5nfVxuXHQgKi9cbiAgZ2V0RmllbGQoKSB7XG4gICAgcmV0dXJuIHRoaXMuZmllbGRfO1xuICB9XG5cbiAgLyoqXG5cdCAqIEdldHMgdGhpcyBhZ2dyZWdhdGlvbidzIG9wZXJhdG9yLlxuXHQgKiBAcmV0dXJuIHtzdHJpbmd9XG5cdCAqL1xuICBnZXRPcGVyYXRvcigpIHtcbiAgICByZXR1cm4gdGhpcy5vcGVyYXRvcl87XG4gIH1cblxuICAvKipcblx0ICogR2V0cyB0aGlzIGFnZ3JlZ2F0aW9uJ3MgdmFsdWUuXG5cdCAqIEByZXR1cm4geyp9XG5cdCAqL1xuICBnZXRWYWx1ZSgpIHtcbiAgICByZXR1cm4gdGhpcy52YWx1ZV87XG4gIH1cblxuICAvKipcblx0ICogQ3JlYXRlcyBhbiB7QGxpbmsgQWdncmVnYXRpb259IGluc3RhbmNlIHdpdGggdGhlIFwiaGlzdG9ncmFtXCIgb3BlcmF0b3IuXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBmaWVsZCBUaGUgYWdncmVnYXRpb24gZmllbGQuXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBpbnRlcnZhbCBUaGUgaGlzdG9ncmFtJ3MgaW50ZXJ2YWwuXG5cdCAqIEByZXR1cm4geyFBZ2dyZWdhdGlvbn1cblx0ICogQHN0YXRpY1xuXHQgKi9cbiAgc3RhdGljIGhpc3RvZ3JhbShmaWVsZCwgaW50ZXJ2YWwpIHtcbiAgICByZXR1cm4gbmV3IEFnZ3JlZ2F0aW9uKGZpZWxkLCAnaGlzdG9ncmFtJywgaW50ZXJ2YWwpO1xuICB9XG5cbiAgLyoqXG5cdCAqIENyZWF0ZXMgYW4ge0BsaW5rIEFnZ3JlZ2F0aW9ufSBpbnN0YW5jZSB3aXRoIHRoZSBcIm1heFwiIG9wZXJhdG9yLlxuXHQgKiBAcGFyYW0ge3N0cmluZ30gZmllbGQgVGhlIGFnZ3JlZ2F0aW9uIGZpZWxkLlxuXHQgKiBAcmV0dXJuIHshQWdncmVnYXRpb259XG5cdCAqIEBzdGF0aWNcblx0ICovXG4gIHN0YXRpYyBtYXgoZmllbGQpIHtcbiAgICByZXR1cm4gQWdncmVnYXRpb24uZmllbGQoZmllbGQsICdtYXgnKTtcbiAgfVxuXG4gIC8qKlxuXHQgKiBDcmVhdGVzIGFuIHtAbGluayBBZ2dyZWdhdGlvbn0gaW5zdGFuY2Ugd2l0aCB0aGUgXCJtaW5cIiBvcGVyYXRvci5cblx0ICogQHBhcmFtIHtzdHJpbmd9IGZpZWxkIFRoZSBhZ2dyZWdhdGlvbiBmaWVsZC5cblx0ICogQHJldHVybiB7IUFnZ3JlZ2F0aW9ufVxuXHQgKiBAc3RhdGljXG5cdCAqL1xuICBzdGF0aWMgbWluKGZpZWxkKSB7XG4gICAgcmV0dXJuIEFnZ3JlZ2F0aW9uLmZpZWxkKGZpZWxkLCAnbWluJyk7XG4gIH1cblxuICAvKipcblx0ICogQ3JlYXRlcyBhbiB7QGxpbmsgQWdncmVnYXRpb259IGluc3RhbmNlIHdpdGggdGhlIFwibWlzc2luZ1wiIG9wZXJhdG9yLlxuXHQgKiBAcGFyYW0ge3N0cmluZ30gZmllbGQgVGhlIGFnZ3JlZ2F0aW9uIGZpZWxkLlxuXHQgKiBAcmV0dXJuIHshQWdncmVnYXRpb259XG5cdCAqIEBzdGF0aWNcblx0ICovXG4gIHN0YXRpYyBtaXNzaW5nKGZpZWxkKSB7XG4gICAgcmV0dXJuIEFnZ3JlZ2F0aW9uLmZpZWxkKGZpZWxkLCAnbWlzc2luZycpO1xuICB9XG5cbiAgLyoqXG5cdCAqIENyZWF0ZXMgYSBuZXcge0BsaW5rIEFnZ3JlZ2F0aW9ufSBpbnN0YW5jZS5cblx0ICogQHBhcmFtIHtzdHJpbmd9IGZpZWxkIFRoZSBhZ2dyZWdhdGlvbiBmaWVsZC5cblx0ICogQHBhcmFtIHtzdHJpbmd9IG9wZXJhdG9yIFRoZSBhZ2dyZWdhdGlvbiBvcGVyYXRvci5cblx0ICogQHJldHVybiB7IUFnZ3JlZ2F0aW9ufVxuXHQgKiBAc3RhdGljXG5cdCAqL1xuICBzdGF0aWMgZmllbGQoZmllbGQsIG9wZXJhdG9yKSB7XG4gICAgcmV0dXJuIG5ldyBBZ2dyZWdhdGlvbihmaWVsZCwgb3BlcmF0b3IpO1xuICB9XG5cbiAgLyoqXG5cdCAqIENyZWF0ZXMgYW4ge0BsaW5rIFJhbmdlQWdncmVnYXRpb259IGluc3RhbmNlIHdpdGggdGhlIFwicmFuZ2VcIiBvcGVyYXRvci5cblx0ICogQHBhcmFtIHtzdHJpbmd9IGZpZWxkIFRoZSBhZ2dyZWdhdGlvbiBmaWVsZC5cblx0ICogQHBhcmFtIHsuLi4hUmFuZ2V9IHJhbmdlcyBUaGUgYWdncmVnYXRpb24gcmFuZ2VzLlxuXHQgKiBAcmV0dXJuIHshUmFuZ2VBZ2dyZWdhdGlvbn1cblx0ICogQHN0YXRpY1xuXHQgKi9cbiAgc3RhdGljIHJhbmdlKGZpZWxkLCAuLi5yYW5nZXMpIHtcbiAgICByZXR1cm4gbmV3IEFnZ3JlZ2F0aW9uLlJhbmdlQWdncmVnYXRpb24oZmllbGQsIC4uLnJhbmdlcyk7XG4gIH1cblxuICAvKipcblx0ICogQ3JlYXRlcyBhbiB7QGxpbmsgQWdncmVnYXRpb259IGluc3RhbmNlIHdpdGggdGhlIFwic3RhdHNcIiBvcGVyYXRvci5cblx0ICogQHBhcmFtIHtzdHJpbmd9IGZpZWxkIFRoZSBhZ2dyZWdhdGlvbiBmaWVsZC5cblx0ICogQHJldHVybiB7IUFnZ3JlZ2F0aW9ufVxuXHQgKiBAc3RhdGljXG5cdCAqL1xuICBzdGF0aWMgc3RhdHMoZmllbGQpIHtcbiAgICByZXR1cm4gQWdncmVnYXRpb24uZmllbGQoZmllbGQsICdzdGF0cycpO1xuICB9XG5cbiAgLyoqXG5cdCAqIENyZWF0ZXMgYW4ge0BsaW5rIEFnZ3JlZ2F0aW9ufSBpbnN0YW5jZSB3aXRoIHRoZSBcInN1bVwiIG9wZXJhdG9yLlxuXHQgKiBAcGFyYW0ge3N0cmluZ30gZmllbGQgVGhlIGFnZ3JlZ2F0aW9uIGZpZWxkLlxuXHQgKiBAcmV0dXJuIHshQWdncmVnYXRpb259XG5cdCAqIEBzdGF0aWNcblx0ICovXG4gIHN0YXRpYyBzdW0oZmllbGQpIHtcbiAgICByZXR1cm4gQWdncmVnYXRpb24uZmllbGQoZmllbGQsICdzdW0nKTtcbiAgfVxuXG4gIC8qKlxuXHQgKiBDcmVhdGVzIGFuIHtAbGluayBBZ2dyZWdhdGlvbn0gaW5zdGFuY2Ugd2l0aCB0aGUgXCJ0ZXJtc1wiIG9wZXJhdG9yLlxuXHQgKiBAcGFyYW0ge3N0cmluZ30gZmllbGQgVGhlIGFnZ3JlZ2F0aW9uIGZpZWxkLlxuXHQgKiBAcmV0dXJuIHshQWdncmVnYXRpb259XG5cdCAqIEBzdGF0aWNcblx0ICovXG4gIHN0YXRpYyB0ZXJtcyhmaWVsZCkge1xuICAgIHJldHVybiBBZ2dyZWdhdGlvbi5maWVsZChmaWVsZCwgJ3Rlcm1zJyk7XG4gIH1cbn1cblxuLyoqXG4gKiBDbGFzcyB0aGF0IHJlcHJlc2VudHMgYSBkaXN0YW5jZSBhZ2dyZWdhdGlvbi5cbiAqIEBleHRlbmRzIHtBZ2dyZWdhdGlvbn1cbiAqL1xuY2xhc3MgRGlzdGFuY2VBZ2dyZWdhdGlvbiBleHRlbmRzIEFnZ3JlZ2F0aW9uIHtcbiAgLyoqXG5cdCAqIENvbnN0cnVjdHMgYW4ge0BsaW5rIERpc3RhbmNlQWdncmVnYXRpb259IGluc3RhbmNlLlxuXHQgKiBAcGFyYW0ge3N0cmluZ30gZmllbGQgVGhlIGFnZ3JlZ2F0aW9uIGZpZWxkLlxuXHQgKiBAcGFyYW0geyp9IGxvY2F0aW9uIFRoZSBhZ2dyZWdhdGlvbiBsb2NhdGlvbi5cblx0ICogQHBhcmFtIHsuLi4hUmFuZ2V9IHJhbmdlcyBUaGUgYWdncmVnYXRpb24gcmFuZ2VzLlxuXHQgKiBAY29uc3RydWN0b3Jcblx0ICovXG4gIGNvbnN0cnVjdG9yKGZpZWxkLCBsb2NhdGlvbiwgLi4ucmFuZ2VzKSB7XG4gICAgc3VwZXIoZmllbGQsICdnZW9EaXN0YW5jZScsIHt9KTtcbiAgICB0aGlzLnZhbHVlXy5sb2NhdGlvbiA9IEVtYm9kaWVkLnRvQm9keShsb2NhdGlvbik7XG4gICAgdGhpcy52YWx1ZV8ucmFuZ2VzID0gcmFuZ2VzLm1hcChyYW5nZSA9PiByYW5nZS5ib2R5KCkpO1xuICB9XG5cbiAgLyoqXG5cdCAqIEFkZHMgYSByYW5nZSB0byB0aGlzIGFnZ3JlZ2F0aW9uLlxuXHQgKiBAcGFyYW0geyp9IHJhbmdlT3JGcm9tXG5cdCAqIEBwYXJhbSB7Kj19IG9wdF90b1xuXHQgKiBAcmV0dXJuIHtBZ2dyZWdhdGlvbn0gUmV0dXJucyB0aGUge0BsaW5rIEFnZ3JlZ2F0aW9ufSBvYmplY3QgaXRzZWxmLCBzb1xuXHQgKiAgIGNhbGxzIGNhbiBiZSBjaGFpbmVkLlxuXHQgKiBAY2hhaW5hYmxlXG5cdCAqL1xuICByYW5nZShyYW5nZU9yRnJvbSwgb3B0X3RvKSB7XG4gICAgbGV0IHJhbmdlID0gcmFuZ2VPckZyb207XG4gICAgaWYgKCEocmFuZ2UgaW5zdGFuY2VvZiBSYW5nZSkpIHtcbiAgICAgIHJhbmdlID0gUmFuZ2UucmFuZ2UocmFuZ2VPckZyb20sIG9wdF90byk7XG4gICAgfVxuICAgIHRoaXMudmFsdWVfLnJhbmdlcy5wdXNoKHJhbmdlLmJvZHkoKSk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICAvKipcblx0ICogU2V0cyB0aGlzIGFnZ3JlZ2F0aW9uJ3MgdW5pdC5cblx0ICogQHBhcmFtIHtzdHJpbmd9IHVuaXRcblx0ICogQHJldHVybiB7QWdncmVnYXRpb259IFJldHVybnMgdGhlIHtAbGluayBBZ2dyZWdhdGlvbn0gb2JqZWN0IGl0c2VsZiwgc29cblx0ICogICBjYWxscyBjYW4gYmUgY2hhaW5lZC5cblx0ICogQGNoYWluYWJsZVxuXHQgKi9cbiAgdW5pdCh1bml0KSB7XG4gICAgdGhpcy52YWx1ZV8udW5pdCA9IHVuaXQ7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbn1cbkFnZ3JlZ2F0aW9uLkRpc3RhbmNlQWdncmVnYXRpb24gPSBEaXN0YW5jZUFnZ3JlZ2F0aW9uO1xuXG4vKipcbiAqIENsYXNzIHRoYXQgcmVwcmVzZW50cyBhIHJhbmdlIGFnZ3JlZ2F0aW9uLlxuICogQGV4dGVuZHMge0FnZ3JlZ2F0aW9ufVxuICovXG5jbGFzcyBSYW5nZUFnZ3JlZ2F0aW9uIGV4dGVuZHMgQWdncmVnYXRpb24ge1xuICAvKipcblx0ICogQ29uc3RydWN0cyBhbiB7QGxpbmsgUmFuZ2VBZ2dyZWdhdGlvbn0gaW5zdGFuY2UuXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBmaWVsZCBUaGUgYWdncmVnYXRpb24gZmllbGQuXG5cdCAqIEBwYXJhbSB7Li4uIVJhbmdlfSByYW5nZXMgVGhlIGFnZ3JlZ2F0aW9uIHJhbmdlcy5cblx0ICogQGNvbnN0cnVjdG9yXG5cdCAqL1xuICBjb25zdHJ1Y3RvcihmaWVsZCwgLi4ucmFuZ2VzKSB7XG4gICAgc3VwZXIoZmllbGQsICdyYW5nZScpO1xuICAgIHRoaXMudmFsdWVfID0gcmFuZ2VzLm1hcChyYW5nZSA9PiByYW5nZS5ib2R5KCkpO1xuICB9XG5cbiAgLyoqXG5cdCAqIEFkZHMgYSByYW5nZSB0byB0aGlzIGFnZ3JlZ2F0aW9uLlxuXHQgKiBAcGFyYW0geyp9IHJhbmdlT3JGcm9tXG5cdCAqIEBwYXJhbSB7Kj19IG9wdF90b1xuXHQgKiBAcmV0dXJuIHtBZ2dyZWdhdGlvbn0gUmV0dXJucyB0aGUge0BsaW5rIEFnZ3JlZ2F0aW9ufSBvYmplY3QgaXRzZWxmLCBzb1xuXHQgKiAgIGNhbGxzIGNhbiBiZSBjaGFpbmVkLlxuXHQgKiBAY2hhaW5hYmxlXG5cdCAqL1xuICByYW5nZShyYW5nZU9yRnJvbSwgb3B0X3RvKSB7XG4gICAgbGV0IHJhbmdlID0gcmFuZ2VPckZyb207XG4gICAgaWYgKCEocmFuZ2UgaW5zdGFuY2VvZiBSYW5nZSkpIHtcbiAgICAgIHJhbmdlID0gUmFuZ2UucmFuZ2UocmFuZ2VPckZyb20sIG9wdF90byk7XG4gICAgfVxuICAgIHRoaXMudmFsdWVfLnB1c2gocmFuZ2UuYm9keSgpKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxufVxuQWdncmVnYXRpb24uUmFuZ2VBZ2dyZWdhdGlvbiA9IFJhbmdlQWdncmVnYXRpb247XG5cbmV4cG9ydCBkZWZhdWx0IEFnZ3JlZ2F0aW9uO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL2FwaS1xdWVyeS9BZ2dyZWdhdGlvbi5qcyIsIid1c2Ugc3RyaWN0JztcblxuaW1wb3J0IHtjb3JlfSBmcm9tICdtZXRhbCc7XG5pbXBvcnQgRW1ib2RpZWQgZnJvbSAnLi9FbWJvZGllZCc7XG5cbi8qKlxuICogQ2xhc3MgcmVzcG9uc2libGUgZm9yIHN0b3JpbmcgYW5kIGhhbmRsaW5nIHRoZSBib2R5IGNvbnRlbnRzXG4gKiBvZiBhIEZpbHRlciBpbnN0YW5jZS5cbiAqL1xuY2xhc3MgRmlsdGVyQm9keSB7XG4gIC8qKlxuXHQgKiBDb25zdHJ1Y3RzIGEge0BsaW5rIEZpbHRlckJvZHl9IGluc3RhbmNlLlxuXHQgKiBAcGFyYW0ge3N0cmluZ30gZmllbGQgVGhlIG5hbWUgb2YgdGhlIGZpZWxkIHRvIGZpbHRlciBieS5cblx0ICogQHBhcmFtIHsqfSBvcGVyYXRvck9yVmFsdWUgSWYgYSB0aGlyZCBwYXJhbSBpcyBnaXZlbiwgdGhpcyBzaG91bGRcblx0ICogICBiZSB0aGUgZmlsdGVyJ3Mgb3BlcmF0b3IgKGxpa2UgXCI+PVwiKS4gT3RoZXJ3aXNlLCB0aGlzIHdpbGwgYmVcblx0ICogICB1c2VkIGFzIHRoZSBmaWx0ZXIncyB2YWx1ZSwgYW5kIHRoZSBmaWx0ZXIncyBvcGVyYXRvciB3aWxsIGJlIFwiPVwiLlxuXHQgKiBAcGFyYW0geyo9fSBvcHRfdmFsdWUgVGhlIGZpbHRlcidzIHZhbHVlLlxuXHQgKiBAY29uc3RydWN0b3Jcblx0ICovXG4gIGNvbnN0cnVjdG9yKGZpZWxkLCBvcGVyYXRvck9yVmFsdWUsIG9wdF92YWx1ZSkge1xuICAgIGxldCBvYmogPSB7XG4gICAgICBvcGVyYXRvcjogY29yZS5pc0RlZihvcHRfdmFsdWUpID8gb3BlcmF0b3JPclZhbHVlIDogJz0nLFxuICAgIH07XG5cbiAgICBsZXQgdmFsdWUgPSBjb3JlLmlzRGVmKG9wdF92YWx1ZSkgPyBvcHRfdmFsdWUgOiBvcGVyYXRvck9yVmFsdWU7XG5cbiAgICBpZiAoY29yZS5pc0RlZkFuZE5vdE51bGwodmFsdWUpKSB7XG4gICAgICBpZiAodmFsdWUgaW5zdGFuY2VvZiBFbWJvZGllZCkge1xuICAgICAgICB2YWx1ZSA9IHZhbHVlLmJvZHkoKTtcbiAgICAgIH1cbiAgICAgIG9iai52YWx1ZSA9IHZhbHVlO1xuICAgIH1cblxuICAgIGlmIChjb3JlLmlzRGVmQW5kTm90TnVsbChmaWVsZCkpIHtcbiAgICAgIHRoaXMuY3JlYXRlQm9keV8oZmllbGQsIG9iaik7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuY3JlYXRlQm9keV8oJ2FuZCcsIFtdKTtcbiAgICB9XG4gIH1cblxuICAvKipcblx0ICogQ29tcG9zZXMgdGhlIGN1cnJlbnQgZmlsdGVyIHdpdGggdGhlIGdpdmVuIG9wZXJhdG9yLlxuXHQgKiBAcGFyYW0ge3N0cmluZ30gb3BlcmF0b3Jcblx0ICogQHBhcmFtIHtGaWx0ZXI9fSBvcHRfZmlsdGVyIEFub3RoZXIgZmlsdGVyIHRvIGNvbXBvc2UgdGhpcyBmaWx0ZXIgd2l0aCxcblx0ICogICBpZiB0aGUgb3BlcmF0b3IgaXMgbm90IHVuYXJ5LlxuXHQgKi9cbiAgYWRkKG9wZXJhdG9yLCBvcHRfZmlsdGVyKSB7XG4gICAgaWYgKG9wdF9maWx0ZXIpIHtcbiAgICAgIHRoaXMuYWRkQXJyYXlPcGVyYXRvcl8ob3BlcmF0b3IsIG9wdF9maWx0ZXIpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmNyZWF0ZUJvZHlfKG9wZXJhdG9yLCB0aGlzLmJvZHlfKTtcbiAgICB9XG4gIH1cblxuICAvKipcblx0ICogQ29tcG9zZXMgdGhlIGN1cnJlbnQgZmlsdGVyIHdpdGggYW4gb3BlcmF0b3IgdGhhdCBzdG9yZXMgaXRzIHZhbHVlcyBpbiBhblxuXHQgKiBhcnJheS5cblx0ICogQHBhcmFtIHtzdHJpbmd9IG9wZXJhdG9yXG5cdCAqIEBwYXJhbSB7IUZpbHRlcn0gZmlsdGVyXG5cdCAqIEBwcm90ZWN0ZWRcblx0ICovXG4gIGFkZEFycmF5T3BlcmF0b3JfKG9wZXJhdG9yLCBmaWx0ZXIpIHtcbiAgICBpZiAoISh0aGlzLmJvZHlfW29wZXJhdG9yXSBpbnN0YW5jZW9mIEFycmF5KSkge1xuICAgICAgdGhpcy5jcmVhdGVCb2R5XyhvcGVyYXRvciwgW3RoaXMuYm9keV9dKTtcbiAgICB9XG4gICAgdGhpcy5ib2R5X1tvcGVyYXRvcl0ucHVzaChmaWx0ZXIuYm9keSgpKTtcbiAgfVxuXG4gIC8qKlxuXHQgKiBBZGRzIGZpbHRlcnMgdG8gYmUgY29tcG9zZWQgd2l0aCB0aGlzIGZpbHRlciBib2R5IHVzaW5nIHRoZSBnaXZlbiBvcGVyYXRvci5cblx0ICogQHBhcmFtIHtzdHJpbmd9IG9wZXJhdG9yXG5cdCAqIEBwYXJhbSB7Li4uKn0gZmlsdGVycyBBIHZhcmlhYmxlIGFtb3VudCBvZiBmaWx0ZXJzIHRvIGJlIGNvbXBvc2VkLlxuXHQgKi9cbiAgYWRkTWFueShvcGVyYXRvciwgLi4uZmlsdGVycykge1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZmlsdGVycy5sZW5ndGg7IGkrKykge1xuICAgICAgdGhpcy5hZGQob3BlcmF0b3IsIGZpbHRlcnNbaV0pO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuXHQgKiBDcmVhdGVzIGEgbmV3IGJvZHkgb2JqZWN0LCBzZXR0aW5nIHRoZSByZXF1ZXN0ZWQga2V5IHRvIHRoZSBnaXZlbiB2YWx1ZS5cblx0ICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IHRvIHNldCBpbiB0aGUgbmV3IGJvZHkgb2JqZWN0XG5cdCAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRoZSByZXF1ZXN0ZWQga2V5IHNob3VsZCBoYXZlIGluIHRoZSBuZXcgYm9keVxuXHQgKiAgIG9iamVjdC5cblx0ICogQHByb3RlY3RlZFxuXHQgKi9cbiAgY3JlYXRlQm9keV8oa2V5LCB2YWx1ZSkge1xuICAgIHRoaXMuYm9keV8gPSB7fTtcbiAgICB0aGlzLmJvZHlfW2tleV0gPSB2YWx1ZTtcbiAgfVxuXG4gIC8qKlxuXHQgKiBHZXRzIHRoZSBqc29uIG9iamVjdCB0aGF0IHJlcHJlc2VudHMgdGhpcyBmaWx0ZXIncyBib2R5LlxuXHQgKiBAcmV0dXJuIHshT2JqZWN0fVxuXHQgKi9cbiAgZ2V0T2JqZWN0KCkge1xuICAgIHJldHVybiB0aGlzLmJvZHlfO1xuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IEZpbHRlckJvZHk7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zcmMvYXBpLXF1ZXJ5L0ZpbHRlckJvZHkuanMiLCIndXNlIHN0cmljdCc7XG5cbmltcG9ydCB7Y29yZX0gZnJvbSAnbWV0YWwnO1xuaW1wb3J0IENsaWVudE1lc3NhZ2UgZnJvbSAnLi9DbGllbnRNZXNzYWdlJztcbmltcG9ydCB7TXVsdGlNYXB9IGZyb20gJ21ldGFsLXN0cnVjdHMnO1xuXG4vKipcbiAqIFJlcHJlc2VudHMgYSBjbGllbnQgcmVxdWVzdCBvYmplY3QuXG4gKiBAZXh0ZW5kcyB7Q2xpZW50TWVzc2FnZX1cbiAqL1xuY2xhc3MgQ2xpZW50UmVxdWVzdCBleHRlbmRzIENsaWVudE1lc3NhZ2Uge1xuICAvKipcblx0ICogQ29uc3RydWN0cyBhbiB7QGxpbmsgQ2xpZW50UmVxdWVzdH0gaW5zdGFuY2UuXG5cdCAqIEBjb25zdHJ1Y3RvclxuXHQgKi9cbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoKTtcbiAgICB0aGlzLnBhcmFtc18gPSBuZXcgTXVsdGlNYXAoKTtcbiAgICB0aGlzLndpdGhDcmVkZW50aWFsc18gPSB0cnVlO1xuICB9XG5cbiAgLyoqXG5cdCAqIEZsdWVudCBnZXR0ZXIgYW5kIHNldHRlciBmb3Igd2l0aCBjcmVkZW50aWFscyBvcHRpb24uXG5cdCAqIEBwYXJhbSB7Ym9vbGVhbj19IG9wdF93aXRoQ3JlZGVudGlhbHNcblx0ICogQHJldHVybiB7IUNsaWVudFJlcXVlc3R8Ym9vbGVhbn0gUmV0dXJucyB0aGUge0BsaW5rIENsaWVudE1lc3NhZ2V9IG9iamVjdFxuXHQgKiAgIGl0c2VsZiB3aGVuIHVzZWQgYXMgc2V0dGVyLCBvdGhlcndpc2UgcmV0dXJucyB0aGUgY3VycmVudCB2YWx1ZSBvZiB3aXRoXG5cdCAqICAgY3JlZGVudGlhbHMgb3B0aW9uLlxuXHQgKiBAY2hhaW5hYmxlIENoYWluYWJsZSB3aGVuIHVzZWQgYXMgc2V0dGVyLlxuXHQgKi9cbiAgd2l0aENyZWRlbnRpYWxzKG9wdF93aXRoQ3JlZGVudGlhbHMpIHtcbiAgICBpZiAoY29yZS5pc0RlZihvcHRfd2l0aENyZWRlbnRpYWxzKSkge1xuICAgICAgdGhpcy53aXRoQ3JlZGVudGlhbHNfID0gISFvcHRfd2l0aENyZWRlbnRpYWxzO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLndpdGhDcmVkZW50aWFsc187XG4gIH1cblxuICAvKipcblx0ICogRmx1ZW50IGdldHRlciBhbmQgc2V0dGVyIGZvciByZXF1ZXN0IG1ldGhvZC5cblx0ICogQHBhcmFtIHtzdHJpbmc9fSBvcHRfbWV0aG9kIFJlcXVlc3QgbWV0aG9kIHRvIGJlIHNldC4gSWYgbm9uZSBpcyBnaXZlbixcblx0ICogICB0aGUgY3VycmVudCBtZXRob2QgdmFsdWUgd2lsbCBiZSByZXR1cm5lZC5cblx0ICogQHJldHVybiB7IUNsaWVudE1lc3NhZ2V8c3RyaW5nfSBSZXR1cm5zIHJlcXVlc3QgbWV0aG9kIGlmIG5vIG5ldyB2YWx1ZSB3YXNcblx0ICogICBnaXZlbi4gT3RoZXJ3aXNlIHJldHVybnMgdGhlIHtAbGluayBDbGllbnRNZXNzYWdlfSBvYmplY3QgaXRzZWxmLCBzb1xuXHQgKiAgIGNhbGxzIGNhbiBiZSBjaGFpbmVkLlxuXHQgKiBAY2hhaW5hYmxlIENoYWluYWJsZSB3aGVuIHVzZWQgYXMgc2V0dGVyLlxuXHQgKi9cbiAgbWV0aG9kKG9wdF9tZXRob2QpIHtcbiAgICBpZiAoY29yZS5pc0RlZihvcHRfbWV0aG9kKSkge1xuICAgICAgdGhpcy5tZXRob2RfID0gb3B0X21ldGhvZDtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5tZXRob2RfIHx8IENsaWVudFJlcXVlc3QuREVGQVVMVF9NRVRIT0Q7XG4gIH1cblxuICAvKipcblx0ICogQWRkcyBhIHF1ZXJ5LiBJZiBhIHF1ZXJ5IHdpdGggdGhlIHNhbWUgbmFtZSBhbHJlYWR5IGV4aXN0cywgaXQgd2lsbCBub3Rcblx0ICogYmUgb3ZlcndyaXR0ZW4sIGJ1dCBuZXcgdmFsdWUgd2lsbCBiZSBzdG9yZWQgYXMgd2VsbC4gVGhlIG9yZGVyIGlzXG5cdCAqIHByZXNlcnZlZC5cblx0ICogQHBhcmFtIHtzdHJpbmd9IG5hbWVcblx0ICogQHBhcmFtIHtzdHJpbmd9IHZhbHVlXG5cdCAqIEByZXR1cm4geyFDbGllbnRNZXNzYWdlfSBSZXR1cm5zIHRoZSB7QGxpbmsgQ2xpZW50TWVzc2FnZX0gb2JqZWN0IGl0c2VsZixcblx0ICogICBzbyBjYWxscyBjYW4gYmUgY2hhaW5lZC5cblx0ICogQGNoYWluYWJsZVxuXHQgKi9cbiAgcGFyYW0obmFtZSwgdmFsdWUpIHtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCAhPT0gMikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGFyZ3VtZW50cycpO1xuICAgIH1cbiAgICB0aGlzLnBhcmFtc18uc2V0KG5hbWUsIHZhbHVlKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8qKlxuXHQgKiBGbHVlbnQgZ2V0dGVyIGFuZCBzZXR0ZXIgZm9yIHJlcXVlc3QgcXVlcnlzdHJpbmcuXG5cdCAqIEBwYXJhbSB7TXVsdGlNYXB8T2JqZWN0PX0gb3B0X3BhcmFtcyBSZXF1ZXN0IHF1ZXJ5c3RyaW5nIG1hcCB0byBiZSBzZXQuXG5cdCAqICAgSWYgbm9uZSBpcyBnaXZlbiB0aGUgY3VycmVudCB2YWx1ZSBvZiB0aGUgcGFyYW1zIHdpbGwgYmUgcmV0dXJuZWQuXG5cdCAqIEByZXR1cm4geyFNdWx0aU1hcHxDbGllbnRNZXNzYWdlfSBSZXR1cm5zIG1hcCBvZiByZXF1ZXN0IHF1ZXJ5c3RyaW5nIGlmXG5cdCAqICAgbm8gbmV3IHZhbHVlIHdhcyBnaXZlbi4gT3RoZXJ3aXNlIHJldHVybnMgdGhlIHtAbGluayBDbGllbnRNZXNzYWdlfVxuXHQgKiAgIG9iamVjdCBpdHNlbGYsIHNvIGNhbGxzIGNhbiBiZSBjaGFpbmVkLlxuXHQgKi9cbiAgcGFyYW1zKG9wdF9wYXJhbXMpIHtcbiAgICBpZiAoY29yZS5pc0RlZihvcHRfcGFyYW1zKSkge1xuICAgICAgaWYgKG9wdF9wYXJhbXMgaW5zdGFuY2VvZiBNdWx0aU1hcCkge1xuICAgICAgICB0aGlzLnBhcmFtc18gPSBvcHRfcGFyYW1zO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5wYXJhbXNfLnZhbHVlcyA9IG9wdF9wYXJhbXM7XG4gICAgICB9XG4gICAgICByZXR1cm4gb3B0X3BhcmFtcztcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMucGFyYW1zXztcbiAgfVxuXG4gIC8qKlxuXHQgKiBGbHVlbnQgZ2V0dGVyIGFuZCBzZXR0ZXIgZm9yIHJlcXVlc3QgdXJsLlxuXHQgKiBAcGFyYW0ge3N0cmluZz19IG9wdF91cmwgUmVxdWVzdCB1cmwgdG8gYmUgc2V0LiBJZiBub25lIGlzIGdpdmVuLFxuXHQgKiAgIHRoZSBjdXJyZW50IHZhbHVlIG9mIHRoZSB1cmwgd2lsbCBiZSByZXR1cm5lZC5cblx0ICogQHJldHVybiB7IUNsaWVudE1lc3NhZ2V8c3RyaW5nfSBSZXR1cm5zIHJlcXVlc3QgdXJsIGlmIG5vIG5ldyB2YWx1ZSB3YXNcblx0ICogIGdpdmVuLlxuXHQgKiAgT3RoZXJ3aXNlIHJldHVybnMgdGhlIHtAbGluayBDbGllbnRNZXNzYWdlfSBvYmplY3QgaXRzZWxmLCBzbyBjYWxscyBjYW4gYmVcblx0ICogIGNoYWluZWQuXG5cdCAqIEBjaGFpbmFibGUgQ2hhaW5hYmxlIHdoZW4gdXNlZCBhcyBzZXR0ZXIuXG5cdCAqL1xuICB1cmwob3B0X3VybCkge1xuICAgIGlmIChjb3JlLmlzRGVmKG9wdF91cmwpKSB7XG4gICAgICB0aGlzLnVybF8gPSBvcHRfdXJsO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLnVybF87XG4gIH1cbn1cblxuQ2xpZW50UmVxdWVzdC5ERUZBVUxUX01FVEhPRCA9ICdHRVQnO1xuXG5leHBvcnQgZGVmYXVsdCBDbGllbnRSZXF1ZXN0O1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL2FwaS9DbGllbnRSZXF1ZXN0LmpzIiwiJ3VzZSBzdHJpY3QnO1xuXG5pbXBvcnQge2NvcmV9IGZyb20gJ21ldGFsJztcbmltcG9ydCBDbGllbnRNZXNzYWdlIGZyb20gJy4vQ2xpZW50TWVzc2FnZSc7XG5cbi8qKlxuICogUmVwcmVzZW50cyBhIGNsaWVudCByZXNwb25zZSBvYmplY3QuXG4gKiBAZXh0ZW5kcyB7Q2xpZW50TWVzc2FnZX1cbiAqL1xuY2xhc3MgQ2xpZW50UmVzcG9uc2UgZXh0ZW5kcyBDbGllbnRNZXNzYWdlIHtcbiAgLyoqXG5cdCAqIENvbnN0cnVjdHMgYW4ge0BsaW5rIENsaWVudFJlc3BvbnNlfSBpbnN0YW5jZS5cblx0ICogQHBhcmFtIHshQ2xpZW50UmVxdWVzdH0gY2xpZW50UmVxdWVzdCBJbnN0YW5jZSBvZiB7QGxpbmsgQ2xpZW50UmVxdWVzdH1cblx0ICogICBvYmplY3QuXG5cdCAqIEBjb25zdHJ1Y3RvclxuXHQgKi9cbiAgY29uc3RydWN0b3IoY2xpZW50UmVxdWVzdCkge1xuICAgIHN1cGVyKCk7XG4gICAgaWYgKCFjbGllbnRSZXF1ZXN0KSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0NhbiBub3QgY3JlYXRlIHJlc3BvbnNlIHdpdGhvdXQgcmVxdWVzdCcpO1xuICAgIH1cbiAgICB0aGlzLmNsaWVudFJlcXVlc3RfID0gY2xpZW50UmVxdWVzdDtcbiAgfVxuXG4gIC8qKlxuXHQgKiBSZXR1cm5zIHJlcXVlc3QgdGhhdCBjcmVhdGVkIHRoaXMgcmVzcG9uc2UuXG5cdCAqIEByZXR1cm4geyFDbGllbnRSZXF1ZXN0fVxuXHQgKi9cbiAgcmVxdWVzdCgpIHtcbiAgICByZXR1cm4gdGhpcy5jbGllbnRSZXF1ZXN0XztcbiAgfVxuXG4gIC8qKlxuXHQgKiBGbHVlbnQgZ2V0dGVyIGFuZCBzZXR0ZXIgZm9yIHJlc3BvbnNlIHN0YXR1cyBjb2RlLlxuXHQgKiBAcGFyYW0ge251bWJlcj19IG9wdF9zdGF0dXNDb2RlIFJlcXVlc3Qgc3RhdHVzIGNvZGUgdG8gYmUgc2V0LiBJZiBub25lIGlzXG5cdCAqICBnaXZlbiwgdGhlIGN1cnJlbnQgc3RhdHVzIGNvZGUgdmFsdWUgd2lsbCBiZSByZXR1cm5lZC5cblx0ICogQHJldHVybiB7IUNsaWVudE1lc3NhZ2V8bnVtYmVyfSBSZXR1cm5zIHJlc3BvbnNlIHN0YXR1cyBjb2RlIGlmIG5vIG5ld1xuXHQgKiAgIHZhbHVlIHdhcyBnaXZlbi4gT3RoZXJ3aXNlIHJldHVybnMgdGhlIHtAbGluayBDbGllbnRNZXNzYWdlfSBvYmplY3Rcblx0ICogICBpdHNlbGYsIHNvIGNhbGxzIGNhbiBiZSBjaGFpbmVkLlxuXHQgKiBAY2hhaW5hYmxlIENoYWluYWJsZSB3aGVuIHVzZWQgYXMgc2V0dGVyLlxuXHQgKi9cbiAgc3RhdHVzQ29kZShvcHRfc3RhdHVzQ29kZSkge1xuICAgIGlmIChjb3JlLmlzRGVmKG9wdF9zdGF0dXNDb2RlKSkge1xuICAgICAgdGhpcy5zdGF0dXNDb2RlXyA9IG9wdF9zdGF0dXNDb2RlO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLnN0YXR1c0NvZGVfO1xuICB9XG5cbiAgLyoqXG5cdCAqIEZsdWVudCBnZXR0ZXIgYW5kIHNldHRlciBmb3IgcmVzcG9uc2Ugc3RhdHVzIHRleHQuXG5cdCAqIEBwYXJhbSB7c3RyaW5nPX0gb3B0X3N0YXR1c1RleHQgUmVxdWVzdCBzdGF0dXMgdGV4dCB0byBiZSBzZXQuIElmIG5vbmUgaXNcblx0ICogICBnaXZlbiwgdGhlIGN1cnJlbnQgc3RhdHVzIHRleHQgdmFsdWUgd2lsbCBiZSByZXR1cm5lZC5cblx0ICogQHJldHVybiB7IUNsaWVudE1lc3NhZ2V8bnVtYmVyfSBSZXR1cm5zIHJlc3BvbnNlIHN0YXR1cyB0ZXh0IGlmIG5vIG5ld1xuXHQgKiAgIHZhbHVlIHdhcyBnaXZlbi4gT3RoZXJ3aXNlIHJldHVybnMgdGhlIHtAbGluayBDbGllbnRNZXNzYWdlfSBvYmplY3Rcblx0ICogICBpdHNlbGYsIHNvIGNhbGxzIGNhbiBiZSBjaGFpbmVkLlxuXHQgKiBAY2hhaW5hYmxlIENoYWluYWJsZSB3aGVuIHVzZWQgYXMgc2V0dGVyLlxuXHQgKi9cbiAgc3RhdHVzVGV4dChvcHRfc3RhdHVzVGV4dCkge1xuICAgIGlmIChjb3JlLmlzRGVmKG9wdF9zdGF0dXNUZXh0KSkge1xuICAgICAgdGhpcy5zdGF0dXNUZXh0XyA9IG9wdF9zdGF0dXNUZXh0O1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLnN0YXR1c1RleHRfO1xuICB9XG5cbiAgLyoqXG5cdCAqIENoZWNrcyBpZiByZXNwb25zZSBzdWNjZWVkZWQuIEFueSBzdGF0dXMgY29kZSAyeHggb3IgM3h4IGlzIGNvbnNpZGVyZWRcblx0ICogdmFsaWQuXG5cdCAqIEByZXR1cm4ge2Jvb2xlYW59XG5cdCAqL1xuICBzdWNjZWVkZWQoKSB7XG4gICAgcmV0dXJuIHRoaXMuc3RhdHVzQ29kZSgpID49IDIwMCAmJiB0aGlzLnN0YXR1c0NvZGUoKSA8PSAzOTk7XG4gIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgQ2xpZW50UmVzcG9uc2U7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zcmMvYXBpL0NsaWVudFJlc3BvbnNlLmpzIiwiJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqIFByb3ZpZGVzIGEgY29udmVuaWVudCBpbnRlcmZhY2UgZm9yIGRhdGEgdHJhbnNwb3J0LlxuICogQGludGVyZmFjZVxuICovXG5jbGFzcyBUcmFuc3BvcnQge1xuICAvKipcblx0ICogU2VuZHMgYSBtZXNzYWdlIGZvciB0aGUgc3BlY2lmaWVkIGNsaWVudC5cblx0ICogQG1ldGhvZCBzZW5kXG5cdCAqIEBwYXJhbSB7IUNsaWVudFJlcXVlc3R9IGNsaWVudFJlcXVlc3Rcblx0ICogQHJldHVybiB7IVByb21pc2V9IERlZmVycmVkIHJlcXVlc3QuXG5cdCAqL1xufVxuXG5leHBvcnQgZGVmYXVsdCBUcmFuc3BvcnQ7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zcmMvYXBpL1RyYW5zcG9ydC5qcyIsIid1c2Ugc3RyaWN0JztcblxuaW1wb3J0IEFqYXhUcmFuc3BvcnQgZnJvbSAnLi9icm93c2VyL0FqYXhUcmFuc3BvcnQnO1xuXG4vKipcbiAqIFByb3ZpZGVzIGEgZmFjdG9yeSBmb3IgZGF0YSB0cmFuc3BvcnQuXG4gKi9cbmNsYXNzIFRyYW5zcG9ydEZhY3Rvcnkge1xuICAvKipcblx0ICogQ29uc3RydWN0cyBhbiB7QGxpbmsgVHJhbnNwb3J0RmFjdG9yeX0gaW5zdGFuY2UuXG5cdCAqIEBjb25zdHJ1Y3RvclxuXHQgKi9cbiAgY29uc3RydWN0b3IoKSB7XG4gICAgdGhpcy50cmFuc3BvcnRzID0ge307XG4gICAgdGhpcy50cmFuc3BvcnRzW1RyYW5zcG9ydEZhY3RvcnkuREVGQVVMVF9UUkFOU1BPUlRfTkFNRV0gPVxuICAgICAgVHJhbnNwb3J0RmFjdG9yeVtUcmFuc3BvcnRGYWN0b3J5LkRFRkFVTFRfVFJBTlNQT1JUX05BTUVdO1xuICB9XG5cbiAgLyoqXG5cdCAqIFJldHVybnMge0BsaW5rIFRyYW5zcG9ydEZhY3Rvcnl9IGluc3RhbmNlLlxuXHQgKiBAcmV0dXJuIHshVHJhbnNwb3J0RmFjdG9yeX0gSW5zdGFuY2Ugb2YgVHJhbnNwb3J0RmFjdG9yeVxuXHQgKi9cbiAgc3RhdGljIGluc3RhbmNlKCkge1xuICAgIGlmICghVHJhbnNwb3J0RmFjdG9yeS5pbnN0YW5jZV8pIHtcbiAgICAgIFRyYW5zcG9ydEZhY3RvcnkuaW5zdGFuY2VfID0gbmV3IFRyYW5zcG9ydEZhY3RvcnkoKTtcbiAgICB9XG4gICAgcmV0dXJuIFRyYW5zcG9ydEZhY3RvcnkuaW5zdGFuY2VfO1xuICB9XG5cbiAgLyoqXG5cdCAqIEdldHMgYW4gaW5zdGFuY2Ugb2YgdGhlIHRyYW5zcG9ydCBpbXBsZW1lbnRhdGlvbiB3aXRoIHRoZSBnaXZlbiBuYW1lLlxuXHQgKiBAcGFyYW0ge3N0cmluZ30gaW1wbGVtZW50YXRpb25OYW1lXG5cdCAqIEByZXR1cm4geyFUcmFuc3BvcnR9XG5cdCAqL1xuICBnZXQoaW1wbGVtZW50YXRpb25OYW1lKSB7XG4gICAgbGV0IFRyYW5zcG9ydENsYXNzID0gdGhpcy50cmFuc3BvcnRzW2ltcGxlbWVudGF0aW9uTmFtZV07XG5cbiAgICBpZiAoIVRyYW5zcG9ydENsYXNzKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgdHJhbnNwb3J0IG5hbWU6ICcgKyBpbXBsZW1lbnRhdGlvbk5hbWUpO1xuICAgIH1cblxuICAgIHRyeSB7XG4gICAgICByZXR1cm4gbmV3IFRyYW5zcG9ydENsYXNzKCk7XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0NhbiBub3QgY3JlYXRlIHRyYW5zcG9ydCcsIGVycik7XG4gICAgfVxuICB9XG5cbiAgLyoqXG5cdCAqIFJldHVybnMgdGhlIGRlZmF1bHQgdHJhbnNwb3J0IGltcGxlbWVudGF0aW9uLlxuXHQgKiBAcmV0dXJuIHshVHJhbnNwb3J0fVxuXHQgKi9cbiAgZ2V0RGVmYXVsdCgpIHtcbiAgICByZXR1cm4gdGhpcy5nZXQoVHJhbnNwb3J0RmFjdG9yeS5ERUZBVUxUX1RSQU5TUE9SVF9OQU1FKTtcbiAgfVxufVxuXG5UcmFuc3BvcnRGYWN0b3J5LkRFRkFVTFRfVFJBTlNQT1JUX05BTUUgPSAnZGVmYXVsdCc7XG5cblRyYW5zcG9ydEZhY3RvcnlbVHJhbnNwb3J0RmFjdG9yeS5ERUZBVUxUX1RSQU5TUE9SVF9OQU1FXSA9IEFqYXhUcmFuc3BvcnQ7XG5cbmV4cG9ydCBkZWZhdWx0IFRyYW5zcG9ydEZhY3Rvcnk7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zcmMvYXBpL1RyYW5zcG9ydEZhY3RvcnkuanMiLCIndXNlIHN0cmljdCc7XG5cbmltcG9ydCBBdXRoIGZyb20gJy4vQXV0aCc7XG5pbXBvcnQgQXBpSGVscGVyIGZyb20gJy4uL0FwaUhlbHBlcic7XG5pbXBvcnQgRmFjZWJvb2tBdXRoUHJvdmlkZXIgZnJvbSAnLi9GYWNlYm9va0F1dGhQcm92aWRlcic7XG5pbXBvcnQgR2l0aHViQXV0aFByb3ZpZGVyIGZyb20gJy4vR2l0aHViQXV0aFByb3ZpZGVyJztcbmltcG9ydCBnbG9iYWxzIGZyb20gJy4uLy4uL2dsb2JhbHMvZ2xvYmFscyc7XG5pbXBvcnQgR29vZ2xlQXV0aFByb3ZpZGVyIGZyb20gJy4vR29vZ2xlQXV0aFByb3ZpZGVyJztcbmltcG9ydCB7U3RvcmFnZSwgTG9jYWxTdG9yYWdlTWVjaGFuaXNtfSBmcm9tICdtZXRhbC1zdG9yYWdlJztcblxuaW1wb3J0IHtcbiAgYXNzZXJ0RGVmQW5kTm90TnVsbCxcbiAgYXNzZXJ0RnVuY3Rpb24sXG4gIGFzc2VydE9iamVjdCxcbiAgYXNzZXJ0VXNlclNpZ25lZEluLFxuICBhc3NlcnRCcm93c2VyRW52aXJvbm1lbnQsXG4gIGFzc2VydFJlc3BvbnNlU3VjY2VlZGVkLFxufSBmcm9tICcuLi9hc3NlcnRpb25zJztcblxuLyoqXG4gKiBDbGFzcyByZXNwb25zaWJsZSBmb3IgZW5jYXBzdWxhdGluZyBhdXRoIEFQSSBjYWxscy5cbiAqL1xuY2xhc3MgQXV0aEFwaUhlbHBlciBleHRlbmRzIEFwaUhlbHBlciB7XG4gIC8qKlxuXHQgKiBDb25zdHJ1Y3RzIGFuIHtAbGluayBBdXRoQXBpSGVscGVyfSBpbnN0YW5jZS5cblx0ICogQHBhcmFtIHshc3RyaW5nfSB3ZWRlcGxveUNsaWVudFxuXHQgKiBAY29uc3RydWN0b3Jcblx0ICovXG4gIGNvbnN0cnVjdG9yKHdlZGVwbG95Q2xpZW50KSB7XG4gICAgc3VwZXIod2VkZXBsb3lDbGllbnQpO1xuICAgIHRoaXMuY3VycmVudFVzZXIgPSBudWxsO1xuICAgIHRoaXMub25TaWduSW5DYWxsYmFjayA9IG51bGw7XG4gICAgdGhpcy5vblNpZ25PdXRDYWxsYmFjayA9IG51bGw7XG5cbiAgICBpZiAoTG9jYWxTdG9yYWdlTWVjaGFuaXNtLmlzU3VwcG9ydGVkKCkpIHtcbiAgICAgIHRoaXMuc3RvcmFnZSA9IG5ldyBTdG9yYWdlKG5ldyBMb2NhbFN0b3JhZ2VNZWNoYW5pc20oKSk7XG4gICAgfVxuXG4gICAgdGhpcy5wcm9jZXNzU2lnbkluXygpO1xuXG4gICAgdGhpcy5wcm92aWRlciA9IHtcbiAgICAgIEZhY2Vib29rOiBGYWNlYm9va0F1dGhQcm92aWRlcixcbiAgICAgIEdvb2dsZTogR29vZ2xlQXV0aFByb3ZpZGVyLFxuICAgICAgR2l0aHViOiBHaXRodWJBdXRoUHJvdmlkZXIsXG4gICAgfTtcbiAgfVxuXG4gIC8qKlxuXHQgKiBDcmVhdGVzIGFjY2VzcyB0b2tlbiBjb29raWUuXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBhY2Nlc3NUb2tlblxuXHQgKi9cbiAgY3JlYXRlQWNjZXNzVG9rZW5Db29raWUoYWNjZXNzVG9rZW4pIHtcbiAgICBpZiAoZ2xvYmFscy5kb2N1bWVudCAmJiBnbG9iYWxzLndpbmRvdykge1xuICAgICAgZ2xvYmFscy5kb2N1bWVudC5jb29raWUgPVxuICAgICAgICAnYWNjZXNzX3Rva2VuPScgK1xuICAgICAgICBhY2Nlc3NUb2tlbiArXG4gICAgICAgICc7IERvbWFpbj0nICtcbiAgICAgICAgZ2xvYmFscy53aW5kb3cubG9jYXRpb24uaG9zdG5hbWUgK1xuICAgICAgICAnOyc7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhXG4gICAqIEByZXR1cm4ge0F1dGh9XG4gICAqL1xuICBjcmVhdGVBdXRoRnJvbURhdGEoZGF0YSkge1xuICAgIGNvbnN0IGF1dGggPSBBdXRoLmNyZWF0ZUZyb21EYXRhKGRhdGEpO1xuICAgIGF1dGguc2V0V2VkZXBsb3lDbGllbnQodGhpcy53ZWRlcGxveUNsaWVudCk7XG4gICAgcmV0dXJuIGF1dGg7XG4gIH1cblxuICAvKipcblx0ICogQ3JlYXRlcyB1c2VyLlxuXHQgKiBAcGFyYW0geyFPYmplY3R9IGRhdGEgVGhlIGRhdGEgdG8gYmUgdXNlZCB0byBjcmVhdGUgdGhlIHVzZXIuXG5cdCAqIEByZXR1cm4ge0NhbmNlbGxhYmxlUHJvbWlzZX1cblx0ICovXG4gIGNyZWF0ZVVzZXIoZGF0YSkge1xuICAgIGFzc2VydE9iamVjdChkYXRhLCAnVXNlciBkYXRhIG11c3QgYmUgc3BlY2lmaWVkIGFzIG9iamVjdCcpO1xuXG4gICAgbGV0IHJlcXVlc3QgPSB0aGlzLmJ1aWxkVXJsXygpLnBhdGgoJy91c2VycycpO1xuXG4gICAgbGV0IGF1dGhTY29wZSA9IHRoaXMucmVzb2x2ZUF1dGhTY29wZSgpO1xuICAgIGlmIChhdXRoU2NvcGUpIHtcbiAgICAgIHJlcXVlc3QuYXV0aChhdXRoU2NvcGUudG9rZW4pO1xuICAgIH1cblxuICAgIHJldHVybiByZXF1ZXN0XG4gICAgICAucG9zdChkYXRhKVxuICAgICAgLnRoZW4ocmVzcG9uc2UgPT4gYXNzZXJ0UmVzcG9uc2VTdWNjZWVkZWQocmVzcG9uc2UpKVxuICAgICAgLnRoZW4ocmVzcG9uc2UgPT4gdGhpcy5jcmVhdGVBdXRoRnJvbURhdGEocmVzcG9uc2UuYm9keSgpKSk7XG4gIH1cblxuICAvKipcblx0ICogRGVsZXRlcyBhY2Nlc3MgdG9rZW4gY29va2llLlxuXHQgKi9cbiAgZGVsZXRlQWNjZXNzVG9rZW5Db29raWUoKSB7XG4gICAgaWYgKGdsb2JhbHMuZG9jdW1lbnQgJiYgZ2xvYmFscy53aW5kb3cpIHtcbiAgICAgIGdsb2JhbHMuZG9jdW1lbnQuY29va2llID1cbiAgICAgICAgJ2FjY2Vzc190b2tlbj07ZXhwaXJlcz1UaHUsIDAxIEphbiAxOTcwIDAwOjAwOjAxIEdNVDtEb21haW49JyArXG4gICAgICAgIGdsb2JhbHMud2luZG93LmxvY2F0aW9uLmhvc3RuYW1lICtcbiAgICAgICAgJzsnO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBEZWxldGVzIHVzZXIgYnkgaWQuXG4gICAqIEBwYXJhbSB7IXN0cmluZ30gdXNlcklkXG4gICAqIEByZXR1cm4ge0NhbmNlbGxhYmxlUHJvbWlzZX1cbiAgICovXG4gIGRlbGV0ZVVzZXIodXNlcklkKSB7XG4gICAgYXNzZXJ0RGVmQW5kTm90TnVsbCh1c2VySWQsICdDYW5ub3QgZGVsZXRlIHVzZXIgd2l0aG91dCBpZCcpO1xuICAgIGFzc2VydFVzZXJTaWduZWRJbih0aGlzLmN1cnJlbnRVc2VyKTtcbiAgICByZXR1cm4gdGhpcy5idWlsZFVybF8oKVxuICAgICAgLnBhdGgoJy91c2VycycsIHVzZXJJZClcbiAgICAgIC5hdXRoKHRoaXMucmVzb2x2ZUF1dGhTY29wZSgpLnRva2VuKVxuICAgICAgLmRlbGV0ZSgpXG4gICAgICAudGhlbihyZXNwb25zZSA9PiBhc3NlcnRSZXNwb25zZVN1Y2NlZWRlZChyZXNwb25zZSkpO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldHMgYWxsIGF1dGggdXNlcnNcbiAgICogQHBhcmFtIHshc3RyaW5nfSB1c2VySWRcbiAgICogQHJldHVybiB7Q2FuY2VsbGFibGVQcm9taXNlfVxuICAgKi9cbiAgZ2V0QWxsVXNlcnMoKSB7XG4gICAgYXNzZXJ0VXNlclNpZ25lZEluKHRoaXMuY3VycmVudFVzZXIpO1xuICAgIHJldHVybiB0aGlzLmJ1aWxkVXJsXygpXG4gICAgICAucGF0aCgnL3VzZXJzJylcbiAgICAgIC5hdXRoKHRoaXMucmVzb2x2ZUF1dGhTY29wZSgpLnRva2VuKVxuICAgICAgLmdldCgpXG4gICAgICAudGhlbihyZXNwb25zZSA9PiBhc3NlcnRSZXNwb25zZVN1Y2NlZWRlZChyZXNwb25zZSkpXG4gICAgICAudGhlbihyZXNwb25zZSA9PiByZXNwb25zZS5ib2R5KCkubWFwKHRoaXMuY3JlYXRlQXV0aEZyb21EYXRhLCB0aGlzKSk7XG4gIH1cblxuICAvKipcblx0ICogR2V0cyB0aGUgY3VycmVudCBicm93c2VyIHVybCB3aXRob3V0IHRoZSBmcmFnbWVudCBwYXJ0LlxuXHQgKiBAcmV0dXJuIHshc3RyaW5nfVxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqL1xuICBnZXRIcmVmV2l0aG91dEZyYWdtZW50XygpIHtcbiAgICBsZXQgbG9jYXRpb24gPSBnbG9iYWxzLndpbmRvdy5sb2NhdGlvbjtcbiAgICByZXR1cm4gKFxuICAgICAgbG9jYXRpb24ucHJvdG9jb2wgK1xuICAgICAgJy8vJyArXG4gICAgICBsb2NhdGlvbi5ob3N0ICtcbiAgICAgIGxvY2F0aW9uLnBhdGhuYW1lICtcbiAgICAgIChsb2NhdGlvbi5zZWFyY2ggPyBsb2NhdGlvbi5zZWFyY2ggOiAnJylcbiAgICApO1xuICB9XG5cbiAgLyoqXG5cdCAqIEdldHMgdGhlIGFjY2VzcyB0b2tlbiBmcm9tIHRoZSB1cmwgZnJhZ21lbnQgYW5kIHJlbW92ZXMgaXQuXG5cdCAqIEByZXR1cm4gez9zdHJpbmd9XG5cdCAqIEBwcm90ZWN0ZWRcblx0ICovXG4gIGdldFJlZGlyZWN0QWNjZXNzVG9rZW5fKCkge1xuICAgIGlmIChnbG9iYWxzLndpbmRvdyAmJiBnbG9iYWxzLndpbmRvdy5sb2NhdGlvbikge1xuICAgICAgbGV0IGZyYWdtZW50ID0gZ2xvYmFscy53aW5kb3cubG9jYXRpb24uaGFzaDtcbiAgICAgIGlmIChmcmFnbWVudC5pbmRleE9mKCcjYWNjZXNzX3Rva2VuPScpID09PSAwKSB7XG4gICAgICAgIHJldHVybiBmcmFnbWVudC5zdWJzdHJpbmcoMTQpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIC8qKlxuXHQgKiBHZXRzIHVzZXIgYnkgaWQuXG5cdCAqIEBwYXJhbSB7IXN0cmluZ30gdXNlcklkXG5cdCAqIEByZXR1cm4ge0NhbmNlbGxhYmxlUHJvbWlzZX1cblx0ICovXG4gIGdldFVzZXIodXNlcklkKSB7XG4gICAgYXNzZXJ0RGVmQW5kTm90TnVsbCh1c2VySWQsICdVc2VyIHVzZXJJZCBtdXN0IGJlIHNwZWNpZmllZCcpO1xuICAgIGFzc2VydFVzZXJTaWduZWRJbih0aGlzLmN1cnJlbnRVc2VyKTtcbiAgICByZXR1cm4gdGhpcy5idWlsZFVybF8oKVxuICAgICAgLnBhdGgoJy91c2VycycsIHVzZXJJZClcbiAgICAgIC5hdXRoKHRoaXMucmVzb2x2ZUF1dGhTY29wZSgpLnRva2VuKVxuICAgICAgLmdldCgpXG4gICAgICAudGhlbihyZXNwb25zZSA9PiBhc3NlcnRSZXNwb25zZVN1Y2NlZWRlZChyZXNwb25zZSkpXG4gICAgICAudGhlbihyZXNwb25zZSA9PiB0aGlzLmNyZWF0ZUF1dGhGcm9tRGF0YShyZXNwb25zZS5ib2R5KCkpKTtcbiAgfVxuXG4gIC8qKlxuXHQgKiBMb2FkcyBjdXJyZW50IHVzZXIuIFJlcXVpcmVzIGEgdXNlciB0b2tlbiBhcyBhcmd1bWVudC5cblx0ICogQHBhcmFtIHshc3RyaW5nfSB0b2tlblxuXHQgKiBAcmV0dXJuIHtDYW5jZWxsYWJsZVByb21pc2V9XG5cdCAqL1xuICBsb2FkQ3VycmVudFVzZXIodG9rZW4pIHtcbiAgICByZXR1cm4gdGhpcy52ZXJpZnlVc2VyKHRva2VuKS50aGVuKGN1cnJlbnRVc2VyID0+IHtcbiAgICAgIHRoaXMuY3VycmVudFVzZXIgPSBjdXJyZW50VXNlcjtcbiAgICAgIGlmICh0aGlzLnN0b3JhZ2UpIHtcbiAgICAgICAgdGhpcy5zdG9yYWdlLnNldCgnY3VycmVudFVzZXInLCBjdXJyZW50VXNlcik7XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5jdXJyZW50VXNlci5oYXNUb2tlbigpKSB7XG4gICAgICAgIHRoaXMuY3JlYXRlQWNjZXNzVG9rZW5Db29raWUodGhpcy5jdXJyZW50VXNlci5nZXRUb2tlbigpKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzLmN1cnJlbnRVc2VyO1xuICAgIH0pO1xuICB9XG5cbiAgLyoqXG5cdCAqIENhbGxzIHRoZSBvbiBzaWduIGluIGNhbGxiYWNrIGlmIHNldC5cblx0ICogQHByb3RlY3RlZFxuXHQgKi9cbiAgbWF5YmVDYWxsT25TaWduSW5DYWxsYmFja18oKSB7XG4gICAgaWYgKHRoaXMub25TaWduSW5DYWxsYmFjaykge1xuICAgICAgdGhpcy5vblNpZ25JbkNhbGxiYWNrLmNhbGwodGhpcywgdGhpcy5jdXJyZW50VXNlcik7XG4gICAgfVxuICB9XG5cbiAgLyoqXG5cdCAqIENhbGxzIHRoZSBvbiBzaWduIG91dCBjYWxsYmFjayBpZiBzZXQuXG5cdCAqIEBwcm90ZWN0ZWRcblx0ICovXG4gIG1heWJlQ2FsbE9uU2lnbk91dENhbGxiYWNrXygpIHtcbiAgICBpZiAodGhpcy5vblNpZ25PdXRDYWxsYmFjaykge1xuICAgICAgdGhpcy5vblNpZ25PdXRDYWxsYmFjay5jYWxsKHRoaXMsIHRoaXMuY3VycmVudFVzZXIpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuXHQgKiBGaXJlcyBwYXNzZWQgY2FsbGJhY2sgd2hlbiBhIHVzZXIgc2lnbi1pbi4gTm90ZSB0aGF0IGl0IGtlZXBzIG9ubHkgdGhlXG5cdCAqIGxhc3QgY2FsbGJhY2sgcGFzc2VkLlxuXHQgKiBAcGFyYW0geyFGdW5jdGlvbn0gY2FsbGJhY2tcblx0ICovXG4gIG9uU2lnbkluKGNhbGxiYWNrKSB7XG4gICAgYXNzZXJ0RnVuY3Rpb24oY2FsbGJhY2ssICdTaWduLWluIGNhbGxiYWNrIG11c3QgYmUgYSBmdW5jdGlvbicpO1xuICAgIHRoaXMub25TaWduSW5DYWxsYmFjayA9IGNhbGxiYWNrO1xuICB9XG5cbiAgLyoqXG5cdCAqIEZpcmVzIHBhc3NlZCBjYWxsYmFjayB3aGVuIGEgdXNlciBzaWduLW91dC4gTm90ZSB0aGF0IGl0IGtlZXBzIG9ubHkgdGhlXG5cdCAqIGxhc3QgY2FsbGJhY2sgcGFzc2VkLlxuXHQgKiBAcGFyYW0geyFGdW5jdGlvbn0gY2FsbGJhY2tcblx0ICovXG4gIG9uU2lnbk91dChjYWxsYmFjaykge1xuICAgIGFzc2VydEZ1bmN0aW9uKGNhbGxiYWNrLCAnU2lnbi1vdXQgY2FsbGJhY2sgbXVzdCBiZSBhIGZ1bmN0aW9uJyk7XG4gICAgdGhpcy5vblNpZ25PdXRDYWxsYmFjayA9IGNhbGxiYWNrO1xuICB9XG5cbiAgLyoqXG5cdCAqIFByb2Nlc3NlcyBzaWduLWluIGJ5IGRldGVjdGluZyBhIHByZXNlbmNlIG9mIGEgZnJhZ21lbnRcblx0ICogPGNvZGU+I2FjY2Vzc190b2tlbj08L2NvZGU+IGluIHRoZSB1cmwgb3IsIGFsdGVybmF0aXZlbHksIGJ5IGxvY2FsXG5cdCAqIHN0b3JhZ2UgY3VycmVudCB1c2VyLlxuXHQgKi9cbiAgcHJvY2Vzc1NpZ25Jbl8oKSB7XG4gICAgbGV0IHJlZGlyZWN0QWNjZXNzVG9rZW4gPSB0aGlzLmdldFJlZGlyZWN0QWNjZXNzVG9rZW5fKCk7XG4gICAgaWYgKHJlZGlyZWN0QWNjZXNzVG9rZW4pIHtcbiAgICAgIHRoaXMucmVtb3ZlVXJsRnJhZ21lbnRDb21wbGV0ZWx5XygpO1xuICAgICAgdGhpcy5sb2FkQ3VycmVudFVzZXIocmVkaXJlY3RBY2Nlc3NUb2tlbikudGhlbigoKSA9PlxuICAgICAgICB0aGlzLm1heWJlQ2FsbE9uU2lnbkluQ2FsbGJhY2tfKClcbiAgICAgICk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGxldCBjdXJyZW50VXNlciA9IHRoaXMuc3RvcmFnZSAmJiB0aGlzLnN0b3JhZ2UuZ2V0KCdjdXJyZW50VXNlcicpO1xuICAgIGlmIChjdXJyZW50VXNlcikge1xuICAgICAgdGhpcy5jdXJyZW50VXNlciA9IHRoaXMuY3JlYXRlQXV0aEZyb21EYXRhKGN1cnJlbnRVc2VyKTtcbiAgICB9XG4gIH1cblxuICAvKipcblx0ICogUmVtb3ZlcyBmcmFnbWVudCBmcm9tIHVybCBieSBwZXJmb3JtaW5nIGEgcHVzaCBzdGF0ZSB0byB0aGUgY3VycmVudCBwYXRoLlxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqL1xuICByZW1vdmVVcmxGcmFnbWVudENvbXBsZXRlbHlfKCkge1xuICAgIGdsb2JhbHMud2luZG93Lmhpc3RvcnkucHVzaFN0YXRlKFxuICAgICAge30sXG4gICAgICAnJyxcbiAgICAgIHdpbmRvdy5sb2NhdGlvbi5wYXRobmFtZSArIHdpbmRvdy5sb2NhdGlvbi5zZWFyY2hcbiAgICApO1xuICB9XG5cbiAgLyoqXG5cdCAqIFJlc29sdmVzIGF1dGggc2NvcGUgZnJvbSBsYXN0IGxvZ2luIG9yIGFwaSBoZWxwZXIuXG5cdCAqIEByZXR1cm4ge0F1dGh9XG5cdCAqL1xuICByZXNvbHZlQXV0aFNjb3BlKCkge1xuICAgIGlmICh0aGlzLmhlbHBlckF1dGhTY29wZSkge1xuICAgICAgcmV0dXJuIHRoaXMuaGVscGVyQXV0aFNjb3BlO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5jdXJyZW50VXNlcjtcbiAgfVxuXG4gIC8qKlxuXHQgKiBTZW5kcyBwYXNzd29yZCByZXNldCBlbWFpbCB0byB0aGUgc3BlY2lmaWVkIGVtYWlsIGlmIGZvdW5kIGluIGRhdGFiYXNlLlxuXHQgKiBGb3Igc2VjdXJpdHkgcmVhc29ucyBjYWxsIGRvIG5vdCBmYWlsIGlmIGVtYWlsIG5vdCBmb3VuZC5cblx0ICogQHBhcmFtIHshc3RyaW5nfSBlbWFpbFxuXHQgKiBAcmV0dXJuIHtDYW5jZWxsYWJsZVByb21pc2V9XG5cdCAqL1xuICBzZW5kUGFzc3dvcmRSZXNldEVtYWlsKGVtYWlsKSB7XG4gICAgYXNzZXJ0RGVmQW5kTm90TnVsbChlbWFpbCwgJ1NlbmQgcGFzc3dvcmQgcmVzZXQgZW1haWwgbXVzdCBiZSBzcGVjaWZpZWQnKTtcbiAgICByZXR1cm4gdGhpcy5idWlsZFVybF8oKVxuICAgICAgLnBhdGgoJy91c2VyL3JlY292ZXInKVxuICAgICAgLnBhcmFtKCdlbWFpbCcsIGVtYWlsKVxuICAgICAgLnBvc3QoKVxuICAgICAgLnRoZW4ocmVzcG9uc2UgPT4gYXNzZXJ0UmVzcG9uc2VTdWNjZWVkZWQocmVzcG9uc2UpKTtcbiAgfVxuXG4gIC8qKlxuXHQgKiBTaWducyBpbiB1c2luZyBlbWFpbCBhbmQgcGFzc3dvcmQuXG5cdCAqIEBwYXJhbSB7IXN0cmluZ30gZW1haWxcblx0ICogQHBhcmFtIHshc3RyaW5nfSBwYXNzd29yZFxuXHQgKiBAcmV0dXJuIHtDYW5jZWxsYWJsZVByb21pc2V9XG5cdCAqL1xuICBzaWduSW5XaXRoRW1haWxBbmRQYXNzd29yZChlbWFpbCwgcGFzc3dvcmQpIHtcbiAgICBhc3NlcnREZWZBbmROb3ROdWxsKGVtYWlsLCAnU2lnbi1pbiBlbWFpbCBtdXN0IGJlIHNwZWNpZmllZCcpO1xuICAgIGFzc2VydERlZkFuZE5vdE51bGwocGFzc3dvcmQsICdTaWduLWluIHBhc3N3b3JkIG11c3QgYmUgc3BlY2lmaWVkJyk7XG5cbiAgICByZXR1cm4gdGhpcy5idWlsZFVybF8oKVxuICAgICAgLnBhdGgoJy9vYXV0aC90b2tlbicpXG4gICAgICAucGFyYW0oJ2dyYW50X3R5cGUnLCAncGFzc3dvcmQnKVxuICAgICAgLnBhcmFtKCd1c2VybmFtZScsIGVtYWlsKVxuICAgICAgLnBhcmFtKCdwYXNzd29yZCcsIHBhc3N3b3JkKVxuICAgICAgLmdldCgpXG4gICAgICAudGhlbihyZXNwb25zZSA9PiBhc3NlcnRSZXNwb25zZVN1Y2NlZWRlZChyZXNwb25zZSkpXG4gICAgICAudGhlbihyZXNwb25zZSA9PiB0aGlzLmxvYWRDdXJyZW50VXNlcihyZXNwb25zZS5ib2R5KCkuYWNjZXNzX3Rva2VuKSlcbiAgICAgIC50aGVuKHVzZXIgPT4ge1xuICAgICAgICB0aGlzLm1heWJlQ2FsbE9uU2lnbkluQ2FsbGJhY2tfKCk7XG4gICAgICAgIHJldHVybiB1c2VyO1xuICAgICAgfSk7XG4gIH1cblxuICAvKipcblx0ICogU2lnbnMgaW4gd2l0aCByZWRpcmVjdC4gU29tZSBwcm92aWRlcnMgYW5kIGVudmlyb25tZW50IG1heSBub3Qgc3VwcG9ydFxuXHQgKiB0aGlzIGZsb3cuXG5cdCAqIEBwYXJhbSB7QXV0aFByb3ZpZGVyfSBwcm92aWRlclxuXHQgKi9cbiAgc2lnbkluV2l0aFJlZGlyZWN0KHByb3ZpZGVyKSB7XG4gICAgYXNzZXJ0QnJvd3NlckVudmlyb25tZW50KCk7XG4gICAgYXNzZXJ0RGVmQW5kTm90TnVsbChwcm92aWRlciwgJ1NpZ24taW4gcHJvdmlkZXIgbXVzdCBiZSBkZWZpbmVkJyk7XG4gICAgYXNzZXJ0U3VwcG9ydGVkUHJvdmlkZXIocHJvdmlkZXIpO1xuXG4gICAgaWYgKCFwcm92aWRlci5oYXNSZWRpcmVjdFVyaSgpKSB7XG4gICAgICBwcm92aWRlci5zZXRSZWRpcmVjdFVyaSh0aGlzLmdldEhyZWZXaXRob3V0RnJhZ21lbnRfKCkpO1xuICAgIH1cbiAgICBnbG9iYWxzLndpbmRvdy5sb2NhdGlvbi5ocmVmID0gcHJvdmlkZXIubWFrZUF1dGhvcml6YXRpb25VcmwoXG4gICAgICB0aGlzLndlZGVwbG95Q2xpZW50LmF1dGhVcmxfXG4gICAgKTtcbiAgfVxuXG4gIC8qKlxuXHQgKiBTaWducyBvdXQgPGNvZGU+Y3VycmVudFVzZXI8L2NvZGU+IGFuZCByZW1vdmVzIGZyb21cblx0ICogICA8Y29kZT5sb2NhbFN0b3JhZ2U8L2NvZGU+LlxuXHQgKiBAcmV0dXJuIHtDYW5jZWxsYWJsZVByb21pc2V9XG5cdCAqL1xuICBzaWduT3V0KCkge1xuICAgIGFzc2VydFVzZXJTaWduZWRJbih0aGlzLmN1cnJlbnRVc2VyKTtcbiAgICByZXR1cm4gdGhpcy5idWlsZFVybF8oKVxuICAgICAgLnBhdGgoJy9vYXV0aC9yZXZva2UnKVxuICAgICAgLnBhcmFtKCd0b2tlbicsIHRoaXMuY3VycmVudFVzZXIudG9rZW4pXG4gICAgICAuZ2V0KClcbiAgICAgIC50aGVuKHJlc3BvbnNlID0+IGFzc2VydFJlc3BvbnNlU3VjY2VlZGVkKHJlc3BvbnNlKSlcbiAgICAgIC50aGVuKHJlc3BvbnNlID0+IHtcbiAgICAgICAgdGhpcy5tYXliZUNhbGxPblNpZ25PdXRDYWxsYmFja18oKTtcbiAgICAgICAgdGhpcy51bmxvYWRDdXJyZW50VXNlcl8oKTtcbiAgICAgICAgcmV0dXJuIHJlc3BvbnNlO1xuICAgICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogQnVpbGRzIFVSTCBieSBqb2luaW5nIHRoZSBoZWFkZXJzLlxuICAgKiBAcmV0dXJuIHtXZURlcGxveX0gUmV0dXJucyB0aGUge0BsaW5rIFdlRGVwbG95fSBvYmplY3QgaXRzZWxmLCBzbyBjYWxscyBjYW5cbiAgICogICBiZSBjaGFpbmVkLlxuICAgKiBAY2hhaW5hYmxlXG4gICAqL1xuICBidWlsZFVybF8oKSB7XG4gICAgcmV0dXJuIHRoaXMud2VkZXBsb3lDbGllbnRcbiAgICAgIC51cmwodGhpcy53ZWRlcGxveUNsaWVudC5hdXRoVXJsXylcbiAgICAgIC5oZWFkZXJzKHRoaXMuaGVhZGVyc18pO1xuICB9XG5cbiAgLyoqXG5cdCAqIFVubG9hZHMgYWxsIGluZm9ybWF0aW9uIGZvciA8Y29kZT5jdXJyZW50VXNlcjwvY29kZT4gYW5kIHJlbW92ZXMgZnJvbVxuXHQgKiA8Y29kZT5sb2NhbFN0b3JhZ2U8L2NvZGU+IGlmIHByZXNlbnQuXG5cdCAqL1xuICB1bmxvYWRDdXJyZW50VXNlcl8oKSB7XG4gICAgdGhpcy5jdXJyZW50VXNlciA9IG51bGw7XG4gICAgaWYgKHRoaXMuc3RvcmFnZSkge1xuICAgICAgdGhpcy5zdG9yYWdlLnJlbW92ZSgnY3VycmVudFVzZXInKTtcbiAgICB9XG4gICAgdGhpcy5kZWxldGVBY2Nlc3NUb2tlbkNvb2tpZSgpO1xuICB9XG5cbiAgLyoqXG5cdCAqIE1ldGhvZCBmb3IgdmVyaWZ5aW5nIHRva2Vucy4gSWYgdGhlIHByb3ZpZGVkIHRva2VuIGhhcyB0aGUgY29ycmVjdFxuXHQgKiBmb3JtYXQsIGlzIG5vdCBleHBpcmVkLCBhbmQgaXMgcHJvcGVybHkgc2lnbmVkLCB0aGUgbWV0aG9kIHJldHVybnMgdGhlXG5cdCAqIGRlY29kZWQgdG9rZW4uXG5cdCAqIEBwYXJhbSB7IXN0cmluZ30gdG9rZW5cblx0ICogQHJldHVybiB7Q2FuY2VsbGFibGVQcm9taXNlfVxuXHQgKi9cbiAgdmVyaWZ5VG9rZW4odG9rZW4pIHtcbiAgICBhc3NlcnREZWZBbmROb3ROdWxsKHRva2VuLCAnVG9rZW4gbXVzdCBiZSBzcGVjaWZpZWQnKTtcbiAgICByZXR1cm4gdGhpcy5idWlsZFVybF8oKVxuICAgICAgLnBhdGgoJy9vYXV0aC90b2tlbmluZm8nKVxuICAgICAgLnBhcmFtKCd0b2tlbicsIHRva2VuKVxuICAgICAgLmdldCgpXG4gICAgICAudGhlbihyZXNwb25zZSA9PiBhc3NlcnRSZXNwb25zZVN1Y2NlZWRlZChyZXNwb25zZSkpXG4gICAgICAudGhlbihyZXNwb25zZSA9PiByZXNwb25zZS5ib2R5KCkpO1xuICB9XG5cbiAgLyoqXG5cdCAqIE1ldGhvZCBmb3IgdmVyaWZ5aW5nIHVzZXIgYnkgdG9rZW4uIElmIHRoZSBwcm92aWRlZCB0b2tlbiBoYXMgdGhlIGNvcnJlY3Rcblx0ICogZm9ybWF0LCBpcyBub3QgZXhwaXJlZCwgYW5kIGlzIHByb3Blcmx5IHNpZ25lZCwgdGhlIG1ldGhvZCByZXR1cm5zIHRoZVxuXHQgKiB1c2VyIHBheWxvYWQuXG5cdCAqIEBwYXJhbSB7IXN0cmluZ30gdG9rZW5PckVtYWlsIEVpdGhlciBhbiBhdXRob3JpemF0aW9uIHRva2VuLFxuXHQgKiBvciB0aGUgZW1haWwuXG5cdCAqIEBwYXJhbSB7c3RyaW5nPX0gb3B0X3Bhc3N3b3JkIElmIGEgZW1haWwgaXMgZ2l2ZW4gYXMgdGhlIGZpcnN0IHBhcmFtLFxuXHQgKiB0aGlzIHNob3VsZCBiZSB0aGUgcGFzc3dvcmQuXG5cdCAqIEByZXR1cm4ge0NhbmNlbGxhYmxlUHJvbWlzZX1cblx0ICovXG4gIHZlcmlmeVVzZXIodG9rZW5PckVtYWlsLCBvcHRfcGFzc3dvcmQpIHtcbiAgICBhc3NlcnREZWZBbmROb3ROdWxsKHRva2VuT3JFbWFpbCwgJ1Rva2VuIG9yIGVtYWlsIG11c3QgYmUgc3BlY2lmaWVkJyk7XG4gICAgcmV0dXJuIHRoaXMuYnVpbGRVcmxfKClcbiAgICAgIC5wYXRoKCcvdXNlcicpXG4gICAgICAuYXV0aCh0b2tlbk9yRW1haWwsIG9wdF9wYXNzd29yZClcbiAgICAgIC5nZXQoKVxuICAgICAgLnRoZW4ocmVzcG9uc2UgPT4gYXNzZXJ0UmVzcG9uc2VTdWNjZWVkZWQocmVzcG9uc2UpKVxuICAgICAgLnRoZW4ocmVzcG9uc2UgPT4ge1xuICAgICAgICBsZXQgZGF0YSA9IHJlc3BvbnNlLmJvZHkoKTtcbiAgICAgICAgaWYgKG9wdF9wYXNzd29yZCkge1xuICAgICAgICAgIGRhdGEuZW1haWwgPSB0b2tlbk9yRW1haWw7XG4gICAgICAgICAgZGF0YS5wYXNzd29yZCA9IG9wdF9wYXNzd29yZDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBkYXRhLnRva2VuID0gdG9rZW5PckVtYWlsO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLmNyZWF0ZUF1dGhGcm9tRGF0YShkYXRhKTtcbiAgICAgIH0pO1xuICB9XG59XG5cbi8qKlxuICogQXNzZXJ0cyBhIHBhc3NlZCBzaWduLWluIHByb3ZpZGVyIGlzIHN1cHBvcnRlZC5cbiAqIFRocm93cyBhbiBleGNlcHRpb24gaWYgdGhlIHBhc3NlZCBwcm92aWRlciBpcyBub3Qgb25lIG9mOlxuICogLSBGYWNlYm9va0F1dGhQcm92aWRlci5QUk9WSURFUlxuICogLSBHaXRodWJBdXRoUHJvdmlkZXIuUFJPVklERVJcbiAqIC0gR29vZ2xlQXV0aFByb3ZpZGVyLlBST1ZJREVSXG4gKiBAcGFyYW0geyFzdHJpbmd9IHByb3ZpZGVyXG4gKi9cbmZ1bmN0aW9uIGFzc2VydFN1cHBvcnRlZFByb3ZpZGVyKHByb3ZpZGVyKSB7XG4gIHN3aXRjaCAocHJvdmlkZXIuY29uc3RydWN0b3IuUFJPVklERVIpIHtcbiAgICBjYXNlIEZhY2Vib29rQXV0aFByb3ZpZGVyLlBST1ZJREVSOlxuICAgIGNhc2UgR2l0aHViQXV0aFByb3ZpZGVyLlBST1ZJREVSOlxuICAgIGNhc2UgR29vZ2xlQXV0aFByb3ZpZGVyLlBST1ZJREVSOlxuICAgICAgYnJlYWs7XG4gICAgZGVmYXVsdDpcbiAgICAgIHRocm93IG5ldyBFcnJvcignU2lnbi1pbiBwcm92aWRlciBub3Qgc3VwcG9ydGVkJyk7XG4gIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgQXV0aEFwaUhlbHBlcjtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy9hcGkvYXV0aC9BdXRoQXBpSGVscGVyLmpzIiwiJ3VzZSBzdHJpY3QnO1xuXG5pbXBvcnQgQXV0aFByb3ZpZGVyIGZyb20gJy4vQXV0aFByb3ZpZGVyJztcblxuLyoqXG4gKiBGYWNlYm9vayBhdXRoIHByb3ZpZGVyIGltcGxlbWVudGF0aW9uLlxuICovXG5jbGFzcyBGYWNlYm9va0F1dGhQcm92aWRlciBleHRlbmRzIEF1dGhQcm92aWRlciB7XG4gIC8qKlxuXHQgKiBDb25zdHJ1Y3RzIGFuIHtAbGluayBGYWNlYm9va0F1dGhQcm92aWRlcn0gaW5zdGFuY2UuXG5cdCAqIEBjb25zdHJ1Y3RvclxuXHQgKi9cbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoKTtcbiAgICB0aGlzLnByb3ZpZGVyID0gRmFjZWJvb2tBdXRoUHJvdmlkZXIuUFJPVklERVI7XG4gIH1cbn1cblxuRmFjZWJvb2tBdXRoUHJvdmlkZXIuUFJPVklERVIgPSAnZmFjZWJvb2snO1xuXG5leHBvcnQgZGVmYXVsdCBGYWNlYm9va0F1dGhQcm92aWRlcjtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy9hcGkvYXV0aC9GYWNlYm9va0F1dGhQcm92aWRlci5qcyIsIid1c2Ugc3RyaWN0JztcblxuaW1wb3J0IEF1dGhQcm92aWRlciBmcm9tICcuL0F1dGhQcm92aWRlcic7XG5cbi8qKlxuICogR2l0aHViIGF1dGggcHJvdmlkZXIgaW1wbGVtZW50YXRpb24uXG4gKi9cbmNsYXNzIEdpdGh1YkF1dGhQcm92aWRlciBleHRlbmRzIEF1dGhQcm92aWRlciB7XG4gIC8qKlxuXHQgKiBDb25zdHJ1Y3RzIGFuIHtAbGluayBHaXRodWJBdXRoUHJvdmlkZXJ9IGluc3RhbmNlLlxuXHQgKiBAY29uc3RydWN0b3Jcblx0ICovXG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKCk7XG4gICAgdGhpcy5wcm92aWRlciA9IEdpdGh1YkF1dGhQcm92aWRlci5QUk9WSURFUjtcbiAgfVxufVxuXG5HaXRodWJBdXRoUHJvdmlkZXIuUFJPVklERVIgPSAnZ2l0aHViJztcblxuZXhwb3J0IGRlZmF1bHQgR2l0aHViQXV0aFByb3ZpZGVyO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL2FwaS9hdXRoL0dpdGh1YkF1dGhQcm92aWRlci5qcyIsIid1c2Ugc3RyaWN0JztcblxuaW1wb3J0IEF1dGhQcm92aWRlciBmcm9tICcuL0F1dGhQcm92aWRlcic7XG5cbi8qKlxuICogR29vZ2xlIGF1dGggcHJvdmlkZXIgaW1wbGVtZW50YXRpb24uXG4gKi9cbmNsYXNzIEdvb2dsZUF1dGhQcm92aWRlciBleHRlbmRzIEF1dGhQcm92aWRlciB7XG4gIC8qKlxuXHQgKiBDb25zdHJ1Y3RzIGFuIHtAbGluayBHb29nbGVBdXRoUHJvdmlkZXJ9IGluc3RhbmNlLlxuXHQgKiBAY29uc3RydWN0b3Jcblx0ICovXG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKCk7XG4gICAgdGhpcy5wcm92aWRlciA9IEdvb2dsZUF1dGhQcm92aWRlci5QUk9WSURFUjtcbiAgfVxufVxuXG5Hb29nbGVBdXRoUHJvdmlkZXIuUFJPVklERVIgPSAnZ29vZ2xlJztcblxuZXhwb3J0IGRlZmF1bHQgR29vZ2xlQXV0aFByb3ZpZGVyO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL2FwaS9hdXRoL0dvb2dsZUF1dGhQcm92aWRlci5qcyIsIid1c2Ugc3RyaWN0JztcblxuaW1wb3J0IEFqYXggZnJvbSAnbWV0YWwtYWpheCc7XG5pbXBvcnQgVHJhbnNwb3J0IGZyb20gJy4uL1RyYW5zcG9ydCc7XG5pbXBvcnQgQ2xpZW50UmVzcG9uc2UgZnJvbSAnLi4vQ2xpZW50UmVzcG9uc2UnO1xuXG4vKipcbiAqIFRoZSBpbXBsZW1lbnRhdGlvbiBvZiBhbiBhamF4IHRyYW5zcG9ydCB0byBiZSB1c2VkIHdpdGgge0BsaW5rIFdlRGVwbG95fS5cbiAqIEBleHRlbmRzIHtUcmFuc3BvcnR9XG4gKi9cbmNsYXNzIEFqYXhUcmFuc3BvcnQgZXh0ZW5kcyBUcmFuc3BvcnQge1xuICAvKipcblx0ICogQGluaGVyaXREb2Ncblx0ICovXG4gIHNlbmQoY2xpZW50UmVxdWVzdCkge1xuICAgIGxldCBkZWZlcnJlZCA9IEFqYXgucmVxdWVzdChcbiAgICAgIGNsaWVudFJlcXVlc3QudXJsKCksXG4gICAgICBjbGllbnRSZXF1ZXN0Lm1ldGhvZCgpLFxuICAgICAgY2xpZW50UmVxdWVzdC5ib2R5KCksXG4gICAgICBjbGllbnRSZXF1ZXN0LmhlYWRlcnMoKSxcbiAgICAgIGNsaWVudFJlcXVlc3QucGFyYW1zKCksXG4gICAgICBudWxsLFxuICAgICAgZmFsc2UsXG4gICAgICBjbGllbnRSZXF1ZXN0LndpdGhDcmVkZW50aWFscygpXG4gICAgKTtcblxuICAgIHJldHVybiBkZWZlcnJlZC50aGVuKGZ1bmN0aW9uKHJlc3BvbnNlKSB7XG4gICAgICBsZXQgY2xpZW50UmVzcG9uc2UgPSBuZXcgQ2xpZW50UmVzcG9uc2UoY2xpZW50UmVxdWVzdCk7XG4gICAgICBjbGllbnRSZXNwb25zZS5ib2R5KHJlc3BvbnNlLnJlc3BvbnNlVGV4dCk7XG4gICAgICBjbGllbnRSZXNwb25zZS5zdGF0dXNDb2RlKHJlc3BvbnNlLnN0YXR1cyk7XG4gICAgICBjbGllbnRSZXNwb25zZS5zdGF0dXNUZXh0KHJlc3BvbnNlLnN0YXR1c1RleHQpO1xuICAgICAgQWpheC5wYXJzZVJlc3BvbnNlSGVhZGVycyhcbiAgICAgICAgcmVzcG9uc2UuZ2V0QWxsUmVzcG9uc2VIZWFkZXJzKClcbiAgICAgICkuZm9yRWFjaChmdW5jdGlvbihoZWFkZXIpIHtcbiAgICAgICAgY2xpZW50UmVzcG9uc2UuaGVhZGVyKGhlYWRlci5uYW1lLCBoZWFkZXIudmFsdWUpO1xuICAgICAgfSk7XG4gICAgICByZXR1cm4gY2xpZW50UmVzcG9uc2U7XG4gICAgfSk7XG4gIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgQWpheFRyYW5zcG9ydDtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy9hcGkvYnJvd3Nlci9BamF4VHJhbnNwb3J0LmpzIiwiJ3VzZSBzdHJpY3QnO1xuXG5pbXBvcnQgQXBpSGVscGVyIGZyb20gJy4uL0FwaUhlbHBlcic7XG5pbXBvcnQgUXVlcnkgZnJvbSAnLi4vLi4vYXBpLXF1ZXJ5L1F1ZXJ5JztcbmltcG9ydCBGaWx0ZXIgZnJvbSAnLi4vLi4vYXBpLXF1ZXJ5L0ZpbHRlcic7XG5pbXBvcnQge1xuICBhc3NlcnREZWZBbmROb3ROdWxsLFxuICBhc3NlcnRPYmplY3QsXG4gIGFzc2VydFJlc3BvbnNlU3VjY2VlZGVkLFxufSBmcm9tICcuLi9hc3NlcnRpb25zJztcbmltcG9ydCB7Y29yZX0gZnJvbSAnbWV0YWwnO1xuXG4vKipcbiAqIENsYXNzIHJlc3BvbnNpYmxlIGZvciBlbmNhcHN1bGF0ZSBkYXRhIGFwaSBjYWxscy5cbiAqL1xuY2xhc3MgRGF0YUFwaUhlbHBlciBleHRlbmRzIEFwaUhlbHBlciB7XG4gIC8qKlxuXHQgKiBDb25zdHJ1Y3RzIGFuIHtAbGluayBEYXRhQXBpSGVscGVyfSBpbnN0YW5jZS5cblx0ICogQHBhcmFtIHshV2VEZXBsb3l9IHdlZGVwbG95Q2xpZW50IHtAbGluayBXZURlcGxveX0gY2xpZW50IHJlZmVyZW5jZS5cblx0ICogQGNvbnN0cnVjdG9yXG5cdCAqL1xuICBjb25zdHJ1Y3Rvcih3ZWRlcGxveUNsaWVudCkge1xuICAgIHN1cGVyKHdlZGVwbG95Q2xpZW50KTtcblxuICAgIHRoaXMuaXNTZWFyY2hfID0gZmFsc2U7XG4gIH1cblxuICAvKipcblx0ICogQWRkcyBhIGZpbHRlciB0byB0aGlzIHJlcXVlc3QncyB7QGxpbmsgUXVlcnl9LlxuXHQgKiBAcGFyYW0geyFGaWx0ZXJ8c3RyaW5nfSBmaWVsZE9yRmlsdGVyIEVpdGhlciBhIEZpbHRlciBpbnN0YW5jZSBvciB0aGVcblx0ICogICBuYW1lIG9mIHRoZSBmaWVsZCB0byBmaWx0ZXIgYnkuXG5cdCAqIEBwYXJhbSB7Kj19IG9wdF9vcGVyYXRvck9yVmFsdWUgRWl0aGVyIHRoZSBmaWVsZCdzIG9wZXJhdG9yIG9yIGl0cyB2YWx1ZS5cblx0ICogQHBhcmFtIHsqPX0gb3B0X3ZhbHVlIFRoZSBmaWx0ZXIncyB2YWx1ZS5cblx0ICogQHJldHVybiB7RGF0YUFwaUhlbHBlcn0gUmV0dXJucyB0aGUge0BsaW5rIERhdGFBcGlIZWxwZXJ9IG9iamVjdCBpdHNlbGYsIHNvXG5cdCAqICAgY2FsbHMgY2FuIGJlIGNoYWluZWQuXG5cdCAqIEBjaGFpbmFibGVcblx0ICovXG4gIHdoZXJlKGZpZWxkT3JGaWx0ZXIsIG9wdF9vcGVyYXRvck9yVmFsdWUsIG9wdF92YWx1ZSkge1xuICAgIHRoaXMuZ2V0T3JDcmVhdGVGaWx0ZXJfKCkuYW5kKFxuICAgICAgZmllbGRPckZpbHRlcixcbiAgICAgIG9wdF9vcGVyYXRvck9yVmFsdWUsXG4gICAgICBvcHRfdmFsdWVcbiAgICApO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLyoqXG5cdCAqIEFkZHMgYSBmaWx0ZXIgdG8gYmUgY29tcG9zZWQgd2l0aCB0aGlzIGZpbHRlciB1c2luZyB0aGUgXCJvclwiIG9wZXJhdG9yLlxuXHQgKiBAcGFyYW0geyFGaWx0ZXJ8c3RyaW5nfSBmaWVsZE9yRmlsdGVyIEVpdGhlciBhIHtAbGluayBGaWx0ZXJ9IGluc3RhbmNlIG9yXG5cdCAqICAgdGhlIG5hbWUgb2YgdGhlIGZpZWxkIHRvIGZpbHRlciBieS5cblx0ICogQHBhcmFtIHsqPX0gb3B0X29wZXJhdG9yT3JWYWx1ZSBFaXRoZXIgdGhlIGZpZWxkJ3Mgb3BlcmF0b3Igb3IgaXRzIHZhbHVlLlxuXHQgKiBAcGFyYW0geyo9fSBvcHRfdmFsdWUgVGhlIGZpbHRlcidzIHZhbHVlLlxuXHQgKiBAcmV0dXJuIHtEYXRhQXBpSGVscGVyfSBSZXR1cm5zIHRoZSB7QGxpbmsgRGF0YUFwaUhlbHBlcn0gb2JqZWN0IGl0c2VsZiwgc29cblx0ICogICBjYWxscyBjYW4gYmUgY2hhaW5lZC5cblx0ICogQGNoYWlubmFibGVcblx0ICovXG4gIG9yKGZpZWxkT3JGaWx0ZXIsIG9wdF9vcGVyYXRvck9yVmFsdWUsIG9wdF92YWx1ZSkge1xuICAgIGlmICh0aGlzLmdldE9yQ3JlYXRlRmlsdGVyXygpLmJvZHkoKS5hbmQubGVuZ3RoID09PSAwKSB7XG4gICAgICB0aHJvdyBFcnJvcihcbiAgICAgICAgJ0l0XFwncyByZXF1aXJlZCB0byBoYXZlIGEgY29uZGl0aW9uIGJlZm9yZSB1c2luZyBhbiBcXCdvcigpXFwnICcgK1xuICAgICAgICAgICdmb3IgdGhlIGZpcnN0IHRpbWUuJ1xuICAgICAgKTtcbiAgICB9XG4gICAgdGhpcy5nZXRPckNyZWF0ZUZpbHRlcl8oKS5vcihmaWVsZE9yRmlsdGVyLCBvcHRfb3BlcmF0b3JPclZhbHVlLCBvcHRfdmFsdWUpO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLyoqXG5cdCAqIEFkZHMgYSBmaWx0ZXIgdG8gYmUgY29tcG9zZSB3aXRoIHRoaXMgZmlsdGVyIHVzaW5nIFwibm9uZVwiIG9wZXJhdG9yLlxuXHQgKiBAcGFyYW0ge3N0cmluZ30gZmllbGQgVGhlIG5hbWUgb2YgdGhlIGZpZWxkIHRvIGZpbHRlciBieS5cblx0ICogQHBhcmFtIHshKEFycmF5fCopfSBhcmdzIEEgdmFyaWFibGUgYW1vdW50IG9mIHZhbHVlcyB0byBiZSB1c2VkIHdpdGhcblx0ICogdGhlIFwibm9uZVwiIG9wZXJhdG9yLiBDYW4gYmUgcGFzc2VkIGVpdGhlciBhcyBhIHNpbmdsZSBhcnJheSBvciBhc1xuXHQgKiBzZXBhcmF0ZSBwYXJhbXMuXG5cdCAqIEByZXR1cm4ge0RhdGFBcGlIZWxwZXJ9IFJldHVybnMgdGhlIHtAbGluayBEYXRhQXBpSGVscGVyfSBvYmplY3QgaXRzZWxmLCBzb1xuXHQgKiAgIGNhbGxzIGNhbiBiZSBjaGFpbmVkLlxuXHQgKiBAY2hhaW5uYWJsZVxuXHQgKi9cbiAgbm9uZShmaWVsZCwgLi4uYXJncykge1xuICAgIHJldHVybiB0aGlzLndoZXJlKEZpbHRlci5ub25lKGZpZWxkLCBhcmdzKSk7XG4gIH1cblxuICAvKipcblx0ICogQWRkcyBhIGZpbHRlciB0byBiZSBjb21wb3NlIHdpdGggdGhpcyBmaWx0ZXIgdXNpbmcgXCJtYXRjaFwiIG9wZXJhdG9yLlxuXHQgKiBAcGFyYW0ge3N0cmluZ30gZmllbGQgSWYgbm8gc2Vjb25kIHN0cmluZyBhcmd1bWVudCBpcyBnaXZlbiwgdGhpc1xuXHQgKiAgIHNob3VsZCBiZSB0aGUgcXVlcnkgc3RyaW5nLCBpbiB3aGljaCBjYXNlIGFsbCBmaWVsZHMgd2lsbCBiZSBtYXRjaGVkLlxuXHQgKiAgIE90aGVyd2lzZSwgdGhpcyBzaG91bGQgYmUgdGhlIG5hbWUgb2YgdGhlIGZpZWxkIHRvIG1hdGNoLlxuXHQgKiBAcGFyYW0ge3N0cmluZz19IG9wdF9xdWVyeSBUaGUgcXVlcnkgc3RyaW5nLlxuXHQgKiBAcmV0dXJuIHtEYXRhQXBpSGVscGVyfSBSZXR1cm5zIHRoZSB7QGxpbmsgRGF0YUFwaUhlbHBlcn0gb2JqZWN0IGl0c2VsZiwgc29cblx0ICogICBjYWxscyBjYW4gYmUgY2hhaW5lZC5cblx0ICogQGNoYWlubmFibGVcblx0ICovXG4gIG1hdGNoKGZpZWxkLCBvcHRfcXVlcnkpIHtcbiAgICByZXR1cm4gdGhpcy53aGVyZShGaWx0ZXIubWF0Y2goZmllbGQsIG9wdF9xdWVyeSkpO1xuICB9XG5cbiAgLyoqXG5cdCAqIEFkZHMgYSBmaWx0ZXIgdG8gYmUgY29tcG9zZSB3aXRoIHRoaXMgZmlsdGVyIHVzaW5nIFwicHJlZml4XCIgb3BlcmF0b3IuXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBmaWVsZCBUaGUgbmFtZSBvZiB0aGUgZmllbGQgdG8gZmlsdGVyIGJ5LlxuXHQgKiBAcGFyYW0ge3N0cmluZz19IG9wdF9xdWVyeSBUaGUgcXVlcnkgc3RyaW5nLlxuXHQgKiBAcmV0dXJuIHtEYXRhQXBpSGVscGVyfSBSZXR1cm5zIHRoZSB7QGxpbmsgRGF0YUFwaUhlbHBlcn0gb2JqZWN0IGl0c2VsZiwgc29cblx0ICogICBjYWxscyBjYW4gYmUgY2hhaW5lZC5cblx0ICogQGNoYWlubmFibGVcblx0ICovXG4gIHByZWZpeChmaWVsZCwgb3B0X3F1ZXJ5KSB7XG4gICAgcmV0dXJuIHRoaXMud2hlcmUoRmlsdGVyLnByZWZpeChmaWVsZCwgb3B0X3F1ZXJ5KSk7XG4gIH1cblxuICAvKipcblx0ICogQWRkcyBhIGZpbHRlciB0byBiZSBjb21wb3NlIHdpdGggdGhpcyBmaWx0ZXIgdXNpbmcgXCJzaW1pbGFyXCIgb3BlcmF0b3IuXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBmaWVsZE9yUXVlcnkgSWYgbm8gc2Vjb25kIHN0cmluZyBhcmd1bWVudCBpcyBnaXZlbiwgdGhpc1xuXHQgKiBzaG91bGQgYmUgdGhlIHF1ZXJ5IHN0cmluZywgaW4gd2hpY2ggY2FzZSBhbGwgZmllbGRzIHdpbGwgYmUgbWF0Y2hlZC5cblx0ICogT3RoZXJ3aXNlLCB0aGlzIHNob3VsZCBiZSB0aGUgbmFtZSBvZiB0aGUgZmllbGQgdG8gbWF0Y2guXG5cdCAqIEBwYXJhbSB7P3N0cmluZ30gcXVlcnkgVGhlIHF1ZXJ5IHN0cmluZy5cblx0ICogQHJldHVybiB7RGF0YUFwaUhlbHBlcn0gUmV0dXJucyB0aGUge0BsaW5rIERhdGFBcGlIZWxwZXJ9IG9iamVjdCBpdHNlbGYsIHNvXG5cdCAqICAgY2FsbHMgY2FuIGJlIGNoYWluZWQuXG5cdCAqIEBjaGFpbm5hYmxlXG5cdCAqL1xuICBzaW1pbGFyKGZpZWxkT3JRdWVyeSwgcXVlcnkpIHtcbiAgICByZXR1cm4gdGhpcy53aGVyZShGaWx0ZXIuc2ltaWxhcihmaWVsZE9yUXVlcnksIHF1ZXJ5KSk7XG4gIH1cblxuICAvKipcblx0ICogUmV0dXJucyBhIHtAbGluayBGaWx0ZXJ9IGluc3RhbmNlIHRoYXQgdXNlcyB0aGUgXCI8XCIgb3BlcmF0b3IuXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBmaWVsZCBUaGUgbmFtZSBvZiB0aGUgZmllbGQgdG8gZmlsdGVyIGJ5LlxuXHQgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSBmaWx0ZXIncyB2YWx1ZS5cblx0ICogQHJldHVybiB7RGF0YUFwaUhlbHBlcn0gUmV0dXJucyB0aGUge0BsaW5rIERhdGFBcGlIZWxwZXJ9IG9iamVjdCBpdHNlbGYsIHNvXG5cdCAqICAgY2FsbHMgY2FuIGJlIGNoYWluZWQuXG5cdCAqIEBjaGFpbm5hYmxlXG5cdCAqL1xuICBsdChmaWVsZCwgdmFsdWUpIHtcbiAgICByZXR1cm4gdGhpcy53aGVyZShGaWx0ZXIubHQoZmllbGQsIHZhbHVlKSk7XG4gIH1cblxuICAvKipcblx0ICogUmV0dXJucyBhIHtAbGluayBGaWx0ZXJ9IGluc3RhbmNlIHRoYXQgdXNlcyB0aGUgXCI8PVwiIG9wZXJhdG9yLlxuXHQgKiBAcGFyYW0ge3N0cmluZ30gZmllbGQgVGhlIG5hbWUgb2YgdGhlIGZpZWxkIHRvIGZpbHRlciBieS5cblx0ICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgZmlsdGVyJ3MgdmFsdWUuXG5cdCAqIEByZXR1cm4ge0RhdGFBcGlIZWxwZXJ9IFJldHVybnMgdGhlIHtAbGluayBEYXRhQXBpSGVscGVyfSBvYmplY3QgaXRzZWxmLCBzb1xuXHQgKiAgIGNhbGxzIGNhbiBiZSBjaGFpbmVkLlxuXHQgKiBAY2hhaW5uYWJsZVxuXHQgKi9cbiAgbHRlKGZpZWxkLCB2YWx1ZSkge1xuICAgIHJldHVybiB0aGlzLndoZXJlKEZpbHRlci5sdGUoZmllbGQsIHZhbHVlKSk7XG4gIH1cblxuICAvKipcblx0ICogUmV0dXJucyBhIHtAbGluayBGaWx0ZXJ9IGluc3RhbmNlIHRoYXQgdXNlcyB0aGUgXCI+XCIgb3BlcmF0b3IuXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBmaWVsZCBUaGUgbmFtZSBvZiB0aGUgZmllbGQgdG8gZmlsdGVyIGJ5LlxuXHQgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSBmaWx0ZXIncyB2YWx1ZS5cblx0ICogQHJldHVybiB7RGF0YUFwaUhlbHBlcn0gUmV0dXJucyB0aGUge0BsaW5rIERhdGFBcGlIZWxwZXJ9IG9iamVjdCBpdHNlbGYsIHNvXG5cdCAqICAgY2FsbHMgY2FuIGJlIGNoYWluZWQuXG5cdCAqIEBjaGFpbm5hYmxlXG5cdCAqL1xuICBndChmaWVsZCwgdmFsdWUpIHtcbiAgICByZXR1cm4gdGhpcy53aGVyZShGaWx0ZXIuZ3QoZmllbGQsIHZhbHVlKSk7XG4gIH1cblxuICAvKipcblx0ICogUmV0dXJucyBhIHtAbGluayBGaWx0ZXJ9IGluc3RhbmNlIHRoYXQgdXNlcyB0aGUgXCI+PVwiIG9wZXJhdG9yLlxuXHQgKiBAcGFyYW0ge3N0cmluZ30gZmllbGQgVGhlIG5hbWUgb2YgdGhlIGZpZWxkIHRvIGZpbHRlciBieS5cblx0ICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgZmlsdGVyJ3MgdmFsdWUuXG5cdCAqIEByZXR1cm4ge0RhdGFBcGlIZWxwZXJ9IFJldHVybnMgdGhlIHtAbGluayBEYXRhQXBpSGVscGVyfSBvYmplY3QgaXRzZWxmLCBzb1xuXHQgKiAgIGNhbGxzIGNhbiBiZSBjaGFpbmVkLlxuXHQgKiBAY2hhaW5uYWJsZVxuXHQgKi9cbiAgZ3RlKGZpZWxkLCB2YWx1ZSkge1xuICAgIHJldHVybiB0aGlzLndoZXJlKEZpbHRlci5ndGUoZmllbGQsIHZhbHVlKSk7XG4gIH1cblxuICAvKipcblx0ICogQWRkcyBhIGZpbHRlciB0byBiZSBjb21wb3NlIHdpdGggdGhpcyBmaWx0ZXIgdXNpbmcgXCJhbnlcIiBvcGVyYXRvci5cblx0ICogQHBhcmFtIHtzdHJpbmd9IGZpZWxkIFRoZSBuYW1lIG9mIHRoZSBmaWVsZCB0byBmaWx0ZXIgYnkuXG5cdCAqIEBwYXJhbSB7IShBcnJheXwqKX0gYXJncyBBIHZhcmlhYmxlIGFtb3VudCBvZiB2YWx1ZXMgdG8gYmUgdXNlZCB3aXRoXG5cdCAqIHRoZSBcIm5vbmVcIiBvcGVyYXRvci4gQ2FuIGJlIHBhc3NlZCBlaXRoZXIgYXMgYSBzaW5nbGUgYXJyYXkgb3IgYXNcblx0ICogc2VwYXJhdGUgcGFyYW1zLlxuXHQgKiBAcmV0dXJuIHtEYXRhQXBpSGVscGVyfSBSZXR1cm5zIHRoZSB7QGxpbmsgRGF0YUFwaUhlbHBlcn0gb2JqZWN0IGl0c2VsZiwgc29cblx0ICogICBjYWxscyBjYW4gYmUgY2hhaW5lZC5cblx0ICogQGNoYWlubmFibGVcblx0ICovXG4gIGFueShmaWVsZCwgLi4uYXJncykge1xuICAgIHJldHVybiB0aGlzLndoZXJlKEZpbHRlci5hbnkoZmllbGQsIGFyZ3MpKTtcbiAgfVxuXG4gIC8qKlxuXHQgKiBBZGRzIGEgZmlsdGVyIHRvIGJlIGNvbXBvc2Ugd2l0aCB0aGlzIGZpbHRlciB1c2luZyBcImdwXCIgb3BlcmF0b3IuIFRoaXMgaXMgYVxuXHQgKiBzcGVjaWFsIHVzZSBjYXNlIG9mIGBGaWx0ZXIucG9seWdvbmAgZm9yIGJvdW5kaW5nIGJveGVzLlxuXHQgKiBAcGFyYW0ge3N0cmluZ30gZmllbGQgVGhlIGZpZWxkJ3MgbmFtZS5cblx0ICogQHBhcmFtIHsqfSBib3hPclVwcGVyTGVmdCBFaXRoZXIgYSBgR2VvLkJvdW5kaW5nQm94YCBpbnN0YW5jZSwgb3IgYVxuXHQgKiBib3VuZGluZyBib3gncyB1cHBlciBsZWZ0IGNvb3JkaW5hdGUuXG5cdCAqIEBwYXJhbSB7Kj19IG9wdF9sb3dlclJpZ2h0IEEgYm91bmRpbmcgYm94J3MgbG93ZXIgcmlnaHQgY29vcmRpbmF0ZS5cblx0ICogQHJldHVybiB7RGF0YUFwaUhlbHBlcn0gUmV0dXJucyB0aGUge0BsaW5rIERhdGFBcGlIZWxwZXJ9IG9iamVjdCBpdHNlbGYsIHNvXG5cdCAqICAgY2FsbHMgY2FuIGJlIGNoYWluZWQuXG5cdCAqIEBjaGFpbm5hYmxlXG5cdCAqL1xuICBib3VuZGluZ0JveChmaWVsZCwgYm94T3JVcHBlckxlZnQsIG9wdF9sb3dlclJpZ2h0KSB7XG4gICAgcmV0dXJuIHRoaXMud2hlcmUoXG4gICAgICBGaWx0ZXIuYm91bmRpbmdCb3goZmllbGQsIGJveE9yVXBwZXJMZWZ0LCBvcHRfbG93ZXJSaWdodClcbiAgICApO1xuICB9XG5cbiAgLyoqXG5cdCAqIEFkZHMgYSBmaWx0ZXIgdG8gYmUgY29tcG9zZSB3aXRoIHRoaXMgZmlsdGVyIHVzaW5nIFwiZ2RcIiBvcGVyYXRvci5cblx0ICogQHBhcmFtIHtzdHJpbmd9IGZpZWxkIFRoZSBmaWVsZCdzIG5hbWUuXG5cdCAqIEBwYXJhbSB7Kn0gbG9jYXRpb25PckNpcmNsZSBFaXRoZXIgYSBgR2VvLkNpcmNsZWAgaW5zdGFuY2Ugb3IgYVxuXHQgKiBjb29yZGluYXRlLlxuXHQgKiBAcGFyYW0ge1JhbmdlfHN0cmluZz19IG9wdF9yYW5nZU9yRGlzdGFuY2UgRWl0aGVyIGEgYFJhbmdlYCBpbnN0YW5jZSBvclxuXHQgKiB0aGUgZGlzdGFuY2UgdmFsdWUuXG5cdCAqIEByZXR1cm4ge0RhdGFBcGlIZWxwZXJ9IFJldHVybnMgdGhlIHtAbGluayBEYXRhQXBpSGVscGVyfSBvYmplY3QgaXRzZWxmLCBzb1xuXHQgKiAgIGNhbGxzIGNhbiBiZSBjaGFpbmVkLlxuXHQgKiBAY2hhaW5uYWJsZVxuXHQgKi9cbiAgZGlzdGFuY2UoZmllbGQsIGxvY2F0aW9uT3JDaXJjbGUsIG9wdF9yYW5nZU9yRGlzdGFuY2UpIHtcbiAgICByZXR1cm4gdGhpcy53aGVyZShcbiAgICAgIEZpbHRlci5kaXN0YW5jZShmaWVsZCwgbG9jYXRpb25PckNpcmNsZSwgb3B0X3JhbmdlT3JEaXN0YW5jZSlcbiAgICApO1xuICB9XG5cbiAgLyoqXG5cdCAqIEFkZHMgYSBmaWx0ZXIgdG8gYmUgY29tcG9zZSB3aXRoIHRoaXMgZmlsdGVyIHVzaW5nIFwicmFuZ2VcIiBvcGVyYXRvci5cblx0ICogQHBhcmFtIHtzdHJpbmd9IGZpZWxkIFRoZSBmaWVsZCdzIG5hbWUuXG5cdCAqIEBwYXJhbSB7Kn0gcmFuZ2VPck1pbiBFaXRoZXIgYSBgUmFuZ2VgIGluc3RhbmNlIG9yIGEgdGhlIHJhbmdlJ3MgbWluXG5cdCAqIHZhbHVlLlxuXHQgKiBAcGFyYW0geyo9fSBvcHRfbWF4IFRoZSByYW5nZSdzIG1heCB2YWx1ZS5cblx0ICogQHJldHVybiB7RGF0YUFwaUhlbHBlcn0gUmV0dXJucyB0aGUge0BsaW5rIERhdGFBcGlIZWxwZXJ9IG9iamVjdCBpdHNlbGYsIHNvXG5cdCAqICAgY2FsbHMgY2FuIGJlIGNoYWluZWQuXG5cdCAqIEBjaGFpbm5hYmxlXG5cdCAqL1xuICByYW5nZShmaWVsZCwgcmFuZ2VPck1pbiwgb3B0X21heCkge1xuICAgIHJldHVybiB0aGlzLndoZXJlKEZpbHRlci5yYW5nZShmaWVsZCwgcmFuZ2VPck1pbiwgb3B0X21heCkpO1xuICB9XG5cbiAgLyoqXG5cdCAqIFNldHMgdGhlIGxpbWl0IGZvciB0aGlzIHJlcXVlc3QncyB7QGxpbmsgUXVlcnl9LlxuXHQgKiBAcGFyYW0ge251bWJlcn0gbGltaXQgVGhlIG1heCBhbW91bnQgb2YgZW50cmllcyB0aGF0IHRoaXMgcmVxdWVzdCBzaG91bGRcblx0ICogICByZXR1cm4uXG5cdCAqIEByZXR1cm4ge0RhdGFBcGlIZWxwZXJ9IFJldHVybnMgdGhlIHtAbGluayBEYXRhQXBpSGVscGVyfSBvYmplY3QgaXRzZWxmLCBzb1xuXHQgKiAgIGNhbGxzIGNhbiBiZSBjaGFpbmVkLlxuXHQgKiBAY2hhaW5uYWJsZVxuXHQgKi9cbiAgbGltaXQobGltaXQpIHtcbiAgICB0aGlzLmdldE9yQ3JlYXRlUXVlcnlfKCkubGltaXQobGltaXQpO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLyoqXG5cdCAqIFNldHMgdGhlIG9mZnNldCBmb3IgdGhpcyByZXF1ZXN0J3Mge0BsaW5rIFF1ZXJ5fS5cblx0ICogQHBhcmFtIHtudW1iZXJ9IG9mZnNldCBUaGUgaW5kZXggb2YgdGhlIGZpcnN0IGVudHJ5IHRoYXQgc2hvdWxkIGJlXG5cdCAqIHJldHVybmVkIGJ5IHRoaXMgcXVlcnkuXG5cdCAqIEByZXR1cm4ge0RhdGFBcGlIZWxwZXJ9IFJldHVybnMgdGhlIHtAbGluayBEYXRhQXBpSGVscGVyfSBvYmplY3QgaXRzZWxmLCBzb1xuXHQgKiAgIGNhbGxzIGNhbiBiZSBjaGFpbmVkLlxuXHQgKiBAY2hhaW5uYWJsZVxuXHQgKi9cbiAgb2Zmc2V0KG9mZnNldCkge1xuICAgIHRoaXMuZ2V0T3JDcmVhdGVRdWVyeV8oKS5vZmZzZXQob2Zmc2V0KTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8qKlxuXHQgKiBBZGRzIGEgaGlnaGxpZ2h0IGVudHJ5IHRvIHRoaXMgcmVxdWVzdCdzIHtAbGluayBRdWVyeX0gaW5zdGFuY2UuXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBmaWVsZCBUaGUgZmllbGQncyBuYW1lLlxuXHQgKiBAcmV0dXJuIHtEYXRhQXBpSGVscGVyfSBSZXR1cm5zIHRoZSB7QGxpbmsgRGF0YUFwaUhlbHBlcn0gb2JqZWN0IGl0c2VsZiwgc29cblx0ICogICBjYWxscyBjYW4gYmUgY2hhaW5lZC5cblx0ICogQGNoYWlubmFibGVcblx0ICovXG4gIGhpZ2hsaWdodChmaWVsZCkge1xuICAgIHRoaXMuZ2V0T3JDcmVhdGVRdWVyeV8oKS5oaWdobGlnaHQoZmllbGQpO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLyoqXG5cdCAqIEFkZHMgYW4gYWdncmVnYXRpb24gdG8gdGhpcyB7QGxpbmsgUXVlcnl9IGluc3RhbmNlLlxuXHQgKiBAcGFyYW0ge3N0cmluZ30gbmFtZSBUaGUgYWdncmVnYXRpb24gbmFtZS5cblx0ICogQHBhcmFtIHshQWdncmVnYXRpb258c3RyaW5nfSBhZ2dyZWdhdGlvbk9yRmllbGQgRWl0aGVyIGFuIHtAbGlua1xuXHQgKiBBZ2dyZWdhdGlvbn0gaW5zdGFuY2Ugb3IgdGhlIG5hbWUgb2YgdGhlIGFnZ3JlZ2F0aW9uIGZpZWxkLlxuXHQgKiBAcGFyYW0ge3N0cmluZz19IG9wdF9vcGVyYXRvciBUaGUgYWdncmVnYXRpb24gb3BlcmF0b3IuXG5cdCAqIEByZXR1cm4ge0RhdGFBcGlIZWxwZXJ9IFJldHVybnMgdGhlIHtAbGluayBEYXRhQXBpSGVscGVyfSBvYmplY3QgaXRzZWxmLCBzb1xuXHQgKiAgIGNhbGxzIGNhbiBiZSBjaGFpbmVkLlxuXHQgKiBAY2hhaW5uYWJsZVxuXHQgKi9cbiAgYWdncmVnYXRlKG5hbWUsIGFnZ3JlZ2F0aW9uT3JGaWVsZCwgb3B0X29wZXJhdG9yKSB7XG4gICAgdGhpcy5nZXRPckNyZWF0ZVF1ZXJ5XygpLmFnZ3JlZ2F0ZShuYW1lLCBhZ2dyZWdhdGlvbk9yRmllbGQsIG9wdF9vcGVyYXRvcik7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICAvKipcblx0ICogU2V0cyB0aGlzIHJlcXVlc3QncyBxdWVyeSB0eXBlIHRvICdjb3VudCcuXG5cdCAqIEByZXR1cm4ge0RhdGFBcGlIZWxwZXJ9IFJldHVybnMgdGhlIHtAbGluayBEYXRhQXBpSGVscGVyfSBvYmplY3QgaXRzZWxmLCBzb1xuXHQgKiAgIGNhbGxzIGNhbiBiZSBjaGFpbmVkLlxuXHQgKiBAY2hhaW5uYWJsZVxuXHQgKi9cbiAgY291bnQoKSB7XG4gICAgdGhpcy5nZXRPckNyZWF0ZVF1ZXJ5XygpLnR5cGUoJ2NvdW50Jyk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICAvKipcblx0ICogQWRkcyBhIHNvcnQgcXVlcnkgdG8gdGhpcyByZXF1ZXN0J3MgYm9keS5cblx0ICogQHBhcmFtIHtzdHJpbmd9IGZpZWxkIFRoZSBmaWVsZCB0aGF0IHRoZSBxdWVyeSBzaG91bGQgYmUgc29ydGVkIGJ5LlxuXHQgKiBAcGFyYW0ge3N0cmluZz19IG9wdF9kaXJlY3Rpb24gVGhlIGRpcmVjdGlvbiB0aGUgc29ydCBvcGVyYXRpb24gc2hvdWxkXG5cdCAqIHVzZS4gSWYgbm9uZSBpcyBnaXZlbiwgJ2FzYycgaXMgdXNlZCBieSBkZWZhdWx0LlxuXHQgKiBAcmV0dXJuIHtEYXRhQXBpSGVscGVyfSBSZXR1cm5zIHRoZSB7QGxpbmsgRGF0YUFwaUhlbHBlcn0gb2JqZWN0IGl0c2VsZiwgc29cblx0ICogICBjYWxscyBjYW4gYmUgY2hhaW5lZC5cblx0ICogQGNoYWlubmFibGVcblx0ICovXG4gIG9yZGVyQnkoZmllbGQsIG9wdF9kaXJlY3Rpb24pIHtcbiAgICB0aGlzLmdldE9yQ3JlYXRlUXVlcnlfKCkuc29ydChmaWVsZCwgb3B0X2RpcmVjdGlvbik7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICAvKipcblx0ICogQ3JlYXRlcyBhbiBvYmplY3QgKG9yIG11bHRpcGxlIG9iamVjdHMpIGFuZCBzYXZlcyBpdCB0byBXZURlcGxveSBkYXRhLiBJZlxuXHQgKiB0aGVyZSdzIGEgdmFsaWRhdGlvbiByZWdpc3RlcmVkIGluIHRoZSBjb2xsZWN0aW9uIGFuZCB0aGUgcmVxdWVzdCBpc1xuXHQgKiBzdWNjZXNzZnVsLCB0aGUgcmVzdWx0aW5nIG9iamVjdCAob3IgYXJyYXkgb2Ygb2JqZWN0cykgaXMgcmV0dXJuZWQuIFRoZVxuXHQgKiBkYXRhIHBhcmFtZXRlciBjYW4gYmUgZWl0aGVyIGFuIE9iamVjdCBvciBhbiBBcnJheSBvZiBPYmplY3RzLlxuXHQgKiBUaGVzZSBPYmplY3RzIGRlc2NyaWJlIHRoZSBhdHRyaWJ1dGVzIG9uIHRoZSBvYmplY3RzIHRoYXQgYXJlIHRvIGJlXG5cdCAqICAgY3JlYXRlZC5cblx0ICogYGBgamF2YXNjcmlwdFxuXHQgKiB2YXIgZGF0YSA9IFdlRGVwbG95LmRhdGEoJ2h0dHA6Ly9kZW1vZGF0YS53ZWRlcGxveS5pbycpO1xuXHQgKlxuXHQgKiBkYXRhLmNyZWF0ZShcblx0ICogICAnbW92aWVzJywgeyd0aXRsZSc9PiAnU3RhciBXYXJzOiBFcGlzb2RlIEkg4oCTIFRoZSBQaGFudG9tIE1lbmFjZSd9KVxuXHQgKiBcdCAudGhlbihmdW5jdGlvbihtb3ZpZSl7XG5cdCAqICAgICBjb25zb2xlLmxvZyhtb3ZpZSlcblx0ICogICB9KTtcblx0ICpcblx0ICogZGF0YS5jcmVhdGUoXG5cdCAqICAgJ21vdmllcycsIFt7J3RpdGxlJz0+ICdTdGFyIFdhcnM6IEVwaXNvZGUgSUkg4oCTIEF0dGFjayBvZiB0aGUgQ2xvbmVzJ30sXG5cdCAqIFx0XHRcdFx0XHRcdCAgeyd0aXRsZSc9PiAnU3RhciBXYXJzOiBFcGlzb2RlIElJSSDigJMgUmV2ZW5nZSBvZiB0aGUgU2l0aCd9KVxuXHQgKiBcdFx0IC50aGVuKGZ1bmN0aW9uKG1vdmllcyl7XG5cdCAqIFx0XHRcdCBjb25zb2xlLmxvZyhtb3ZpZXMpXG5cdCAqICAgICB9KTtcblx0ICogYGBgXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBjb2xsZWN0aW9uIENvbGxlY3Rpb24gKGtleSkgdXNlZCB0byBjcmVhdGUgdGhlIG5ldyBkYXRhLlxuXHQgKiBAcGFyYW0ge09iamVjdH0gZGF0YSBBdHRyaWJ1dGVzIG9uIHRoZSBvYmplY3QgdGhhdCBpcyB0byBiZSBjcmVhdGVkLlxuXHQgKiBAcmV0dXJuIHshQ2FuY2VsbGFibGVQcm9taXNlfVxuXHQgKi9cbiAgY3JlYXRlKGNvbGxlY3Rpb24sIGRhdGEpIHtcbiAgICBhc3NlcnREZWZBbmROb3ROdWxsKGNvbGxlY3Rpb24sICdDb2xsZWN0aW9uIGtleSBtdXN0IGJlIHNwZWNpZmllZC4nKTtcbiAgICBhc3NlcnRPYmplY3QoZGF0YSwgJ0RhdGEgY2FuXFwndCBiZSBlbXB0eS4nKTtcblxuICAgIHJldHVybiB0aGlzLmJ1aWxkVXJsXygpXG4gICAgICAucGF0aChjb2xsZWN0aW9uKVxuICAgICAgLnBvc3QoZGF0YSlcbiAgICAgIC50aGVuKHJlc3BvbnNlID0+IGFzc2VydFJlc3BvbnNlU3VjY2VlZGVkKHJlc3BvbnNlKSlcbiAgICAgIC50aGVuKHJlc3BvbnNlID0+IHJlc3BvbnNlLmJvZHkoKSk7XG4gIH1cblxuICAvKipcblx0ICogUmVwbGFjZXMgdGhlIGF0dHJpYnV0ZXMgb2YgYSBkb2N1bWVudCBmb3JtIHRoZSBwYXNzZWQtaW4gb2JqZWN0IGFuZCBzYXZlc1xuXHQgKiB0aGUgcmVjb3JkLiBJZiB0aGUgb2JqZWN0IGlzIGludmFsaWQsIHRoZSBzYXZpbmcgd2lsbCBmYWlsIGFuZCBhbiBlcnJvclxuXHQgKiBvYmplY3Qgd2lsbCBiZSByZXR1cm5lZC5cblx0ICpcblx0ICogYGBgamF2YXNjcmlwdFxuXHQgKiB2YXIgZGF0YSA9IFdlRGVwbG95LmRhdGEoJ2h0dHA6Ly9kZW1vZGF0YS53ZWRlcGxveS5pbycpO1xuXHQgKlxuXHQgKiBkYXRhLnJlcGxhY2UoJ21vdmllcy8xMDE5MTEyMzUzJywgeyd0aXRsZSc9PiAnU3RhciBXYXJzOiBFcGlzb2RlIEknfSlcblx0ICogXHRcdCAudGhlbihmdW5jdGlvbihtb3ZpZSl7XG5cdCAqIFx0XHRcdCBjb25zb2xlLmxvZyhtb3ZpZSlcblx0ICogICAgIH0pO1xuXHQgKiBgYGBcblx0ICogQHBhcmFtIHtzdHJpbmd9IGRvYyBLZXkgdXNlZCB0byB1cGRhdGUgdGhlIGRvY3VtZW50LlxuXHQgKiBAcGFyYW0ge09iamVjdH0gZGF0YSBBdHRyaWJ1dGVzIG9uIHRoZSBvYmplY3QgdGhhdCBpcyB0byBiZSB1cGRhdGVkLlxuXHQgKiBAcmV0dXJuIHshQ2FuY2VsbGFibGVQcm9taXNlfVxuXHQgKi9cbiAgcmVwbGFjZShkb2MsIGRhdGEpIHtcbiAgICBhc3NlcnREZWZBbmROb3ROdWxsKGRvYywgJ0RvY3VtZW50IGtleSBtdXN0IGJlIHNwZWNpZmllZC4nKTtcbiAgICBhc3NlcnRPYmplY3QoZGF0YSwgJ0RhdGEgbXVzdCBiZSBzcGVjaWZpZWQuJyk7XG5cbiAgICByZXR1cm4gdGhpcy5idWlsZFVybF8oKVxuICAgICAgLnBhdGgoZG9jKVxuICAgICAgLnB1dChkYXRhKVxuICAgICAgLnRoZW4ocmVzcG9uc2UgPT4gYXNzZXJ0UmVzcG9uc2VTdWNjZWVkZWQocmVzcG9uc2UpKVxuICAgICAgLnRoZW4ocmVzcG9uc2UgPT4gcmVzcG9uc2UuYm9keSgpKTtcbiAgfVxuXG4gIC8qKlxuXHQgKiBVcGRhdGUgdGhlIGF0dHJpYnV0ZXMgb2YgYSBkb2N1bWVudCBmb3JtIHRoZSBwYXNzZWQtaW4gb2JqZWN0IGFuZCBzYXZlc1xuXHQgKiB0aGUgcmVjb3JkLiBJZiB0aGUgb2JqZWN0IGlzIGludmFsaWQsIHRoZSBzYXZpbmcgd2lsbCBmYWlsIGFuZCBhbiBlcnJvclxuXHQgKiBvYmplY3Qgd2lsbCBiZSByZXR1cm5lZC5cblx0ICpcblx0ICogYGBgamF2YXNjcmlwdFxuXHQgKiB2YXIgZGF0YSA9IFdlRGVwbG95LmRhdGEoJ2h0dHA6Ly9kZW1vZGF0YS53ZWRlcGxveS5pbycpO1xuXHQgKlxuXHQgKiBkYXRhLnVwZGF0ZSgnbW92aWVzLzEwMTkxMTIzNTMnLCB7J3RpdGxlJz0+ICdTdGFyIFdhcnM6IEVwaXNvZGUgSSd9KVxuXHQgKiBcdFx0IC50aGVuKGZ1bmN0aW9uKG1vdmllKXtcblx0ICogXHRcdFx0IGNvbnNvbGUubG9nKG1vdmllKVxuXHQgKiAgICAgfSk7XG5cdCAqIGBgYFxuXHQgKiBAcGFyYW0ge3N0cmluZ30gZG9jIEtleSB1c2VkIHRvIHVwZGF0ZSB0aGUgZG9jdW1lbnQuXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhIEF0dHJpYnV0ZXMgb24gdGhlIG9iamVjdCB0aGF0IGlzIHRvIGJlIHVwZGF0ZWQuXG5cdCAqIEByZXR1cm4geyFDYW5jZWxsYWJsZVByb21pc2V9XG5cdCAqL1xuICB1cGRhdGUoZG9jLCBkYXRhKSB7XG4gICAgYXNzZXJ0RGVmQW5kTm90TnVsbChkb2MsICdEb2N1bWVudCBrZXkgbXVzdCBiZSBzcGVjaWZpZWQuJyk7XG4gICAgYXNzZXJ0T2JqZWN0KGRhdGEsICdEYXRhIG11c3QgYmUgc3BlY2lmaWVkLicpO1xuXG4gICAgcmV0dXJuIHRoaXMuYnVpbGRVcmxfKClcbiAgICAgIC5wYXRoKGRvYylcbiAgICAgIC5wYXRjaChkYXRhKVxuICAgICAgLnRoZW4ocmVzcG9uc2UgPT4gYXNzZXJ0UmVzcG9uc2VTdWNjZWVkZWQocmVzcG9uc2UpKVxuICAgICAgLnRoZW4ocmVzcG9uc2UgPT4gcmVzcG9uc2UuYm9keSgpKTtcbiAgfVxuXG4gIC8qKlxuXHQgKiBEZWxldGVzIGEgW2RvY3VtZW50L2ZpZWxkL2NvbGxlY3Rpb25dLlxuXHQgKiBAcGFyYW0ge3N0cmluZ30ga2V5IEtleSB1c2VkIHRvIGRlbGV0ZSB0aGVcblx0ICogZG9jdW1lbnQvZmllbGQvY29sbGVjdGlvbi5cblx0ICogQHJldHVybiB7IUNhbmNlbGxhYmxlUHJvbWlzZX1cblx0ICovXG4gIGRlbGV0ZShrZXkpIHtcbiAgICBhc3NlcnREZWZBbmROb3ROdWxsKGtleSwgJ0RvY3VtZW50L0ZpZWxkL0NvbGxlY3Rpb24ga2V5IG11c3QgYmUgc3BlY2lmaWVkJyk7XG5cbiAgICByZXR1cm4gdGhpcy5idWlsZFVybF8oKVxuICAgICAgLnBhdGgoa2V5KVxuICAgICAgLmRlbGV0ZSgpXG4gICAgICAudGhlbihyZXNwb25zZSA9PiBhc3NlcnRSZXNwb25zZVN1Y2NlZWRlZChyZXNwb25zZSkpXG4gICAgICAudGhlbigoKSA9PiB1bmRlZmluZWQpO1xuICB9XG5cbiAgLyoqXG5cdCAqIFJldHJpZXZlIGRhdGEgZnJvbSBhIFtkb2N1bWVudC9maWVsZC9jb2xsZWN0aW9uXS5cblx0ICogQHBhcmFtIHtzdHJpbmd9IGtleSBLZXkgdXNlZCB0byBkZWxldGUgdGhlIGRvY3VtZW50L2ZpZWxkL2NvbGxlY3Rpb24uXG5cdCAqIEByZXR1cm4geyFDYW5jZWxsYWJsZVByb21pc2V9XG5cdCAqL1xuICBnZXQoa2V5KSB7XG4gICAgYXNzZXJ0RGVmQW5kTm90TnVsbChrZXksICdEb2N1bWVudC9GaWVsZC9Db2xsZWN0aW9uIGtleSBtdXN0IGJlIHNwZWNpZmllZCcpO1xuXG4gICAgcmV0dXJuIHRoaXMuYnVpbGRVcmxfKClcbiAgICAgIC5wYXRoKGtleSlcbiAgICAgIC5nZXQodGhpcy5wcm9jZXNzQW5kUmVzZXRRdWVyeVN0YXRlKCkpXG4gICAgICAudGhlbihyZXNwb25zZSA9PiBhc3NlcnRSZXNwb25zZVN1Y2NlZWRlZChyZXNwb25zZSkpXG4gICAgICAudGhlbihyZXNwb25zZSA9PiByZXNwb25zZS5ib2R5KCkpO1xuICB9XG5cbiAgLyoqXG5cdCAqIFJldHJpZXZlIGRhdGEgZnJvbSBhIFtkb2N1bWVudC9maWVsZC9jb2xsZWN0aW9uXSBhbmQgcHV0IGl0IGluIGEgc2VhcmNoXG5cdCAqIGZvcm1hdC5cblx0ICogQHBhcmFtIHtzdHJpbmd9IGtleSBLZXkgdXNlZCB0byBkZWxldGUgdGhlIGRvY3VtZW50L2ZpZWxkL2NvbGxlY3Rpb24uXG5cdCAqIEByZXR1cm4geyFDYW5jZWxsYWJsZVByb21pc2V9XG5cdCAqL1xuICBzZWFyY2goa2V5KSB7XG4gICAgYXNzZXJ0RGVmQW5kTm90TnVsbChrZXksICdEb2N1bWVudC9GaWVsZC9Db2xsZWN0aW9uIGtleSBtdXN0IGJlIHNwZWNpZmllZCcpO1xuXG4gICAgdGhpcy5pc1NlYXJjaF8gPSB0cnVlO1xuXG4gICAgcmV0dXJuIHRoaXMuYnVpbGRVcmxfKClcbiAgICAgIC5wYXRoKGtleSlcbiAgICAgIC5nZXQodGhpcy5wcm9jZXNzQW5kUmVzZXRRdWVyeVN0YXRlKCkpXG4gICAgICAudGhlbihyZXNwb25zZSA9PiBhc3NlcnRSZXNwb25zZVN1Y2NlZWRlZChyZXNwb25zZSkpXG4gICAgICAudGhlbihyZXNwb25zZSA9PiByZXNwb25zZS5ib2R5KCkpO1xuICB9XG5cbiAgLyoqXG5cdCAqIENyZWF0ZXMgbmV3IHNvY2tldC5pbyBpbnN0YW5jZS4gTW9uaXRvciB0aGUgYXJyaXZhbCBvZiBuZXcgYnJvYWRjYXN0ZWRcblx0ICogZGF0YS5cblx0ICogQHBhcmFtICB7c3RyaW5nfSBjb2xsZWN0aW9uIGtleS9jb2xsZWN0aW9uIHVzZWQgdG8gZmluZCBvcmdhbml6ZWQgZGF0YS5cblx0ICogQHBhcmFtICB7T2JqZWN0PX0gb3B0X29wdGlvbnMgT2JqZWN0IHdpdGggU29ja2V0IElPIG9wdGlvbnMuXG5cdCAqIEByZXR1cm4geyFpb30gU29ja2V0IElPIHJlZmVyZW5jZS4gU2VydmVyIGV2ZW50cyBjYW4gYmUgbGlzdGVuZWQgb24gaXQuXG5cdCAqL1xuICB3YXRjaChjb2xsZWN0aW9uLCBvcHRfb3B0aW9ucykge1xuICAgIGFzc2VydERlZkFuZE5vdE51bGwoY29sbGVjdGlvbiwgJ0NvbGxlY3Rpb24ga2V5IG11c3QgYmUgc3BlY2lmaWVkJyk7XG5cbiAgICByZXR1cm4gdGhpcy5idWlsZFVybF8oKVxuICAgICAgLnBhdGgoY29sbGVjdGlvbilcbiAgICAgIC53YXRjaCh0aGlzLnByb2Nlc3NBbmRSZXNldFF1ZXJ5U3RhdGUoKSwgb3B0X29wdGlvbnMpO1xuICB9XG5cbiAgLyoqXG5cdCogQnVpbGRzIFVSTCBieSBqb2luaW5nIHRoZSBoZWFkZXJzIGFuZCBhdXRoLlxuXHQqIEByZXR1cm4ge1dlRGVwbG95fSBSZXR1cm5zIHRoZSB7QGxpbmsgV2VEZXBsb3l9IG9iamVjdCBpdHNlbGYsIHNvIGNhbGxzIGNhblxuXHQqICAgYmUgY2hhaW5lZC5cblx0KiBAY2hhaW5hYmxlXG5cdCovXG4gIGJ1aWxkVXJsXygpIHtcbiAgICByZXR1cm4gdGhpcy53ZWRlcGxveUNsaWVudFxuICAgICAgLnVybCh0aGlzLndlZGVwbG95Q2xpZW50LmRhdGFVcmxfKVxuICAgICAgLmhlYWRlcnModGhpcy5oZWFkZXJzXylcbiAgICAgIC5hdXRoKHRoaXMuaGVscGVyQXV0aFNjb3BlKTtcbiAgfVxuXG4gIC8qKlxuXHQgKiBHZXRzIHRoZSBjdXJyZW50bHkgdXNlZCBtYWluIHtAbGluayBGaWx0ZXJ9IG9iamVjdC4gSWYgbm9uZSBleGlzdHMgeWV0LCBhXG5cdCAqIG5ldyBvbmUgaXMgY3JlYXRlZC5cblx0ICogQHJldHVybiB7IVF1ZXJ5fVxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqL1xuICBnZXRPckNyZWF0ZUZpbHRlcl8oKSB7XG4gICAgaWYgKCF0aGlzLmZpbHRlcl8pIHtcbiAgICAgIHRoaXMuZmlsdGVyXyA9IG5ldyBGaWx0ZXIoKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuZmlsdGVyXztcbiAgfVxuXG4gIC8qKlxuXHQgKiBHZXRzIHRoZSBjdXJyZW50bHkgdXNlZCB7QGxpbmsgUXVlcnl9IG9iamVjdC4gSWYgbm9uZSBleGlzdHMgeWV0LFxuXHQgKiBhIG5ldyBvbmUgaXMgY3JlYXRlZC5cblx0ICogQHJldHVybiB7IVF1ZXJ5fVxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqL1xuICBnZXRPckNyZWF0ZVF1ZXJ5XygpIHtcbiAgICBpZiAoIXRoaXMucXVlcnlfKSB7XG4gICAgICB0aGlzLnF1ZXJ5XyA9IG5ldyBRdWVyeSgpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5xdWVyeV87XG4gIH1cblxuICAvKipcblx0ICogQWdncmVnYXRlIGZpbHRlcnMgaW50byBxdWVyeSBhbmQgcmV0dXJuIGl0cyBsYXRlc3QgdmFsdWUuIFF1ZXJ5IGFuZFxuXHQgKiBmaWx0ZXJzIGFyZSBjbGVhbmVkIGFmdGVyIGFnZ3JlZ2F0aW9uLlxuXHQgKiBAcmV0dXJuIHtRdWVyeX1cblx0ICogQHByb3RlY3RlZFxuXHQgKi9cbiAgcHJvY2Vzc0FuZFJlc2V0UXVlcnlTdGF0ZSgpIHtcbiAgICBsZXQgZmlsdGVyO1xuXG4gICAgaWYgKGNvcmUuaXNEZWZBbmROb3ROdWxsKHRoaXMuZmlsdGVyXykpIHtcbiAgICAgIGZpbHRlciA9IHRoaXMuZ2V0T3JDcmVhdGVGaWx0ZXJfKCk7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuaXNTZWFyY2hfKSB7XG4gICAgICB0aGlzLmdldE9yQ3JlYXRlUXVlcnlfKCkuc2VhcmNoKGZpbHRlcik7XG4gICAgfSBlbHNlIGlmIChmaWx0ZXIpIHtcbiAgICAgIHRoaXMuZ2V0T3JDcmVhdGVRdWVyeV8oKS5maWx0ZXIoZmlsdGVyKTtcbiAgICB9XG5cbiAgICBjb25zdCBxdWVyeSA9IHRoaXMucXVlcnlfO1xuICAgIHRoaXMuaGVhZGVyc18uY2xlYXIoKTtcbiAgICB0aGlzLmZpbHRlcl8gPSBudWxsO1xuICAgIHRoaXMuaXNTZWFyY2hfID0gZmFsc2U7XG4gICAgdGhpcy5xdWVyeV8gPSBudWxsO1xuICAgIHJldHVybiBxdWVyeTtcbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBEYXRhQXBpSGVscGVyO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL2FwaS9kYXRhL0RhdGFBcGlIZWxwZXIuanMiLCIndXNlIHN0cmljdCc7XG5cbmltcG9ydCB7YXNzZXJ0RGVmQW5kTm90TnVsbCwgYXNzZXJ0UmVzcG9uc2VTdWNjZWVkZWR9IGZyb20gJy4uL2Fzc2VydGlvbnMnO1xuaW1wb3J0IHtNdWx0aU1hcH0gZnJvbSAnbWV0YWwtc3RydWN0cyc7XG5pbXBvcnQgQXBpSGVscGVyIGZyb20gJy4uL0FwaUhlbHBlcic7XG5cbi8qKlxuICogQ2xhc3MgcmVzcG9uc2libGUgZm9yIGVuY2Fwc3VsYXRlIGVtYWlsIGFwaSBjYWxscy5cbiAqL1xuY2xhc3MgRW1haWxBcGlIZWxwZXIgZXh0ZW5kcyBBcGlIZWxwZXIge1xuICAvKipcblx0ICogQ29uc3RydWN0cyBhbiB7QGxpbmsgRW1haWxBcGlIZWxwZXJ9IGluc3RhbmNlLlxuXHQgKiBAcGFyYW0geyFXZURlcGxveX0gd2VkZXBsb3lDbGllbnQge0BsaW5rIFdlRGVwbG95fSBjbGllbnQgcmVmZXJlbmNlLlxuXHQgKiBAY29uc3RydWN0b3Jcblx0ICovXG4gIGNvbnN0cnVjdG9yKHdlZGVwbG95Q2xpZW50KSB7XG4gICAgc3VwZXIod2VkZXBsb3lDbGllbnQpO1xuICAgIHRoaXMucGFyYW1zID0gbmV3IE11bHRpTWFwKCk7XG4gIH1cblxuICAvKipcblx0ICogU2V0IGZyb20gYXR0cmlidXRlIG9uIHBhcmFtcyB0byBiZSBzZW5kIG9uIGVtYWlsIHJlcXVlc3QuXG5cdCAqIEBwYXJhbSAge3N0cmluZ30gZnJvbVxuXHQgKiBAcmV0dXJuIHtFbWFpbEFwaUhlbHBlcn0gUmV0dXJucyB0aGUge0BsaW5rIEVtYWlsQXBpSGVscGVyfSBvYmplY3QgaXRzZWxmLFxuXHQgKiAgIHNvIGNhbGxzIGNhbiBiZSBjaGFpbmVkLlxuXHQgKiBAY2hhaW5hYmxlXG5cdCAqL1xuICBmcm9tKGZyb20pIHtcbiAgICBhc3NlcnREZWZBbmROb3ROdWxsKGZyb20sICdQYXJhbWV0ZXIgXCJmcm9tXCIgbXVzdCBiZSBzcGVjaWZpZWQnKTtcblxuICAgIHRoaXMucGFyYW1zLnNldCgnZnJvbScsIGZyb20pO1xuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICAvKipcblx0ICogU2V0IGJjYyBhdHRyaWJ1dGUgb24gcGFyYW1zIHRvIGJlIHNlbmQgb24gZW1haWwgcmVxdWVzdC5cblx0ICogQHBhcmFtICB7c3RyaW5nfSBiY2Ncblx0ICogQHJldHVybiB7RW1haWxBcGlIZWxwZXJ9IFJldHVybnMgdGhlIHtAbGluayBFbWFpbEFwaUhlbHBlcn0gb2JqZWN0IGl0c2VsZixcblx0ICogICBzbyBjYWxscyBjYW4gYmUgY2hhaW5lZC5cblx0ICogQGNoYWluYWJsZVxuXHQgKi9cbiAgYmNjKGJjYykge1xuICAgIGFzc2VydERlZkFuZE5vdE51bGwoYmNjLCAnUGFyYW1ldGVyIFwiYmNjXCIgbXVzdCBiZSBzcGVjaWZpZWQnKTtcblxuICAgIHRoaXMucGFyYW1zLmFkZCgnYmNjJywgYmNjKTtcblxuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLyoqXG5cdCAqIFNldCBjYyBhdHRyaWJ1dGUgb24gcGFyYW1zIHRvIGJlIHNlbmQgb24gZW1haWwgcmVxdWVzdC5cblx0ICogQHBhcmFtICB7c3RyaW5nfSBjY1xuXHQgKiBAcmV0dXJuIHtFbWFpbEFwaUhlbHBlcn0gUmV0dXJucyB0aGUge0BsaW5rIEVtYWlsQXBpSGVscGVyfSBvYmplY3QgaXRzZWxmLFxuXHQgKiAgIHNvIGNhbGxzIGNhbiBiZSBjaGFpbmVkLlxuXHQgKiBAY2hhaW5hYmxlXG5cdCAqL1xuICBjYyhjYykge1xuICAgIGFzc2VydERlZkFuZE5vdE51bGwoY2MsICdQYXJhbWV0ZXIgXCJjY1wiIG11c3QgYmUgc3BlY2lmaWVkJyk7XG5cbiAgICB0aGlzLnBhcmFtcy5hZGQoJ2NjJywgY2MpO1xuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICAvKipcblx0ICogU2V0IG1lc3NhZ2UgYXR0cmlidXRlIG9uIHBhcmFtcyB0byBiZSBzZW5kIG9uIGVtYWlsIHJlcXVlc3QuXG5cdCAqIEBwYXJhbSAge3N0cmluZ30gbWVzc2FnZVxuXHQgKiBAcmV0dXJuIHtFbWFpbEFwaUhlbHBlcn0gUmV0dXJucyB0aGUge0BsaW5rIEVtYWlsQXBpSGVscGVyfSBvYmplY3QgaXRzZWxmLFxuXHQgKiAgIHNvIGNhbGxzIGNhbiBiZSBjaGFpbmVkLlxuXHQgKiBAY2hhaW5hYmxlXG5cdCAqL1xuICBtZXNzYWdlKG1lc3NhZ2UpIHtcbiAgICBhc3NlcnREZWZBbmROb3ROdWxsKG1lc3NhZ2UsICdQYXJhbWV0ZXIgXCJtZXNzYWdlXCIgbXVzdCBiZSBzcGVjaWZpZWQnKTtcblxuICAgIHRoaXMucGFyYW1zLnNldCgnbWVzc2FnZScsIG1lc3NhZ2UpO1xuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICAvKipcblx0ICogU2V0IHByaW9yaXR5IGF0dHJpYnV0ZSBvbiBwYXJhbXMgdG8gYmUgc2VuZCBvbiBlbWFpbCByZXF1ZXN0LlxuXHQgKiBAcGFyYW0gIHtzdHJpbmd9IHByaW9yaXR5XG5cdCAqIEByZXR1cm4ge0VtYWlsQXBpSGVscGVyfSBSZXR1cm5zIHRoZSB7QGxpbmsgRW1haWxBcGlIZWxwZXJ9IG9iamVjdCBpdHNlbGYsXG5cdCAqICAgc28gY2FsbHMgY2FuIGJlIGNoYWluZWQuXG5cdCAqIEBjaGFpbmFibGVcblx0ICovXG4gIHByaW9yaXR5KHByaW9yaXR5KSB7XG4gICAgYXNzZXJ0RGVmQW5kTm90TnVsbChwcmlvcml0eSwgJ1BhcmFtZXRlciBcInByaW9yaXR5XCIgbXVzdCBiZSBzcGVjaWZpZWQnKTtcblxuICAgIHRoaXMucGFyYW1zLnNldCgncHJpb3JpdHknLCBwcmlvcml0eSk7XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8qKlxuXHQgKiBTZXQgcmVwbHlUbyBhdHRyaWJ1dGUgb24gcGFyYW1zIHRvIGJlIHNlbmQgb24gZW1haWwgcmVxdWVzdC5cblx0ICogQHBhcmFtICB7c3RyaW5nfSByZXBseVRvXG5cdCAqIEByZXR1cm4ge0VtYWlsQXBpSGVscGVyfSBSZXR1cm5zIHRoZSB7QGxpbmsgRW1haWxBcGlIZWxwZXJ9IG9iamVjdCBpdHNlbGYsXG5cdCAqICAgc28gY2FsbHMgY2FuIGJlIGNoYWluZWQuXG5cdCAqIEBjaGFpbmFibGVcblx0ICovXG4gIHJlcGx5VG8ocmVwbHlUbykge1xuICAgIGFzc2VydERlZkFuZE5vdE51bGwocmVwbHlUbywgJ1BhcmFtZXRlciBcInJlcGx5VG9cIiBtdXN0IGJlIHNwZWNpZmllZCcpO1xuXG4gICAgdGhpcy5wYXJhbXMuc2V0KCdyZXBseVRvJywgcmVwbHlUbyk7XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8qKlxuXHQgKiBTZXQgdG8gYXR0cmlidXRlIG9uIHBhcmFtcyB0byBiZSBzZW5kIG9uIGVtYWlsIHJlcXVlc3QuXG5cdCAqIEBwYXJhbSAge3N0cmluZ30gdG9cblx0ICogQHJldHVybiB7RW1haWxBcGlIZWxwZXJ9IFJldHVybnMgdGhlIHtAbGluayBFbWFpbEFwaUhlbHBlcn0gb2JqZWN0IGl0c2VsZixcblx0ICogICBzbyBjYWxscyBjYW4gYmUgY2hhaW5lZC5cblx0ICogQGNoYWluYWJsZVxuXHQgKi9cbiAgdG8odG8pIHtcbiAgICBhc3NlcnREZWZBbmROb3ROdWxsKHRvLCAnUGFyYW1ldGVyIFwidG9cIiBtdXN0IGJlIHNwZWNpZmllZCcpO1xuXG4gICAgdGhpcy5wYXJhbXMuYWRkKCd0bycsIHRvKTtcblxuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLyoqXG5cdCAqIFNldCBzdWJqZWN0IGF0dHJpYnV0ZSBvbiBwYXJhbXMgdG8gYmUgc2VuZCBvbiBlbWFpbCByZXF1ZXN0LlxuXHQgKiBAcGFyYW0gIHtzdHJpbmd9IHN1YmplY3Rcblx0ICogQHJldHVybiB7RW1haWxBcGlIZWxwZXJ9IFJldHVybnMgdGhlIHtAbGluayBFbWFpbEFwaUhlbHBlcn0gb2JqZWN0IGl0c2VsZixcblx0ICogICBzbyBjYWxscyBjYW4gYmUgY2hhaW5lZC5cblx0ICogQGNoYWluYWJsZVxuXHQgKi9cbiAgc3ViamVjdChzdWJqZWN0KSB7XG4gICAgYXNzZXJ0RGVmQW5kTm90TnVsbChzdWJqZWN0LCAnUGFyYW1ldGVyIFwic3ViamVjdFwiIG11c3QgYmUgc3BlY2lmaWVkJyk7XG5cbiAgICB0aGlzLnBhcmFtcy5zZXQoJ3N1YmplY3QnLCBzdWJqZWN0KTtcblxuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLyoqXG5cdCAqIFNlbmRzIGFuIGVtYWlsIGJhc2VkIG9uIGdpdmVuIHBhcmFtcy5cblx0ICogQHJldHVybiB7IUNhbmNlbGxhYmxlUHJvbWlzZX1cblx0ICovXG4gIHNlbmQoKSB7XG4gICAgY29uc3QgY2xpZW50ID0gdGhpcy5idWlsZFVybF8oKS5wYXRoKCdlbWFpbHMnKTtcblxuICAgIHRoaXMucGFyYW1zLm5hbWVzKCkuZm9yRWFjaChuYW1lID0+IHtcbiAgICAgIGNvbnN0IHZhbHVlcyA9IHRoaXMucGFyYW1zLmdldEFsbChuYW1lKTtcblxuICAgICAgdmFsdWVzLmZvckVhY2godmFsdWUgPT4ge1xuICAgICAgICBjbGllbnQuZm9ybShuYW1lLCB2YWx1ZSk7XG4gICAgICB9KTtcbiAgICB9KTtcblxuICAgIHRoaXMucGFyYW1zLmNsZWFyKCk7XG4gICAgdGhpcy5oZWFkZXJzXy5jbGVhcigpO1xuXG4gICAgcmV0dXJuIGNsaWVudFxuICAgICAgLnBvc3QoKVxuICAgICAgLnRoZW4ocmVzcG9uc2UgPT4gYXNzZXJ0UmVzcG9uc2VTdWNjZWVkZWQocmVzcG9uc2UpKVxuICAgICAgLnRoZW4ocmVzcG9uc2UgPT4gcmVzcG9uc2UuYm9keSgpKTtcbiAgfVxuXG4gIC8qKlxuXHQgKiBDaGVja3MgdGhlIHN0YXR1cyBvZiBhbiBlbWFpbC5cblx0ICogQHBhcmFtICB7c3RyaW5nfSBlbWFpbElkXG5cdCAqIEByZXR1cm4geyFDYW5jZWxsYWJsZVByb21pc2V9XG5cdCAqL1xuICBzdGF0dXMoZW1haWxJZCkge1xuICAgIGFzc2VydERlZkFuZE5vdE51bGwoZW1haWxJZCwgJ1BhcmFtZXRlciBcImVtYWlsSWRcIiBwYXJhbSBtdXN0IGJlIHNwZWNpZmllZCcpO1xuXG4gICAgcmV0dXJuIHRoaXMuYnVpbGRVcmxfKClcbiAgICAgIC5wYXRoKCdlbWFpbHMnLCBlbWFpbElkLCAnc3RhdHVzJylcbiAgICAgIC5nZXQoKVxuICAgICAgLnRoZW4ocmVzcG9uc2UgPT4gYXNzZXJ0UmVzcG9uc2VTdWNjZWVkZWQocmVzcG9uc2UpKVxuICAgICAgLnRoZW4ocmVzcG9uc2UgPT4gcmVzcG9uc2UuYm9keSgpKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBCdWlsZHMgVVJMIGJ5IGpvaW5pbmcgdGhlIGhlYWRlcnMgYW5kIGF1dGguXG4gICAqIEByZXR1cm4ge1dlRGVwbG95fSBSZXR1cm5zIHRoZSB7QGxpbmsgV2VEZXBsb3l9IG9iamVjdCBpdHNlbGYsIHNvIGNhbGxzIGNhblxuICAgKiAgIGJlIGNoYWluZWQuXG4gICAqIEBjaGFpbmFibGVcbiAgICovXG4gIGJ1aWxkVXJsXygpIHtcbiAgICByZXR1cm4gdGhpcy53ZWRlcGxveUNsaWVudFxuICAgICAgLnVybCh0aGlzLndlZGVwbG95Q2xpZW50LmVtYWlsVXJsXylcbiAgICAgIC5oZWFkZXJzKHRoaXMuaGVhZGVyc18pXG4gICAgICAuYXV0aCh0aGlzLmhlbHBlckF1dGhTY29wZSk7XG4gIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgRW1haWxBcGlIZWxwZXI7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zcmMvYXBpL2VtYWlsL0VtYWlsQXBpSGVscGVyLmpzIiwiJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqIEFic3RyYWN0aW9uIGxheWVyIGZvciBzdHJpbmcgdG8gYmFzZTY0IGNvbnZlcnNpb25cbiAqIHJlZmVyZW5jZTogaHR0cHM6Ly9naXRodWIuY29tL25vZGVqcy9ub2RlL2lzc3Vlcy8zNDYyXG4gKi9cbmNsYXNzIEJhc2U2NCB7XG4gIC8qKlxuXHQgKiBDcmVhdGVzIGEgYmFzZS02NCBlbmNvZGVkIEFTQ0lJIHN0cmluZyBmcm9tIGEgXCJzdHJpbmdcIiBvZiBiaW5hcnkgZGF0YS5cblx0ICogQHBhcmFtIHtzdHJpbmd9IHN0cmluZyB0byBiZSBlbmNvZGVkLlxuXHQgKiBAcmV0dXJuIHtzdHJpbmd9XG5cdCAqIEBzdGF0aWNcblx0ICovXG4gIHN0YXRpYyBlbmNvZGVTdHJpbmcoc3RyaW5nKSB7XG4gICAgaWYgKHR5cGVvZiBidG9hID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICByZXR1cm4gYnRvYShzdHJpbmcpO1xuICAgIH1cblxuICAgIHJldHVybiBuZXcgQnVmZmVyKHN0cmluZy50b1N0cmluZygpLCAnYmluYXJ5JykudG9TdHJpbmcoJ2Jhc2U2NCcpO1xuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IEJhc2U2NDtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy9jcnlwdC9CYXNlNjQuanMiLCIndXNlIHN0cmljdCc7XG5cbmltcG9ydCBnbG9iYWxzIGZyb20gJy4uL2dsb2JhbHMvZ2xvYmFscyc7XG5pbXBvcnQgRmlsdGVyIGZyb20gJy4uL2FwaS1xdWVyeS9GaWx0ZXInO1xuaW1wb3J0IEdlbyBmcm9tICcuLi9hcGktcXVlcnkvR2VvJztcbmltcG9ydCBXZURlcGxveSBmcm9tICcuLi9hcGkvV2VEZXBsb3knO1xuaW1wb3J0IFF1ZXJ5IGZyb20gJy4uL2FwaS1xdWVyeS9RdWVyeSc7XG5pbXBvcnQgUmFuZ2UgZnJvbSAnLi4vYXBpLXF1ZXJ5L1JhbmdlJztcblxuZ2xvYmFscy53aW5kb3cuRmlsdGVyID0gRmlsdGVyO1xuZ2xvYmFscy53aW5kb3cuR2VvID0gR2VvO1xuZ2xvYmFscy53aW5kb3cuUXVlcnkgPSBRdWVyeTtcbmdsb2JhbHMud2luZG93LlJhbmdlID0gUmFuZ2U7XG5nbG9iYWxzLndpbmRvdy5XZURlcGxveSA9IFdlRGVwbG95O1xuXG5leHBvcnQge0ZpbHRlciwgR2VvLCBRdWVyeSwgUmFuZ2UsIFdlRGVwbG95fTtcbmV4cG9ydCBkZWZhdWx0IFdlRGVwbG95O1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL2Vudi9icm93c2VyLmpzIiwiJ3VzZSBzdHJpY3QnXG5cbmV4cG9ydHMuYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGhcbmV4cG9ydHMudG9CeXRlQXJyYXkgPSB0b0J5dGVBcnJheVxuZXhwb3J0cy5mcm9tQnl0ZUFycmF5ID0gZnJvbUJ5dGVBcnJheVxuXG52YXIgbG9va3VwID0gW11cbnZhciByZXZMb29rdXAgPSBbXVxudmFyIEFyciA9IHR5cGVvZiBVaW50OEFycmF5ICE9PSAndW5kZWZpbmVkJyA/IFVpbnQ4QXJyYXkgOiBBcnJheVxuXG52YXIgY29kZSA9ICdBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWmFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6MDEyMzQ1Njc4OSsvJ1xuZm9yICh2YXIgaSA9IDAsIGxlbiA9IGNvZGUubGVuZ3RoOyBpIDwgbGVuOyArK2kpIHtcbiAgbG9va3VwW2ldID0gY29kZVtpXVxuICByZXZMb29rdXBbY29kZS5jaGFyQ29kZUF0KGkpXSA9IGlcbn1cblxucmV2TG9va3VwWyctJy5jaGFyQ29kZUF0KDApXSA9IDYyXG5yZXZMb29rdXBbJ18nLmNoYXJDb2RlQXQoMCldID0gNjNcblxuZnVuY3Rpb24gcGxhY2VIb2xkZXJzQ291bnQgKGI2NCkge1xuICB2YXIgbGVuID0gYjY0Lmxlbmd0aFxuICBpZiAobGVuICUgNCA+IDApIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgc3RyaW5nLiBMZW5ndGggbXVzdCBiZSBhIG11bHRpcGxlIG9mIDQnKVxuICB9XG5cbiAgLy8gdGhlIG51bWJlciBvZiBlcXVhbCBzaWducyAocGxhY2UgaG9sZGVycylcbiAgLy8gaWYgdGhlcmUgYXJlIHR3byBwbGFjZWhvbGRlcnMsIHRoYW4gdGhlIHR3byBjaGFyYWN0ZXJzIGJlZm9yZSBpdFxuICAvLyByZXByZXNlbnQgb25lIGJ5dGVcbiAgLy8gaWYgdGhlcmUgaXMgb25seSBvbmUsIHRoZW4gdGhlIHRocmVlIGNoYXJhY3RlcnMgYmVmb3JlIGl0IHJlcHJlc2VudCAyIGJ5dGVzXG4gIC8vIHRoaXMgaXMganVzdCBhIGNoZWFwIGhhY2sgdG8gbm90IGRvIGluZGV4T2YgdHdpY2VcbiAgcmV0dXJuIGI2NFtsZW4gLSAyXSA9PT0gJz0nID8gMiA6IGI2NFtsZW4gLSAxXSA9PT0gJz0nID8gMSA6IDBcbn1cblxuZnVuY3Rpb24gYnl0ZUxlbmd0aCAoYjY0KSB7XG4gIC8vIGJhc2U2NCBpcyA0LzMgKyB1cCB0byB0d28gY2hhcmFjdGVycyBvZiB0aGUgb3JpZ2luYWwgZGF0YVxuICByZXR1cm4gKGI2NC5sZW5ndGggKiAzIC8gNCkgLSBwbGFjZUhvbGRlcnNDb3VudChiNjQpXG59XG5cbmZ1bmN0aW9uIHRvQnl0ZUFycmF5IChiNjQpIHtcbiAgdmFyIGksIGwsIHRtcCwgcGxhY2VIb2xkZXJzLCBhcnJcbiAgdmFyIGxlbiA9IGI2NC5sZW5ndGhcbiAgcGxhY2VIb2xkZXJzID0gcGxhY2VIb2xkZXJzQ291bnQoYjY0KVxuXG4gIGFyciA9IG5ldyBBcnIoKGxlbiAqIDMgLyA0KSAtIHBsYWNlSG9sZGVycylcblxuICAvLyBpZiB0aGVyZSBhcmUgcGxhY2Vob2xkZXJzLCBvbmx5IGdldCB1cCB0byB0aGUgbGFzdCBjb21wbGV0ZSA0IGNoYXJzXG4gIGwgPSBwbGFjZUhvbGRlcnMgPiAwID8gbGVuIC0gNCA6IGxlblxuXG4gIHZhciBMID0gMFxuXG4gIGZvciAoaSA9IDA7IGkgPCBsOyBpICs9IDQpIHtcbiAgICB0bXAgPSAocmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkpXSA8PCAxOCkgfCAocmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkgKyAxKV0gPDwgMTIpIHwgKHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpICsgMildIDw8IDYpIHwgcmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkgKyAzKV1cbiAgICBhcnJbTCsrXSA9ICh0bXAgPj4gMTYpICYgMHhGRlxuICAgIGFycltMKytdID0gKHRtcCA+PiA4KSAmIDB4RkZcbiAgICBhcnJbTCsrXSA9IHRtcCAmIDB4RkZcbiAgfVxuXG4gIGlmIChwbGFjZUhvbGRlcnMgPT09IDIpIHtcbiAgICB0bXAgPSAocmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkpXSA8PCAyKSB8IChyZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSArIDEpXSA+PiA0KVxuICAgIGFycltMKytdID0gdG1wICYgMHhGRlxuICB9IGVsc2UgaWYgKHBsYWNlSG9sZGVycyA9PT0gMSkge1xuICAgIHRtcCA9IChyZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSldIDw8IDEwKSB8IChyZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSArIDEpXSA8PCA0KSB8IChyZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSArIDIpXSA+PiAyKVxuICAgIGFycltMKytdID0gKHRtcCA+PiA4KSAmIDB4RkZcbiAgICBhcnJbTCsrXSA9IHRtcCAmIDB4RkZcbiAgfVxuXG4gIHJldHVybiBhcnJcbn1cblxuZnVuY3Rpb24gdHJpcGxldFRvQmFzZTY0IChudW0pIHtcbiAgcmV0dXJuIGxvb2t1cFtudW0gPj4gMTggJiAweDNGXSArIGxvb2t1cFtudW0gPj4gMTIgJiAweDNGXSArIGxvb2t1cFtudW0gPj4gNiAmIDB4M0ZdICsgbG9va3VwW251bSAmIDB4M0ZdXG59XG5cbmZ1bmN0aW9uIGVuY29kZUNodW5rICh1aW50OCwgc3RhcnQsIGVuZCkge1xuICB2YXIgdG1wXG4gIHZhciBvdXRwdXQgPSBbXVxuICBmb3IgKHZhciBpID0gc3RhcnQ7IGkgPCBlbmQ7IGkgKz0gMykge1xuICAgIHRtcCA9ICh1aW50OFtpXSA8PCAxNikgKyAodWludDhbaSArIDFdIDw8IDgpICsgKHVpbnQ4W2kgKyAyXSlcbiAgICBvdXRwdXQucHVzaCh0cmlwbGV0VG9CYXNlNjQodG1wKSlcbiAgfVxuICByZXR1cm4gb3V0cHV0LmpvaW4oJycpXG59XG5cbmZ1bmN0aW9uIGZyb21CeXRlQXJyYXkgKHVpbnQ4KSB7XG4gIHZhciB0bXBcbiAgdmFyIGxlbiA9IHVpbnQ4Lmxlbmd0aFxuICB2YXIgZXh0cmFCeXRlcyA9IGxlbiAlIDMgLy8gaWYgd2UgaGF2ZSAxIGJ5dGUgbGVmdCwgcGFkIDIgYnl0ZXNcbiAgdmFyIG91dHB1dCA9ICcnXG4gIHZhciBwYXJ0cyA9IFtdXG4gIHZhciBtYXhDaHVua0xlbmd0aCA9IDE2MzgzIC8vIG11c3QgYmUgbXVsdGlwbGUgb2YgM1xuXG4gIC8vIGdvIHRocm91Z2ggdGhlIGFycmF5IGV2ZXJ5IHRocmVlIGJ5dGVzLCB3ZSdsbCBkZWFsIHdpdGggdHJhaWxpbmcgc3R1ZmYgbGF0ZXJcbiAgZm9yICh2YXIgaSA9IDAsIGxlbjIgPSBsZW4gLSBleHRyYUJ5dGVzOyBpIDwgbGVuMjsgaSArPSBtYXhDaHVua0xlbmd0aCkge1xuICAgIHBhcnRzLnB1c2goZW5jb2RlQ2h1bmsodWludDgsIGksIChpICsgbWF4Q2h1bmtMZW5ndGgpID4gbGVuMiA/IGxlbjIgOiAoaSArIG1heENodW5rTGVuZ3RoKSkpXG4gIH1cblxuICAvLyBwYWQgdGhlIGVuZCB3aXRoIHplcm9zLCBidXQgbWFrZSBzdXJlIHRvIG5vdCBmb3JnZXQgdGhlIGV4dHJhIGJ5dGVzXG4gIGlmIChleHRyYUJ5dGVzID09PSAxKSB7XG4gICAgdG1wID0gdWludDhbbGVuIC0gMV1cbiAgICBvdXRwdXQgKz0gbG9va3VwW3RtcCA+PiAyXVxuICAgIG91dHB1dCArPSBsb29rdXBbKHRtcCA8PCA0KSAmIDB4M0ZdXG4gICAgb3V0cHV0ICs9ICc9PSdcbiAgfSBlbHNlIGlmIChleHRyYUJ5dGVzID09PSAyKSB7XG4gICAgdG1wID0gKHVpbnQ4W2xlbiAtIDJdIDw8IDgpICsgKHVpbnQ4W2xlbiAtIDFdKVxuICAgIG91dHB1dCArPSBsb29rdXBbdG1wID4+IDEwXVxuICAgIG91dHB1dCArPSBsb29rdXBbKHRtcCA+PiA0KSAmIDB4M0ZdXG4gICAgb3V0cHV0ICs9IGxvb2t1cFsodG1wIDw8IDIpICYgMHgzRl1cbiAgICBvdXRwdXQgKz0gJz0nXG4gIH1cblxuICBwYXJ0cy5wdXNoKG91dHB1dClcblxuICByZXR1cm4gcGFydHMuam9pbignJylcbn1cblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9iYXNlNjQtanMvaW5kZXguanNcbi8vIG1vZHVsZSBpZCA9IDM0XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qIVxuICogVGhlIGJ1ZmZlciBtb2R1bGUgZnJvbSBub2RlLmpzLCBmb3IgdGhlIGJyb3dzZXIuXG4gKlxuICogQGF1dGhvciAgIEZlcm9zcyBBYm91a2hhZGlqZWggPGZlcm9zc0BmZXJvc3Mub3JnPiA8aHR0cDovL2Zlcm9zcy5vcmc+XG4gKiBAbGljZW5zZSAgTUlUXG4gKi9cbi8qIGVzbGludC1kaXNhYmxlIG5vLXByb3RvICovXG5cbid1c2Ugc3RyaWN0J1xuXG52YXIgYmFzZTY0ID0gcmVxdWlyZSgnYmFzZTY0LWpzJylcbnZhciBpZWVlNzU0ID0gcmVxdWlyZSgnaWVlZTc1NCcpXG52YXIgaXNBcnJheSA9IHJlcXVpcmUoJ2lzYXJyYXknKVxuXG5leHBvcnRzLkJ1ZmZlciA9IEJ1ZmZlclxuZXhwb3J0cy5TbG93QnVmZmVyID0gU2xvd0J1ZmZlclxuZXhwb3J0cy5JTlNQRUNUX01BWF9CWVRFUyA9IDUwXG5cbi8qKlxuICogSWYgYEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUYDpcbiAqICAgPT09IHRydWUgICAgVXNlIFVpbnQ4QXJyYXkgaW1wbGVtZW50YXRpb24gKGZhc3Rlc3QpXG4gKiAgID09PSBmYWxzZSAgIFVzZSBPYmplY3QgaW1wbGVtZW50YXRpb24gKG1vc3QgY29tcGF0aWJsZSwgZXZlbiBJRTYpXG4gKlxuICogQnJvd3NlcnMgdGhhdCBzdXBwb3J0IHR5cGVkIGFycmF5cyBhcmUgSUUgMTArLCBGaXJlZm94IDQrLCBDaHJvbWUgNyssIFNhZmFyaSA1LjErLFxuICogT3BlcmEgMTEuNissIGlPUyA0LjIrLlxuICpcbiAqIER1ZSB0byB2YXJpb3VzIGJyb3dzZXIgYnVncywgc29tZXRpbWVzIHRoZSBPYmplY3QgaW1wbGVtZW50YXRpb24gd2lsbCBiZSB1c2VkIGV2ZW5cbiAqIHdoZW4gdGhlIGJyb3dzZXIgc3VwcG9ydHMgdHlwZWQgYXJyYXlzLlxuICpcbiAqIE5vdGU6XG4gKlxuICogICAtIEZpcmVmb3ggNC0yOSBsYWNrcyBzdXBwb3J0IGZvciBhZGRpbmcgbmV3IHByb3BlcnRpZXMgdG8gYFVpbnQ4QXJyYXlgIGluc3RhbmNlcyxcbiAqICAgICBTZWU6IGh0dHBzOi8vYnVnemlsbGEubW96aWxsYS5vcmcvc2hvd19idWcuY2dpP2lkPTY5NTQzOC5cbiAqXG4gKiAgIC0gQ2hyb21lIDktMTAgaXMgbWlzc2luZyB0aGUgYFR5cGVkQXJyYXkucHJvdG90eXBlLnN1YmFycmF5YCBmdW5jdGlvbi5cbiAqXG4gKiAgIC0gSUUxMCBoYXMgYSBicm9rZW4gYFR5cGVkQXJyYXkucHJvdG90eXBlLnN1YmFycmF5YCBmdW5jdGlvbiB3aGljaCByZXR1cm5zIGFycmF5cyBvZlxuICogICAgIGluY29ycmVjdCBsZW5ndGggaW4gc29tZSBzaXR1YXRpb25zLlxuXG4gKiBXZSBkZXRlY3QgdGhlc2UgYnVnZ3kgYnJvd3NlcnMgYW5kIHNldCBgQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlRgIHRvIGBmYWxzZWAgc28gdGhleVxuICogZ2V0IHRoZSBPYmplY3QgaW1wbGVtZW50YXRpb24sIHdoaWNoIGlzIHNsb3dlciBidXQgYmVoYXZlcyBjb3JyZWN0bHkuXG4gKi9cbkJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUID0gZ2xvYmFsLlRZUEVEX0FSUkFZX1NVUFBPUlQgIT09IHVuZGVmaW5lZFxuICA/IGdsb2JhbC5UWVBFRF9BUlJBWV9TVVBQT1JUXG4gIDogdHlwZWRBcnJheVN1cHBvcnQoKVxuXG4vKlxuICogRXhwb3J0IGtNYXhMZW5ndGggYWZ0ZXIgdHlwZWQgYXJyYXkgc3VwcG9ydCBpcyBkZXRlcm1pbmVkLlxuICovXG5leHBvcnRzLmtNYXhMZW5ndGggPSBrTWF4TGVuZ3RoKClcblxuZnVuY3Rpb24gdHlwZWRBcnJheVN1cHBvcnQgKCkge1xuICB0cnkge1xuICAgIHZhciBhcnIgPSBuZXcgVWludDhBcnJheSgxKVxuICAgIGFyci5fX3Byb3RvX18gPSB7X19wcm90b19fOiBVaW50OEFycmF5LnByb3RvdHlwZSwgZm9vOiBmdW5jdGlvbiAoKSB7IHJldHVybiA0MiB9fVxuICAgIHJldHVybiBhcnIuZm9vKCkgPT09IDQyICYmIC8vIHR5cGVkIGFycmF5IGluc3RhbmNlcyBjYW4gYmUgYXVnbWVudGVkXG4gICAgICAgIHR5cGVvZiBhcnIuc3ViYXJyYXkgPT09ICdmdW5jdGlvbicgJiYgLy8gY2hyb21lIDktMTAgbGFjayBgc3ViYXJyYXlgXG4gICAgICAgIGFyci5zdWJhcnJheSgxLCAxKS5ieXRlTGVuZ3RoID09PSAwIC8vIGllMTAgaGFzIGJyb2tlbiBgc3ViYXJyYXlgXG4gIH0gY2F0Y2ggKGUpIHtcbiAgICByZXR1cm4gZmFsc2VcbiAgfVxufVxuXG5mdW5jdGlvbiBrTWF4TGVuZ3RoICgpIHtcbiAgcmV0dXJuIEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUXG4gICAgPyAweDdmZmZmZmZmXG4gICAgOiAweDNmZmZmZmZmXG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUJ1ZmZlciAodGhhdCwgbGVuZ3RoKSB7XG4gIGlmIChrTWF4TGVuZ3RoKCkgPCBsZW5ndGgpIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignSW52YWxpZCB0eXBlZCBhcnJheSBsZW5ndGgnKVxuICB9XG4gIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIC8vIFJldHVybiBhbiBhdWdtZW50ZWQgYFVpbnQ4QXJyYXlgIGluc3RhbmNlLCBmb3IgYmVzdCBwZXJmb3JtYW5jZVxuICAgIHRoYXQgPSBuZXcgVWludDhBcnJheShsZW5ndGgpXG4gICAgdGhhdC5fX3Byb3RvX18gPSBCdWZmZXIucHJvdG90eXBlXG4gIH0gZWxzZSB7XG4gICAgLy8gRmFsbGJhY2s6IFJldHVybiBhbiBvYmplY3QgaW5zdGFuY2Ugb2YgdGhlIEJ1ZmZlciBjbGFzc1xuICAgIGlmICh0aGF0ID09PSBudWxsKSB7XG4gICAgICB0aGF0ID0gbmV3IEJ1ZmZlcihsZW5ndGgpXG4gICAgfVxuICAgIHRoYXQubGVuZ3RoID0gbGVuZ3RoXG4gIH1cblxuICByZXR1cm4gdGhhdFxufVxuXG4vKipcbiAqIFRoZSBCdWZmZXIgY29uc3RydWN0b3IgcmV0dXJucyBpbnN0YW5jZXMgb2YgYFVpbnQ4QXJyYXlgIHRoYXQgaGF2ZSB0aGVpclxuICogcHJvdG90eXBlIGNoYW5nZWQgdG8gYEJ1ZmZlci5wcm90b3R5cGVgLiBGdXJ0aGVybW9yZSwgYEJ1ZmZlcmAgaXMgYSBzdWJjbGFzcyBvZlxuICogYFVpbnQ4QXJyYXlgLCBzbyB0aGUgcmV0dXJuZWQgaW5zdGFuY2VzIHdpbGwgaGF2ZSBhbGwgdGhlIG5vZGUgYEJ1ZmZlcmAgbWV0aG9kc1xuICogYW5kIHRoZSBgVWludDhBcnJheWAgbWV0aG9kcy4gU3F1YXJlIGJyYWNrZXQgbm90YXRpb24gd29ya3MgYXMgZXhwZWN0ZWQgLS0gaXRcbiAqIHJldHVybnMgYSBzaW5nbGUgb2N0ZXQuXG4gKlxuICogVGhlIGBVaW50OEFycmF5YCBwcm90b3R5cGUgcmVtYWlucyB1bm1vZGlmaWVkLlxuICovXG5cbmZ1bmN0aW9uIEJ1ZmZlciAoYXJnLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpIHtcbiAgaWYgKCFCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCAmJiAhKHRoaXMgaW5zdGFuY2VvZiBCdWZmZXIpKSB7XG4gICAgcmV0dXJuIG5ldyBCdWZmZXIoYXJnLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpXG4gIH1cblxuICAvLyBDb21tb24gY2FzZS5cbiAgaWYgKHR5cGVvZiBhcmcgPT09ICdudW1iZXInKSB7XG4gICAgaWYgKHR5cGVvZiBlbmNvZGluZ09yT2Zmc2V0ID09PSAnc3RyaW5nJykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAnSWYgZW5jb2RpbmcgaXMgc3BlY2lmaWVkIHRoZW4gdGhlIGZpcnN0IGFyZ3VtZW50IG11c3QgYmUgYSBzdHJpbmcnXG4gICAgICApXG4gICAgfVxuICAgIHJldHVybiBhbGxvY1Vuc2FmZSh0aGlzLCBhcmcpXG4gIH1cbiAgcmV0dXJuIGZyb20odGhpcywgYXJnLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpXG59XG5cbkJ1ZmZlci5wb29sU2l6ZSA9IDgxOTIgLy8gbm90IHVzZWQgYnkgdGhpcyBpbXBsZW1lbnRhdGlvblxuXG4vLyBUT0RPOiBMZWdhY3ksIG5vdCBuZWVkZWQgYW55bW9yZS4gUmVtb3ZlIGluIG5leHQgbWFqb3IgdmVyc2lvbi5cbkJ1ZmZlci5fYXVnbWVudCA9IGZ1bmN0aW9uIChhcnIpIHtcbiAgYXJyLl9fcHJvdG9fXyA9IEJ1ZmZlci5wcm90b3R5cGVcbiAgcmV0dXJuIGFyclxufVxuXG5mdW5jdGlvbiBmcm9tICh0aGF0LCB2YWx1ZSwgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKSB7XG4gIGlmICh0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignXCJ2YWx1ZVwiIGFyZ3VtZW50IG11c3Qgbm90IGJlIGEgbnVtYmVyJylcbiAgfVxuXG4gIGlmICh0eXBlb2YgQXJyYXlCdWZmZXIgIT09ICd1bmRlZmluZWQnICYmIHZhbHVlIGluc3RhbmNlb2YgQXJyYXlCdWZmZXIpIHtcbiAgICByZXR1cm4gZnJvbUFycmF5QnVmZmVyKHRoYXQsIHZhbHVlLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpXG4gIH1cblxuICBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJykge1xuICAgIHJldHVybiBmcm9tU3RyaW5nKHRoYXQsIHZhbHVlLCBlbmNvZGluZ09yT2Zmc2V0KVxuICB9XG5cbiAgcmV0dXJuIGZyb21PYmplY3QodGhhdCwgdmFsdWUpXG59XG5cbi8qKlxuICogRnVuY3Rpb25hbGx5IGVxdWl2YWxlbnQgdG8gQnVmZmVyKGFyZywgZW5jb2RpbmcpIGJ1dCB0aHJvd3MgYSBUeXBlRXJyb3JcbiAqIGlmIHZhbHVlIGlzIGEgbnVtYmVyLlxuICogQnVmZmVyLmZyb20oc3RyWywgZW5jb2RpbmddKVxuICogQnVmZmVyLmZyb20oYXJyYXkpXG4gKiBCdWZmZXIuZnJvbShidWZmZXIpXG4gKiBCdWZmZXIuZnJvbShhcnJheUJ1ZmZlclssIGJ5dGVPZmZzZXRbLCBsZW5ndGhdXSlcbiAqKi9cbkJ1ZmZlci5mcm9tID0gZnVuY3Rpb24gKHZhbHVlLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpIHtcbiAgcmV0dXJuIGZyb20obnVsbCwgdmFsdWUsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aClcbn1cblxuaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gIEJ1ZmZlci5wcm90b3R5cGUuX19wcm90b19fID0gVWludDhBcnJheS5wcm90b3R5cGVcbiAgQnVmZmVyLl9fcHJvdG9fXyA9IFVpbnQ4QXJyYXlcbiAgaWYgKHR5cGVvZiBTeW1ib2wgIT09ICd1bmRlZmluZWQnICYmIFN5bWJvbC5zcGVjaWVzICYmXG4gICAgICBCdWZmZXJbU3ltYm9sLnNwZWNpZXNdID09PSBCdWZmZXIpIHtcbiAgICAvLyBGaXggc3ViYXJyYXkoKSBpbiBFUzIwMTYuIFNlZTogaHR0cHM6Ly9naXRodWIuY29tL2Zlcm9zcy9idWZmZXIvcHVsbC85N1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShCdWZmZXIsIFN5bWJvbC5zcGVjaWVzLCB7XG4gICAgICB2YWx1ZTogbnVsbCxcbiAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pXG4gIH1cbn1cblxuZnVuY3Rpb24gYXNzZXJ0U2l6ZSAoc2l6ZSkge1xuICBpZiAodHlwZW9mIHNpemUgIT09ICdudW1iZXInKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignXCJzaXplXCIgYXJndW1lbnQgbXVzdCBiZSBhIG51bWJlcicpXG4gIH0gZWxzZSBpZiAoc2l6ZSA8IDApIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignXCJzaXplXCIgYXJndW1lbnQgbXVzdCBub3QgYmUgbmVnYXRpdmUnKVxuICB9XG59XG5cbmZ1bmN0aW9uIGFsbG9jICh0aGF0LCBzaXplLCBmaWxsLCBlbmNvZGluZykge1xuICBhc3NlcnRTaXplKHNpemUpXG4gIGlmIChzaXplIDw9IDApIHtcbiAgICByZXR1cm4gY3JlYXRlQnVmZmVyKHRoYXQsIHNpemUpXG4gIH1cbiAgaWYgKGZpbGwgIT09IHVuZGVmaW5lZCkge1xuICAgIC8vIE9ubHkgcGF5IGF0dGVudGlvbiB0byBlbmNvZGluZyBpZiBpdCdzIGEgc3RyaW5nLiBUaGlzXG4gICAgLy8gcHJldmVudHMgYWNjaWRlbnRhbGx5IHNlbmRpbmcgaW4gYSBudW1iZXIgdGhhdCB3b3VsZFxuICAgIC8vIGJlIGludGVycHJldHRlZCBhcyBhIHN0YXJ0IG9mZnNldC5cbiAgICByZXR1cm4gdHlwZW9mIGVuY29kaW5nID09PSAnc3RyaW5nJ1xuICAgICAgPyBjcmVhdGVCdWZmZXIodGhhdCwgc2l6ZSkuZmlsbChmaWxsLCBlbmNvZGluZylcbiAgICAgIDogY3JlYXRlQnVmZmVyKHRoYXQsIHNpemUpLmZpbGwoZmlsbClcbiAgfVxuICByZXR1cm4gY3JlYXRlQnVmZmVyKHRoYXQsIHNpemUpXG59XG5cbi8qKlxuICogQ3JlYXRlcyBhIG5ldyBmaWxsZWQgQnVmZmVyIGluc3RhbmNlLlxuICogYWxsb2Moc2l6ZVssIGZpbGxbLCBlbmNvZGluZ11dKVxuICoqL1xuQnVmZmVyLmFsbG9jID0gZnVuY3Rpb24gKHNpemUsIGZpbGwsIGVuY29kaW5nKSB7XG4gIHJldHVybiBhbGxvYyhudWxsLCBzaXplLCBmaWxsLCBlbmNvZGluZylcbn1cblxuZnVuY3Rpb24gYWxsb2NVbnNhZmUgKHRoYXQsIHNpemUpIHtcbiAgYXNzZXJ0U2l6ZShzaXplKVxuICB0aGF0ID0gY3JlYXRlQnVmZmVyKHRoYXQsIHNpemUgPCAwID8gMCA6IGNoZWNrZWQoc2l6ZSkgfCAwKVxuICBpZiAoIUJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzaXplOyArK2kpIHtcbiAgICAgIHRoYXRbaV0gPSAwXG4gICAgfVxuICB9XG4gIHJldHVybiB0aGF0XG59XG5cbi8qKlxuICogRXF1aXZhbGVudCB0byBCdWZmZXIobnVtKSwgYnkgZGVmYXVsdCBjcmVhdGVzIGEgbm9uLXplcm8tZmlsbGVkIEJ1ZmZlciBpbnN0YW5jZS5cbiAqICovXG5CdWZmZXIuYWxsb2NVbnNhZmUgPSBmdW5jdGlvbiAoc2l6ZSkge1xuICByZXR1cm4gYWxsb2NVbnNhZmUobnVsbCwgc2l6ZSlcbn1cbi8qKlxuICogRXF1aXZhbGVudCB0byBTbG93QnVmZmVyKG51bSksIGJ5IGRlZmF1bHQgY3JlYXRlcyBhIG5vbi16ZXJvLWZpbGxlZCBCdWZmZXIgaW5zdGFuY2UuXG4gKi9cbkJ1ZmZlci5hbGxvY1Vuc2FmZVNsb3cgPSBmdW5jdGlvbiAoc2l6ZSkge1xuICByZXR1cm4gYWxsb2NVbnNhZmUobnVsbCwgc2l6ZSlcbn1cblxuZnVuY3Rpb24gZnJvbVN0cmluZyAodGhhdCwgc3RyaW5nLCBlbmNvZGluZykge1xuICBpZiAodHlwZW9mIGVuY29kaW5nICE9PSAnc3RyaW5nJyB8fCBlbmNvZGluZyA9PT0gJycpIHtcbiAgICBlbmNvZGluZyA9ICd1dGY4J1xuICB9XG5cbiAgaWYgKCFCdWZmZXIuaXNFbmNvZGluZyhlbmNvZGluZykpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdcImVuY29kaW5nXCIgbXVzdCBiZSBhIHZhbGlkIHN0cmluZyBlbmNvZGluZycpXG4gIH1cblxuICB2YXIgbGVuZ3RoID0gYnl0ZUxlbmd0aChzdHJpbmcsIGVuY29kaW5nKSB8IDBcbiAgdGhhdCA9IGNyZWF0ZUJ1ZmZlcih0aGF0LCBsZW5ndGgpXG5cbiAgdmFyIGFjdHVhbCA9IHRoYXQud3JpdGUoc3RyaW5nLCBlbmNvZGluZylcblxuICBpZiAoYWN0dWFsICE9PSBsZW5ndGgpIHtcbiAgICAvLyBXcml0aW5nIGEgaGV4IHN0cmluZywgZm9yIGV4YW1wbGUsIHRoYXQgY29udGFpbnMgaW52YWxpZCBjaGFyYWN0ZXJzIHdpbGxcbiAgICAvLyBjYXVzZSBldmVyeXRoaW5nIGFmdGVyIHRoZSBmaXJzdCBpbnZhbGlkIGNoYXJhY3RlciB0byBiZSBpZ25vcmVkLiAoZS5nLlxuICAgIC8vICdhYnh4Y2QnIHdpbGwgYmUgdHJlYXRlZCBhcyAnYWInKVxuICAgIHRoYXQgPSB0aGF0LnNsaWNlKDAsIGFjdHVhbClcbiAgfVxuXG4gIHJldHVybiB0aGF0XG59XG5cbmZ1bmN0aW9uIGZyb21BcnJheUxpa2UgKHRoYXQsIGFycmF5KSB7XG4gIHZhciBsZW5ndGggPSBhcnJheS5sZW5ndGggPCAwID8gMCA6IGNoZWNrZWQoYXJyYXkubGVuZ3RoKSB8IDBcbiAgdGhhdCA9IGNyZWF0ZUJ1ZmZlcih0aGF0LCBsZW5ndGgpXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpICs9IDEpIHtcbiAgICB0aGF0W2ldID0gYXJyYXlbaV0gJiAyNTVcbiAgfVxuICByZXR1cm4gdGhhdFxufVxuXG5mdW5jdGlvbiBmcm9tQXJyYXlCdWZmZXIgKHRoYXQsIGFycmF5LCBieXRlT2Zmc2V0LCBsZW5ndGgpIHtcbiAgYXJyYXkuYnl0ZUxlbmd0aCAvLyB0aGlzIHRocm93cyBpZiBgYXJyYXlgIGlzIG5vdCBhIHZhbGlkIEFycmF5QnVmZmVyXG5cbiAgaWYgKGJ5dGVPZmZzZXQgPCAwIHx8IGFycmF5LmJ5dGVMZW5ndGggPCBieXRlT2Zmc2V0KSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ1xcJ29mZnNldFxcJyBpcyBvdXQgb2YgYm91bmRzJylcbiAgfVxuXG4gIGlmIChhcnJheS5ieXRlTGVuZ3RoIDwgYnl0ZU9mZnNldCArIChsZW5ndGggfHwgMCkpIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignXFwnbGVuZ3RoXFwnIGlzIG91dCBvZiBib3VuZHMnKVxuICB9XG5cbiAgaWYgKGJ5dGVPZmZzZXQgPT09IHVuZGVmaW5lZCAmJiBsZW5ndGggPT09IHVuZGVmaW5lZCkge1xuICAgIGFycmF5ID0gbmV3IFVpbnQ4QXJyYXkoYXJyYXkpXG4gIH0gZWxzZSBpZiAobGVuZ3RoID09PSB1bmRlZmluZWQpIHtcbiAgICBhcnJheSA9IG5ldyBVaW50OEFycmF5KGFycmF5LCBieXRlT2Zmc2V0KVxuICB9IGVsc2Uge1xuICAgIGFycmF5ID0gbmV3IFVpbnQ4QXJyYXkoYXJyYXksIGJ5dGVPZmZzZXQsIGxlbmd0aClcbiAgfVxuXG4gIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIC8vIFJldHVybiBhbiBhdWdtZW50ZWQgYFVpbnQ4QXJyYXlgIGluc3RhbmNlLCBmb3IgYmVzdCBwZXJmb3JtYW5jZVxuICAgIHRoYXQgPSBhcnJheVxuICAgIHRoYXQuX19wcm90b19fID0gQnVmZmVyLnByb3RvdHlwZVxuICB9IGVsc2Uge1xuICAgIC8vIEZhbGxiYWNrOiBSZXR1cm4gYW4gb2JqZWN0IGluc3RhbmNlIG9mIHRoZSBCdWZmZXIgY2xhc3NcbiAgICB0aGF0ID0gZnJvbUFycmF5TGlrZSh0aGF0LCBhcnJheSlcbiAgfVxuICByZXR1cm4gdGhhdFxufVxuXG5mdW5jdGlvbiBmcm9tT2JqZWN0ICh0aGF0LCBvYmopIHtcbiAgaWYgKEJ1ZmZlci5pc0J1ZmZlcihvYmopKSB7XG4gICAgdmFyIGxlbiA9IGNoZWNrZWQob2JqLmxlbmd0aCkgfCAwXG4gICAgdGhhdCA9IGNyZWF0ZUJ1ZmZlcih0aGF0LCBsZW4pXG5cbiAgICBpZiAodGhhdC5sZW5ndGggPT09IDApIHtcbiAgICAgIHJldHVybiB0aGF0XG4gICAgfVxuXG4gICAgb2JqLmNvcHkodGhhdCwgMCwgMCwgbGVuKVxuICAgIHJldHVybiB0aGF0XG4gIH1cblxuICBpZiAob2JqKSB7XG4gICAgaWYgKCh0eXBlb2YgQXJyYXlCdWZmZXIgIT09ICd1bmRlZmluZWQnICYmXG4gICAgICAgIG9iai5idWZmZXIgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlcikgfHwgJ2xlbmd0aCcgaW4gb2JqKSB7XG4gICAgICBpZiAodHlwZW9mIG9iai5sZW5ndGggIT09ICdudW1iZXInIHx8IGlzbmFuKG9iai5sZW5ndGgpKSB7XG4gICAgICAgIHJldHVybiBjcmVhdGVCdWZmZXIodGhhdCwgMClcbiAgICAgIH1cbiAgICAgIHJldHVybiBmcm9tQXJyYXlMaWtlKHRoYXQsIG9iailcbiAgICB9XG5cbiAgICBpZiAob2JqLnR5cGUgPT09ICdCdWZmZXInICYmIGlzQXJyYXkob2JqLmRhdGEpKSB7XG4gICAgICByZXR1cm4gZnJvbUFycmF5TGlrZSh0aGF0LCBvYmouZGF0YSlcbiAgICB9XG4gIH1cblxuICB0aHJvdyBuZXcgVHlwZUVycm9yKCdGaXJzdCBhcmd1bWVudCBtdXN0IGJlIGEgc3RyaW5nLCBCdWZmZXIsIEFycmF5QnVmZmVyLCBBcnJheSwgb3IgYXJyYXktbGlrZSBvYmplY3QuJylcbn1cblxuZnVuY3Rpb24gY2hlY2tlZCAobGVuZ3RoKSB7XG4gIC8vIE5vdGU6IGNhbm5vdCB1c2UgYGxlbmd0aCA8IGtNYXhMZW5ndGgoKWAgaGVyZSBiZWNhdXNlIHRoYXQgZmFpbHMgd2hlblxuICAvLyBsZW5ndGggaXMgTmFOICh3aGljaCBpcyBvdGhlcndpc2UgY29lcmNlZCB0byB6ZXJvLilcbiAgaWYgKGxlbmd0aCA+PSBrTWF4TGVuZ3RoKCkpIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignQXR0ZW1wdCB0byBhbGxvY2F0ZSBCdWZmZXIgbGFyZ2VyIHRoYW4gbWF4aW11bSAnICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAnc2l6ZTogMHgnICsga01heExlbmd0aCgpLnRvU3RyaW5nKDE2KSArICcgYnl0ZXMnKVxuICB9XG4gIHJldHVybiBsZW5ndGggfCAwXG59XG5cbmZ1bmN0aW9uIFNsb3dCdWZmZXIgKGxlbmd0aCkge1xuICBpZiAoK2xlbmd0aCAhPSBsZW5ndGgpIHsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBlcWVxZXFcbiAgICBsZW5ndGggPSAwXG4gIH1cbiAgcmV0dXJuIEJ1ZmZlci5hbGxvYygrbGVuZ3RoKVxufVxuXG5CdWZmZXIuaXNCdWZmZXIgPSBmdW5jdGlvbiBpc0J1ZmZlciAoYikge1xuICByZXR1cm4gISEoYiAhPSBudWxsICYmIGIuX2lzQnVmZmVyKVxufVxuXG5CdWZmZXIuY29tcGFyZSA9IGZ1bmN0aW9uIGNvbXBhcmUgKGEsIGIpIHtcbiAgaWYgKCFCdWZmZXIuaXNCdWZmZXIoYSkgfHwgIUJ1ZmZlci5pc0J1ZmZlcihiKSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0FyZ3VtZW50cyBtdXN0IGJlIEJ1ZmZlcnMnKVxuICB9XG5cbiAgaWYgKGEgPT09IGIpIHJldHVybiAwXG5cbiAgdmFyIHggPSBhLmxlbmd0aFxuICB2YXIgeSA9IGIubGVuZ3RoXG5cbiAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IE1hdGgubWluKHgsIHkpOyBpIDwgbGVuOyArK2kpIHtcbiAgICBpZiAoYVtpXSAhPT0gYltpXSkge1xuICAgICAgeCA9IGFbaV1cbiAgICAgIHkgPSBiW2ldXG4gICAgICBicmVha1xuICAgIH1cbiAgfVxuXG4gIGlmICh4IDwgeSkgcmV0dXJuIC0xXG4gIGlmICh5IDwgeCkgcmV0dXJuIDFcbiAgcmV0dXJuIDBcbn1cblxuQnVmZmVyLmlzRW5jb2RpbmcgPSBmdW5jdGlvbiBpc0VuY29kaW5nIChlbmNvZGluZykge1xuICBzd2l0Y2ggKFN0cmluZyhlbmNvZGluZykudG9Mb3dlckNhc2UoKSkge1xuICAgIGNhc2UgJ2hleCc6XG4gICAgY2FzZSAndXRmOCc6XG4gICAgY2FzZSAndXRmLTgnOlxuICAgIGNhc2UgJ2FzY2lpJzpcbiAgICBjYXNlICdsYXRpbjEnOlxuICAgIGNhc2UgJ2JpbmFyeSc6XG4gICAgY2FzZSAnYmFzZTY0JzpcbiAgICBjYXNlICd1Y3MyJzpcbiAgICBjYXNlICd1Y3MtMic6XG4gICAgY2FzZSAndXRmMTZsZSc6XG4gICAgY2FzZSAndXRmLTE2bGUnOlxuICAgICAgcmV0dXJuIHRydWVcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIGZhbHNlXG4gIH1cbn1cblxuQnVmZmVyLmNvbmNhdCA9IGZ1bmN0aW9uIGNvbmNhdCAobGlzdCwgbGVuZ3RoKSB7XG4gIGlmICghaXNBcnJheShsaXN0KSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1wibGlzdFwiIGFyZ3VtZW50IG11c3QgYmUgYW4gQXJyYXkgb2YgQnVmZmVycycpXG4gIH1cblxuICBpZiAobGlzdC5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4gQnVmZmVyLmFsbG9jKDApXG4gIH1cblxuICB2YXIgaVxuICBpZiAobGVuZ3RoID09PSB1bmRlZmluZWQpIHtcbiAgICBsZW5ndGggPSAwXG4gICAgZm9yIChpID0gMDsgaSA8IGxpc3QubGVuZ3RoOyArK2kpIHtcbiAgICAgIGxlbmd0aCArPSBsaXN0W2ldLmxlbmd0aFxuICAgIH1cbiAgfVxuXG4gIHZhciBidWZmZXIgPSBCdWZmZXIuYWxsb2NVbnNhZmUobGVuZ3RoKVxuICB2YXIgcG9zID0gMFxuICBmb3IgKGkgPSAwOyBpIDwgbGlzdC5sZW5ndGg7ICsraSkge1xuICAgIHZhciBidWYgPSBsaXN0W2ldXG4gICAgaWYgKCFCdWZmZXIuaXNCdWZmZXIoYnVmKSkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignXCJsaXN0XCIgYXJndW1lbnQgbXVzdCBiZSBhbiBBcnJheSBvZiBCdWZmZXJzJylcbiAgICB9XG4gICAgYnVmLmNvcHkoYnVmZmVyLCBwb3MpXG4gICAgcG9zICs9IGJ1Zi5sZW5ndGhcbiAgfVxuICByZXR1cm4gYnVmZmVyXG59XG5cbmZ1bmN0aW9uIGJ5dGVMZW5ndGggKHN0cmluZywgZW5jb2RpbmcpIHtcbiAgaWYgKEJ1ZmZlci5pc0J1ZmZlcihzdHJpbmcpKSB7XG4gICAgcmV0dXJuIHN0cmluZy5sZW5ndGhcbiAgfVxuICBpZiAodHlwZW9mIEFycmF5QnVmZmVyICE9PSAndW5kZWZpbmVkJyAmJiB0eXBlb2YgQXJyYXlCdWZmZXIuaXNWaWV3ID09PSAnZnVuY3Rpb24nICYmXG4gICAgICAoQXJyYXlCdWZmZXIuaXNWaWV3KHN0cmluZykgfHwgc3RyaW5nIGluc3RhbmNlb2YgQXJyYXlCdWZmZXIpKSB7XG4gICAgcmV0dXJuIHN0cmluZy5ieXRlTGVuZ3RoXG4gIH1cbiAgaWYgKHR5cGVvZiBzdHJpbmcgIT09ICdzdHJpbmcnKSB7XG4gICAgc3RyaW5nID0gJycgKyBzdHJpbmdcbiAgfVxuXG4gIHZhciBsZW4gPSBzdHJpbmcubGVuZ3RoXG4gIGlmIChsZW4gPT09IDApIHJldHVybiAwXG5cbiAgLy8gVXNlIGEgZm9yIGxvb3AgdG8gYXZvaWQgcmVjdXJzaW9uXG4gIHZhciBsb3dlcmVkQ2FzZSA9IGZhbHNlXG4gIGZvciAoOzspIHtcbiAgICBzd2l0Y2ggKGVuY29kaW5nKSB7XG4gICAgICBjYXNlICdhc2NpaSc6XG4gICAgICBjYXNlICdsYXRpbjEnOlxuICAgICAgY2FzZSAnYmluYXJ5JzpcbiAgICAgICAgcmV0dXJuIGxlblxuICAgICAgY2FzZSAndXRmOCc6XG4gICAgICBjYXNlICd1dGYtOCc6XG4gICAgICBjYXNlIHVuZGVmaW5lZDpcbiAgICAgICAgcmV0dXJuIHV0ZjhUb0J5dGVzKHN0cmluZykubGVuZ3RoXG4gICAgICBjYXNlICd1Y3MyJzpcbiAgICAgIGNhc2UgJ3Vjcy0yJzpcbiAgICAgIGNhc2UgJ3V0ZjE2bGUnOlxuICAgICAgY2FzZSAndXRmLTE2bGUnOlxuICAgICAgICByZXR1cm4gbGVuICogMlxuICAgICAgY2FzZSAnaGV4JzpcbiAgICAgICAgcmV0dXJuIGxlbiA+Pj4gMVxuICAgICAgY2FzZSAnYmFzZTY0JzpcbiAgICAgICAgcmV0dXJuIGJhc2U2NFRvQnl0ZXMoc3RyaW5nKS5sZW5ndGhcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGlmIChsb3dlcmVkQ2FzZSkgcmV0dXJuIHV0ZjhUb0J5dGVzKHN0cmluZykubGVuZ3RoIC8vIGFzc3VtZSB1dGY4XG4gICAgICAgIGVuY29kaW5nID0gKCcnICsgZW5jb2RpbmcpLnRvTG93ZXJDYXNlKClcbiAgICAgICAgbG93ZXJlZENhc2UgPSB0cnVlXG4gICAgfVxuICB9XG59XG5CdWZmZXIuYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGhcblxuZnVuY3Rpb24gc2xvd1RvU3RyaW5nIChlbmNvZGluZywgc3RhcnQsIGVuZCkge1xuICB2YXIgbG93ZXJlZENhc2UgPSBmYWxzZVxuXG4gIC8vIE5vIG5lZWQgdG8gdmVyaWZ5IHRoYXQgXCJ0aGlzLmxlbmd0aCA8PSBNQVhfVUlOVDMyXCIgc2luY2UgaXQncyBhIHJlYWQtb25seVxuICAvLyBwcm9wZXJ0eSBvZiBhIHR5cGVkIGFycmF5LlxuXG4gIC8vIFRoaXMgYmVoYXZlcyBuZWl0aGVyIGxpa2UgU3RyaW5nIG5vciBVaW50OEFycmF5IGluIHRoYXQgd2Ugc2V0IHN0YXJ0L2VuZFxuICAvLyB0byB0aGVpciB1cHBlci9sb3dlciBib3VuZHMgaWYgdGhlIHZhbHVlIHBhc3NlZCBpcyBvdXQgb2YgcmFuZ2UuXG4gIC8vIHVuZGVmaW5lZCBpcyBoYW5kbGVkIHNwZWNpYWxseSBhcyBwZXIgRUNNQS0yNjIgNnRoIEVkaXRpb24sXG4gIC8vIFNlY3Rpb24gMTMuMy4zLjcgUnVudGltZSBTZW1hbnRpY3M6IEtleWVkQmluZGluZ0luaXRpYWxpemF0aW9uLlxuICBpZiAoc3RhcnQgPT09IHVuZGVmaW5lZCB8fCBzdGFydCA8IDApIHtcbiAgICBzdGFydCA9IDBcbiAgfVxuICAvLyBSZXR1cm4gZWFybHkgaWYgc3RhcnQgPiB0aGlzLmxlbmd0aC4gRG9uZSBoZXJlIHRvIHByZXZlbnQgcG90ZW50aWFsIHVpbnQzMlxuICAvLyBjb2VyY2lvbiBmYWlsIGJlbG93LlxuICBpZiAoc3RhcnQgPiB0aGlzLmxlbmd0aCkge1xuICAgIHJldHVybiAnJ1xuICB9XG5cbiAgaWYgKGVuZCA9PT0gdW5kZWZpbmVkIHx8IGVuZCA+IHRoaXMubGVuZ3RoKSB7XG4gICAgZW5kID0gdGhpcy5sZW5ndGhcbiAgfVxuXG4gIGlmIChlbmQgPD0gMCkge1xuICAgIHJldHVybiAnJ1xuICB9XG5cbiAgLy8gRm9yY2UgY29lcnNpb24gdG8gdWludDMyLiBUaGlzIHdpbGwgYWxzbyBjb2VyY2UgZmFsc2V5L05hTiB2YWx1ZXMgdG8gMC5cbiAgZW5kID4+Pj0gMFxuICBzdGFydCA+Pj49IDBcblxuICBpZiAoZW5kIDw9IHN0YXJ0KSB7XG4gICAgcmV0dXJuICcnXG4gIH1cblxuICBpZiAoIWVuY29kaW5nKSBlbmNvZGluZyA9ICd1dGY4J1xuXG4gIHdoaWxlICh0cnVlKSB7XG4gICAgc3dpdGNoIChlbmNvZGluZykge1xuICAgICAgY2FzZSAnaGV4JzpcbiAgICAgICAgcmV0dXJuIGhleFNsaWNlKHRoaXMsIHN0YXJ0LCBlbmQpXG5cbiAgICAgIGNhc2UgJ3V0ZjgnOlxuICAgICAgY2FzZSAndXRmLTgnOlxuICAgICAgICByZXR1cm4gdXRmOFNsaWNlKHRoaXMsIHN0YXJ0LCBlbmQpXG5cbiAgICAgIGNhc2UgJ2FzY2lpJzpcbiAgICAgICAgcmV0dXJuIGFzY2lpU2xpY2UodGhpcywgc3RhcnQsIGVuZClcblxuICAgICAgY2FzZSAnbGF0aW4xJzpcbiAgICAgIGNhc2UgJ2JpbmFyeSc6XG4gICAgICAgIHJldHVybiBsYXRpbjFTbGljZSh0aGlzLCBzdGFydCwgZW5kKVxuXG4gICAgICBjYXNlICdiYXNlNjQnOlxuICAgICAgICByZXR1cm4gYmFzZTY0U2xpY2UodGhpcywgc3RhcnQsIGVuZClcblxuICAgICAgY2FzZSAndWNzMic6XG4gICAgICBjYXNlICd1Y3MtMic6XG4gICAgICBjYXNlICd1dGYxNmxlJzpcbiAgICAgIGNhc2UgJ3V0Zi0xNmxlJzpcbiAgICAgICAgcmV0dXJuIHV0ZjE2bGVTbGljZSh0aGlzLCBzdGFydCwgZW5kKVxuXG4gICAgICBkZWZhdWx0OlxuICAgICAgICBpZiAobG93ZXJlZENhc2UpIHRocm93IG5ldyBUeXBlRXJyb3IoJ1Vua25vd24gZW5jb2Rpbmc6ICcgKyBlbmNvZGluZylcbiAgICAgICAgZW5jb2RpbmcgPSAoZW5jb2RpbmcgKyAnJykudG9Mb3dlckNhc2UoKVxuICAgICAgICBsb3dlcmVkQ2FzZSA9IHRydWVcbiAgICB9XG4gIH1cbn1cblxuLy8gVGhlIHByb3BlcnR5IGlzIHVzZWQgYnkgYEJ1ZmZlci5pc0J1ZmZlcmAgYW5kIGBpcy1idWZmZXJgIChpbiBTYWZhcmkgNS03KSB0byBkZXRlY3Rcbi8vIEJ1ZmZlciBpbnN0YW5jZXMuXG5CdWZmZXIucHJvdG90eXBlLl9pc0J1ZmZlciA9IHRydWVcblxuZnVuY3Rpb24gc3dhcCAoYiwgbiwgbSkge1xuICB2YXIgaSA9IGJbbl1cbiAgYltuXSA9IGJbbV1cbiAgYlttXSA9IGlcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5zd2FwMTYgPSBmdW5jdGlvbiBzd2FwMTYgKCkge1xuICB2YXIgbGVuID0gdGhpcy5sZW5ndGhcbiAgaWYgKGxlbiAlIDIgIT09IDApIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignQnVmZmVyIHNpemUgbXVzdCBiZSBhIG11bHRpcGxlIG9mIDE2LWJpdHMnKVxuICB9XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpICs9IDIpIHtcbiAgICBzd2FwKHRoaXMsIGksIGkgKyAxKVxuICB9XG4gIHJldHVybiB0aGlzXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuc3dhcDMyID0gZnVuY3Rpb24gc3dhcDMyICgpIHtcbiAgdmFyIGxlbiA9IHRoaXMubGVuZ3RoXG4gIGlmIChsZW4gJSA0ICE9PSAwKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0J1ZmZlciBzaXplIG11c3QgYmUgYSBtdWx0aXBsZSBvZiAzMi1iaXRzJylcbiAgfVxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSArPSA0KSB7XG4gICAgc3dhcCh0aGlzLCBpLCBpICsgMylcbiAgICBzd2FwKHRoaXMsIGkgKyAxLCBpICsgMilcbiAgfVxuICByZXR1cm4gdGhpc1xufVxuXG5CdWZmZXIucHJvdG90eXBlLnN3YXA2NCA9IGZ1bmN0aW9uIHN3YXA2NCAoKSB7XG4gIHZhciBsZW4gPSB0aGlzLmxlbmd0aFxuICBpZiAobGVuICUgOCAhPT0gMCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdCdWZmZXIgc2l6ZSBtdXN0IGJlIGEgbXVsdGlwbGUgb2YgNjQtYml0cycpXG4gIH1cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkgKz0gOCkge1xuICAgIHN3YXAodGhpcywgaSwgaSArIDcpXG4gICAgc3dhcCh0aGlzLCBpICsgMSwgaSArIDYpXG4gICAgc3dhcCh0aGlzLCBpICsgMiwgaSArIDUpXG4gICAgc3dhcCh0aGlzLCBpICsgMywgaSArIDQpXG4gIH1cbiAgcmV0dXJuIHRoaXNcbn1cblxuQnVmZmVyLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uIHRvU3RyaW5nICgpIHtcbiAgdmFyIGxlbmd0aCA9IHRoaXMubGVuZ3RoIHwgMFxuICBpZiAobGVuZ3RoID09PSAwKSByZXR1cm4gJydcbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDApIHJldHVybiB1dGY4U2xpY2UodGhpcywgMCwgbGVuZ3RoKVxuICByZXR1cm4gc2xvd1RvU3RyaW5nLmFwcGx5KHRoaXMsIGFyZ3VtZW50cylcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5lcXVhbHMgPSBmdW5jdGlvbiBlcXVhbHMgKGIpIHtcbiAgaWYgKCFCdWZmZXIuaXNCdWZmZXIoYikpIHRocm93IG5ldyBUeXBlRXJyb3IoJ0FyZ3VtZW50IG11c3QgYmUgYSBCdWZmZXInKVxuICBpZiAodGhpcyA9PT0gYikgcmV0dXJuIHRydWVcbiAgcmV0dXJuIEJ1ZmZlci5jb21wYXJlKHRoaXMsIGIpID09PSAwXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuaW5zcGVjdCA9IGZ1bmN0aW9uIGluc3BlY3QgKCkge1xuICB2YXIgc3RyID0gJydcbiAgdmFyIG1heCA9IGV4cG9ydHMuSU5TUEVDVF9NQVhfQllURVNcbiAgaWYgKHRoaXMubGVuZ3RoID4gMCkge1xuICAgIHN0ciA9IHRoaXMudG9TdHJpbmcoJ2hleCcsIDAsIG1heCkubWF0Y2goLy57Mn0vZykuam9pbignICcpXG4gICAgaWYgKHRoaXMubGVuZ3RoID4gbWF4KSBzdHIgKz0gJyAuLi4gJ1xuICB9XG4gIHJldHVybiAnPEJ1ZmZlciAnICsgc3RyICsgJz4nXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuY29tcGFyZSA9IGZ1bmN0aW9uIGNvbXBhcmUgKHRhcmdldCwgc3RhcnQsIGVuZCwgdGhpc1N0YXJ0LCB0aGlzRW5kKSB7XG4gIGlmICghQnVmZmVyLmlzQnVmZmVyKHRhcmdldCkpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdBcmd1bWVudCBtdXN0IGJlIGEgQnVmZmVyJylcbiAgfVxuXG4gIGlmIChzdGFydCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgc3RhcnQgPSAwXG4gIH1cbiAgaWYgKGVuZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgZW5kID0gdGFyZ2V0ID8gdGFyZ2V0Lmxlbmd0aCA6IDBcbiAgfVxuICBpZiAodGhpc1N0YXJ0ID09PSB1bmRlZmluZWQpIHtcbiAgICB0aGlzU3RhcnQgPSAwXG4gIH1cbiAgaWYgKHRoaXNFbmQgPT09IHVuZGVmaW5lZCkge1xuICAgIHRoaXNFbmQgPSB0aGlzLmxlbmd0aFxuICB9XG5cbiAgaWYgKHN0YXJ0IDwgMCB8fCBlbmQgPiB0YXJnZXQubGVuZ3RoIHx8IHRoaXNTdGFydCA8IDAgfHwgdGhpc0VuZCA+IHRoaXMubGVuZ3RoKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ291dCBvZiByYW5nZSBpbmRleCcpXG4gIH1cblxuICBpZiAodGhpc1N0YXJ0ID49IHRoaXNFbmQgJiYgc3RhcnQgPj0gZW5kKSB7XG4gICAgcmV0dXJuIDBcbiAgfVxuICBpZiAodGhpc1N0YXJ0ID49IHRoaXNFbmQpIHtcbiAgICByZXR1cm4gLTFcbiAgfVxuICBpZiAoc3RhcnQgPj0gZW5kKSB7XG4gICAgcmV0dXJuIDFcbiAgfVxuXG4gIHN0YXJ0ID4+Pj0gMFxuICBlbmQgPj4+PSAwXG4gIHRoaXNTdGFydCA+Pj49IDBcbiAgdGhpc0VuZCA+Pj49IDBcblxuICBpZiAodGhpcyA9PT0gdGFyZ2V0KSByZXR1cm4gMFxuXG4gIHZhciB4ID0gdGhpc0VuZCAtIHRoaXNTdGFydFxuICB2YXIgeSA9IGVuZCAtIHN0YXJ0XG4gIHZhciBsZW4gPSBNYXRoLm1pbih4LCB5KVxuXG4gIHZhciB0aGlzQ29weSA9IHRoaXMuc2xpY2UodGhpc1N0YXJ0LCB0aGlzRW5kKVxuICB2YXIgdGFyZ2V0Q29weSA9IHRhcmdldC5zbGljZShzdGFydCwgZW5kKVxuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyArK2kpIHtcbiAgICBpZiAodGhpc0NvcHlbaV0gIT09IHRhcmdldENvcHlbaV0pIHtcbiAgICAgIHggPSB0aGlzQ29weVtpXVxuICAgICAgeSA9IHRhcmdldENvcHlbaV1cbiAgICAgIGJyZWFrXG4gICAgfVxuICB9XG5cbiAgaWYgKHggPCB5KSByZXR1cm4gLTFcbiAgaWYgKHkgPCB4KSByZXR1cm4gMVxuICByZXR1cm4gMFxufVxuXG4vLyBGaW5kcyBlaXRoZXIgdGhlIGZpcnN0IGluZGV4IG9mIGB2YWxgIGluIGBidWZmZXJgIGF0IG9mZnNldCA+PSBgYnl0ZU9mZnNldGAsXG4vLyBPUiB0aGUgbGFzdCBpbmRleCBvZiBgdmFsYCBpbiBgYnVmZmVyYCBhdCBvZmZzZXQgPD0gYGJ5dGVPZmZzZXRgLlxuLy9cbi8vIEFyZ3VtZW50czpcbi8vIC0gYnVmZmVyIC0gYSBCdWZmZXIgdG8gc2VhcmNoXG4vLyAtIHZhbCAtIGEgc3RyaW5nLCBCdWZmZXIsIG9yIG51bWJlclxuLy8gLSBieXRlT2Zmc2V0IC0gYW4gaW5kZXggaW50byBgYnVmZmVyYDsgd2lsbCBiZSBjbGFtcGVkIHRvIGFuIGludDMyXG4vLyAtIGVuY29kaW5nIC0gYW4gb3B0aW9uYWwgZW5jb2RpbmcsIHJlbGV2YW50IGlzIHZhbCBpcyBhIHN0cmluZ1xuLy8gLSBkaXIgLSB0cnVlIGZvciBpbmRleE9mLCBmYWxzZSBmb3IgbGFzdEluZGV4T2ZcbmZ1bmN0aW9uIGJpZGlyZWN0aW9uYWxJbmRleE9mIChidWZmZXIsIHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcsIGRpcikge1xuICAvLyBFbXB0eSBidWZmZXIgbWVhbnMgbm8gbWF0Y2hcbiAgaWYgKGJ1ZmZlci5sZW5ndGggPT09IDApIHJldHVybiAtMVxuXG4gIC8vIE5vcm1hbGl6ZSBieXRlT2Zmc2V0XG4gIGlmICh0eXBlb2YgYnl0ZU9mZnNldCA9PT0gJ3N0cmluZycpIHtcbiAgICBlbmNvZGluZyA9IGJ5dGVPZmZzZXRcbiAgICBieXRlT2Zmc2V0ID0gMFxuICB9IGVsc2UgaWYgKGJ5dGVPZmZzZXQgPiAweDdmZmZmZmZmKSB7XG4gICAgYnl0ZU9mZnNldCA9IDB4N2ZmZmZmZmZcbiAgfSBlbHNlIGlmIChieXRlT2Zmc2V0IDwgLTB4ODAwMDAwMDApIHtcbiAgICBieXRlT2Zmc2V0ID0gLTB4ODAwMDAwMDBcbiAgfVxuICBieXRlT2Zmc2V0ID0gK2J5dGVPZmZzZXQgIC8vIENvZXJjZSB0byBOdW1iZXIuXG4gIGlmIChpc05hTihieXRlT2Zmc2V0KSkge1xuICAgIC8vIGJ5dGVPZmZzZXQ6IGl0IGl0J3MgdW5kZWZpbmVkLCBudWxsLCBOYU4sIFwiZm9vXCIsIGV0Yywgc2VhcmNoIHdob2xlIGJ1ZmZlclxuICAgIGJ5dGVPZmZzZXQgPSBkaXIgPyAwIDogKGJ1ZmZlci5sZW5ndGggLSAxKVxuICB9XG5cbiAgLy8gTm9ybWFsaXplIGJ5dGVPZmZzZXQ6IG5lZ2F0aXZlIG9mZnNldHMgc3RhcnQgZnJvbSB0aGUgZW5kIG9mIHRoZSBidWZmZXJcbiAgaWYgKGJ5dGVPZmZzZXQgPCAwKSBieXRlT2Zmc2V0ID0gYnVmZmVyLmxlbmd0aCArIGJ5dGVPZmZzZXRcbiAgaWYgKGJ5dGVPZmZzZXQgPj0gYnVmZmVyLmxlbmd0aCkge1xuICAgIGlmIChkaXIpIHJldHVybiAtMVxuICAgIGVsc2UgYnl0ZU9mZnNldCA9IGJ1ZmZlci5sZW5ndGggLSAxXG4gIH0gZWxzZSBpZiAoYnl0ZU9mZnNldCA8IDApIHtcbiAgICBpZiAoZGlyKSBieXRlT2Zmc2V0ID0gMFxuICAgIGVsc2UgcmV0dXJuIC0xXG4gIH1cblxuICAvLyBOb3JtYWxpemUgdmFsXG4gIGlmICh0eXBlb2YgdmFsID09PSAnc3RyaW5nJykge1xuICAgIHZhbCA9IEJ1ZmZlci5mcm9tKHZhbCwgZW5jb2RpbmcpXG4gIH1cblxuICAvLyBGaW5hbGx5LCBzZWFyY2ggZWl0aGVyIGluZGV4T2YgKGlmIGRpciBpcyB0cnVlKSBvciBsYXN0SW5kZXhPZlxuICBpZiAoQnVmZmVyLmlzQnVmZmVyKHZhbCkpIHtcbiAgICAvLyBTcGVjaWFsIGNhc2U6IGxvb2tpbmcgZm9yIGVtcHR5IHN0cmluZy9idWZmZXIgYWx3YXlzIGZhaWxzXG4gICAgaWYgKHZhbC5sZW5ndGggPT09IDApIHtcbiAgICAgIHJldHVybiAtMVxuICAgIH1cbiAgICByZXR1cm4gYXJyYXlJbmRleE9mKGJ1ZmZlciwgdmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZywgZGlyKVxuICB9IGVsc2UgaWYgKHR5cGVvZiB2YWwgPT09ICdudW1iZXInKSB7XG4gICAgdmFsID0gdmFsICYgMHhGRiAvLyBTZWFyY2ggZm9yIGEgYnl0ZSB2YWx1ZSBbMC0yNTVdXG4gICAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUICYmXG4gICAgICAgIHR5cGVvZiBVaW50OEFycmF5LnByb3RvdHlwZS5pbmRleE9mID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBpZiAoZGlyKSB7XG4gICAgICAgIHJldHVybiBVaW50OEFycmF5LnByb3RvdHlwZS5pbmRleE9mLmNhbGwoYnVmZmVyLCB2YWwsIGJ5dGVPZmZzZXQpXG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gVWludDhBcnJheS5wcm90b3R5cGUubGFzdEluZGV4T2YuY2FsbChidWZmZXIsIHZhbCwgYnl0ZU9mZnNldClcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGFycmF5SW5kZXhPZihidWZmZXIsIFsgdmFsIF0sIGJ5dGVPZmZzZXQsIGVuY29kaW5nLCBkaXIpXG4gIH1cblxuICB0aHJvdyBuZXcgVHlwZUVycm9yKCd2YWwgbXVzdCBiZSBzdHJpbmcsIG51bWJlciBvciBCdWZmZXInKVxufVxuXG5mdW5jdGlvbiBhcnJheUluZGV4T2YgKGFyciwgdmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZywgZGlyKSB7XG4gIHZhciBpbmRleFNpemUgPSAxXG4gIHZhciBhcnJMZW5ndGggPSBhcnIubGVuZ3RoXG4gIHZhciB2YWxMZW5ndGggPSB2YWwubGVuZ3RoXG5cbiAgaWYgKGVuY29kaW5nICE9PSB1bmRlZmluZWQpIHtcbiAgICBlbmNvZGluZyA9IFN0cmluZyhlbmNvZGluZykudG9Mb3dlckNhc2UoKVxuICAgIGlmIChlbmNvZGluZyA9PT0gJ3VjczInIHx8IGVuY29kaW5nID09PSAndWNzLTInIHx8XG4gICAgICAgIGVuY29kaW5nID09PSAndXRmMTZsZScgfHwgZW5jb2RpbmcgPT09ICd1dGYtMTZsZScpIHtcbiAgICAgIGlmIChhcnIubGVuZ3RoIDwgMiB8fCB2YWwubGVuZ3RoIDwgMikge1xuICAgICAgICByZXR1cm4gLTFcbiAgICAgIH1cbiAgICAgIGluZGV4U2l6ZSA9IDJcbiAgICAgIGFyckxlbmd0aCAvPSAyXG4gICAgICB2YWxMZW5ndGggLz0gMlxuICAgICAgYnl0ZU9mZnNldCAvPSAyXG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gcmVhZCAoYnVmLCBpKSB7XG4gICAgaWYgKGluZGV4U2l6ZSA9PT0gMSkge1xuICAgICAgcmV0dXJuIGJ1ZltpXVxuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gYnVmLnJlYWRVSW50MTZCRShpICogaW5kZXhTaXplKVxuICAgIH1cbiAgfVxuXG4gIHZhciBpXG4gIGlmIChkaXIpIHtcbiAgICB2YXIgZm91bmRJbmRleCA9IC0xXG4gICAgZm9yIChpID0gYnl0ZU9mZnNldDsgaSA8IGFyckxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAocmVhZChhcnIsIGkpID09PSByZWFkKHZhbCwgZm91bmRJbmRleCA9PT0gLTEgPyAwIDogaSAtIGZvdW5kSW5kZXgpKSB7XG4gICAgICAgIGlmIChmb3VuZEluZGV4ID09PSAtMSkgZm91bmRJbmRleCA9IGlcbiAgICAgICAgaWYgKGkgLSBmb3VuZEluZGV4ICsgMSA9PT0gdmFsTGVuZ3RoKSByZXR1cm4gZm91bmRJbmRleCAqIGluZGV4U2l6ZVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKGZvdW5kSW5kZXggIT09IC0xKSBpIC09IGkgLSBmb3VuZEluZGV4XG4gICAgICAgIGZvdW5kSW5kZXggPSAtMVxuICAgICAgfVxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBpZiAoYnl0ZU9mZnNldCArIHZhbExlbmd0aCA+IGFyckxlbmd0aCkgYnl0ZU9mZnNldCA9IGFyckxlbmd0aCAtIHZhbExlbmd0aFxuICAgIGZvciAoaSA9IGJ5dGVPZmZzZXQ7IGkgPj0gMDsgaS0tKSB7XG4gICAgICB2YXIgZm91bmQgPSB0cnVlXG4gICAgICBmb3IgKHZhciBqID0gMDsgaiA8IHZhbExlbmd0aDsgaisrKSB7XG4gICAgICAgIGlmIChyZWFkKGFyciwgaSArIGopICE9PSByZWFkKHZhbCwgaikpIHtcbiAgICAgICAgICBmb3VuZCA9IGZhbHNlXG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKGZvdW5kKSByZXR1cm4gaVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiAtMVxufVxuXG5CdWZmZXIucHJvdG90eXBlLmluY2x1ZGVzID0gZnVuY3Rpb24gaW5jbHVkZXMgKHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcpIHtcbiAgcmV0dXJuIHRoaXMuaW5kZXhPZih2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nKSAhPT0gLTFcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5pbmRleE9mID0gZnVuY3Rpb24gaW5kZXhPZiAodmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZykge1xuICByZXR1cm4gYmlkaXJlY3Rpb25hbEluZGV4T2YodGhpcywgdmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZywgdHJ1ZSlcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5sYXN0SW5kZXhPZiA9IGZ1bmN0aW9uIGxhc3RJbmRleE9mICh2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nKSB7XG4gIHJldHVybiBiaWRpcmVjdGlvbmFsSW5kZXhPZih0aGlzLCB2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nLCBmYWxzZSlcbn1cblxuZnVuY3Rpb24gaGV4V3JpdGUgKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCkge1xuICBvZmZzZXQgPSBOdW1iZXIob2Zmc2V0KSB8fCAwXG4gIHZhciByZW1haW5pbmcgPSBidWYubGVuZ3RoIC0gb2Zmc2V0XG4gIGlmICghbGVuZ3RoKSB7XG4gICAgbGVuZ3RoID0gcmVtYWluaW5nXG4gIH0gZWxzZSB7XG4gICAgbGVuZ3RoID0gTnVtYmVyKGxlbmd0aClcbiAgICBpZiAobGVuZ3RoID4gcmVtYWluaW5nKSB7XG4gICAgICBsZW5ndGggPSByZW1haW5pbmdcbiAgICB9XG4gIH1cblxuICAvLyBtdXN0IGJlIGFuIGV2ZW4gbnVtYmVyIG9mIGRpZ2l0c1xuICB2YXIgc3RyTGVuID0gc3RyaW5nLmxlbmd0aFxuICBpZiAoc3RyTGVuICUgMiAhPT0gMCkgdGhyb3cgbmV3IFR5cGVFcnJvcignSW52YWxpZCBoZXggc3RyaW5nJylcblxuICBpZiAobGVuZ3RoID4gc3RyTGVuIC8gMikge1xuICAgIGxlbmd0aCA9IHN0ckxlbiAvIDJcbiAgfVxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgKytpKSB7XG4gICAgdmFyIHBhcnNlZCA9IHBhcnNlSW50KHN0cmluZy5zdWJzdHIoaSAqIDIsIDIpLCAxNilcbiAgICBpZiAoaXNOYU4ocGFyc2VkKSkgcmV0dXJuIGlcbiAgICBidWZbb2Zmc2V0ICsgaV0gPSBwYXJzZWRcbiAgfVxuICByZXR1cm4gaVxufVxuXG5mdW5jdGlvbiB1dGY4V3JpdGUgKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCkge1xuICByZXR1cm4gYmxpdEJ1ZmZlcih1dGY4VG9CeXRlcyhzdHJpbmcsIGJ1Zi5sZW5ndGggLSBvZmZzZXQpLCBidWYsIG9mZnNldCwgbGVuZ3RoKVxufVxuXG5mdW5jdGlvbiBhc2NpaVdyaXRlIChidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgcmV0dXJuIGJsaXRCdWZmZXIoYXNjaWlUb0J5dGVzKHN0cmluZyksIGJ1Ziwgb2Zmc2V0LCBsZW5ndGgpXG59XG5cbmZ1bmN0aW9uIGxhdGluMVdyaXRlIChidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgcmV0dXJuIGFzY2lpV3JpdGUoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKVxufVxuXG5mdW5jdGlvbiBiYXNlNjRXcml0ZSAoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIHJldHVybiBibGl0QnVmZmVyKGJhc2U2NFRvQnl0ZXMoc3RyaW5nKSwgYnVmLCBvZmZzZXQsIGxlbmd0aClcbn1cblxuZnVuY3Rpb24gdWNzMldyaXRlIChidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgcmV0dXJuIGJsaXRCdWZmZXIodXRmMTZsZVRvQnl0ZXMoc3RyaW5nLCBidWYubGVuZ3RoIC0gb2Zmc2V0KSwgYnVmLCBvZmZzZXQsIGxlbmd0aClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZSA9IGZ1bmN0aW9uIHdyaXRlIChzdHJpbmcsIG9mZnNldCwgbGVuZ3RoLCBlbmNvZGluZykge1xuICAvLyBCdWZmZXIjd3JpdGUoc3RyaW5nKVxuICBpZiAob2Zmc2V0ID09PSB1bmRlZmluZWQpIHtcbiAgICBlbmNvZGluZyA9ICd1dGY4J1xuICAgIGxlbmd0aCA9IHRoaXMubGVuZ3RoXG4gICAgb2Zmc2V0ID0gMFxuICAvLyBCdWZmZXIjd3JpdGUoc3RyaW5nLCBlbmNvZGluZylcbiAgfSBlbHNlIGlmIChsZW5ndGggPT09IHVuZGVmaW5lZCAmJiB0eXBlb2Ygb2Zmc2V0ID09PSAnc3RyaW5nJykge1xuICAgIGVuY29kaW5nID0gb2Zmc2V0XG4gICAgbGVuZ3RoID0gdGhpcy5sZW5ndGhcbiAgICBvZmZzZXQgPSAwXG4gIC8vIEJ1ZmZlciN3cml0ZShzdHJpbmcsIG9mZnNldFssIGxlbmd0aF1bLCBlbmNvZGluZ10pXG4gIH0gZWxzZSBpZiAoaXNGaW5pdGUob2Zmc2V0KSkge1xuICAgIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgICBpZiAoaXNGaW5pdGUobGVuZ3RoKSkge1xuICAgICAgbGVuZ3RoID0gbGVuZ3RoIHwgMFxuICAgICAgaWYgKGVuY29kaW5nID09PSB1bmRlZmluZWQpIGVuY29kaW5nID0gJ3V0ZjgnXG4gICAgfSBlbHNlIHtcbiAgICAgIGVuY29kaW5nID0gbGVuZ3RoXG4gICAgICBsZW5ndGggPSB1bmRlZmluZWRcbiAgICB9XG4gIC8vIGxlZ2FjeSB3cml0ZShzdHJpbmcsIGVuY29kaW5nLCBvZmZzZXQsIGxlbmd0aCkgLSByZW1vdmUgaW4gdjAuMTNcbiAgfSBlbHNlIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAnQnVmZmVyLndyaXRlKHN0cmluZywgZW5jb2RpbmcsIG9mZnNldFssIGxlbmd0aF0pIGlzIG5vIGxvbmdlciBzdXBwb3J0ZWQnXG4gICAgKVxuICB9XG5cbiAgdmFyIHJlbWFpbmluZyA9IHRoaXMubGVuZ3RoIC0gb2Zmc2V0XG4gIGlmIChsZW5ndGggPT09IHVuZGVmaW5lZCB8fCBsZW5ndGggPiByZW1haW5pbmcpIGxlbmd0aCA9IHJlbWFpbmluZ1xuXG4gIGlmICgoc3RyaW5nLmxlbmd0aCA+IDAgJiYgKGxlbmd0aCA8IDAgfHwgb2Zmc2V0IDwgMCkpIHx8IG9mZnNldCA+IHRoaXMubGVuZ3RoKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0F0dGVtcHQgdG8gd3JpdGUgb3V0c2lkZSBidWZmZXIgYm91bmRzJylcbiAgfVxuXG4gIGlmICghZW5jb2RpbmcpIGVuY29kaW5nID0gJ3V0ZjgnXG5cbiAgdmFyIGxvd2VyZWRDYXNlID0gZmFsc2VcbiAgZm9yICg7Oykge1xuICAgIHN3aXRjaCAoZW5jb2RpbmcpIHtcbiAgICAgIGNhc2UgJ2hleCc6XG4gICAgICAgIHJldHVybiBoZXhXcml0ZSh0aGlzLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKVxuXG4gICAgICBjYXNlICd1dGY4JzpcbiAgICAgIGNhc2UgJ3V0Zi04JzpcbiAgICAgICAgcmV0dXJuIHV0ZjhXcml0ZSh0aGlzLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKVxuXG4gICAgICBjYXNlICdhc2NpaSc6XG4gICAgICAgIHJldHVybiBhc2NpaVdyaXRlKHRoaXMsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpXG5cbiAgICAgIGNhc2UgJ2xhdGluMSc6XG4gICAgICBjYXNlICdiaW5hcnknOlxuICAgICAgICByZXR1cm4gbGF0aW4xV3JpdGUodGhpcywgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aClcblxuICAgICAgY2FzZSAnYmFzZTY0JzpcbiAgICAgICAgLy8gV2FybmluZzogbWF4TGVuZ3RoIG5vdCB0YWtlbiBpbnRvIGFjY291bnQgaW4gYmFzZTY0V3JpdGVcbiAgICAgICAgcmV0dXJuIGJhc2U2NFdyaXRlKHRoaXMsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpXG5cbiAgICAgIGNhc2UgJ3VjczInOlxuICAgICAgY2FzZSAndWNzLTInOlxuICAgICAgY2FzZSAndXRmMTZsZSc6XG4gICAgICBjYXNlICd1dGYtMTZsZSc6XG4gICAgICAgIHJldHVybiB1Y3MyV3JpdGUodGhpcywgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aClcblxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgaWYgKGxvd2VyZWRDYXNlKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdVbmtub3duIGVuY29kaW5nOiAnICsgZW5jb2RpbmcpXG4gICAgICAgIGVuY29kaW5nID0gKCcnICsgZW5jb2RpbmcpLnRvTG93ZXJDYXNlKClcbiAgICAgICAgbG93ZXJlZENhc2UgPSB0cnVlXG4gICAgfVxuICB9XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUudG9KU09OID0gZnVuY3Rpb24gdG9KU09OICgpIHtcbiAgcmV0dXJuIHtcbiAgICB0eXBlOiAnQnVmZmVyJyxcbiAgICBkYXRhOiBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbCh0aGlzLl9hcnIgfHwgdGhpcywgMClcbiAgfVxufVxuXG5mdW5jdGlvbiBiYXNlNjRTbGljZSAoYnVmLCBzdGFydCwgZW5kKSB7XG4gIGlmIChzdGFydCA9PT0gMCAmJiBlbmQgPT09IGJ1Zi5sZW5ndGgpIHtcbiAgICByZXR1cm4gYmFzZTY0LmZyb21CeXRlQXJyYXkoYnVmKVxuICB9IGVsc2Uge1xuICAgIHJldHVybiBiYXNlNjQuZnJvbUJ5dGVBcnJheShidWYuc2xpY2Uoc3RhcnQsIGVuZCkpXG4gIH1cbn1cblxuZnVuY3Rpb24gdXRmOFNsaWNlIChidWYsIHN0YXJ0LCBlbmQpIHtcbiAgZW5kID0gTWF0aC5taW4oYnVmLmxlbmd0aCwgZW5kKVxuICB2YXIgcmVzID0gW11cblxuICB2YXIgaSA9IHN0YXJ0XG4gIHdoaWxlIChpIDwgZW5kKSB7XG4gICAgdmFyIGZpcnN0Qnl0ZSA9IGJ1ZltpXVxuICAgIHZhciBjb2RlUG9pbnQgPSBudWxsXG4gICAgdmFyIGJ5dGVzUGVyU2VxdWVuY2UgPSAoZmlyc3RCeXRlID4gMHhFRikgPyA0XG4gICAgICA6IChmaXJzdEJ5dGUgPiAweERGKSA/IDNcbiAgICAgIDogKGZpcnN0Qnl0ZSA+IDB4QkYpID8gMlxuICAgICAgOiAxXG5cbiAgICBpZiAoaSArIGJ5dGVzUGVyU2VxdWVuY2UgPD0gZW5kKSB7XG4gICAgICB2YXIgc2Vjb25kQnl0ZSwgdGhpcmRCeXRlLCBmb3VydGhCeXRlLCB0ZW1wQ29kZVBvaW50XG5cbiAgICAgIHN3aXRjaCAoYnl0ZXNQZXJTZXF1ZW5jZSkge1xuICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgaWYgKGZpcnN0Qnl0ZSA8IDB4ODApIHtcbiAgICAgICAgICAgIGNvZGVQb2ludCA9IGZpcnN0Qnl0ZVxuICAgICAgICAgIH1cbiAgICAgICAgICBicmVha1xuICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgc2Vjb25kQnl0ZSA9IGJ1ZltpICsgMV1cbiAgICAgICAgICBpZiAoKHNlY29uZEJ5dGUgJiAweEMwKSA9PT0gMHg4MCkge1xuICAgICAgICAgICAgdGVtcENvZGVQb2ludCA9IChmaXJzdEJ5dGUgJiAweDFGKSA8PCAweDYgfCAoc2Vjb25kQnl0ZSAmIDB4M0YpXG4gICAgICAgICAgICBpZiAodGVtcENvZGVQb2ludCA+IDB4N0YpIHtcbiAgICAgICAgICAgICAgY29kZVBvaW50ID0gdGVtcENvZGVQb2ludFxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBicmVha1xuICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgc2Vjb25kQnl0ZSA9IGJ1ZltpICsgMV1cbiAgICAgICAgICB0aGlyZEJ5dGUgPSBidWZbaSArIDJdXG4gICAgICAgICAgaWYgKChzZWNvbmRCeXRlICYgMHhDMCkgPT09IDB4ODAgJiYgKHRoaXJkQnl0ZSAmIDB4QzApID09PSAweDgwKSB7XG4gICAgICAgICAgICB0ZW1wQ29kZVBvaW50ID0gKGZpcnN0Qnl0ZSAmIDB4RikgPDwgMHhDIHwgKHNlY29uZEJ5dGUgJiAweDNGKSA8PCAweDYgfCAodGhpcmRCeXRlICYgMHgzRilcbiAgICAgICAgICAgIGlmICh0ZW1wQ29kZVBvaW50ID4gMHg3RkYgJiYgKHRlbXBDb2RlUG9pbnQgPCAweEQ4MDAgfHwgdGVtcENvZGVQb2ludCA+IDB4REZGRikpIHtcbiAgICAgICAgICAgICAgY29kZVBvaW50ID0gdGVtcENvZGVQb2ludFxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBicmVha1xuICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgc2Vjb25kQnl0ZSA9IGJ1ZltpICsgMV1cbiAgICAgICAgICB0aGlyZEJ5dGUgPSBidWZbaSArIDJdXG4gICAgICAgICAgZm91cnRoQnl0ZSA9IGJ1ZltpICsgM11cbiAgICAgICAgICBpZiAoKHNlY29uZEJ5dGUgJiAweEMwKSA9PT0gMHg4MCAmJiAodGhpcmRCeXRlICYgMHhDMCkgPT09IDB4ODAgJiYgKGZvdXJ0aEJ5dGUgJiAweEMwKSA9PT0gMHg4MCkge1xuICAgICAgICAgICAgdGVtcENvZGVQb2ludCA9IChmaXJzdEJ5dGUgJiAweEYpIDw8IDB4MTIgfCAoc2Vjb25kQnl0ZSAmIDB4M0YpIDw8IDB4QyB8ICh0aGlyZEJ5dGUgJiAweDNGKSA8PCAweDYgfCAoZm91cnRoQnl0ZSAmIDB4M0YpXG4gICAgICAgICAgICBpZiAodGVtcENvZGVQb2ludCA+IDB4RkZGRiAmJiB0ZW1wQ29kZVBvaW50IDwgMHgxMTAwMDApIHtcbiAgICAgICAgICAgICAgY29kZVBvaW50ID0gdGVtcENvZGVQb2ludFxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoY29kZVBvaW50ID09PSBudWxsKSB7XG4gICAgICAvLyB3ZSBkaWQgbm90IGdlbmVyYXRlIGEgdmFsaWQgY29kZVBvaW50IHNvIGluc2VydCBhXG4gICAgICAvLyByZXBsYWNlbWVudCBjaGFyIChVK0ZGRkQpIGFuZCBhZHZhbmNlIG9ubHkgMSBieXRlXG4gICAgICBjb2RlUG9pbnQgPSAweEZGRkRcbiAgICAgIGJ5dGVzUGVyU2VxdWVuY2UgPSAxXG4gICAgfSBlbHNlIGlmIChjb2RlUG9pbnQgPiAweEZGRkYpIHtcbiAgICAgIC8vIGVuY29kZSB0byB1dGYxNiAoc3Vycm9nYXRlIHBhaXIgZGFuY2UpXG4gICAgICBjb2RlUG9pbnQgLT0gMHgxMDAwMFxuICAgICAgcmVzLnB1c2goY29kZVBvaW50ID4+PiAxMCAmIDB4M0ZGIHwgMHhEODAwKVxuICAgICAgY29kZVBvaW50ID0gMHhEQzAwIHwgY29kZVBvaW50ICYgMHgzRkZcbiAgICB9XG5cbiAgICByZXMucHVzaChjb2RlUG9pbnQpXG4gICAgaSArPSBieXRlc1BlclNlcXVlbmNlXG4gIH1cblxuICByZXR1cm4gZGVjb2RlQ29kZVBvaW50c0FycmF5KHJlcylcbn1cblxuLy8gQmFzZWQgb24gaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL2EvMjI3NDcyNzIvNjgwNzQyLCB0aGUgYnJvd3NlciB3aXRoXG4vLyB0aGUgbG93ZXN0IGxpbWl0IGlzIENocm9tZSwgd2l0aCAweDEwMDAwIGFyZ3MuXG4vLyBXZSBnbyAxIG1hZ25pdHVkZSBsZXNzLCBmb3Igc2FmZXR5XG52YXIgTUFYX0FSR1VNRU5UU19MRU5HVEggPSAweDEwMDBcblxuZnVuY3Rpb24gZGVjb2RlQ29kZVBvaW50c0FycmF5IChjb2RlUG9pbnRzKSB7XG4gIHZhciBsZW4gPSBjb2RlUG9pbnRzLmxlbmd0aFxuICBpZiAobGVuIDw9IE1BWF9BUkdVTUVOVFNfTEVOR1RIKSB7XG4gICAgcmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUuYXBwbHkoU3RyaW5nLCBjb2RlUG9pbnRzKSAvLyBhdm9pZCBleHRyYSBzbGljZSgpXG4gIH1cblxuICAvLyBEZWNvZGUgaW4gY2h1bmtzIHRvIGF2b2lkIFwiY2FsbCBzdGFjayBzaXplIGV4Y2VlZGVkXCIuXG4gIHZhciByZXMgPSAnJ1xuICB2YXIgaSA9IDBcbiAgd2hpbGUgKGkgPCBsZW4pIHtcbiAgICByZXMgKz0gU3RyaW5nLmZyb21DaGFyQ29kZS5hcHBseShcbiAgICAgIFN0cmluZyxcbiAgICAgIGNvZGVQb2ludHMuc2xpY2UoaSwgaSArPSBNQVhfQVJHVU1FTlRTX0xFTkdUSClcbiAgICApXG4gIH1cbiAgcmV0dXJuIHJlc1xufVxuXG5mdW5jdGlvbiBhc2NpaVNsaWNlIChidWYsIHN0YXJ0LCBlbmQpIHtcbiAgdmFyIHJldCA9ICcnXG4gIGVuZCA9IE1hdGgubWluKGJ1Zi5sZW5ndGgsIGVuZClcblxuICBmb3IgKHZhciBpID0gc3RhcnQ7IGkgPCBlbmQ7ICsraSkge1xuICAgIHJldCArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGJ1ZltpXSAmIDB4N0YpXG4gIH1cbiAgcmV0dXJuIHJldFxufVxuXG5mdW5jdGlvbiBsYXRpbjFTbGljZSAoYnVmLCBzdGFydCwgZW5kKSB7XG4gIHZhciByZXQgPSAnJ1xuICBlbmQgPSBNYXRoLm1pbihidWYubGVuZ3RoLCBlbmQpXG5cbiAgZm9yICh2YXIgaSA9IHN0YXJ0OyBpIDwgZW5kOyArK2kpIHtcbiAgICByZXQgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShidWZbaV0pXG4gIH1cbiAgcmV0dXJuIHJldFxufVxuXG5mdW5jdGlvbiBoZXhTbGljZSAoYnVmLCBzdGFydCwgZW5kKSB7XG4gIHZhciBsZW4gPSBidWYubGVuZ3RoXG5cbiAgaWYgKCFzdGFydCB8fCBzdGFydCA8IDApIHN0YXJ0ID0gMFxuICBpZiAoIWVuZCB8fCBlbmQgPCAwIHx8IGVuZCA+IGxlbikgZW5kID0gbGVuXG5cbiAgdmFyIG91dCA9ICcnXG4gIGZvciAodmFyIGkgPSBzdGFydDsgaSA8IGVuZDsgKytpKSB7XG4gICAgb3V0ICs9IHRvSGV4KGJ1ZltpXSlcbiAgfVxuICByZXR1cm4gb3V0XG59XG5cbmZ1bmN0aW9uIHV0ZjE2bGVTbGljZSAoYnVmLCBzdGFydCwgZW5kKSB7XG4gIHZhciBieXRlcyA9IGJ1Zi5zbGljZShzdGFydCwgZW5kKVxuICB2YXIgcmVzID0gJydcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBieXRlcy5sZW5ndGg7IGkgKz0gMikge1xuICAgIHJlcyArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGJ5dGVzW2ldICsgYnl0ZXNbaSArIDFdICogMjU2KVxuICB9XG4gIHJldHVybiByZXNcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5zbGljZSA9IGZ1bmN0aW9uIHNsaWNlIChzdGFydCwgZW5kKSB7XG4gIHZhciBsZW4gPSB0aGlzLmxlbmd0aFxuICBzdGFydCA9IH5+c3RhcnRcbiAgZW5kID0gZW5kID09PSB1bmRlZmluZWQgPyBsZW4gOiB+fmVuZFxuXG4gIGlmIChzdGFydCA8IDApIHtcbiAgICBzdGFydCArPSBsZW5cbiAgICBpZiAoc3RhcnQgPCAwKSBzdGFydCA9IDBcbiAgfSBlbHNlIGlmIChzdGFydCA+IGxlbikge1xuICAgIHN0YXJ0ID0gbGVuXG4gIH1cblxuICBpZiAoZW5kIDwgMCkge1xuICAgIGVuZCArPSBsZW5cbiAgICBpZiAoZW5kIDwgMCkgZW5kID0gMFxuICB9IGVsc2UgaWYgKGVuZCA+IGxlbikge1xuICAgIGVuZCA9IGxlblxuICB9XG5cbiAgaWYgKGVuZCA8IHN0YXJ0KSBlbmQgPSBzdGFydFxuXG4gIHZhciBuZXdCdWZcbiAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgbmV3QnVmID0gdGhpcy5zdWJhcnJheShzdGFydCwgZW5kKVxuICAgIG5ld0J1Zi5fX3Byb3RvX18gPSBCdWZmZXIucHJvdG90eXBlXG4gIH0gZWxzZSB7XG4gICAgdmFyIHNsaWNlTGVuID0gZW5kIC0gc3RhcnRcbiAgICBuZXdCdWYgPSBuZXcgQnVmZmVyKHNsaWNlTGVuLCB1bmRlZmluZWQpXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzbGljZUxlbjsgKytpKSB7XG4gICAgICBuZXdCdWZbaV0gPSB0aGlzW2kgKyBzdGFydF1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gbmV3QnVmXG59XG5cbi8qXG4gKiBOZWVkIHRvIG1ha2Ugc3VyZSB0aGF0IGJ1ZmZlciBpc24ndCB0cnlpbmcgdG8gd3JpdGUgb3V0IG9mIGJvdW5kcy5cbiAqL1xuZnVuY3Rpb24gY2hlY2tPZmZzZXQgKG9mZnNldCwgZXh0LCBsZW5ndGgpIHtcbiAgaWYgKChvZmZzZXQgJSAxKSAhPT0gMCB8fCBvZmZzZXQgPCAwKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignb2Zmc2V0IGlzIG5vdCB1aW50JylcbiAgaWYgKG9mZnNldCArIGV4dCA+IGxlbmd0aCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ1RyeWluZyB0byBhY2Nlc3MgYmV5b25kIGJ1ZmZlciBsZW5ndGgnKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRVSW50TEUgPSBmdW5jdGlvbiByZWFkVUludExFIChvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGggfCAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgYnl0ZUxlbmd0aCwgdGhpcy5sZW5ndGgpXG5cbiAgdmFyIHZhbCA9IHRoaXNbb2Zmc2V0XVxuICB2YXIgbXVsID0gMVxuICB2YXIgaSA9IDBcbiAgd2hpbGUgKCsraSA8IGJ5dGVMZW5ndGggJiYgKG11bCAqPSAweDEwMCkpIHtcbiAgICB2YWwgKz0gdGhpc1tvZmZzZXQgKyBpXSAqIG11bFxuICB9XG5cbiAgcmV0dXJuIHZhbFxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRVSW50QkUgPSBmdW5jdGlvbiByZWFkVUludEJFIChvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGggfCAwXG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICBjaGVja09mZnNldChvZmZzZXQsIGJ5dGVMZW5ndGgsIHRoaXMubGVuZ3RoKVxuICB9XG5cbiAgdmFyIHZhbCA9IHRoaXNbb2Zmc2V0ICsgLS1ieXRlTGVuZ3RoXVxuICB2YXIgbXVsID0gMVxuICB3aGlsZSAoYnl0ZUxlbmd0aCA+IDAgJiYgKG11bCAqPSAweDEwMCkpIHtcbiAgICB2YWwgKz0gdGhpc1tvZmZzZXQgKyAtLWJ5dGVMZW5ndGhdICogbXVsXG4gIH1cblxuICByZXR1cm4gdmFsXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnQ4ID0gZnVuY3Rpb24gcmVhZFVJbnQ4IChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgMSwgdGhpcy5sZW5ndGgpXG4gIHJldHVybiB0aGlzW29mZnNldF1cbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludDE2TEUgPSBmdW5jdGlvbiByZWFkVUludDE2TEUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCAyLCB0aGlzLmxlbmd0aClcbiAgcmV0dXJuIHRoaXNbb2Zmc2V0XSB8ICh0aGlzW29mZnNldCArIDFdIDw8IDgpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnQxNkJFID0gZnVuY3Rpb24gcmVhZFVJbnQxNkJFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgMiwgdGhpcy5sZW5ndGgpXG4gIHJldHVybiAodGhpc1tvZmZzZXRdIDw8IDgpIHwgdGhpc1tvZmZzZXQgKyAxXVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRVSW50MzJMRSA9IGZ1bmN0aW9uIHJlYWRVSW50MzJMRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDQsIHRoaXMubGVuZ3RoKVxuXG4gIHJldHVybiAoKHRoaXNbb2Zmc2V0XSkgfFxuICAgICAgKHRoaXNbb2Zmc2V0ICsgMV0gPDwgOCkgfFxuICAgICAgKHRoaXNbb2Zmc2V0ICsgMl0gPDwgMTYpKSArXG4gICAgICAodGhpc1tvZmZzZXQgKyAzXSAqIDB4MTAwMDAwMClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludDMyQkUgPSBmdW5jdGlvbiByZWFkVUludDMyQkUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA0LCB0aGlzLmxlbmd0aClcblxuICByZXR1cm4gKHRoaXNbb2Zmc2V0XSAqIDB4MTAwMDAwMCkgK1xuICAgICgodGhpc1tvZmZzZXQgKyAxXSA8PCAxNikgfFxuICAgICh0aGlzW29mZnNldCArIDJdIDw8IDgpIHxcbiAgICB0aGlzW29mZnNldCArIDNdKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRJbnRMRSA9IGZ1bmN0aW9uIHJlYWRJbnRMRSAob2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoIHwgMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIGJ5dGVMZW5ndGgsIHRoaXMubGVuZ3RoKVxuXG4gIHZhciB2YWwgPSB0aGlzW29mZnNldF1cbiAgdmFyIG11bCA9IDFcbiAgdmFyIGkgPSAwXG4gIHdoaWxlICgrK2kgPCBieXRlTGVuZ3RoICYmIChtdWwgKj0gMHgxMDApKSB7XG4gICAgdmFsICs9IHRoaXNbb2Zmc2V0ICsgaV0gKiBtdWxcbiAgfVxuICBtdWwgKj0gMHg4MFxuXG4gIGlmICh2YWwgPj0gbXVsKSB2YWwgLT0gTWF0aC5wb3coMiwgOCAqIGJ5dGVMZW5ndGgpXG5cbiAgcmV0dXJuIHZhbFxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRJbnRCRSA9IGZ1bmN0aW9uIHJlYWRJbnRCRSAob2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoIHwgMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIGJ5dGVMZW5ndGgsIHRoaXMubGVuZ3RoKVxuXG4gIHZhciBpID0gYnl0ZUxlbmd0aFxuICB2YXIgbXVsID0gMVxuICB2YXIgdmFsID0gdGhpc1tvZmZzZXQgKyAtLWldXG4gIHdoaWxlIChpID4gMCAmJiAobXVsICo9IDB4MTAwKSkge1xuICAgIHZhbCArPSB0aGlzW29mZnNldCArIC0taV0gKiBtdWxcbiAgfVxuICBtdWwgKj0gMHg4MFxuXG4gIGlmICh2YWwgPj0gbXVsKSB2YWwgLT0gTWF0aC5wb3coMiwgOCAqIGJ5dGVMZW5ndGgpXG5cbiAgcmV0dXJuIHZhbFxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRJbnQ4ID0gZnVuY3Rpb24gcmVhZEludDggKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCAxLCB0aGlzLmxlbmd0aClcbiAgaWYgKCEodGhpc1tvZmZzZXRdICYgMHg4MCkpIHJldHVybiAodGhpc1tvZmZzZXRdKVxuICByZXR1cm4gKCgweGZmIC0gdGhpc1tvZmZzZXRdICsgMSkgKiAtMSlcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50MTZMRSA9IGZ1bmN0aW9uIHJlYWRJbnQxNkxFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgMiwgdGhpcy5sZW5ndGgpXG4gIHZhciB2YWwgPSB0aGlzW29mZnNldF0gfCAodGhpc1tvZmZzZXQgKyAxXSA8PCA4KVxuICByZXR1cm4gKHZhbCAmIDB4ODAwMCkgPyB2YWwgfCAweEZGRkYwMDAwIDogdmFsXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludDE2QkUgPSBmdW5jdGlvbiByZWFkSW50MTZCRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDIsIHRoaXMubGVuZ3RoKVxuICB2YXIgdmFsID0gdGhpc1tvZmZzZXQgKyAxXSB8ICh0aGlzW29mZnNldF0gPDwgOClcbiAgcmV0dXJuICh2YWwgJiAweDgwMDApID8gdmFsIHwgMHhGRkZGMDAwMCA6IHZhbFxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRJbnQzMkxFID0gZnVuY3Rpb24gcmVhZEludDMyTEUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA0LCB0aGlzLmxlbmd0aClcblxuICByZXR1cm4gKHRoaXNbb2Zmc2V0XSkgfFxuICAgICh0aGlzW29mZnNldCArIDFdIDw8IDgpIHxcbiAgICAodGhpc1tvZmZzZXQgKyAyXSA8PCAxNikgfFxuICAgICh0aGlzW29mZnNldCArIDNdIDw8IDI0KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRJbnQzMkJFID0gZnVuY3Rpb24gcmVhZEludDMyQkUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA0LCB0aGlzLmxlbmd0aClcblxuICByZXR1cm4gKHRoaXNbb2Zmc2V0XSA8PCAyNCkgfFxuICAgICh0aGlzW29mZnNldCArIDFdIDw8IDE2KSB8XG4gICAgKHRoaXNbb2Zmc2V0ICsgMl0gPDwgOCkgfFxuICAgICh0aGlzW29mZnNldCArIDNdKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRGbG9hdExFID0gZnVuY3Rpb24gcmVhZEZsb2F0TEUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA0LCB0aGlzLmxlbmd0aClcbiAgcmV0dXJuIGllZWU3NTQucmVhZCh0aGlzLCBvZmZzZXQsIHRydWUsIDIzLCA0KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRGbG9hdEJFID0gZnVuY3Rpb24gcmVhZEZsb2F0QkUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA0LCB0aGlzLmxlbmd0aClcbiAgcmV0dXJuIGllZWU3NTQucmVhZCh0aGlzLCBvZmZzZXQsIGZhbHNlLCAyMywgNClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkRG91YmxlTEUgPSBmdW5jdGlvbiByZWFkRG91YmxlTEUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA4LCB0aGlzLmxlbmd0aClcbiAgcmV0dXJuIGllZWU3NTQucmVhZCh0aGlzLCBvZmZzZXQsIHRydWUsIDUyLCA4KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWREb3VibGVCRSA9IGZ1bmN0aW9uIHJlYWREb3VibGVCRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDgsIHRoaXMubGVuZ3RoKVxuICByZXR1cm4gaWVlZTc1NC5yZWFkKHRoaXMsIG9mZnNldCwgZmFsc2UsIDUyLCA4KVxufVxuXG5mdW5jdGlvbiBjaGVja0ludCAoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBleHQsIG1heCwgbWluKSB7XG4gIGlmICghQnVmZmVyLmlzQnVmZmVyKGJ1ZikpIHRocm93IG5ldyBUeXBlRXJyb3IoJ1wiYnVmZmVyXCIgYXJndW1lbnQgbXVzdCBiZSBhIEJ1ZmZlciBpbnN0YW5jZScpXG4gIGlmICh2YWx1ZSA+IG1heCB8fCB2YWx1ZSA8IG1pbikgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ1widmFsdWVcIiBhcmd1bWVudCBpcyBvdXQgb2YgYm91bmRzJylcbiAgaWYgKG9mZnNldCArIGV4dCA+IGJ1Zi5sZW5ndGgpIHRocm93IG5ldyBSYW5nZUVycm9yKCdJbmRleCBvdXQgb2YgcmFuZ2UnKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludExFID0gZnVuY3Rpb24gd3JpdGVVSW50TEUgKHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGggfCAwXG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICB2YXIgbWF4Qnl0ZXMgPSBNYXRoLnBvdygyLCA4ICogYnl0ZUxlbmd0aCkgLSAxXG4gICAgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbWF4Qnl0ZXMsIDApXG4gIH1cblxuICB2YXIgbXVsID0gMVxuICB2YXIgaSA9IDBcbiAgdGhpc1tvZmZzZXRdID0gdmFsdWUgJiAweEZGXG4gIHdoaWxlICgrK2kgPCBieXRlTGVuZ3RoICYmIChtdWwgKj0gMHgxMDApKSB7XG4gICAgdGhpc1tvZmZzZXQgKyBpXSA9ICh2YWx1ZSAvIG11bCkgJiAweEZGXG4gIH1cblxuICByZXR1cm4gb2Zmc2V0ICsgYnl0ZUxlbmd0aFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludEJFID0gZnVuY3Rpb24gd3JpdGVVSW50QkUgKHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGggfCAwXG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICB2YXIgbWF4Qnl0ZXMgPSBNYXRoLnBvdygyLCA4ICogYnl0ZUxlbmd0aCkgLSAxXG4gICAgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbWF4Qnl0ZXMsIDApXG4gIH1cblxuICB2YXIgaSA9IGJ5dGVMZW5ndGggLSAxXG4gIHZhciBtdWwgPSAxXG4gIHRoaXNbb2Zmc2V0ICsgaV0gPSB2YWx1ZSAmIDB4RkZcbiAgd2hpbGUgKC0taSA+PSAwICYmIChtdWwgKj0gMHgxMDApKSB7XG4gICAgdGhpc1tvZmZzZXQgKyBpXSA9ICh2YWx1ZSAvIG11bCkgJiAweEZGXG4gIH1cblxuICByZXR1cm4gb2Zmc2V0ICsgYnl0ZUxlbmd0aFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludDggPSBmdW5jdGlvbiB3cml0ZVVJbnQ4ICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDEsIDB4ZmYsIDApXG4gIGlmICghQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHZhbHVlID0gTWF0aC5mbG9vcih2YWx1ZSlcbiAgdGhpc1tvZmZzZXRdID0gKHZhbHVlICYgMHhmZilcbiAgcmV0dXJuIG9mZnNldCArIDFcbn1cblxuZnVuY3Rpb24gb2JqZWN0V3JpdGVVSW50MTYgKGJ1ZiwgdmFsdWUsIG9mZnNldCwgbGl0dGxlRW5kaWFuKSB7XG4gIGlmICh2YWx1ZSA8IDApIHZhbHVlID0gMHhmZmZmICsgdmFsdWUgKyAxXG4gIGZvciAodmFyIGkgPSAwLCBqID0gTWF0aC5taW4oYnVmLmxlbmd0aCAtIG9mZnNldCwgMik7IGkgPCBqOyArK2kpIHtcbiAgICBidWZbb2Zmc2V0ICsgaV0gPSAodmFsdWUgJiAoMHhmZiA8PCAoOCAqIChsaXR0bGVFbmRpYW4gPyBpIDogMSAtIGkpKSkpID4+PlxuICAgICAgKGxpdHRsZUVuZGlhbiA/IGkgOiAxIC0gaSkgKiA4XG4gIH1cbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQxNkxFID0gZnVuY3Rpb24gd3JpdGVVSW50MTZMRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCAyLCAweGZmZmYsIDApXG4gIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSAmIDB4ZmYpXG4gICAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSA+Pj4gOClcbiAgfSBlbHNlIHtcbiAgICBvYmplY3RXcml0ZVVJbnQxNih0aGlzLCB2YWx1ZSwgb2Zmc2V0LCB0cnVlKVxuICB9XG4gIHJldHVybiBvZmZzZXQgKyAyXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50MTZCRSA9IGZ1bmN0aW9uIHdyaXRlVUludDE2QkUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgMiwgMHhmZmZmLCAwKVxuICBpZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICB0aGlzW29mZnNldF0gPSAodmFsdWUgPj4+IDgpXG4gICAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSAmIDB4ZmYpXG4gIH0gZWxzZSB7XG4gICAgb2JqZWN0V3JpdGVVSW50MTYodGhpcywgdmFsdWUsIG9mZnNldCwgZmFsc2UpXG4gIH1cbiAgcmV0dXJuIG9mZnNldCArIDJcbn1cblxuZnVuY3Rpb24gb2JqZWN0V3JpdGVVSW50MzIgKGJ1ZiwgdmFsdWUsIG9mZnNldCwgbGl0dGxlRW5kaWFuKSB7XG4gIGlmICh2YWx1ZSA8IDApIHZhbHVlID0gMHhmZmZmZmZmZiArIHZhbHVlICsgMVxuICBmb3IgKHZhciBpID0gMCwgaiA9IE1hdGgubWluKGJ1Zi5sZW5ndGggLSBvZmZzZXQsIDQpOyBpIDwgajsgKytpKSB7XG4gICAgYnVmW29mZnNldCArIGldID0gKHZhbHVlID4+PiAobGl0dGxlRW5kaWFuID8gaSA6IDMgLSBpKSAqIDgpICYgMHhmZlxuICB9XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50MzJMRSA9IGZ1bmN0aW9uIHdyaXRlVUludDMyTEUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgNCwgMHhmZmZmZmZmZiwgMClcbiAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgdGhpc1tvZmZzZXQgKyAzXSA9ICh2YWx1ZSA+Pj4gMjQpXG4gICAgdGhpc1tvZmZzZXQgKyAyXSA9ICh2YWx1ZSA+Pj4gMTYpXG4gICAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSA+Pj4gOClcbiAgICB0aGlzW29mZnNldF0gPSAodmFsdWUgJiAweGZmKVxuICB9IGVsc2Uge1xuICAgIG9iamVjdFdyaXRlVUludDMyKHRoaXMsIHZhbHVlLCBvZmZzZXQsIHRydWUpXG4gIH1cbiAgcmV0dXJuIG9mZnNldCArIDRcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQzMkJFID0gZnVuY3Rpb24gd3JpdGVVSW50MzJCRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCA0LCAweGZmZmZmZmZmLCAwKVxuICBpZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICB0aGlzW29mZnNldF0gPSAodmFsdWUgPj4+IDI0KVxuICAgIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgPj4+IDE2KVxuICAgIHRoaXNbb2Zmc2V0ICsgMl0gPSAodmFsdWUgPj4+IDgpXG4gICAgdGhpc1tvZmZzZXQgKyAzXSA9ICh2YWx1ZSAmIDB4ZmYpXG4gIH0gZWxzZSB7XG4gICAgb2JqZWN0V3JpdGVVSW50MzIodGhpcywgdmFsdWUsIG9mZnNldCwgZmFsc2UpXG4gIH1cbiAgcmV0dXJuIG9mZnNldCArIDRcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludExFID0gZnVuY3Rpb24gd3JpdGVJbnRMRSAodmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgdmFyIGxpbWl0ID0gTWF0aC5wb3coMiwgOCAqIGJ5dGVMZW5ndGggLSAxKVxuXG4gICAgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbGltaXQgLSAxLCAtbGltaXQpXG4gIH1cblxuICB2YXIgaSA9IDBcbiAgdmFyIG11bCA9IDFcbiAgdmFyIHN1YiA9IDBcbiAgdGhpc1tvZmZzZXRdID0gdmFsdWUgJiAweEZGXG4gIHdoaWxlICgrK2kgPCBieXRlTGVuZ3RoICYmIChtdWwgKj0gMHgxMDApKSB7XG4gICAgaWYgKHZhbHVlIDwgMCAmJiBzdWIgPT09IDAgJiYgdGhpc1tvZmZzZXQgKyBpIC0gMV0gIT09IDApIHtcbiAgICAgIHN1YiA9IDFcbiAgICB9XG4gICAgdGhpc1tvZmZzZXQgKyBpXSA9ICgodmFsdWUgLyBtdWwpID4+IDApIC0gc3ViICYgMHhGRlxuICB9XG5cbiAgcmV0dXJuIG9mZnNldCArIGJ5dGVMZW5ndGhcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludEJFID0gZnVuY3Rpb24gd3JpdGVJbnRCRSAodmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgdmFyIGxpbWl0ID0gTWF0aC5wb3coMiwgOCAqIGJ5dGVMZW5ndGggLSAxKVxuXG4gICAgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbGltaXQgLSAxLCAtbGltaXQpXG4gIH1cblxuICB2YXIgaSA9IGJ5dGVMZW5ndGggLSAxXG4gIHZhciBtdWwgPSAxXG4gIHZhciBzdWIgPSAwXG4gIHRoaXNbb2Zmc2V0ICsgaV0gPSB2YWx1ZSAmIDB4RkZcbiAgd2hpbGUgKC0taSA+PSAwICYmIChtdWwgKj0gMHgxMDApKSB7XG4gICAgaWYgKHZhbHVlIDwgMCAmJiBzdWIgPT09IDAgJiYgdGhpc1tvZmZzZXQgKyBpICsgMV0gIT09IDApIHtcbiAgICAgIHN1YiA9IDFcbiAgICB9XG4gICAgdGhpc1tvZmZzZXQgKyBpXSA9ICgodmFsdWUgLyBtdWwpID4+IDApIC0gc3ViICYgMHhGRlxuICB9XG5cbiAgcmV0dXJuIG9mZnNldCArIGJ5dGVMZW5ndGhcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludDggPSBmdW5jdGlvbiB3cml0ZUludDggKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgMSwgMHg3ZiwgLTB4ODApXG4gIGlmICghQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHZhbHVlID0gTWF0aC5mbG9vcih2YWx1ZSlcbiAgaWYgKHZhbHVlIDwgMCkgdmFsdWUgPSAweGZmICsgdmFsdWUgKyAxXG4gIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSAmIDB4ZmYpXG4gIHJldHVybiBvZmZzZXQgKyAxXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnQxNkxFID0gZnVuY3Rpb24gd3JpdGVJbnQxNkxFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDIsIDB4N2ZmZiwgLTB4ODAwMClcbiAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgdGhpc1tvZmZzZXRdID0gKHZhbHVlICYgMHhmZilcbiAgICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlID4+PiA4KVxuICB9IGVsc2Uge1xuICAgIG9iamVjdFdyaXRlVUludDE2KHRoaXMsIHZhbHVlLCBvZmZzZXQsIHRydWUpXG4gIH1cbiAgcmV0dXJuIG9mZnNldCArIDJcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludDE2QkUgPSBmdW5jdGlvbiB3cml0ZUludDE2QkUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgMiwgMHg3ZmZmLCAtMHg4MDAwKVxuICBpZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICB0aGlzW29mZnNldF0gPSAodmFsdWUgPj4+IDgpXG4gICAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSAmIDB4ZmYpXG4gIH0gZWxzZSB7XG4gICAgb2JqZWN0V3JpdGVVSW50MTYodGhpcywgdmFsdWUsIG9mZnNldCwgZmFsc2UpXG4gIH1cbiAgcmV0dXJuIG9mZnNldCArIDJcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludDMyTEUgPSBmdW5jdGlvbiB3cml0ZUludDMyTEUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgNCwgMHg3ZmZmZmZmZiwgLTB4ODAwMDAwMDApXG4gIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSAmIDB4ZmYpXG4gICAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSA+Pj4gOClcbiAgICB0aGlzW29mZnNldCArIDJdID0gKHZhbHVlID4+PiAxNilcbiAgICB0aGlzW29mZnNldCArIDNdID0gKHZhbHVlID4+PiAyNClcbiAgfSBlbHNlIHtcbiAgICBvYmplY3RXcml0ZVVJbnQzMih0aGlzLCB2YWx1ZSwgb2Zmc2V0LCB0cnVlKVxuICB9XG4gIHJldHVybiBvZmZzZXQgKyA0XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnQzMkJFID0gZnVuY3Rpb24gd3JpdGVJbnQzMkJFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDQsIDB4N2ZmZmZmZmYsIC0weDgwMDAwMDAwKVxuICBpZiAodmFsdWUgPCAwKSB2YWx1ZSA9IDB4ZmZmZmZmZmYgKyB2YWx1ZSArIDFcbiAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgdGhpc1tvZmZzZXRdID0gKHZhbHVlID4+PiAyNClcbiAgICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlID4+PiAxNilcbiAgICB0aGlzW29mZnNldCArIDJdID0gKHZhbHVlID4+PiA4KVxuICAgIHRoaXNbb2Zmc2V0ICsgM10gPSAodmFsdWUgJiAweGZmKVxuICB9IGVsc2Uge1xuICAgIG9iamVjdFdyaXRlVUludDMyKHRoaXMsIHZhbHVlLCBvZmZzZXQsIGZhbHNlKVxuICB9XG4gIHJldHVybiBvZmZzZXQgKyA0XG59XG5cbmZ1bmN0aW9uIGNoZWNrSUVFRTc1NCAoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBleHQsIG1heCwgbWluKSB7XG4gIGlmIChvZmZzZXQgKyBleHQgPiBidWYubGVuZ3RoKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignSW5kZXggb3V0IG9mIHJhbmdlJylcbiAgaWYgKG9mZnNldCA8IDApIHRocm93IG5ldyBSYW5nZUVycm9yKCdJbmRleCBvdXQgb2YgcmFuZ2UnKVxufVxuXG5mdW5jdGlvbiB3cml0ZUZsb2F0IChidWYsIHZhbHVlLCBvZmZzZXQsIGxpdHRsZUVuZGlhbiwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIGNoZWNrSUVFRTc1NChidWYsIHZhbHVlLCBvZmZzZXQsIDQsIDMuNDAyODIzNDY2Mzg1Mjg4NmUrMzgsIC0zLjQwMjgyMzQ2NjM4NTI4ODZlKzM4KVxuICB9XG4gIGllZWU3NTQud3JpdGUoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4sIDIzLCA0KVxuICByZXR1cm4gb2Zmc2V0ICsgNFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlRmxvYXRMRSA9IGZ1bmN0aW9uIHdyaXRlRmxvYXRMRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgcmV0dXJuIHdyaXRlRmxvYXQodGhpcywgdmFsdWUsIG9mZnNldCwgdHJ1ZSwgbm9Bc3NlcnQpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVGbG9hdEJFID0gZnVuY3Rpb24gd3JpdGVGbG9hdEJFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICByZXR1cm4gd3JpdGVGbG9hdCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBmYWxzZSwgbm9Bc3NlcnQpXG59XG5cbmZ1bmN0aW9uIHdyaXRlRG91YmxlIChidWYsIHZhbHVlLCBvZmZzZXQsIGxpdHRsZUVuZGlhbiwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIGNoZWNrSUVFRTc1NChidWYsIHZhbHVlLCBvZmZzZXQsIDgsIDEuNzk3NjkzMTM0ODYyMzE1N0UrMzA4LCAtMS43OTc2OTMxMzQ4NjIzMTU3RSszMDgpXG4gIH1cbiAgaWVlZTc1NC53cml0ZShidWYsIHZhbHVlLCBvZmZzZXQsIGxpdHRsZUVuZGlhbiwgNTIsIDgpXG4gIHJldHVybiBvZmZzZXQgKyA4XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVEb3VibGVMRSA9IGZ1bmN0aW9uIHdyaXRlRG91YmxlTEUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHJldHVybiB3cml0ZURvdWJsZSh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCB0cnVlLCBub0Fzc2VydClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZURvdWJsZUJFID0gZnVuY3Rpb24gd3JpdGVEb3VibGVCRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgcmV0dXJuIHdyaXRlRG91YmxlKHRoaXMsIHZhbHVlLCBvZmZzZXQsIGZhbHNlLCBub0Fzc2VydClcbn1cblxuLy8gY29weSh0YXJnZXRCdWZmZXIsIHRhcmdldFN0YXJ0PTAsIHNvdXJjZVN0YXJ0PTAsIHNvdXJjZUVuZD1idWZmZXIubGVuZ3RoKVxuQnVmZmVyLnByb3RvdHlwZS5jb3B5ID0gZnVuY3Rpb24gY29weSAodGFyZ2V0LCB0YXJnZXRTdGFydCwgc3RhcnQsIGVuZCkge1xuICBpZiAoIXN0YXJ0KSBzdGFydCA9IDBcbiAgaWYgKCFlbmQgJiYgZW5kICE9PSAwKSBlbmQgPSB0aGlzLmxlbmd0aFxuICBpZiAodGFyZ2V0U3RhcnQgPj0gdGFyZ2V0Lmxlbmd0aCkgdGFyZ2V0U3RhcnQgPSB0YXJnZXQubGVuZ3RoXG4gIGlmICghdGFyZ2V0U3RhcnQpIHRhcmdldFN0YXJ0ID0gMFxuICBpZiAoZW5kID4gMCAmJiBlbmQgPCBzdGFydCkgZW5kID0gc3RhcnRcblxuICAvLyBDb3B5IDAgYnl0ZXM7IHdlJ3JlIGRvbmVcbiAgaWYgKGVuZCA9PT0gc3RhcnQpIHJldHVybiAwXG4gIGlmICh0YXJnZXQubGVuZ3RoID09PSAwIHx8IHRoaXMubGVuZ3RoID09PSAwKSByZXR1cm4gMFxuXG4gIC8vIEZhdGFsIGVycm9yIGNvbmRpdGlvbnNcbiAgaWYgKHRhcmdldFN0YXJ0IDwgMCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCd0YXJnZXRTdGFydCBvdXQgb2YgYm91bmRzJylcbiAgfVxuICBpZiAoc3RhcnQgPCAwIHx8IHN0YXJ0ID49IHRoaXMubGVuZ3RoKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignc291cmNlU3RhcnQgb3V0IG9mIGJvdW5kcycpXG4gIGlmIChlbmQgPCAwKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignc291cmNlRW5kIG91dCBvZiBib3VuZHMnKVxuXG4gIC8vIEFyZSB3ZSBvb2I/XG4gIGlmIChlbmQgPiB0aGlzLmxlbmd0aCkgZW5kID0gdGhpcy5sZW5ndGhcbiAgaWYgKHRhcmdldC5sZW5ndGggLSB0YXJnZXRTdGFydCA8IGVuZCAtIHN0YXJ0KSB7XG4gICAgZW5kID0gdGFyZ2V0Lmxlbmd0aCAtIHRhcmdldFN0YXJ0ICsgc3RhcnRcbiAgfVxuXG4gIHZhciBsZW4gPSBlbmQgLSBzdGFydFxuICB2YXIgaVxuXG4gIGlmICh0aGlzID09PSB0YXJnZXQgJiYgc3RhcnQgPCB0YXJnZXRTdGFydCAmJiB0YXJnZXRTdGFydCA8IGVuZCkge1xuICAgIC8vIGRlc2NlbmRpbmcgY29weSBmcm9tIGVuZFxuICAgIGZvciAoaSA9IGxlbiAtIDE7IGkgPj0gMDsgLS1pKSB7XG4gICAgICB0YXJnZXRbaSArIHRhcmdldFN0YXJ0XSA9IHRoaXNbaSArIHN0YXJ0XVxuICAgIH1cbiAgfSBlbHNlIGlmIChsZW4gPCAxMDAwIHx8ICFCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIC8vIGFzY2VuZGluZyBjb3B5IGZyb20gc3RhcnRcbiAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyArK2kpIHtcbiAgICAgIHRhcmdldFtpICsgdGFyZ2V0U3RhcnRdID0gdGhpc1tpICsgc3RhcnRdXG4gICAgfVxuICB9IGVsc2Uge1xuICAgIFVpbnQ4QXJyYXkucHJvdG90eXBlLnNldC5jYWxsKFxuICAgICAgdGFyZ2V0LFxuICAgICAgdGhpcy5zdWJhcnJheShzdGFydCwgc3RhcnQgKyBsZW4pLFxuICAgICAgdGFyZ2V0U3RhcnRcbiAgICApXG4gIH1cblxuICByZXR1cm4gbGVuXG59XG5cbi8vIFVzYWdlOlxuLy8gICAgYnVmZmVyLmZpbGwobnVtYmVyWywgb2Zmc2V0WywgZW5kXV0pXG4vLyAgICBidWZmZXIuZmlsbChidWZmZXJbLCBvZmZzZXRbLCBlbmRdXSlcbi8vICAgIGJ1ZmZlci5maWxsKHN0cmluZ1ssIG9mZnNldFssIGVuZF1dWywgZW5jb2RpbmddKVxuQnVmZmVyLnByb3RvdHlwZS5maWxsID0gZnVuY3Rpb24gZmlsbCAodmFsLCBzdGFydCwgZW5kLCBlbmNvZGluZykge1xuICAvLyBIYW5kbGUgc3RyaW5nIGNhc2VzOlxuICBpZiAodHlwZW9mIHZhbCA9PT0gJ3N0cmluZycpIHtcbiAgICBpZiAodHlwZW9mIHN0YXJ0ID09PSAnc3RyaW5nJykge1xuICAgICAgZW5jb2RpbmcgPSBzdGFydFxuICAgICAgc3RhcnQgPSAwXG4gICAgICBlbmQgPSB0aGlzLmxlbmd0aFxuICAgIH0gZWxzZSBpZiAodHlwZW9mIGVuZCA9PT0gJ3N0cmluZycpIHtcbiAgICAgIGVuY29kaW5nID0gZW5kXG4gICAgICBlbmQgPSB0aGlzLmxlbmd0aFxuICAgIH1cbiAgICBpZiAodmFsLmxlbmd0aCA9PT0gMSkge1xuICAgICAgdmFyIGNvZGUgPSB2YWwuY2hhckNvZGVBdCgwKVxuICAgICAgaWYgKGNvZGUgPCAyNTYpIHtcbiAgICAgICAgdmFsID0gY29kZVxuICAgICAgfVxuICAgIH1cbiAgICBpZiAoZW5jb2RpbmcgIT09IHVuZGVmaW5lZCAmJiB0eXBlb2YgZW5jb2RpbmcgIT09ICdzdHJpbmcnKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdlbmNvZGluZyBtdXN0IGJlIGEgc3RyaW5nJylcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBlbmNvZGluZyA9PT0gJ3N0cmluZycgJiYgIUJ1ZmZlci5pc0VuY29kaW5nKGVuY29kaW5nKSkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignVW5rbm93biBlbmNvZGluZzogJyArIGVuY29kaW5nKVxuICAgIH1cbiAgfSBlbHNlIGlmICh0eXBlb2YgdmFsID09PSAnbnVtYmVyJykge1xuICAgIHZhbCA9IHZhbCAmIDI1NVxuICB9XG5cbiAgLy8gSW52YWxpZCByYW5nZXMgYXJlIG5vdCBzZXQgdG8gYSBkZWZhdWx0LCBzbyBjYW4gcmFuZ2UgY2hlY2sgZWFybHkuXG4gIGlmIChzdGFydCA8IDAgfHwgdGhpcy5sZW5ndGggPCBzdGFydCB8fCB0aGlzLmxlbmd0aCA8IGVuZCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdPdXQgb2YgcmFuZ2UgaW5kZXgnKVxuICB9XG5cbiAgaWYgKGVuZCA8PSBzdGFydCkge1xuICAgIHJldHVybiB0aGlzXG4gIH1cblxuICBzdGFydCA9IHN0YXJ0ID4+PiAwXG4gIGVuZCA9IGVuZCA9PT0gdW5kZWZpbmVkID8gdGhpcy5sZW5ndGggOiBlbmQgPj4+IDBcblxuICBpZiAoIXZhbCkgdmFsID0gMFxuXG4gIHZhciBpXG4gIGlmICh0eXBlb2YgdmFsID09PSAnbnVtYmVyJykge1xuICAgIGZvciAoaSA9IHN0YXJ0OyBpIDwgZW5kOyArK2kpIHtcbiAgICAgIHRoaXNbaV0gPSB2YWxcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgdmFyIGJ5dGVzID0gQnVmZmVyLmlzQnVmZmVyKHZhbClcbiAgICAgID8gdmFsXG4gICAgICA6IHV0ZjhUb0J5dGVzKG5ldyBCdWZmZXIodmFsLCBlbmNvZGluZykudG9TdHJpbmcoKSlcbiAgICB2YXIgbGVuID0gYnl0ZXMubGVuZ3RoXG4gICAgZm9yIChpID0gMDsgaSA8IGVuZCAtIHN0YXJ0OyArK2kpIHtcbiAgICAgIHRoaXNbaSArIHN0YXJ0XSA9IGJ5dGVzW2kgJSBsZW5dXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRoaXNcbn1cblxuLy8gSEVMUEVSIEZVTkNUSU9OU1xuLy8gPT09PT09PT09PT09PT09PVxuXG52YXIgSU5WQUxJRF9CQVNFNjRfUkUgPSAvW14rXFwvMC05QS1aYS16LV9dL2dcblxuZnVuY3Rpb24gYmFzZTY0Y2xlYW4gKHN0cikge1xuICAvLyBOb2RlIHN0cmlwcyBvdXQgaW52YWxpZCBjaGFyYWN0ZXJzIGxpa2UgXFxuIGFuZCBcXHQgZnJvbSB0aGUgc3RyaW5nLCBiYXNlNjQtanMgZG9lcyBub3RcbiAgc3RyID0gc3RyaW5ndHJpbShzdHIpLnJlcGxhY2UoSU5WQUxJRF9CQVNFNjRfUkUsICcnKVxuICAvLyBOb2RlIGNvbnZlcnRzIHN0cmluZ3Mgd2l0aCBsZW5ndGggPCAyIHRvICcnXG4gIGlmIChzdHIubGVuZ3RoIDwgMikgcmV0dXJuICcnXG4gIC8vIE5vZGUgYWxsb3dzIGZvciBub24tcGFkZGVkIGJhc2U2NCBzdHJpbmdzIChtaXNzaW5nIHRyYWlsaW5nID09PSksIGJhc2U2NC1qcyBkb2VzIG5vdFxuICB3aGlsZSAoc3RyLmxlbmd0aCAlIDQgIT09IDApIHtcbiAgICBzdHIgPSBzdHIgKyAnPSdcbiAgfVxuICByZXR1cm4gc3RyXG59XG5cbmZ1bmN0aW9uIHN0cmluZ3RyaW0gKHN0cikge1xuICBpZiAoc3RyLnRyaW0pIHJldHVybiBzdHIudHJpbSgpXG4gIHJldHVybiBzdHIucmVwbGFjZSgvXlxccyt8XFxzKyQvZywgJycpXG59XG5cbmZ1bmN0aW9uIHRvSGV4IChuKSB7XG4gIGlmIChuIDwgMTYpIHJldHVybiAnMCcgKyBuLnRvU3RyaW5nKDE2KVxuICByZXR1cm4gbi50b1N0cmluZygxNilcbn1cblxuZnVuY3Rpb24gdXRmOFRvQnl0ZXMgKHN0cmluZywgdW5pdHMpIHtcbiAgdW5pdHMgPSB1bml0cyB8fCBJbmZpbml0eVxuICB2YXIgY29kZVBvaW50XG4gIHZhciBsZW5ndGggPSBzdHJpbmcubGVuZ3RoXG4gIHZhciBsZWFkU3Vycm9nYXRlID0gbnVsbFxuICB2YXIgYnl0ZXMgPSBbXVxuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyArK2kpIHtcbiAgICBjb2RlUG9pbnQgPSBzdHJpbmcuY2hhckNvZGVBdChpKVxuXG4gICAgLy8gaXMgc3Vycm9nYXRlIGNvbXBvbmVudFxuICAgIGlmIChjb2RlUG9pbnQgPiAweEQ3RkYgJiYgY29kZVBvaW50IDwgMHhFMDAwKSB7XG4gICAgICAvLyBsYXN0IGNoYXIgd2FzIGEgbGVhZFxuICAgICAgaWYgKCFsZWFkU3Vycm9nYXRlKSB7XG4gICAgICAgIC8vIG5vIGxlYWQgeWV0XG4gICAgICAgIGlmIChjb2RlUG9pbnQgPiAweERCRkYpIHtcbiAgICAgICAgICAvLyB1bmV4cGVjdGVkIHRyYWlsXG4gICAgICAgICAgaWYgKCh1bml0cyAtPSAzKSA+IC0xKSBieXRlcy5wdXNoKDB4RUYsIDB4QkYsIDB4QkQpXG4gICAgICAgICAgY29udGludWVcbiAgICAgICAgfSBlbHNlIGlmIChpICsgMSA9PT0gbGVuZ3RoKSB7XG4gICAgICAgICAgLy8gdW5wYWlyZWQgbGVhZFxuICAgICAgICAgIGlmICgodW5pdHMgLT0gMykgPiAtMSkgYnl0ZXMucHVzaCgweEVGLCAweEJGLCAweEJEKVxuICAgICAgICAgIGNvbnRpbnVlXG4gICAgICAgIH1cblxuICAgICAgICAvLyB2YWxpZCBsZWFkXG4gICAgICAgIGxlYWRTdXJyb2dhdGUgPSBjb2RlUG9pbnRcblxuICAgICAgICBjb250aW51ZVxuICAgICAgfVxuXG4gICAgICAvLyAyIGxlYWRzIGluIGEgcm93XG4gICAgICBpZiAoY29kZVBvaW50IDwgMHhEQzAwKSB7XG4gICAgICAgIGlmICgodW5pdHMgLT0gMykgPiAtMSkgYnl0ZXMucHVzaCgweEVGLCAweEJGLCAweEJEKVxuICAgICAgICBsZWFkU3Vycm9nYXRlID0gY29kZVBvaW50XG4gICAgICAgIGNvbnRpbnVlXG4gICAgICB9XG5cbiAgICAgIC8vIHZhbGlkIHN1cnJvZ2F0ZSBwYWlyXG4gICAgICBjb2RlUG9pbnQgPSAobGVhZFN1cnJvZ2F0ZSAtIDB4RDgwMCA8PCAxMCB8IGNvZGVQb2ludCAtIDB4REMwMCkgKyAweDEwMDAwXG4gICAgfSBlbHNlIGlmIChsZWFkU3Vycm9nYXRlKSB7XG4gICAgICAvLyB2YWxpZCBibXAgY2hhciwgYnV0IGxhc3QgY2hhciB3YXMgYSBsZWFkXG4gICAgICBpZiAoKHVuaXRzIC09IDMpID4gLTEpIGJ5dGVzLnB1c2goMHhFRiwgMHhCRiwgMHhCRClcbiAgICB9XG5cbiAgICBsZWFkU3Vycm9nYXRlID0gbnVsbFxuXG4gICAgLy8gZW5jb2RlIHV0ZjhcbiAgICBpZiAoY29kZVBvaW50IDwgMHg4MCkge1xuICAgICAgaWYgKCh1bml0cyAtPSAxKSA8IDApIGJyZWFrXG4gICAgICBieXRlcy5wdXNoKGNvZGVQb2ludClcbiAgICB9IGVsc2UgaWYgKGNvZGVQb2ludCA8IDB4ODAwKSB7XG4gICAgICBpZiAoKHVuaXRzIC09IDIpIDwgMCkgYnJlYWtcbiAgICAgIGJ5dGVzLnB1c2goXG4gICAgICAgIGNvZGVQb2ludCA+PiAweDYgfCAweEMwLFxuICAgICAgICBjb2RlUG9pbnQgJiAweDNGIHwgMHg4MFxuICAgICAgKVxuICAgIH0gZWxzZSBpZiAoY29kZVBvaW50IDwgMHgxMDAwMCkge1xuICAgICAgaWYgKCh1bml0cyAtPSAzKSA8IDApIGJyZWFrXG4gICAgICBieXRlcy5wdXNoKFxuICAgICAgICBjb2RlUG9pbnQgPj4gMHhDIHwgMHhFMCxcbiAgICAgICAgY29kZVBvaW50ID4+IDB4NiAmIDB4M0YgfCAweDgwLFxuICAgICAgICBjb2RlUG9pbnQgJiAweDNGIHwgMHg4MFxuICAgICAgKVxuICAgIH0gZWxzZSBpZiAoY29kZVBvaW50IDwgMHgxMTAwMDApIHtcbiAgICAgIGlmICgodW5pdHMgLT0gNCkgPCAwKSBicmVha1xuICAgICAgYnl0ZXMucHVzaChcbiAgICAgICAgY29kZVBvaW50ID4+IDB4MTIgfCAweEYwLFxuICAgICAgICBjb2RlUG9pbnQgPj4gMHhDICYgMHgzRiB8IDB4ODAsXG4gICAgICAgIGNvZGVQb2ludCA+PiAweDYgJiAweDNGIHwgMHg4MCxcbiAgICAgICAgY29kZVBvaW50ICYgMHgzRiB8IDB4ODBcbiAgICAgIClcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGNvZGUgcG9pbnQnKVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBieXRlc1xufVxuXG5mdW5jdGlvbiBhc2NpaVRvQnl0ZXMgKHN0cikge1xuICB2YXIgYnl0ZUFycmF5ID0gW11cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdHIubGVuZ3RoOyArK2kpIHtcbiAgICAvLyBOb2RlJ3MgY29kZSBzZWVtcyB0byBiZSBkb2luZyB0aGlzIGFuZCBub3QgJiAweDdGLi5cbiAgICBieXRlQXJyYXkucHVzaChzdHIuY2hhckNvZGVBdChpKSAmIDB4RkYpXG4gIH1cbiAgcmV0dXJuIGJ5dGVBcnJheVxufVxuXG5mdW5jdGlvbiB1dGYxNmxlVG9CeXRlcyAoc3RyLCB1bml0cykge1xuICB2YXIgYywgaGksIGxvXG4gIHZhciBieXRlQXJyYXkgPSBbXVxuICBmb3IgKHZhciBpID0gMDsgaSA8IHN0ci5sZW5ndGg7ICsraSkge1xuICAgIGlmICgodW5pdHMgLT0gMikgPCAwKSBicmVha1xuXG4gICAgYyA9IHN0ci5jaGFyQ29kZUF0KGkpXG4gICAgaGkgPSBjID4+IDhcbiAgICBsbyA9IGMgJSAyNTZcbiAgICBieXRlQXJyYXkucHVzaChsbylcbiAgICBieXRlQXJyYXkucHVzaChoaSlcbiAgfVxuXG4gIHJldHVybiBieXRlQXJyYXlcbn1cblxuZnVuY3Rpb24gYmFzZTY0VG9CeXRlcyAoc3RyKSB7XG4gIHJldHVybiBiYXNlNjQudG9CeXRlQXJyYXkoYmFzZTY0Y2xlYW4oc3RyKSlcbn1cblxuZnVuY3Rpb24gYmxpdEJ1ZmZlciAoc3JjLCBkc3QsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyArK2kpIHtcbiAgICBpZiAoKGkgKyBvZmZzZXQgPj0gZHN0Lmxlbmd0aCkgfHwgKGkgPj0gc3JjLmxlbmd0aCkpIGJyZWFrXG4gICAgZHN0W2kgKyBvZmZzZXRdID0gc3JjW2ldXG4gIH1cbiAgcmV0dXJuIGlcbn1cblxuZnVuY3Rpb24gaXNuYW4gKHZhbCkge1xuICByZXR1cm4gdmFsICE9PSB2YWwgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1zZWxmLWNvbXBhcmVcbn1cblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9idWZmZXIvaW5kZXguanNcbi8vIG1vZHVsZSBpZCA9IDM1XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsImV4cG9ydHMucmVhZCA9IGZ1bmN0aW9uIChidWZmZXIsIG9mZnNldCwgaXNMRSwgbUxlbiwgbkJ5dGVzKSB7XG4gIHZhciBlLCBtXG4gIHZhciBlTGVuID0gbkJ5dGVzICogOCAtIG1MZW4gLSAxXG4gIHZhciBlTWF4ID0gKDEgPDwgZUxlbikgLSAxXG4gIHZhciBlQmlhcyA9IGVNYXggPj4gMVxuICB2YXIgbkJpdHMgPSAtN1xuICB2YXIgaSA9IGlzTEUgPyAobkJ5dGVzIC0gMSkgOiAwXG4gIHZhciBkID0gaXNMRSA/IC0xIDogMVxuICB2YXIgcyA9IGJ1ZmZlcltvZmZzZXQgKyBpXVxuXG4gIGkgKz0gZFxuXG4gIGUgPSBzICYgKCgxIDw8ICgtbkJpdHMpKSAtIDEpXG4gIHMgPj49ICgtbkJpdHMpXG4gIG5CaXRzICs9IGVMZW5cbiAgZm9yICg7IG5CaXRzID4gMDsgZSA9IGUgKiAyNTYgKyBidWZmZXJbb2Zmc2V0ICsgaV0sIGkgKz0gZCwgbkJpdHMgLT0gOCkge31cblxuICBtID0gZSAmICgoMSA8PCAoLW5CaXRzKSkgLSAxKVxuICBlID4+PSAoLW5CaXRzKVxuICBuQml0cyArPSBtTGVuXG4gIGZvciAoOyBuQml0cyA+IDA7IG0gPSBtICogMjU2ICsgYnVmZmVyW29mZnNldCArIGldLCBpICs9IGQsIG5CaXRzIC09IDgpIHt9XG5cbiAgaWYgKGUgPT09IDApIHtcbiAgICBlID0gMSAtIGVCaWFzXG4gIH0gZWxzZSBpZiAoZSA9PT0gZU1heCkge1xuICAgIHJldHVybiBtID8gTmFOIDogKChzID8gLTEgOiAxKSAqIEluZmluaXR5KVxuICB9IGVsc2Uge1xuICAgIG0gPSBtICsgTWF0aC5wb3coMiwgbUxlbilcbiAgICBlID0gZSAtIGVCaWFzXG4gIH1cbiAgcmV0dXJuIChzID8gLTEgOiAxKSAqIG0gKiBNYXRoLnBvdygyLCBlIC0gbUxlbilcbn1cblxuZXhwb3J0cy53cml0ZSA9IGZ1bmN0aW9uIChidWZmZXIsIHZhbHVlLCBvZmZzZXQsIGlzTEUsIG1MZW4sIG5CeXRlcykge1xuICB2YXIgZSwgbSwgY1xuICB2YXIgZUxlbiA9IG5CeXRlcyAqIDggLSBtTGVuIC0gMVxuICB2YXIgZU1heCA9ICgxIDw8IGVMZW4pIC0gMVxuICB2YXIgZUJpYXMgPSBlTWF4ID4+IDFcbiAgdmFyIHJ0ID0gKG1MZW4gPT09IDIzID8gTWF0aC5wb3coMiwgLTI0KSAtIE1hdGgucG93KDIsIC03NykgOiAwKVxuICB2YXIgaSA9IGlzTEUgPyAwIDogKG5CeXRlcyAtIDEpXG4gIHZhciBkID0gaXNMRSA/IDEgOiAtMVxuICB2YXIgcyA9IHZhbHVlIDwgMCB8fCAodmFsdWUgPT09IDAgJiYgMSAvIHZhbHVlIDwgMCkgPyAxIDogMFxuXG4gIHZhbHVlID0gTWF0aC5hYnModmFsdWUpXG5cbiAgaWYgKGlzTmFOKHZhbHVlKSB8fCB2YWx1ZSA9PT0gSW5maW5pdHkpIHtcbiAgICBtID0gaXNOYU4odmFsdWUpID8gMSA6IDBcbiAgICBlID0gZU1heFxuICB9IGVsc2Uge1xuICAgIGUgPSBNYXRoLmZsb29yKE1hdGgubG9nKHZhbHVlKSAvIE1hdGguTE4yKVxuICAgIGlmICh2YWx1ZSAqIChjID0gTWF0aC5wb3coMiwgLWUpKSA8IDEpIHtcbiAgICAgIGUtLVxuICAgICAgYyAqPSAyXG4gICAgfVxuICAgIGlmIChlICsgZUJpYXMgPj0gMSkge1xuICAgICAgdmFsdWUgKz0gcnQgLyBjXG4gICAgfSBlbHNlIHtcbiAgICAgIHZhbHVlICs9IHJ0ICogTWF0aC5wb3coMiwgMSAtIGVCaWFzKVxuICAgIH1cbiAgICBpZiAodmFsdWUgKiBjID49IDIpIHtcbiAgICAgIGUrK1xuICAgICAgYyAvPSAyXG4gICAgfVxuXG4gICAgaWYgKGUgKyBlQmlhcyA+PSBlTWF4KSB7XG4gICAgICBtID0gMFxuICAgICAgZSA9IGVNYXhcbiAgICB9IGVsc2UgaWYgKGUgKyBlQmlhcyA+PSAxKSB7XG4gICAgICBtID0gKHZhbHVlICogYyAtIDEpICogTWF0aC5wb3coMiwgbUxlbilcbiAgICAgIGUgPSBlICsgZUJpYXNcbiAgICB9IGVsc2Uge1xuICAgICAgbSA9IHZhbHVlICogTWF0aC5wb3coMiwgZUJpYXMgLSAxKSAqIE1hdGgucG93KDIsIG1MZW4pXG4gICAgICBlID0gMFxuICAgIH1cbiAgfVxuXG4gIGZvciAoOyBtTGVuID49IDg7IGJ1ZmZlcltvZmZzZXQgKyBpXSA9IG0gJiAweGZmLCBpICs9IGQsIG0gLz0gMjU2LCBtTGVuIC09IDgpIHt9XG5cbiAgZSA9IChlIDw8IG1MZW4pIHwgbVxuICBlTGVuICs9IG1MZW5cbiAgZm9yICg7IGVMZW4gPiAwOyBidWZmZXJbb2Zmc2V0ICsgaV0gPSBlICYgMHhmZiwgaSArPSBkLCBlIC89IDI1NiwgZUxlbiAtPSA4KSB7fVxuXG4gIGJ1ZmZlcltvZmZzZXQgKyBpIC0gZF0gfD0gcyAqIDEyOFxufVxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2llZWU3NTQvaW5kZXguanNcbi8vIG1vZHVsZSBpZCA9IDM2XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG5cdHZhbHVlOiB0cnVlXG59KTtcblxudmFyIF9jcmVhdGVDbGFzcyA9IGZ1bmN0aW9uICgpIHsgZnVuY3Rpb24gZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsgfSB9IHJldHVybiBmdW5jdGlvbiAoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyByZXR1cm4gQ29uc3RydWN0b3I7IH07IH0oKTtcblxudmFyIF9tZXRhbCA9IHJlcXVpcmUoJ21ldGFsJyk7XG5cbnZhciBfbWV0YWxVcmkgPSByZXF1aXJlKCdtZXRhbC11cmknKTtcblxudmFyIF9tZXRhbFVyaTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9tZXRhbFVyaSk7XG5cbnZhciBfbWV0YWxQcm9taXNlID0gcmVxdWlyZSgnbWV0YWwtcHJvbWlzZScpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG52YXIgQWpheCA9IGZ1bmN0aW9uICgpIHtcblx0ZnVuY3Rpb24gQWpheCgpIHtcblx0XHRfY2xhc3NDYWxsQ2hlY2sodGhpcywgQWpheCk7XG5cdH1cblxuXHRfY3JlYXRlQ2xhc3MoQWpheCwgbnVsbCwgW3tcblx0XHRrZXk6ICdwYXJzZVJlc3BvbnNlSGVhZGVycycsXG5cblxuXHRcdC8qKlxuICAgKiBYbWxIdHRwUmVxdWVzdCdzIGdldEFsbFJlc3BvbnNlSGVhZGVycygpIG1ldGhvZCByZXR1cm5zIGEgc3RyaW5nIG9mXG4gICAqIHJlc3BvbnNlIGhlYWRlcnMgYWNjb3JkaW5nIHRvIHRoZSBmb3JtYXQgZGVzY3JpYmVkIG9uIHRoZSBzcGVjOlxuICAgKiB7QGxpbmsgaHR0cDovL3d3dy53My5vcmcvVFIvWE1MSHR0cFJlcXVlc3QvI3RoZS1nZXRhbGxyZXNwb25zZWhlYWRlcnMtbWV0aG9kfS5cbiAgICogVGhpcyBtZXRob2QgcGFyc2VzIHRoYXQgc3RyaW5nIGludG8gYSB1c2VyLWZyaWVuZGx5IG5hbWUvdmFsdWUgcGFpclxuICAgKiBvYmplY3QuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBhbGxIZWFkZXJzIEFsbCBoZWFkZXJzIGFzIHN0cmluZy5cbiAgICogQHJldHVybiB7IUFycmF5LjxPYmplY3Q8c3RyaW5nLCBzdHJpbmc+Pn1cbiAgICovXG5cdFx0dmFsdWU6IGZ1bmN0aW9uIHBhcnNlUmVzcG9uc2VIZWFkZXJzKGFsbEhlYWRlcnMpIHtcblx0XHRcdHZhciBoZWFkZXJzID0gW107XG5cdFx0XHRpZiAoIWFsbEhlYWRlcnMpIHtcblx0XHRcdFx0cmV0dXJuIGhlYWRlcnM7XG5cdFx0XHR9XG5cdFx0XHR2YXIgcGFpcnMgPSBhbGxIZWFkZXJzLnNwbGl0KCdcXHJcXG4nKTtcblx0XHRcdGZvciAodmFyIGkgPSAwOyBpIDwgcGFpcnMubGVuZ3RoOyBpKyspIHtcblx0XHRcdFx0dmFyIGluZGV4ID0gcGFpcnNbaV0uaW5kZXhPZignOiAnKTtcblx0XHRcdFx0aWYgKGluZGV4ID4gMCkge1xuXHRcdFx0XHRcdHZhciBuYW1lID0gcGFpcnNbaV0uc3Vic3RyaW5nKDAsIGluZGV4KTtcblx0XHRcdFx0XHR2YXIgdmFsdWUgPSBwYWlyc1tpXS5zdWJzdHJpbmcoaW5kZXggKyAyKTtcblx0XHRcdFx0XHRoZWFkZXJzLnB1c2goe1xuXHRcdFx0XHRcdFx0bmFtZTogbmFtZSxcblx0XHRcdFx0XHRcdHZhbHVlOiB2YWx1ZVxuXHRcdFx0XHRcdH0pO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gaGVhZGVycztcblx0XHR9XG5cblx0XHQvKipcbiAgICogUmVxdWVzdHMgdGhlIHVybCB1c2luZyBYTUxIdHRwUmVxdWVzdC5cbiAgICogQHBhcmFtIHshc3RyaW5nfSB1cmxcbiAgICogQHBhcmFtIHshc3RyaW5nfSBtZXRob2RcbiAgICogQHBhcmFtIHs/c3RyaW5nfSBib2R5XG4gICAqIEBwYXJhbSB7TXVsdGlNYXA9fSBvcHRfaGVhZGVyc1xuICAgKiBAcGFyYW0ge011bHRpTWFwPX0gb3B0X3BhcmFtc1xuICAgKiBAcGFyYW0ge251bWJlcj19IG9wdF90aW1lb3V0XG4gICAqIEBwYXJhbSB7Ym9vbGVhbj19IG9wdF9zeW5jXG4gICAqIEBwYXJhbSB7Ym9vbGVhbj19IG9wdF93aXRoQ3JlZGVudGlhbHNcbiAgICogQHJldHVybiB7UHJvbWlzZX0gRGVmZXJyZWQgYWpheCByZXF1ZXN0LlxuICAgKiBAcHJvdGVjdGVkXG4gICAqL1xuXG5cdH0sIHtcblx0XHRrZXk6ICdyZXF1ZXN0Jyxcblx0XHR2YWx1ZTogZnVuY3Rpb24gcmVxdWVzdCh1cmwsIG1ldGhvZCwgYm9keSwgb3B0X2hlYWRlcnMsIG9wdF9wYXJhbXMsIG9wdF90aW1lb3V0LCBvcHRfc3luYywgb3B0X3dpdGhDcmVkZW50aWFscykge1xuXHRcdFx0dXJsID0gdXJsIHx8ICcnO1xuXHRcdFx0bWV0aG9kID0gbWV0aG9kIHx8ICdHRVQnO1xuXG5cdFx0XHR2YXIgcmVxdWVzdCA9IG5ldyBYTUxIdHRwUmVxdWVzdCgpO1xuXG5cdFx0XHR2YXIgcHJvbWlzZSA9IG5ldyBfbWV0YWxQcm9taXNlLkNhbmNlbGxhYmxlUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG5cdFx0XHRcdHJlcXVlc3Qub25sb2FkID0gZnVuY3Rpb24gKCkge1xuXHRcdFx0XHRcdGlmIChyZXF1ZXN0LmFib3J0ZWQpIHtcblx0XHRcdFx0XHRcdHJlcXVlc3Qub25lcnJvcigpO1xuXHRcdFx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRyZXNvbHZlKHJlcXVlc3QpO1xuXHRcdFx0XHR9O1xuXHRcdFx0XHRyZXF1ZXN0Lm9uZXJyb3IgPSBmdW5jdGlvbiAoKSB7XG5cdFx0XHRcdFx0dmFyIGVycm9yID0gbmV3IEVycm9yKCdSZXF1ZXN0IGVycm9yJyk7XG5cdFx0XHRcdFx0ZXJyb3IucmVxdWVzdCA9IHJlcXVlc3Q7XG5cdFx0XHRcdFx0cmVqZWN0KGVycm9yKTtcblx0XHRcdFx0fTtcblx0XHRcdH0pLnRoZW5DYXRjaChmdW5jdGlvbiAocmVhc29uKSB7XG5cdFx0XHRcdHJlcXVlc3QuYWJvcnQoKTtcblx0XHRcdFx0dGhyb3cgcmVhc29uO1xuXHRcdFx0fSkudGhlbkFsd2F5cyhmdW5jdGlvbiAoKSB7XG5cdFx0XHRcdGNsZWFyVGltZW91dCh0aW1lb3V0KTtcblx0XHRcdH0pO1xuXG5cdFx0XHR1cmwgPSBuZXcgX21ldGFsVXJpMi5kZWZhdWx0KHVybCk7XG5cblx0XHRcdGlmIChvcHRfcGFyYW1zKSB7XG5cdFx0XHRcdHVybC5hZGRQYXJhbWV0ZXJzRnJvbU11bHRpTWFwKG9wdF9wYXJhbXMpLnRvU3RyaW5nKCk7XG5cdFx0XHR9XG5cblx0XHRcdHVybCA9IHVybC50b1N0cmluZygpO1xuXG5cdFx0XHRyZXF1ZXN0Lm9wZW4obWV0aG9kLCB1cmwsICFvcHRfc3luYyk7XG5cblx0XHRcdGlmIChvcHRfd2l0aENyZWRlbnRpYWxzKSB7XG5cdFx0XHRcdHJlcXVlc3Qud2l0aENyZWRlbnRpYWxzID0gdHJ1ZTtcblx0XHRcdH1cblxuXHRcdFx0aWYgKG9wdF9oZWFkZXJzKSB7XG5cdFx0XHRcdG9wdF9oZWFkZXJzLm5hbWVzKCkuZm9yRWFjaChmdW5jdGlvbiAobmFtZSkge1xuXHRcdFx0XHRcdHJlcXVlc3Quc2V0UmVxdWVzdEhlYWRlcihuYW1lLCBvcHRfaGVhZGVycy5nZXRBbGwobmFtZSkuam9pbignLCAnKSk7XG5cdFx0XHRcdH0pO1xuXHRcdFx0fVxuXG5cdFx0XHRyZXF1ZXN0LnNlbmQoKDAsIF9tZXRhbC5pc0RlZikoYm9keSkgPyBib2R5IDogbnVsbCk7XG5cblx0XHRcdGlmICgoMCwgX21ldGFsLmlzRGVmQW5kTm90TnVsbCkob3B0X3RpbWVvdXQpKSB7XG5cdFx0XHRcdHZhciB0aW1lb3V0ID0gc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG5cdFx0XHRcdFx0cHJvbWlzZS5jYW5jZWwoJ1JlcXVlc3QgdGltZW91dCcpO1xuXHRcdFx0XHR9LCBvcHRfdGltZW91dCk7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBwcm9taXNlO1xuXHRcdH1cblx0fV0pO1xuXG5cdHJldHVybiBBamF4O1xufSgpO1xuXG5leHBvcnRzLmRlZmF1bHQgPSBBamF4O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9tZXRhbC1hamF4L2xpYi9BamF4LmpzXG4vLyBtb2R1bGUgaWQgPSAzOFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKiFcbiAqIFByb21pc2VzIHBvbHlmaWxsIGZyb20gR29vZ2xlJ3MgQ2xvc3VyZSBMaWJyYXJ5LlxuICpcbiAqICAgICAgQ29weXJpZ2h0IDIwMTMgVGhlIENsb3N1cmUgTGlicmFyeSBBdXRob3JzLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIE5PVEUoZWR1YXJkbyk6IFByb21pc2Ugc3VwcG9ydCBpcyBub3QgcmVhZHkgb24gYWxsIHN1cHBvcnRlZCBicm93c2VycyxcbiAqIHRoZXJlZm9yZSBtZXRhbC1wcm9taXNlIGlzIHRlbXBvcmFyaWx5IHVzaW5nIEdvb2dsZSdzIHByb21pc2VzIGFzIHBvbHlmaWxsLlxuICogSXQgc3VwcG9ydHMgY2FuY2VsbGFibGUgcHJvbWlzZXMgYW5kIGhhcyBjbGVhbiBhbmQgZmFzdCBpbXBsZW1lbnRhdGlvbi5cbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLkNhbmNlbGxhYmxlUHJvbWlzZSA9IHVuZGVmaW5lZDtcblxudmFyIF9tZXRhbCA9IHJlcXVpcmUoJ21ldGFsJyk7XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbmZ1bmN0aW9uIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHNlbGYsIGNhbGwpIHsgaWYgKCFzZWxmKSB7IHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFwiKTsgfSByZXR1cm4gY2FsbCAmJiAodHlwZW9mIGNhbGwgPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIGNhbGwgPT09IFwiZnVuY3Rpb25cIikgPyBjYWxsIDogc2VsZjsgfVxuXG5mdW5jdGlvbiBfaW5oZXJpdHMoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHsgaWYgKHR5cGVvZiBzdXBlckNsYXNzICE9PSBcImZ1bmN0aW9uXCIgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb24sIG5vdCBcIiArIHR5cGVvZiBzdXBlckNsYXNzKTsgfSBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MgJiYgc3VwZXJDbGFzcy5wcm90b3R5cGUsIHsgY29uc3RydWN0b3I6IHsgdmFsdWU6IHN1YkNsYXNzLCBlbnVtZXJhYmxlOiBmYWxzZSwgd3JpdGFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH0pOyBpZiAoc3VwZXJDbGFzcykgT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LnNldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKSA6IHN1YkNsYXNzLl9fcHJvdG9fXyA9IHN1cGVyQ2xhc3M7IH1cblxuLyoqXG4gKiBQcm92aWRlcyBhIG1vcmUgc3RyaWN0IGludGVyZmFjZSBmb3IgVGhlbmFibGVzIGluIHRlcm1zIG9mXG4gKiBodHRwOi8vcHJvbWlzZXNhcGx1cy5jb20gZm9yIGludGVyb3Agd2l0aCB7QHNlZSBDYW5jZWxsYWJsZVByb21pc2V9LlxuICpcbiAqIEBpbnRlcmZhY2VcbiAqIEBleHRlbmRzIHtJVGhlbmFibGUuPFRZUEU+fVxuICogQHRlbXBsYXRlIFRZUEVcbiAqL1xudmFyIFRoZW5hYmxlID0gZnVuY3Rpb24gVGhlbmFibGUoKSB7fTtcblxuLyoqXG4gKiBBZGRzIGNhbGxiYWNrcyB0aGF0IHdpbGwgb3BlcmF0ZSBvbiB0aGUgcmVzdWx0IG9mIHRoZSBUaGVuYWJsZSwgcmV0dXJuaW5nIGFcbiAqIG5ldyBjaGlsZCBQcm9taXNlLlxuICpcbiAqIElmIHRoZSBUaGVuYWJsZSBpcyBmdWxmaWxsZWQsIHRoZSB7QGNvZGUgb25GdWxmaWxsZWR9IGNhbGxiYWNrIHdpbGwgYmVcbiAqIGludm9rZWQgd2l0aCB0aGUgZnVsZmlsbG1lbnQgdmFsdWUgYXMgYXJndW1lbnQsIGFuZCB0aGUgY2hpbGQgUHJvbWlzZSB3aWxsXG4gKiBiZSBmdWxmaWxsZWQgd2l0aCB0aGUgcmV0dXJuIHZhbHVlIG9mIHRoZSBjYWxsYmFjay4gSWYgdGhlIGNhbGxiYWNrIHRocm93c1xuICogYW4gZXhjZXB0aW9uLCB0aGUgY2hpbGQgUHJvbWlzZSB3aWxsIGJlIHJlamVjdGVkIHdpdGggdGhlIHRocm93biB2YWx1ZVxuICogaW5zdGVhZC5cbiAqXG4gKiBJZiB0aGUgVGhlbmFibGUgaXMgcmVqZWN0ZWQsIHRoZSB7QGNvZGUgb25SZWplY3RlZH0gY2FsbGJhY2sgd2lsbCBiZSBpbnZva2VkXG4gKiB3aXRoIHRoZSByZWplY3Rpb24gcmVhc29uIGFzIGFyZ3VtZW50LCBhbmQgdGhlIGNoaWxkIFByb21pc2Ugd2lsbCBiZSByZWplY3RlZFxuICogd2l0aCB0aGUgcmV0dXJuIHZhbHVlIG9mIHRoZSBjYWxsYmFjayBvciB0aHJvd24gdmFsdWUuXG4gKlxuICogQHBhcmFtIHs/KGZ1bmN0aW9uKHRoaXM6VEhJUywgVFlQRSk6XG4gKiAgICAgICAgICAgICAoUkVTVUxUfElUaGVuYWJsZS48UkVTVUxUPnxUaGVuYWJsZSkpPX0gb3B0X29uRnVsZmlsbGVkIEFcbiAqICAgICBmdW5jdGlvbiB0aGF0IHdpbGwgYmUgaW52b2tlZCB3aXRoIHRoZSBmdWxmaWxsbWVudCB2YWx1ZSBpZiB0aGUgUHJvbWlzZVxuICogICAgIGlzIGZ1bGxmaWxsZWQuXG4gKiBAcGFyYW0gez8oZnVuY3Rpb24oKik6ICopPX0gb3B0X29uUmVqZWN0ZWQgQSBmdW5jdGlvbiB0aGF0IHdpbGwgYmUgaW52b2tlZFxuICogICAgIHdpdGggdGhlIHJlamVjdGlvbiByZWFzb24gaWYgdGhlIFByb21pc2UgaXMgcmVqZWN0ZWQuXG4gKiBAcGFyYW0ge1RISVM9fSBvcHRfY29udGV4dCBBbiBvcHRpb25hbCBjb250ZXh0IG9iamVjdCB0aGF0IHdpbGwgYmUgdGhlXG4gKiAgICAgZXhlY3V0aW9uIGNvbnRleHQgZm9yIHRoZSBjYWxsYmFja3MuIEJ5IGRlZmF1bHQsIGZ1bmN0aW9ucyBhcmUgZXhlY3V0ZWRcbiAqICAgICB3aXRoIHRoZSBkZWZhdWx0IHRoaXMuXG4gKiBAcmV0dXJuIHshQ2FuY2VsbGFibGVQcm9taXNlLjxSRVNVTFQ+fSBBIG5ldyBQcm9taXNlIHRoYXQgd2lsbCByZWNlaXZlIHRoZVxuICogICAgIHJlc3VsdCBvZiB0aGUgZnVsZmlsbG1lbnQgb3IgcmVqZWN0aW9uIGNhbGxiYWNrLlxuICogQHRlbXBsYXRlIFJFU1VMVCxUSElTXG4gKi9cblRoZW5hYmxlLnByb3RvdHlwZS50aGVuID0gZnVuY3Rpb24gKCkge307XG5cbi8qKlxuICogQW4gZXhwYW5kbyBwcm9wZXJ0eSB0byBpbmRpY2F0ZSB0aGF0IGFuIG9iamVjdCBpbXBsZW1lbnRzXG4gKiB7QGNvZGUgVGhlbmFibGV9LlxuICpcbiAqIHtAc2VlIGFkZEltcGxlbWVudGF0aW9ufS5cbiAqXG4gKiBAY29uc3RcbiAqL1xuVGhlbmFibGUuSU1QTEVNRU5URURfQllfUFJPUCA9ICckZ29vZ19UaGVuYWJsZSc7XG5cbi8qKlxuICogTWFya3MgYSBnaXZlbiBjbGFzcyAoY29uc3RydWN0b3IpIGFzIGFuIGltcGxlbWVudGF0aW9uIG9mIFRoZW5hYmxlLCBzb1xuICogdGhhdCB3ZSBjYW4gcXVlcnkgdGhhdCBmYWN0IGF0IHJ1bnRpbWUuIFRoZSBjbGFzcyBtdXN0IGhhdmUgYWxyZWFkeVxuICogaW1wbGVtZW50ZWQgdGhlIGludGVyZmFjZS5cbiAqIEV4cG9ydHMgYSAndGhlbicgbWV0aG9kIG9uIHRoZSBjb25zdHJ1Y3RvciBwcm90b3R5cGUsIHNvIHRoYXQgdGhlIG9iamVjdHNcbiAqIGFsc28gaW1wbGVtZW50IHRoZSBleHRlcm4ge0BzZWUgVGhlbmFibGV9IGludGVyZmFjZSBmb3IgaW50ZXJvcCB3aXRoXG4gKiBvdGhlciBQcm9taXNlIGltcGxlbWVudGF0aW9ucy5cbiAqIEBwYXJhbSB7ZnVuY3Rpb24obmV3OlRoZW5hYmxlLC4uLls/XSl9IGN0b3IgVGhlIGNsYXNzIGNvbnN0cnVjdG9yLiBUaGVcbiAqICAgICBjb3JyZXNwb25kaW5nIGNsYXNzIG11c3QgaGF2ZSBhbHJlYWR5IGltcGxlbWVudGVkIHRoZSBpbnRlcmZhY2UuXG4gKi9cblRoZW5hYmxlLmFkZEltcGxlbWVudGF0aW9uID0gZnVuY3Rpb24gKGN0b3IpIHtcbiAgY3Rvci5wcm90b3R5cGUudGhlbiA9IGN0b3IucHJvdG90eXBlLnRoZW47XG4gIGN0b3IucHJvdG90eXBlLiRnb29nX1RoZW5hYmxlID0gdHJ1ZTtcbn07XG5cbi8qKlxuICogQHBhcmFtIHsqfSBvYmplY3RcbiAqIEByZXR1cm4ge2Jvb2xlYW59IFdoZXRoZXIgYSBnaXZlbiBpbnN0YW5jZSBpbXBsZW1lbnRzIHtAY29kZSBUaGVuYWJsZX0uXG4gKiAgICAgVGhlIGNsYXNzL3N1cGVyY2xhc3Mgb2YgdGhlIGluc3RhbmNlIG11c3QgY2FsbCB7QGNvZGUgYWRkSW1wbGVtZW50YXRpb259LlxuICovXG5UaGVuYWJsZS5pc0ltcGxlbWVudGVkQnkgPSBmdW5jdGlvbiAob2JqZWN0KSB7XG4gIGlmICghb2JqZWN0KSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHRyeSB7XG4gICAgcmV0dXJuICEhb2JqZWN0LiRnb29nX1RoZW5hYmxlO1xuICB9IGNhdGNoIChlKSB7XG4gICAgLy8gUHJvcGVydHkgYWNjZXNzIHNlZW1zIHRvIGJlIGZvcmJpZGRlbi5cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbn07XG5cbi8qKlxuICogTGlrZSBiaW5kKCksIGV4Y2VwdCB0aGF0IGEgJ3RoaXMgb2JqZWN0JyBpcyBub3QgcmVxdWlyZWQuIFVzZWZ1bCB3aGVuIHRoZVxuICogdGFyZ2V0IGZ1bmN0aW9uIGlzIGFscmVhZHkgYm91bmQuXG4gKlxuICogVXNhZ2U6XG4gKiB2YXIgZyA9IHBhcnRpYWwoZiwgYXJnMSwgYXJnMik7XG4gKiBnKGFyZzMsIGFyZzQpO1xuICpcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuIEEgZnVuY3Rpb24gdG8gcGFydGlhbGx5IGFwcGx5LlxuICogQHBhcmFtIHsuLi4qfSB2YXJfYXJncyBBZGRpdGlvbmFsIGFyZ3VtZW50cyB0aGF0IGFyZSBwYXJ0aWFsbHkgYXBwbGllZCB0byBmbi5cbiAqIEByZXR1cm4geyFGdW5jdGlvbn0gQSBwYXJ0aWFsbHktYXBwbGllZCBmb3JtIG9mIHRoZSBmdW5jdGlvbiBiaW5kKCkgd2FzXG4gKiAgICAgaW52b2tlZCBhcyBhIG1ldGhvZCBvZi5cbiAqL1xudmFyIHBhcnRpYWwgPSBmdW5jdGlvbiBwYXJ0aWFsKGZuKSB7XG4gIHZhciBhcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKTtcbiAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAvLyBDbG9uZSB0aGUgYXJyYXkgKHdpdGggc2xpY2UoKSkgYW5kIGFwcGVuZCBhZGRpdGlvbmFsIGFyZ3VtZW50c1xuICAgIC8vIHRvIHRoZSBleGlzdGluZyBhcmd1bWVudHMuXG4gICAgdmFyIG5ld0FyZ3MgPSBhcmdzLnNsaWNlKCk7XG4gICAgbmV3QXJncy5wdXNoLmFwcGx5KG5ld0FyZ3MsIGFyZ3VtZW50cyk7XG4gICAgcmV0dXJuIGZuLmFwcGx5KHRoaXMsIG5ld0FyZ3MpO1xuICB9O1xufTtcblxuLyoqXG4gKiBQcm9taXNlcyBwcm92aWRlIGEgcmVzdWx0IHRoYXQgbWF5IGJlIHJlc29sdmVkIGFzeW5jaHJvbm91c2x5LiBBIFByb21pc2UgbWF5XG4gKiBiZSByZXNvbHZlZCBieSBiZWluZyBmdWxmaWxsZWQgb3IgcmVqZWN0ZWQgd2l0aCBhIHZhbHVlLCB3aGljaCB3aWxsIGJlIGtub3duXG4gKiBhcyB0aGUgZnVsZmlsbG1lbnQgdmFsdWUgb3IgdGhlIHJlamVjdGlvbiByZWFzb24uIFdoZXRoZXIgZnVsZmlsbGVkIG9yXG4gKiByZWplY3RlZCwgdGhlIFByb21pc2UgcmVzdWx0IGlzIGltbXV0YWJsZSBvbmNlIGl0IGlzIHNldC5cbiAqXG4gKiBQcm9taXNlcyBtYXkgcmVwcmVzZW50IHJlc3VsdHMgb2YgYW55IHR5cGUsIGluY2x1ZGluZyB1bmRlZmluZWQuIFJlamVjdGlvblxuICogcmVhc29ucyBhcmUgdHlwaWNhbGx5IEVycm9ycywgYnV0IG1heSBhbHNvIGJlIG9mIGFueSB0eXBlLiBDbG9zdXJlIFByb21pc2VzXG4gKiBhbGxvdyBmb3Igb3B0aW9uYWwgdHlwZSBhbm5vdGF0aW9ucyB0aGF0IGVuZm9yY2UgdGhhdCBmdWxmaWxsbWVudCB2YWx1ZXMgYXJlXG4gKiBvZiB0aGUgYXBwcm9wcmlhdGUgdHlwZXMgYXQgY29tcGlsZSB0aW1lLlxuICpcbiAqIFRoZSByZXN1bHQgb2YgYSBQcm9taXNlIGlzIGFjY2Vzc2libGUgYnkgY2FsbGluZyB7QGNvZGUgdGhlbn0gYW5kIHJlZ2lzdGVyaW5nXG4gKiB7QGNvZGUgb25GdWxmaWxsZWR9IGFuZCB7QGNvZGUgb25SZWplY3RlZH0gY2FsbGJhY2tzLiBPbmNlIHRoZSBQcm9taXNlXG4gKiByZXNvbHZlcywgdGhlIHJlbGV2YW50IGNhbGxiYWNrcyBhcmUgaW52b2tlZCB3aXRoIHRoZSBmdWxmaWxsbWVudCB2YWx1ZSBvclxuICogcmVqZWN0aW9uIHJlYXNvbiBhcyBhcmd1bWVudC4gQ2FsbGJhY2tzIGFyZSBhbHdheXMgaW52b2tlZCBpbiB0aGUgb3JkZXIgdGhleVxuICogd2VyZSByZWdpc3RlcmVkLCBldmVuIHdoZW4gYWRkaXRpb25hbCB7QGNvZGUgdGhlbn0gY2FsbHMgYXJlIG1hZGUgZnJvbSBpbnNpZGVcbiAqIGFub3RoZXIgY2FsbGJhY2suIEEgY2FsbGJhY2sgaXMgYWx3YXlzIHJ1biBhc3luY2hyb25vdXNseSBzb21ldGltZSBhZnRlciB0aGVcbiAqIHNjb3BlIGNvbnRhaW5pbmcgdGhlIHJlZ2lzdGVyaW5nIHtAY29kZSB0aGVufSBpbnZvY2F0aW9uIGhhcyByZXR1cm5lZC5cbiAqXG4gKiBJZiBhIFByb21pc2UgaXMgcmVzb2x2ZWQgd2l0aCBhbm90aGVyIFByb21pc2UsIHRoZSBmaXJzdCBQcm9taXNlIHdpbGwgYmxvY2tcbiAqIHVudGlsIHRoZSBzZWNvbmQgaXMgcmVzb2x2ZWQsIGFuZCB0aGVuIGFzc3VtZXMgdGhlIHNhbWUgcmVzdWx0IGFzIHRoZSBzZWNvbmRcbiAqIFByb21pc2UuIFRoaXMgYWxsb3dzIFByb21pc2VzIHRvIGRlcGVuZCBvbiB0aGUgcmVzdWx0cyBvZiBvdGhlciBQcm9taXNlcyxcbiAqIGxpbmtpbmcgdG9nZXRoZXIgbXVsdGlwbGUgYXN5bmNocm9ub3VzIG9wZXJhdGlvbnMuXG4gKlxuICogVGhpcyBpbXBsZW1lbnRhdGlvbiBpcyBjb21wYXRpYmxlIHdpdGggdGhlIFByb21pc2VzL0ErIHNwZWNpZmljYXRpb24gYW5kXG4gKiBwYXNzZXMgdGhhdCBzcGVjaWZpY2F0aW9uJ3MgY29uZm9ybWFuY2UgdGVzdCBzdWl0ZS4gQSBDbG9zdXJlIFByb21pc2UgbWF5IGJlXG4gKiByZXNvbHZlZCB3aXRoIGEgUHJvbWlzZSBpbnN0YW5jZSAob3Igc3VmZmljaWVudGx5IGNvbXBhdGlibGUgUHJvbWlzZS1saWtlXG4gKiBvYmplY3QpIGNyZWF0ZWQgYnkgb3RoZXIgUHJvbWlzZSBpbXBsZW1lbnRhdGlvbnMuIEZyb20gdGhlIHNwZWNpZmljYXRpb24sXG4gKiBQcm9taXNlLWxpa2Ugb2JqZWN0cyBhcmUga25vd24gYXMgXCJUaGVuYWJsZXNcIi5cbiAqXG4gKiBAc2VlIGh0dHA6Ly9wcm9taXNlc2FwbHVzLmNvbS9cbiAqXG4gKiBAcGFyYW0ge2Z1bmN0aW9uKFxuICogICAgICAgICAgICAgdGhpczpSRVNPTFZFUl9DT05URVhULFxuICogICAgICAgICAgICAgZnVuY3Rpb24oKFRZUEV8SVRoZW5hYmxlLjxUWVBFPnxUaGVuYWJsZSkpLFxuICogICAgICAgICAgICAgZnVuY3Rpb24oKikpOiB2b2lkfSByZXNvbHZlclxuICogICAgIEluaXRpYWxpemF0aW9uIGZ1bmN0aW9uIHRoYXQgaXMgaW52b2tlZCBpbW1lZGlhdGVseSB3aXRoIHtAY29kZSByZXNvbHZlfVxuICogICAgIGFuZCB7QGNvZGUgcmVqZWN0fSBmdW5jdGlvbnMgYXMgYXJndW1lbnRzLiBUaGUgUHJvbWlzZSBpcyByZXNvbHZlZCBvclxuICogICAgIHJlamVjdGVkIHdpdGggdGhlIGZpcnN0IGFyZ3VtZW50IHBhc3NlZCB0byBlaXRoZXIgZnVuY3Rpb24uXG4gKiBAcGFyYW0ge1JFU09MVkVSX0NPTlRFWFQ9fSBvcHRfY29udGV4dCBBbiBvcHRpb25hbCBjb250ZXh0IGZvciBleGVjdXRpbmcgdGhlXG4gKiAgICAgcmVzb2x2ZXIgZnVuY3Rpb24uIElmIHVuc3BlY2lmaWVkLCB0aGUgcmVzb2x2ZXIgZnVuY3Rpb24gd2lsbCBiZSBleGVjdXRlZFxuICogICAgIGluIHRoZSBkZWZhdWx0IHNjb3BlLlxuICogQGNvbnN0cnVjdG9yXG4gKiBAc3RydWN0XG4gKiBAZmluYWxcbiAqIEBpbXBsZW1lbnRzIHtUaGVuYWJsZS48VFlQRT59XG4gKiBAdGVtcGxhdGUgVFlQRSxSRVNPTFZFUl9DT05URVhUXG4gKi9cbnZhciBDYW5jZWxsYWJsZVByb21pc2UgPSBmdW5jdGlvbiBDYW5jZWxsYWJsZVByb21pc2UocmVzb2x2ZXIsIG9wdF9jb250ZXh0KSB7XG4gIC8qKlxuICAgKiBUaGUgaW50ZXJuYWwgc3RhdGUgb2YgdGhpcyBQcm9taXNlLiBFaXRoZXIgUEVORElORywgRlVMRklMTEVELCBSRUpFQ1RFRCwgb3JcbiAgICogQkxPQ0tFRC5cbiAgICogQHByaXZhdGUge0NhbmNlbGxhYmxlUHJvbWlzZS5TdGF0ZV99XG4gICAqL1xuICB0aGlzLnN0YXRlXyA9IENhbmNlbGxhYmxlUHJvbWlzZS5TdGF0ZV8uUEVORElORztcblxuICAvKipcbiAgICogVGhlIHJlc29sdmVkIHJlc3VsdCBvZiB0aGUgUHJvbWlzZS4gSW1tdXRhYmxlIG9uY2Ugc2V0IHdpdGggZWl0aGVyIGFcbiAgICogZnVsZmlsbG1lbnQgdmFsdWUgb3IgcmVqZWN0aW9uIHJlYXNvbi5cbiAgICogQHByaXZhdGUgeyp9XG4gICAqL1xuICB0aGlzLnJlc3VsdF8gPSB1bmRlZmluZWQ7XG5cbiAgLyoqXG4gICAqIEZvciBQcm9taXNlcyBjcmVhdGVkIGJ5IGNhbGxpbmcge0Bjb2RlIHRoZW4oKX0sIHRoZSBvcmlnaW5hdGluZyBwYXJlbnQuXG4gICAqIEBwcml2YXRlIHtDYW5jZWxsYWJsZVByb21pc2V9XG4gICAqL1xuICB0aGlzLnBhcmVudF8gPSBudWxsO1xuXG4gIC8qKlxuICAgKiBUaGUgbGlzdCBvZiB7QGNvZGUgb25GdWxmaWxsZWR9IGFuZCB7QGNvZGUgb25SZWplY3RlZH0gY2FsbGJhY2tzIGFkZGVkIHRvXG4gICAqIHRoaXMgUHJvbWlzZSBieSBjYWxscyB0byB7QGNvZGUgdGhlbigpfS5cbiAgICogQHByaXZhdGUge0FycmF5LjxDYW5jZWxsYWJsZVByb21pc2UuQ2FsbGJhY2tFbnRyeV8+fVxuICAgKi9cbiAgdGhpcy5jYWxsYmFja0VudHJpZXNfID0gbnVsbDtcblxuICAvKipcbiAgICogV2hldGhlciB0aGUgUHJvbWlzZSBpcyBpbiB0aGUgcXVldWUgb2YgUHJvbWlzZXMgdG8gZXhlY3V0ZS5cbiAgICogQHByaXZhdGUge2Jvb2xlYW59XG4gICAqL1xuICB0aGlzLmV4ZWN1dGluZ18gPSBmYWxzZTtcblxuICBpZiAoQ2FuY2VsbGFibGVQcm9taXNlLlVOSEFORExFRF9SRUpFQ1RJT05fREVMQVkgPiAwKSB7XG4gICAgLyoqXG4gICAgICogQSB0aW1lb3V0IElEIHVzZWQgd2hlbiB0aGUge0Bjb2RlIFVOSEFORExFRF9SRUpFQ1RJT05fREVMQVl9IGlzIGdyZWF0ZXJcbiAgICAgKiB0aGFuIDAgbWlsbGlzZWNvbmRzLiBUaGUgSUQgaXMgc2V0IHdoZW4gdGhlIFByb21pc2UgaXMgcmVqZWN0ZWQsIGFuZFxuICAgICAqIGNsZWFyZWQgb25seSBpZiBhbiB7QGNvZGUgb25SZWplY3RlZH0gY2FsbGJhY2sgaXMgaW52b2tlZCBmb3IgdGhlXG4gICAgICogUHJvbWlzZSAob3Igb25lIG9mIGl0cyBkZXNjZW5kYW50cykgYmVmb3JlIHRoZSBkZWxheSBpcyBleGNlZWRlZC5cbiAgICAgKlxuICAgICAqIElmIHRoZSByZWplY3Rpb24gaXMgbm90IGhhbmRsZWQgYmVmb3JlIHRoZSB0aW1lb3V0IGNvbXBsZXRlcywgdGhlXG4gICAgICogcmVqZWN0aW9uIHJlYXNvbiBpcyBwYXNzZWQgdG8gdGhlIHVuaGFuZGxlZCByZWplY3Rpb24gaGFuZGxlci5cbiAgICAgKiBAcHJpdmF0ZSB7bnVtYmVyfVxuICAgICAqL1xuICAgIHRoaXMudW5oYW5kbGVkUmVqZWN0aW9uSWRfID0gMDtcbiAgfSBlbHNlIGlmIChDYW5jZWxsYWJsZVByb21pc2UuVU5IQU5ETEVEX1JFSkVDVElPTl9ERUxBWSA9PT0gMCkge1xuICAgIC8qKlxuICAgICAqIFdoZW4gdGhlIHtAY29kZSBVTkhBTkRMRURfUkVKRUNUSU9OX0RFTEFZfSBpcyBzZXQgdG8gMCBtaWxsaXNlY29uZHMsIGFcbiAgICAgKiBib29sZWFuIHRoYXQgaXMgc2V0IGlmIHRoZSBQcm9taXNlIGlzIHJlamVjdGVkLCBhbmQgcmVzZXQgdG8gZmFsc2UgaWYgYW5cbiAgICAgKiB7QGNvZGUgb25SZWplY3RlZH0gY2FsbGJhY2sgaXMgaW52b2tlZCBmb3IgdGhlIFByb21pc2UgKG9yIG9uZSBvZiBpdHNcbiAgICAgKiBkZXNjZW5kYW50cykuIElmIHRoZSByZWplY3Rpb24gaXMgbm90IGhhbmRsZWQgYmVmb3JlIHRoZSBuZXh0IHRpbWVzdGVwLFxuICAgICAqIHRoZSByZWplY3Rpb24gcmVhc29uIGlzIHBhc3NlZCB0byB0aGUgdW5oYW5kbGVkIHJlamVjdGlvbiBoYW5kbGVyLlxuICAgICAqIEBwcml2YXRlIHtib29sZWFufVxuICAgICAqL1xuICAgIHRoaXMuaGFkVW5oYW5kbGVkUmVqZWN0aW9uXyA9IGZhbHNlO1xuICB9XG5cbiAgdHJ5IHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgcmVzb2x2ZXIuY2FsbChvcHRfY29udGV4dCwgZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICBzZWxmLnJlc29sdmVfKENhbmNlbGxhYmxlUHJvbWlzZS5TdGF0ZV8uRlVMRklMTEVELCB2YWx1ZSk7XG4gICAgfSwgZnVuY3Rpb24gKHJlYXNvbikge1xuICAgICAgc2VsZi5yZXNvbHZlXyhDYW5jZWxsYWJsZVByb21pc2UuU3RhdGVfLlJFSkVDVEVELCByZWFzb24pO1xuICAgIH0pO1xuICB9IGNhdGNoIChlKSB7XG4gICAgdGhpcy5yZXNvbHZlXyhDYW5jZWxsYWJsZVByb21pc2UuU3RhdGVfLlJFSkVDVEVELCBlKTtcbiAgfVxufTtcblxuLyoqXG4gKiBUaGUgZGVsYXkgaW4gbWlsbGlzZWNvbmRzIGJlZm9yZSBhIHJlamVjdGVkIFByb21pc2UncyByZWFzb24gaXMgcGFzc2VkIHRvXG4gKiB0aGUgcmVqZWN0aW9uIGhhbmRsZXIuIEJ5IGRlZmF1bHQsIHRoZSByZWplY3Rpb24gaGFuZGxlciByZXRocm93cyB0aGVcbiAqIHJlamVjdGlvbiByZWFzb24gc28gdGhhdCBpdCBhcHBlYXJzIGluIHRoZSBkZXZlbG9wZXIgY29uc29sZSBvclxuICoge0Bjb2RlIHdpbmRvdy5vbmVycm9yfSBoYW5kbGVyLlxuICogUmVqZWN0aW9ucyBhcmUgcmV0aHJvd24gYXMgcXVpY2tseSBhcyBwb3NzaWJsZSBieSBkZWZhdWx0LiBBIG5lZ2F0aXZlIHZhbHVlXG4gKiBkaXNhYmxlcyByZWplY3Rpb24gaGFuZGxpbmcgZW50aXJlbHkuXG4gKiBAdHlwZSB7bnVtYmVyfVxuICovXG5DYW5jZWxsYWJsZVByb21pc2UuVU5IQU5ETEVEX1JFSkVDVElPTl9ERUxBWSA9IDA7XG5cbi8qKlxuICogVGhlIHBvc3NpYmxlIGludGVybmFsIHN0YXRlcyBmb3IgYSBQcm9taXNlLiBUaGVzZSBzdGF0ZXMgYXJlIG5vdCBkaXJlY3RseVxuICogb2JzZXJ2YWJsZSB0byBleHRlcm5hbCBjYWxsZXJzLlxuICogQGVudW0ge251bWJlcn1cbiAqIEBwcml2YXRlXG4gKi9cbkNhbmNlbGxhYmxlUHJvbWlzZS5TdGF0ZV8gPSB7XG4gIC8qKiBUaGUgUHJvbWlzZSBpcyB3YWl0aW5nIGZvciByZXNvbHV0aW9uLiAqL1xuICBQRU5ESU5HOiAwLFxuXG4gIC8qKiBUaGUgUHJvbWlzZSBpcyBibG9ja2VkIHdhaXRpbmcgZm9yIHRoZSByZXN1bHQgb2YgYW5vdGhlciBUaGVuYWJsZS4gKi9cbiAgQkxPQ0tFRDogMSxcblxuICAvKiogVGhlIFByb21pc2UgaGFzIGJlZW4gcmVzb2x2ZWQgd2l0aCBhIGZ1bGZpbGxtZW50IHZhbHVlLiAqL1xuICBGVUxGSUxMRUQ6IDIsXG5cbiAgLyoqIFRoZSBQcm9taXNlIGhhcyBiZWVuIHJlc29sdmVkIHdpdGggYSByZWplY3Rpb24gcmVhc29uLiAqL1xuICBSRUpFQ1RFRDogM1xufTtcblxuLyoqXG4gKiBUeXBlZGVmIGZvciBlbnRyaWVzIGluIHRoZSBjYWxsYmFjayBjaGFpbi4gRWFjaCBjYWxsIHRvIHtAY29kZSB0aGVufSxcbiAqIHtAY29kZSB0aGVuQ2F0Y2h9LCBvciB7QGNvZGUgdGhlbkFsd2F5c30gY3JlYXRlcyBhbiBlbnRyeSBjb250YWluaW5nIHRoZVxuICogZnVuY3Rpb25zIHRoYXQgbWF5IGJlIGludm9rZWQgb25jZSB0aGUgUHJvbWlzZSBpcyByZXNvbHZlZC5cbiAqXG4gKiBAdHlwZWRlZiB7e1xuICogICBjaGlsZDogQ2FuY2VsbGFibGVQcm9taXNlLFxuICogICBvbkZ1bGZpbGxlZDogZnVuY3Rpb24oKiksXG4gKiAgIG9uUmVqZWN0ZWQ6IGZ1bmN0aW9uKCopXG4gKiB9fVxuICogQHByaXZhdGVcbiAqL1xuQ2FuY2VsbGFibGVQcm9taXNlLkNhbGxiYWNrRW50cnlfID0gbnVsbDtcblxuLyoqXG4gKiBAcGFyYW0geyhUWVBFfFRoZW5hYmxlLjxUWVBFPnxUaGVuYWJsZSk9fSBvcHRfdmFsdWVcbiAqIEByZXR1cm4geyFDYW5jZWxsYWJsZVByb21pc2UuPFRZUEU+fSBBIG5ldyBQcm9taXNlIHRoYXQgaXMgaW1tZWRpYXRlbHkgcmVzb2x2ZWRcbiAqICAgICB3aXRoIHRoZSBnaXZlbiB2YWx1ZS5cbiAqIEB0ZW1wbGF0ZSBUWVBFXG4gKi9cbkNhbmNlbGxhYmxlUHJvbWlzZS5yZXNvbHZlID0gZnVuY3Rpb24gKG9wdF92YWx1ZSkge1xuICByZXR1cm4gbmV3IENhbmNlbGxhYmxlUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSkge1xuICAgIHJlc29sdmUob3B0X3ZhbHVlKTtcbiAgfSk7XG59O1xuXG4vKipcbiAqIEBwYXJhbSB7Kj19IG9wdF9yZWFzb25cbiAqIEByZXR1cm4geyFDYW5jZWxsYWJsZVByb21pc2V9IEEgbmV3IFByb21pc2UgdGhhdCBpcyBpbW1lZGlhdGVseSByZWplY3RlZCB3aXRoIHRoZVxuICogICAgIGdpdmVuIHJlYXNvbi5cbiAqL1xuQ2FuY2VsbGFibGVQcm9taXNlLnJlamVjdCA9IGZ1bmN0aW9uIChvcHRfcmVhc29uKSB7XG4gIHJldHVybiBuZXcgQ2FuY2VsbGFibGVQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICByZWplY3Qob3B0X3JlYXNvbik7XG4gIH0pO1xufTtcblxuLyoqXG4gKiBAcGFyYW0geyFBcnJheS48IShUaGVuYWJsZS48VFlQRT58VGhlbmFibGUpPn0gcHJvbWlzZXNcbiAqIEByZXR1cm4geyFDYW5jZWxsYWJsZVByb21pc2UuPFRZUEU+fSBBIFByb21pc2UgdGhhdCByZWNlaXZlcyB0aGUgcmVzdWx0IG9mIHRoZVxuICogICAgIGZpcnN0IFByb21pc2UgKG9yIFByb21pc2UtbGlrZSkgaW5wdXQgdG8gY29tcGxldGUuXG4gKiBAdGVtcGxhdGUgVFlQRVxuICovXG5DYW5jZWxsYWJsZVByb21pc2UucmFjZSA9IGZ1bmN0aW9uIChwcm9taXNlcykge1xuICByZXR1cm4gbmV3IENhbmNlbGxhYmxlUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgaWYgKCFwcm9taXNlcy5sZW5ndGgpIHtcbiAgICAgIHJlc29sdmUodW5kZWZpbmVkKTtcbiAgICB9XG4gICAgZm9yICh2YXIgaSA9IDAsIHByb21pc2U7IHByb21pc2UgPSBwcm9taXNlc1tpXTsgaSsrKSB7XG4gICAgICBwcm9taXNlLnRoZW4ocmVzb2x2ZSwgcmVqZWN0KTtcbiAgICB9XG4gIH0pO1xufTtcblxuLyoqXG4gKiBAcGFyYW0geyFBcnJheS48IShUaGVuYWJsZS48VFlQRT58VGhlbmFibGUpPn0gcHJvbWlzZXNcbiAqIEByZXR1cm4geyFDYW5jZWxsYWJsZVByb21pc2UuPCFBcnJheS48VFlQRT4+fSBBIFByb21pc2UgdGhhdCByZWNlaXZlcyBhIGxpc3Qgb2ZcbiAqICAgICBldmVyeSBmdWxmaWxsZWQgdmFsdWUgb25jZSBldmVyeSBpbnB1dCBQcm9taXNlIChvciBQcm9taXNlLWxpa2UpIGlzXG4gKiAgICAgc3VjY2Vzc2Z1bGx5IGZ1bGZpbGxlZCwgb3IgaXMgcmVqZWN0ZWQgYnkgdGhlIGZpcnN0IHJlamVjdGlvbiByZXN1bHQuXG4gKiBAdGVtcGxhdGUgVFlQRVxuICovXG5DYW5jZWxsYWJsZVByb21pc2UuYWxsID0gZnVuY3Rpb24gKHByb21pc2VzKSB7XG4gIHJldHVybiBuZXcgQ2FuY2VsbGFibGVQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICB2YXIgdG9GdWxmaWxsID0gcHJvbWlzZXMubGVuZ3RoO1xuICAgIHZhciB2YWx1ZXMgPSBbXTtcblxuICAgIGlmICghdG9GdWxmaWxsKSB7XG4gICAgICByZXNvbHZlKHZhbHVlcyk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIG9uRnVsZmlsbCA9IGZ1bmN0aW9uIG9uRnVsZmlsbChpbmRleCwgdmFsdWUpIHtcbiAgICAgIHRvRnVsZmlsbC0tO1xuICAgICAgdmFsdWVzW2luZGV4XSA9IHZhbHVlO1xuICAgICAgaWYgKHRvRnVsZmlsbCA9PT0gMCkge1xuICAgICAgICByZXNvbHZlKHZhbHVlcyk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIHZhciBvblJlamVjdCA9IGZ1bmN0aW9uIG9uUmVqZWN0KHJlYXNvbikge1xuICAgICAgcmVqZWN0KHJlYXNvbik7XG4gICAgfTtcblxuICAgIGZvciAodmFyIGkgPSAwLCBwcm9taXNlOyBwcm9taXNlID0gcHJvbWlzZXNbaV07IGkrKykge1xuICAgICAgcHJvbWlzZS50aGVuKHBhcnRpYWwob25GdWxmaWxsLCBpKSwgb25SZWplY3QpO1xuICAgIH1cbiAgfSk7XG59O1xuXG4vKipcbiAqIEBwYXJhbSB7IUFycmF5LjwhKFRoZW5hYmxlLjxUWVBFPnxUaGVuYWJsZSk+fSBwcm9taXNlc1xuICogQHJldHVybiB7IUNhbmNlbGxhYmxlUHJvbWlzZS48VFlQRT59IEEgUHJvbWlzZSB0aGF0IHJlY2VpdmVzIHRoZSB2YWx1ZSBvZlxuICogICAgIHRoZSBmaXJzdCBpbnB1dCB0byBiZSBmdWxmaWxsZWQsIG9yIGlzIHJlamVjdGVkIHdpdGggYSBsaXN0IG9mIGV2ZXJ5XG4gKiAgICAgcmVqZWN0aW9uIHJlYXNvbiBpZiBhbGwgaW5wdXRzIGFyZSByZWplY3RlZC5cbiAqIEB0ZW1wbGF0ZSBUWVBFXG4gKi9cbkNhbmNlbGxhYmxlUHJvbWlzZS5maXJzdEZ1bGZpbGxlZCA9IGZ1bmN0aW9uIChwcm9taXNlcykge1xuICByZXR1cm4gbmV3IENhbmNlbGxhYmxlUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgdmFyIHRvUmVqZWN0ID0gcHJvbWlzZXMubGVuZ3RoO1xuICAgIHZhciByZWFzb25zID0gW107XG5cbiAgICBpZiAoIXRvUmVqZWN0KSB7XG4gICAgICByZXNvbHZlKHVuZGVmaW5lZCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIG9uRnVsZmlsbCA9IGZ1bmN0aW9uIG9uRnVsZmlsbCh2YWx1ZSkge1xuICAgICAgcmVzb2x2ZSh2YWx1ZSk7XG4gICAgfTtcblxuICAgIHZhciBvblJlamVjdCA9IGZ1bmN0aW9uIG9uUmVqZWN0KGluZGV4LCByZWFzb24pIHtcbiAgICAgIHRvUmVqZWN0LS07XG4gICAgICByZWFzb25zW2luZGV4XSA9IHJlYXNvbjtcbiAgICAgIGlmICh0b1JlamVjdCA9PT0gMCkge1xuICAgICAgICByZWplY3QocmVhc29ucyk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIGZvciAodmFyIGkgPSAwLCBwcm9taXNlOyBwcm9taXNlID0gcHJvbWlzZXNbaV07IGkrKykge1xuICAgICAgcHJvbWlzZS50aGVuKG9uRnVsZmlsbCwgcGFydGlhbChvblJlamVjdCwgaSkpO1xuICAgIH1cbiAgfSk7XG59O1xuXG4vKipcbiAqIEFkZHMgY2FsbGJhY2tzIHRoYXQgd2lsbCBvcGVyYXRlIG9uIHRoZSByZXN1bHQgb2YgdGhlIFByb21pc2UsIHJldHVybmluZyBhXG4gKiBuZXcgY2hpbGQgUHJvbWlzZS5cbiAqXG4gKiBJZiB0aGUgUHJvbWlzZSBpcyBmdWxmaWxsZWQsIHRoZSB7QGNvZGUgb25GdWxmaWxsZWR9IGNhbGxiYWNrIHdpbGwgYmUgaW52b2tlZFxuICogd2l0aCB0aGUgZnVsZmlsbG1lbnQgdmFsdWUgYXMgYXJndW1lbnQsIGFuZCB0aGUgY2hpbGQgUHJvbWlzZSB3aWxsIGJlXG4gKiBmdWxmaWxsZWQgd2l0aCB0aGUgcmV0dXJuIHZhbHVlIG9mIHRoZSBjYWxsYmFjay4gSWYgdGhlIGNhbGxiYWNrIHRocm93cyBhblxuICogZXhjZXB0aW9uLCB0aGUgY2hpbGQgUHJvbWlzZSB3aWxsIGJlIHJlamVjdGVkIHdpdGggdGhlIHRocm93biB2YWx1ZSBpbnN0ZWFkLlxuICpcbiAqIElmIHRoZSBQcm9taXNlIGlzIHJlamVjdGVkLCB0aGUge0Bjb2RlIG9uUmVqZWN0ZWR9IGNhbGxiYWNrIHdpbGwgYmUgaW52b2tlZFxuICogd2l0aCB0aGUgcmVqZWN0aW9uIHJlYXNvbiBhcyBhcmd1bWVudCwgYW5kIHRoZSBjaGlsZCBQcm9taXNlIHdpbGwgYmUgcmVqZWN0ZWRcbiAqIHdpdGggdGhlIHJldHVybiB2YWx1ZSAob3IgdGhyb3duIHZhbHVlKSBvZiB0aGUgY2FsbGJhY2suXG4gKlxuICogQG92ZXJyaWRlXG4gKi9cbkNhbmNlbGxhYmxlUHJvbWlzZS5wcm90b3R5cGUudGhlbiA9IGZ1bmN0aW9uIChvcHRfb25GdWxmaWxsZWQsIG9wdF9vblJlamVjdGVkLCBvcHRfY29udGV4dCkge1xuICByZXR1cm4gdGhpcy5hZGRDaGlsZFByb21pc2VfKCgwLCBfbWV0YWwuaXNGdW5jdGlvbikob3B0X29uRnVsZmlsbGVkKSA/IG9wdF9vbkZ1bGZpbGxlZCA6IG51bGwsICgwLCBfbWV0YWwuaXNGdW5jdGlvbikob3B0X29uUmVqZWN0ZWQpID8gb3B0X29uUmVqZWN0ZWQgOiBudWxsLCBvcHRfY29udGV4dCk7XG59O1xuVGhlbmFibGUuYWRkSW1wbGVtZW50YXRpb24oQ2FuY2VsbGFibGVQcm9taXNlKTtcblxuLyoqXG4gKiBBZGRzIGEgY2FsbGJhY2sgdGhhdCB3aWxsIGJlIGludm9rZWQgd2hldGhlciB0aGUgUHJvbWlzZSBpcyBmdWxmaWxsZWQgb3JcbiAqIHJlamVjdGVkLiBUaGUgY2FsbGJhY2sgcmVjZWl2ZXMgbm8gYXJndW1lbnQsIGFuZCBubyBuZXcgY2hpbGQgUHJvbWlzZSBpc1xuICogY3JlYXRlZC4gVGhpcyBpcyB1c2VmdWwgZm9yIGVuc3VyaW5nIHRoYXQgY2xlYW51cCB0YWtlcyBwbGFjZSBhZnRlciBjZXJ0YWluXG4gKiBhc3luY2hyb25vdXMgb3BlcmF0aW9ucy4gQ2FsbGJhY2tzIGFkZGVkIHdpdGgge0Bjb2RlIHRoZW5BbHdheXN9IHdpbGwgYmVcbiAqIGV4ZWN1dGVkIGluIHRoZSBzYW1lIG9yZGVyIHdpdGggb3RoZXIgY2FsbHMgdG8ge0Bjb2RlIHRoZW59LFxuICoge0Bjb2RlIHRoZW5BbHdheXN9LCBvciB7QGNvZGUgdGhlbkNhdGNofS5cbiAqXG4gKiBTaW5jZSBpdCBkb2VzIG5vdCBwcm9kdWNlIGEgbmV3IGNoaWxkIFByb21pc2UsIGNhbmNlbGxhdGlvbiBwcm9wYWdhdGlvbiBpc1xuICogbm90IHByZXZlbnRlZCBieSBhZGRpbmcgY2FsbGJhY2tzIHdpdGgge0Bjb2RlIHRoZW5BbHdheXN9LiBBIFByb21pc2UgdGhhdCBoYXNcbiAqIGEgY2xlYW51cCBoYW5kbGVyIGFkZGVkIHdpdGgge0Bjb2RlIHRoZW5BbHdheXN9IHdpbGwgYmUgY2FuY2VsZWQgaWYgYWxsIG9mXG4gKiBpdHMgY2hpbGRyZW4gY3JlYXRlZCBieSB7QGNvZGUgdGhlbn0gKG9yIHtAY29kZSB0aGVuQ2F0Y2h9KSBhcmUgY2FuY2VsZWQuXG4gKlxuICogQHBhcmFtIHtmdW5jdGlvbih0aGlzOlRISVMpOiB2b2lkfSBvblJlc29sdmVkIEEgZnVuY3Rpb24gdGhhdCB3aWxsIGJlIGludm9rZWRcbiAqICAgICB3aGVuIHRoZSBQcm9taXNlIGlzIHJlc29sdmVkLlxuICogQHBhcmFtIHtUSElTPX0gb3B0X2NvbnRleHQgQW4gb3B0aW9uYWwgY29udGV4dCBvYmplY3QgdGhhdCB3aWxsIGJlIHRoZVxuICogICAgIGV4ZWN1dGlvbiBjb250ZXh0IGZvciB0aGUgY2FsbGJhY2tzLiBCeSBkZWZhdWx0LCBmdW5jdGlvbnMgYXJlIGV4ZWN1dGVkXG4gKiAgICAgaW4gdGhlIGdsb2JhbCBzY29wZS5cbiAqIEByZXR1cm4geyFDYW5jZWxsYWJsZVByb21pc2UuPFRZUEU+fSBUaGlzIFByb21pc2UsIGZvciBjaGFpbmluZyBhZGRpdGlvbmFsIGNhbGxzLlxuICogQHRlbXBsYXRlIFRISVNcbiAqL1xuQ2FuY2VsbGFibGVQcm9taXNlLnByb3RvdHlwZS50aGVuQWx3YXlzID0gZnVuY3Rpb24gKG9uUmVzb2x2ZWQsIG9wdF9jb250ZXh0KSB7XG4gIHZhciBjYWxsYmFjayA9IGZ1bmN0aW9uIGNhbGxiYWNrKCkge1xuICAgIHRyeSB7XG4gICAgICAvLyBFbnN1cmUgdGhhdCBubyBhcmd1bWVudHMgYXJlIHBhc3NlZCB0byBvblJlc29sdmVkLlxuICAgICAgb25SZXNvbHZlZC5jYWxsKG9wdF9jb250ZXh0KTtcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIENhbmNlbGxhYmxlUHJvbWlzZS5oYW5kbGVSZWplY3Rpb25fLmNhbGwobnVsbCwgZXJyKTtcbiAgICB9XG4gIH07XG5cbiAgdGhpcy5hZGRDYWxsYmFja0VudHJ5Xyh7XG4gICAgY2hpbGQ6IG51bGwsXG4gICAgb25SZWplY3RlZDogY2FsbGJhY2ssXG4gICAgb25GdWxmaWxsZWQ6IGNhbGxiYWNrXG4gIH0pO1xuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogQWRkcyBhIGNhbGxiYWNrIHRoYXQgd2lsbCBiZSBpbnZva2VkIG9ubHkgaWYgdGhlIFByb21pc2UgaXMgcmVqZWN0ZWQuIFRoaXNcbiAqIGlzIGVxdWl2YWxlbnQgdG8ge0Bjb2RlIHRoZW4obnVsbCwgb25SZWplY3RlZCl9LlxuICpcbiAqIEBwYXJhbSB7IWZ1bmN0aW9uKHRoaXM6VEhJUywgKik6ICp9IG9uUmVqZWN0ZWQgQSBmdW5jdGlvbiB0aGF0IHdpbGwgYmVcbiAqICAgICBpbnZva2VkIHdpdGggdGhlIHJlamVjdGlvbiByZWFzb24gaWYgdGhlIFByb21pc2UgaXMgcmVqZWN0ZWQuXG4gKiBAcGFyYW0ge1RISVM9fSBvcHRfY29udGV4dCBBbiBvcHRpb25hbCBjb250ZXh0IG9iamVjdCB0aGF0IHdpbGwgYmUgdGhlXG4gKiAgICAgZXhlY3V0aW9uIGNvbnRleHQgZm9yIHRoZSBjYWxsYmFja3MuIEJ5IGRlZmF1bHQsIGZ1bmN0aW9ucyBhcmUgZXhlY3V0ZWRcbiAqICAgICBpbiB0aGUgZ2xvYmFsIHNjb3BlLlxuICogQHJldHVybiB7IUNhbmNlbGxhYmxlUHJvbWlzZX0gQSBuZXcgUHJvbWlzZSB0aGF0IHdpbGwgcmVjZWl2ZSB0aGUgcmVzdWx0IG9mIHRoZVxuICogICAgIGNhbGxiYWNrLlxuICogQHRlbXBsYXRlIFRISVNcbiAqL1xuQ2FuY2VsbGFibGVQcm9taXNlLnByb3RvdHlwZS50aGVuQ2F0Y2ggPSBmdW5jdGlvbiAob25SZWplY3RlZCwgb3B0X2NvbnRleHQpIHtcbiAgcmV0dXJuIHRoaXMuYWRkQ2hpbGRQcm9taXNlXyhudWxsLCBvblJlamVjdGVkLCBvcHRfY29udGV4dCk7XG59O1xuXG4vKipcbiAqIEFsaWFzIG9mIHtAbGluayBDYW5jZWxsYWJsZVByb21pc2UucHJvdG90eXBlLnRoZW5DYXRjaH1cbiAqL1xuQ2FuY2VsbGFibGVQcm9taXNlLnByb3RvdHlwZS5jYXRjaCA9IENhbmNlbGxhYmxlUHJvbWlzZS5wcm90b3R5cGUudGhlbkNhdGNoO1xuXG4vKipcbiAqIENhbmNlbHMgdGhlIFByb21pc2UgaWYgaXQgaXMgc3RpbGwgcGVuZGluZyBieSByZWplY3RpbmcgaXQgd2l0aCBhIGNhbmNlbFxuICogRXJyb3IuIE5vIGFjdGlvbiBpcyBwZXJmb3JtZWQgaWYgdGhlIFByb21pc2UgaXMgYWxyZWFkeSByZXNvbHZlZC5cbiAqXG4gKiBBbGwgY2hpbGQgUHJvbWlzZXMgb2YgdGhlIGNhbmNlbGVkIFByb21pc2Ugd2lsbCBiZSByZWplY3RlZCB3aXRoIHRoZSBzYW1lXG4gKiBjYW5jZWwgZXJyb3IsIGFzIHdpdGggbm9ybWFsIFByb21pc2UgcmVqZWN0aW9uLiBJZiB0aGUgUHJvbWlzZSB0byBiZSBjYW5jZWxlZFxuICogaXMgdGhlIG9ubHkgY2hpbGQgb2YgYSBwZW5kaW5nIFByb21pc2UsIHRoZSBwYXJlbnQgUHJvbWlzZSB3aWxsIGFsc28gYmVcbiAqIGNhbmNlbGVkLiBDYW5jZWxsYXRpb24gbWF5IHByb3BhZ2F0ZSB1cHdhcmQgdGhyb3VnaCBtdWx0aXBsZSBnZW5lcmF0aW9ucy5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZz19IG9wdF9tZXNzYWdlIEFuIG9wdGlvbmFsIGRlYnVnZ2luZyBtZXNzYWdlIGZvciBkZXNjcmliaW5nIHRoZVxuICogICAgIGNhbmNlbGxhdGlvbiByZWFzb24uXG4gKi9cbkNhbmNlbGxhYmxlUHJvbWlzZS5wcm90b3R5cGUuY2FuY2VsID0gZnVuY3Rpb24gKG9wdF9tZXNzYWdlKSB7XG4gIGlmICh0aGlzLnN0YXRlXyA9PT0gQ2FuY2VsbGFibGVQcm9taXNlLlN0YXRlXy5QRU5ESU5HKSB7XG4gICAgX21ldGFsLmFzeW5jLnJ1bihmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgZXJyID0gbmV3IENhbmNlbGxhYmxlUHJvbWlzZS5DYW5jZWxsYXRpb25FcnJvcihvcHRfbWVzc2FnZSk7XG4gICAgICBlcnIuSVNfQ0FOQ0VMTEFUSU9OX0VSUk9SID0gdHJ1ZTtcbiAgICAgIHRoaXMuY2FuY2VsSW50ZXJuYWxfKGVycik7XG4gICAgfSwgdGhpcyk7XG4gIH1cbn07XG5cbi8qKlxuICogQ2FuY2VscyB0aGlzIFByb21pc2Ugd2l0aCB0aGUgZ2l2ZW4gZXJyb3IuXG4gKlxuICogQHBhcmFtIHshRXJyb3J9IGVyciBUaGUgY2FuY2VsbGF0aW9uIGVycm9yLlxuICogQHByaXZhdGVcbiAqL1xuQ2FuY2VsbGFibGVQcm9taXNlLnByb3RvdHlwZS5jYW5jZWxJbnRlcm5hbF8gPSBmdW5jdGlvbiAoZXJyKSB7XG4gIGlmICh0aGlzLnN0YXRlXyA9PT0gQ2FuY2VsbGFibGVQcm9taXNlLlN0YXRlXy5QRU5ESU5HKSB7XG4gICAgaWYgKHRoaXMucGFyZW50Xykge1xuICAgICAgLy8gQ2FuY2VsIHRoZSBQcm9taXNlIGFuZCByZW1vdmUgaXQgZnJvbSB0aGUgcGFyZW50J3MgY2hpbGQgbGlzdC5cbiAgICAgIHRoaXMucGFyZW50Xy5jYW5jZWxDaGlsZF8odGhpcywgZXJyKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5yZXNvbHZlXyhDYW5jZWxsYWJsZVByb21pc2UuU3RhdGVfLlJFSkVDVEVELCBlcnIpO1xuICAgIH1cbiAgfVxufTtcblxuLyoqXG4gKiBDYW5jZWxzIGEgY2hpbGQgUHJvbWlzZSBmcm9tIHRoZSBsaXN0IG9mIGNhbGxiYWNrIGVudHJpZXMuIElmIHRoZSBQcm9taXNlIGhhc1xuICogbm90IGFscmVhZHkgYmVlbiByZXNvbHZlZCwgcmVqZWN0IGl0IHdpdGggYSBjYW5jZWwgZXJyb3IuIElmIHRoZXJlIGFyZSBub1xuICogb3RoZXIgY2hpbGRyZW4gaW4gdGhlIGxpc3Qgb2YgY2FsbGJhY2sgZW50cmllcywgcHJvcGFnYXRlIHRoZSBjYW5jZWxsYXRpb25cbiAqIGJ5IGNhbmNlbGluZyB0aGlzIFByb21pc2UgYXMgd2VsbC5cbiAqXG4gKiBAcGFyYW0geyFDYW5jZWxsYWJsZVByb21pc2V9IGNoaWxkUHJvbWlzZSBUaGUgUHJvbWlzZSB0byBjYW5jZWwuXG4gKiBAcGFyYW0geyFFcnJvcn0gZXJyIFRoZSBjYW5jZWwgZXJyb3IgdG8gdXNlIGZvciByZWplY3RpbmcgdGhlIFByb21pc2UuXG4gKiBAcHJpdmF0ZVxuICovXG5DYW5jZWxsYWJsZVByb21pc2UucHJvdG90eXBlLmNhbmNlbENoaWxkXyA9IGZ1bmN0aW9uIChjaGlsZFByb21pc2UsIGVycikge1xuICBpZiAoIXRoaXMuY2FsbGJhY2tFbnRyaWVzXykge1xuICAgIHJldHVybjtcbiAgfVxuICB2YXIgY2hpbGRDb3VudCA9IDA7XG4gIHZhciBjaGlsZEluZGV4ID0gLTE7XG5cbiAgLy8gRmluZCB0aGUgY2FsbGJhY2sgZW50cnkgZm9yIHRoZSBjaGlsZFByb21pc2UsIGFuZCBjb3VudCB3aGV0aGVyIHRoZXJlIGFyZVxuICAvLyBhZGRpdGlvbmFsIGNoaWxkIFByb21pc2VzLlxuICBmb3IgKHZhciBpID0gMCwgZW50cnk7IGVudHJ5ID0gdGhpcy5jYWxsYmFja0VudHJpZXNfW2ldOyBpKyspIHtcbiAgICB2YXIgY2hpbGQgPSBlbnRyeS5jaGlsZDtcbiAgICBpZiAoY2hpbGQpIHtcbiAgICAgIGNoaWxkQ291bnQrKztcbiAgICAgIGlmIChjaGlsZCA9PT0gY2hpbGRQcm9taXNlKSB7XG4gICAgICAgIGNoaWxkSW5kZXggPSBpO1xuICAgICAgfVxuICAgICAgaWYgKGNoaWxkSW5kZXggPj0gMCAmJiBjaGlsZENvdW50ID4gMSkge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvLyBJZiB0aGUgY2hpbGQgUHJvbWlzZSB3YXMgdGhlIG9ubHkgY2hpbGQsIGNhbmNlbCB0aGlzIFByb21pc2UgYXMgd2VsbC5cbiAgLy8gT3RoZXJ3aXNlLCByZWplY3Qgb25seSB0aGUgY2hpbGQgUHJvbWlzZSB3aXRoIHRoZSBjYW5jZWwgZXJyb3IuXG4gIGlmIChjaGlsZEluZGV4ID49IDApIHtcbiAgICBpZiAodGhpcy5zdGF0ZV8gPT09IENhbmNlbGxhYmxlUHJvbWlzZS5TdGF0ZV8uUEVORElORyAmJiBjaGlsZENvdW50ID09PSAxKSB7XG4gICAgICB0aGlzLmNhbmNlbEludGVybmFsXyhlcnIpO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgY2FsbGJhY2tFbnRyeSA9IHRoaXMuY2FsbGJhY2tFbnRyaWVzXy5zcGxpY2UoY2hpbGRJbmRleCwgMSlbMF07XG4gICAgICB0aGlzLmV4ZWN1dGVDYWxsYmFja18oY2FsbGJhY2tFbnRyeSwgQ2FuY2VsbGFibGVQcm9taXNlLlN0YXRlXy5SRUpFQ1RFRCwgZXJyKTtcbiAgICB9XG4gIH1cbn07XG5cbi8qKlxuICogQWRkcyBhIGNhbGxiYWNrIGVudHJ5IHRvIHRoZSBjdXJyZW50IFByb21pc2UsIGFuZCBzY2hlZHVsZXMgY2FsbGJhY2tcbiAqIGV4ZWN1dGlvbiBpZiB0aGUgUHJvbWlzZSBoYXMgYWxyZWFkeSBiZWVuIHJlc29sdmVkLlxuICpcbiAqIEBwYXJhbSB7Q2FuY2VsbGFibGVQcm9taXNlLkNhbGxiYWNrRW50cnlffSBjYWxsYmFja0VudHJ5IFJlY29yZCBjb250YWluaW5nXG4gKiAgICAge0Bjb2RlIG9uRnVsZmlsbGVkfSBhbmQge0Bjb2RlIG9uUmVqZWN0ZWR9IGNhbGxiYWNrcyB0byBleGVjdXRlIGFmdGVyXG4gKiAgICAgdGhlIFByb21pc2UgaXMgcmVzb2x2ZWQuXG4gKiBAcHJpdmF0ZVxuICovXG5DYW5jZWxsYWJsZVByb21pc2UucHJvdG90eXBlLmFkZENhbGxiYWNrRW50cnlfID0gZnVuY3Rpb24gKGNhbGxiYWNrRW50cnkpIHtcbiAgaWYgKCghdGhpcy5jYWxsYmFja0VudHJpZXNfIHx8ICF0aGlzLmNhbGxiYWNrRW50cmllc18ubGVuZ3RoKSAmJiAodGhpcy5zdGF0ZV8gPT09IENhbmNlbGxhYmxlUHJvbWlzZS5TdGF0ZV8uRlVMRklMTEVEIHx8IHRoaXMuc3RhdGVfID09PSBDYW5jZWxsYWJsZVByb21pc2UuU3RhdGVfLlJFSkVDVEVEKSkge1xuICAgIHRoaXMuc2NoZWR1bGVDYWxsYmFja3NfKCk7XG4gIH1cbiAgaWYgKCF0aGlzLmNhbGxiYWNrRW50cmllc18pIHtcbiAgICB0aGlzLmNhbGxiYWNrRW50cmllc18gPSBbXTtcbiAgfVxuICB0aGlzLmNhbGxiYWNrRW50cmllc18ucHVzaChjYWxsYmFja0VudHJ5KTtcbn07XG5cbi8qKlxuICogQ3JlYXRlcyBhIGNoaWxkIFByb21pc2UgYW5kIGFkZHMgaXQgdG8gdGhlIGNhbGxiYWNrIGVudHJ5IGxpc3QuIFRoZSByZXN1bHQgb2ZcbiAqIHRoZSBjaGlsZCBQcm9taXNlIGlzIGRldGVybWluZWQgYnkgdGhlIHN0YXRlIG9mIHRoZSBwYXJlbnQgUHJvbWlzZSBhbmQgdGhlXG4gKiByZXN1bHQgb2YgdGhlIHtAY29kZSBvbkZ1bGZpbGxlZH0gb3Ige0Bjb2RlIG9uUmVqZWN0ZWR9IGNhbGxiYWNrcyBhc1xuICogc3BlY2lmaWVkIGluIHRoZSBQcm9taXNlIHJlc29sdXRpb24gcHJvY2VkdXJlLlxuICpcbiAqIEBzZWUgaHR0cDovL3Byb21pc2VzYXBsdXMuY29tLyN0aGVfX21ldGhvZFxuICpcbiAqIEBwYXJhbSB7P2Z1bmN0aW9uKHRoaXM6VEhJUywgVFlQRSk6XG4gKiAgICAgICAgICAoUkVTVUxUfENhbmNlbGxhYmxlUHJvbWlzZS48UkVTVUxUPnxUaGVuYWJsZSl9IG9uRnVsZmlsbGVkIEEgY2FsbGJhY2sgdGhhdFxuICogICAgIHdpbGwgYmUgaW52b2tlZCBpZiB0aGUgUHJvbWlzZSBpcyBmdWxsZmlsbGVkLCBvciBudWxsLlxuICogQHBhcmFtIHs/ZnVuY3Rpb24odGhpczpUSElTLCAqKTogKn0gb25SZWplY3RlZCBBIGNhbGxiYWNrIHRoYXQgd2lsbCBiZVxuICogICAgIGludm9rZWQgaWYgdGhlIFByb21pc2UgaXMgcmVqZWN0ZWQsIG9yIG51bGwuXG4gKiBAcGFyYW0ge1RISVM9fSBvcHRfY29udGV4dCBBbiBvcHRpb25hbCBleGVjdXRpb24gY29udGV4dCBmb3IgdGhlIGNhbGxiYWNrcy5cbiAqICAgICBpbiB0aGUgZGVmYXVsdCBjYWxsaW5nIGNvbnRleHQuXG4gKiBAcmV0dXJuIHshQ2FuY2VsbGFibGVQcm9taXNlfSBUaGUgY2hpbGQgUHJvbWlzZS5cbiAqIEB0ZW1wbGF0ZSBSRVNVTFQsVEhJU1xuICogQHByaXZhdGVcbiAqL1xuQ2FuY2VsbGFibGVQcm9taXNlLnByb3RvdHlwZS5hZGRDaGlsZFByb21pc2VfID0gZnVuY3Rpb24gKG9uRnVsZmlsbGVkLCBvblJlamVjdGVkLCBvcHRfY29udGV4dCkge1xuXG4gIHZhciBjYWxsYmFja0VudHJ5ID0ge1xuICAgIGNoaWxkOiBudWxsLFxuICAgIG9uRnVsZmlsbGVkOiBudWxsLFxuICAgIG9uUmVqZWN0ZWQ6IG51bGxcbiAgfTtcblxuICBjYWxsYmFja0VudHJ5LmNoaWxkID0gbmV3IENhbmNlbGxhYmxlUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgLy8gSW52b2tlIG9uRnVsZmlsbGVkLCBvciByZXNvbHZlIHdpdGggdGhlIHBhcmVudCdzIHZhbHVlIGlmIGFic2VudC5cbiAgICBjYWxsYmFja0VudHJ5Lm9uRnVsZmlsbGVkID0gb25GdWxmaWxsZWQgPyBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHZhciByZXN1bHQgPSBvbkZ1bGZpbGxlZC5jYWxsKG9wdF9jb250ZXh0LCB2YWx1ZSk7XG4gICAgICAgIHJlc29sdmUocmVzdWx0KTtcbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICByZWplY3QoZXJyKTtcbiAgICAgIH1cbiAgICB9IDogcmVzb2x2ZTtcblxuICAgIC8vIEludm9rZSBvblJlamVjdGVkLCBvciByZWplY3Qgd2l0aCB0aGUgcGFyZW50J3MgcmVhc29uIGlmIGFic2VudC5cbiAgICBjYWxsYmFja0VudHJ5Lm9uUmVqZWN0ZWQgPSBvblJlamVjdGVkID8gZnVuY3Rpb24gKHJlYXNvbikge1xuICAgICAgdHJ5IHtcbiAgICAgICAgdmFyIHJlc3VsdCA9IG9uUmVqZWN0ZWQuY2FsbChvcHRfY29udGV4dCwgcmVhc29uKTtcbiAgICAgICAgaWYgKCEoMCwgX21ldGFsLmlzRGVmKShyZXN1bHQpICYmIHJlYXNvbi5JU19DQU5DRUxMQVRJT05fRVJST1IpIHtcbiAgICAgICAgICAvLyBQcm9wYWdhdGUgY2FuY2VsbGF0aW9uIHRvIGNoaWxkcmVuIGlmIG5vIG90aGVyIHJlc3VsdCBpcyByZXR1cm5lZC5cbiAgICAgICAgICByZWplY3QocmVhc29uKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXNvbHZlKHJlc3VsdCk7XG4gICAgICAgIH1cbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICByZWplY3QoZXJyKTtcbiAgICAgIH1cbiAgICB9IDogcmVqZWN0O1xuICB9KTtcblxuICBjYWxsYmFja0VudHJ5LmNoaWxkLnBhcmVudF8gPSB0aGlzO1xuICB0aGlzLmFkZENhbGxiYWNrRW50cnlfKFxuICAvKiogQHR5cGUge0NhbmNlbGxhYmxlUHJvbWlzZS5DYWxsYmFja0VudHJ5X30gKi9jYWxsYmFja0VudHJ5KTtcbiAgcmV0dXJuIGNhbGxiYWNrRW50cnkuY2hpbGQ7XG59O1xuXG4vKipcbiAqIFVuYmxvY2tzIHRoZSBQcm9taXNlIGFuZCBmdWxmaWxscyBpdCB3aXRoIHRoZSBnaXZlbiB2YWx1ZS5cbiAqXG4gKiBAcGFyYW0ge1RZUEV9IHZhbHVlXG4gKiBAcHJpdmF0ZVxuICovXG5DYW5jZWxsYWJsZVByb21pc2UucHJvdG90eXBlLnVuYmxvY2tBbmRGdWxmaWxsXyA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICBpZiAodGhpcy5zdGF0ZV8gIT09IENhbmNlbGxhYmxlUHJvbWlzZS5TdGF0ZV8uQkxPQ0tFRCkge1xuICAgIHRocm93IG5ldyBFcnJvcignQ2FuY2VsbGFibGVQcm9taXNlIGlzIG5vdCBibG9ja2VkLicpO1xuICB9XG4gIHRoaXMuc3RhdGVfID0gQ2FuY2VsbGFibGVQcm9taXNlLlN0YXRlXy5QRU5ESU5HO1xuICB0aGlzLnJlc29sdmVfKENhbmNlbGxhYmxlUHJvbWlzZS5TdGF0ZV8uRlVMRklMTEVELCB2YWx1ZSk7XG59O1xuXG4vKipcbiAqIFVuYmxvY2tzIHRoZSBQcm9taXNlIGFuZCByZWplY3RzIGl0IHdpdGggdGhlIGdpdmVuIHJlamVjdGlvbiByZWFzb24uXG4gKlxuICogQHBhcmFtIHsqfSByZWFzb25cbiAqIEBwcml2YXRlXG4gKi9cbkNhbmNlbGxhYmxlUHJvbWlzZS5wcm90b3R5cGUudW5ibG9ja0FuZFJlamVjdF8gPSBmdW5jdGlvbiAocmVhc29uKSB7XG4gIGlmICh0aGlzLnN0YXRlXyAhPT0gQ2FuY2VsbGFibGVQcm9taXNlLlN0YXRlXy5CTE9DS0VEKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdDYW5jZWxsYWJsZVByb21pc2UgaXMgbm90IGJsb2NrZWQuJyk7XG4gIH1cbiAgdGhpcy5zdGF0ZV8gPSBDYW5jZWxsYWJsZVByb21pc2UuU3RhdGVfLlBFTkRJTkc7XG4gIHRoaXMucmVzb2x2ZV8oQ2FuY2VsbGFibGVQcm9taXNlLlN0YXRlXy5SRUpFQ1RFRCwgcmVhc29uKTtcbn07XG5cbi8qKlxuICogQXR0ZW1wdHMgdG8gcmVzb2x2ZSBhIFByb21pc2Ugd2l0aCBhIGdpdmVuIHJlc29sdXRpb24gc3RhdGUgYW5kIHZhbHVlLiBUaGlzXG4gKiBpcyBhIG5vLW9wIGlmIHRoZSBnaXZlbiBQcm9taXNlIGhhcyBhbHJlYWR5IGJlZW4gcmVzb2x2ZWQuXG4gKlxuICogSWYgdGhlIGdpdmVuIHJlc3VsdCBpcyBhIFRoZW5hYmxlIChzdWNoIGFzIGFub3RoZXIgUHJvbWlzZSksIHRoZSBQcm9taXNlIHdpbGxcbiAqIGJlIHJlc29sdmVkIHdpdGggdGhlIHNhbWUgc3RhdGUgYW5kIHJlc3VsdCBhcyB0aGUgVGhlbmFibGUgb25jZSBpdCBpcyBpdHNlbGZcbiAqIHJlc29sdmVkLlxuICpcbiAqIElmIHRoZSBnaXZlbiByZXN1bHQgaXMgbm90IGEgVGhlbmFibGUsIHRoZSBQcm9taXNlIHdpbGwgYmUgZnVsZmlsbGVkIG9yXG4gKiByZWplY3RlZCB3aXRoIHRoYXQgcmVzdWx0IGJhc2VkIG9uIHRoZSBnaXZlbiBzdGF0ZS5cbiAqXG4gKiBAc2VlIGh0dHA6Ly9wcm9taXNlc2FwbHVzLmNvbS8jdGhlX3Byb21pc2VfcmVzb2x1dGlvbl9wcm9jZWR1cmVcbiAqXG4gKiBAcGFyYW0ge0NhbmNlbGxhYmxlUHJvbWlzZS5TdGF0ZV99IHN0YXRlXG4gKiBAcGFyYW0geyp9IHggVGhlIHJlc3VsdCB0byBhcHBseSB0byB0aGUgUHJvbWlzZS5cbiAqIEBwcml2YXRlXG4gKi9cbkNhbmNlbGxhYmxlUHJvbWlzZS5wcm90b3R5cGUucmVzb2x2ZV8gPSBmdW5jdGlvbiAoc3RhdGUsIHgpIHtcbiAgaWYgKHRoaXMuc3RhdGVfICE9PSBDYW5jZWxsYWJsZVByb21pc2UuU3RhdGVfLlBFTkRJTkcpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICBpZiAodGhpcyA9PT0geCkge1xuICAgIHN0YXRlID0gQ2FuY2VsbGFibGVQcm9taXNlLlN0YXRlXy5SRUpFQ1RFRDtcbiAgICB4ID0gbmV3IFR5cGVFcnJvcignQ2FuY2VsbGFibGVQcm9taXNlIGNhbm5vdCByZXNvbHZlIHRvIGl0c2VsZicpO1xuICB9IGVsc2UgaWYgKFRoZW5hYmxlLmlzSW1wbGVtZW50ZWRCeSh4KSkge1xuICAgIHggPSAvKiogQHR5cGUgeyFUaGVuYWJsZX0gKi94O1xuICAgIHRoaXMuc3RhdGVfID0gQ2FuY2VsbGFibGVQcm9taXNlLlN0YXRlXy5CTE9DS0VEO1xuICAgIHgudGhlbih0aGlzLnVuYmxvY2tBbmRGdWxmaWxsXywgdGhpcy51bmJsb2NrQW5kUmVqZWN0XywgdGhpcyk7XG4gICAgcmV0dXJuO1xuICB9IGVsc2UgaWYgKCgwLCBfbWV0YWwuaXNPYmplY3QpKHgpKSB7XG4gICAgdHJ5IHtcbiAgICAgIHZhciB0aGVuID0geC50aGVuO1xuICAgICAgaWYgKCgwLCBfbWV0YWwuaXNGdW5jdGlvbikodGhlbikpIHtcbiAgICAgICAgdGhpcy50cnlUaGVuXyh4LCB0aGVuKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIHN0YXRlID0gQ2FuY2VsbGFibGVQcm9taXNlLlN0YXRlXy5SRUpFQ1RFRDtcbiAgICAgIHggPSBlO1xuICAgIH1cbiAgfVxuXG4gIHRoaXMucmVzdWx0XyA9IHg7XG4gIHRoaXMuc3RhdGVfID0gc3RhdGU7XG4gIHRoaXMuc2NoZWR1bGVDYWxsYmFja3NfKCk7XG5cbiAgaWYgKHN0YXRlID09PSBDYW5jZWxsYWJsZVByb21pc2UuU3RhdGVfLlJFSkVDVEVEICYmICF4LklTX0NBTkNFTExBVElPTl9FUlJPUikge1xuICAgIENhbmNlbGxhYmxlUHJvbWlzZS5hZGRVbmhhbmRsZWRSZWplY3Rpb25fKHRoaXMsIHgpO1xuICB9XG59O1xuXG4vKipcbiAqIEF0dGVtcHRzIHRvIGNhbGwgdGhlIHtAY29kZSB0aGVufSBtZXRob2Qgb24gYW4gb2JqZWN0IGluIHRoZSBob3BlcyB0aGF0IGl0IGlzXG4gKiBhIFByb21pc2UtY29tcGF0aWJsZSBpbnN0YW5jZS4gVGhpcyBhbGxvd3MgaW50ZXJvcGVyYXRpb24gYmV0d2VlbiBkaWZmZXJlbnRcbiAqIFByb21pc2UgaW1wbGVtZW50YXRpb25zLCBob3dldmVyIGEgbm9uLWNvbXBsaWFudCBvYmplY3QgbWF5IGNhdXNlIGEgUHJvbWlzZVxuICogdG8gaGFuZyBpbmRlZmluaXRlbHkuIElmIHRoZSB7QGNvZGUgdGhlbn0gbWV0aG9kIHRocm93cyBhbiBleGNlcHRpb24sIHRoZVxuICogZGVwZW5kZW50IFByb21pc2Ugd2lsbCBiZSByZWplY3RlZCB3aXRoIHRoZSB0aHJvd24gdmFsdWUuXG4gKlxuICogQHNlZSBodHRwOi8vcHJvbWlzZXNhcGx1cy5jb20vI3BvaW50LTcwXG4gKlxuICogQHBhcmFtIHtUaGVuYWJsZX0gdGhlbmFibGUgQW4gb2JqZWN0IHdpdGggYSB7QGNvZGUgdGhlbn0gbWV0aG9kIHRoYXQgbWF5IGJlXG4gKiAgICAgY29tcGF0aWJsZSB3aXRoIHRoZSBQcm9taXNlL0ErIHNwZWNpZmljYXRpb24uXG4gKiBAcGFyYW0geyFGdW5jdGlvbn0gdGhlbiBUaGUge0Bjb2RlIHRoZW59IG1ldGhvZCBvZiB0aGUgVGhlbmFibGUgb2JqZWN0LlxuICogQHByaXZhdGVcbiAqL1xuQ2FuY2VsbGFibGVQcm9taXNlLnByb3RvdHlwZS50cnlUaGVuXyA9IGZ1bmN0aW9uICh0aGVuYWJsZSwgdGhlbikge1xuICB0aGlzLnN0YXRlXyA9IENhbmNlbGxhYmxlUHJvbWlzZS5TdGF0ZV8uQkxPQ0tFRDtcbiAgdmFyIHByb21pc2UgPSB0aGlzO1xuICB2YXIgY2FsbGVkID0gZmFsc2U7XG5cbiAgdmFyIHJlc29sdmUgPSBmdW5jdGlvbiByZXNvbHZlKHZhbHVlKSB7XG4gICAgaWYgKCFjYWxsZWQpIHtcbiAgICAgIGNhbGxlZCA9IHRydWU7XG4gICAgICBwcm9taXNlLnVuYmxvY2tBbmRGdWxmaWxsXyh2YWx1ZSk7XG4gICAgfVxuICB9O1xuXG4gIHZhciByZWplY3QgPSBmdW5jdGlvbiByZWplY3QocmVhc29uKSB7XG4gICAgaWYgKCFjYWxsZWQpIHtcbiAgICAgIGNhbGxlZCA9IHRydWU7XG4gICAgICBwcm9taXNlLnVuYmxvY2tBbmRSZWplY3RfKHJlYXNvbik7XG4gICAgfVxuICB9O1xuXG4gIHRyeSB7XG4gICAgdGhlbi5jYWxsKHRoZW5hYmxlLCByZXNvbHZlLCByZWplY3QpO1xuICB9IGNhdGNoIChlKSB7XG4gICAgcmVqZWN0KGUpO1xuICB9XG59O1xuXG4vKipcbiAqIEV4ZWN1dGVzIHRoZSBwZW5kaW5nIGNhbGxiYWNrcyBvZiBhIHJlc29sdmVkIFByb21pc2UgYWZ0ZXIgYSB0aW1lb3V0LlxuICpcbiAqIFNlY3Rpb24gMi4yLjQgb2YgdGhlIFByb21pc2VzL0ErIHNwZWNpZmljYXRpb24gcmVxdWlyZXMgdGhhdCBQcm9taXNlXG4gKiBjYWxsYmFja3MgbXVzdCBvbmx5IGJlIGludm9rZWQgZnJvbSBhIGNhbGwgc3RhY2sgdGhhdCBvbmx5IGNvbnRhaW5zIFByb21pc2VcbiAqIGltcGxlbWVudGF0aW9uIGNvZGUsIHdoaWNoIHdlIGFjY29tcGxpc2ggYnkgaW52b2tpbmcgY2FsbGJhY2sgZXhlY3V0aW9uIGFmdGVyXG4gKiBhIHRpbWVvdXQuIElmIHtAY29kZSBzdGFydEV4ZWN1dGlvbl99IGlzIGNhbGxlZCBtdWx0aXBsZSB0aW1lcyBmb3IgdGhlIHNhbWVcbiAqIFByb21pc2UsIHRoZSBjYWxsYmFjayBjaGFpbiB3aWxsIGJlIGV2YWx1YXRlZCBvbmx5IG9uY2UuIEFkZGl0aW9uYWwgY2FsbGJhY2tzXG4gKiBtYXkgYmUgYWRkZWQgZHVyaW5nIHRoZSBldmFsdWF0aW9uIHBoYXNlLCBhbmQgd2lsbCBiZSBleGVjdXRlZCBpbiB0aGUgc2FtZVxuICogZXZlbnQgbG9vcC5cbiAqXG4gKiBBbGwgUHJvbWlzZXMgYWRkZWQgdG8gdGhlIHdhaXRpbmcgbGlzdCBkdXJpbmcgdGhlIHNhbWUgYnJvd3NlciBldmVudCBsb29wXG4gKiB3aWxsIGJlIGV4ZWN1dGVkIGluIG9uZSBiYXRjaCB0byBhdm9pZCB1c2luZyBhIHNlcGFyYXRlIHRpbWVvdXQgcGVyIFByb21pc2UuXG4gKlxuICogQHByaXZhdGVcbiAqL1xuQ2FuY2VsbGFibGVQcm9taXNlLnByb3RvdHlwZS5zY2hlZHVsZUNhbGxiYWNrc18gPSBmdW5jdGlvbiAoKSB7XG4gIGlmICghdGhpcy5leGVjdXRpbmdfKSB7XG4gICAgdGhpcy5leGVjdXRpbmdfID0gdHJ1ZTtcbiAgICBfbWV0YWwuYXN5bmMucnVuKHRoaXMuZXhlY3V0ZUNhbGxiYWNrc18sIHRoaXMpO1xuICB9XG59O1xuXG4vKipcbiAqIEV4ZWN1dGVzIGFsbCBwZW5kaW5nIGNhbGxiYWNrcyBmb3IgdGhpcyBQcm9taXNlLlxuICpcbiAqIEBwcml2YXRlXG4gKi9cbkNhbmNlbGxhYmxlUHJvbWlzZS5wcm90b3R5cGUuZXhlY3V0ZUNhbGxiYWNrc18gPSBmdW5jdGlvbiAoKSB7XG4gIHdoaWxlICh0aGlzLmNhbGxiYWNrRW50cmllc18gJiYgdGhpcy5jYWxsYmFja0VudHJpZXNfLmxlbmd0aCkge1xuICAgIHZhciBlbnRyaWVzID0gdGhpcy5jYWxsYmFja0VudHJpZXNfO1xuICAgIHRoaXMuY2FsbGJhY2tFbnRyaWVzXyA9IFtdO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBlbnRyaWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB0aGlzLmV4ZWN1dGVDYWxsYmFja18oZW50cmllc1tpXSwgdGhpcy5zdGF0ZV8sIHRoaXMucmVzdWx0Xyk7XG4gICAgfVxuICB9XG4gIHRoaXMuZXhlY3V0aW5nXyA9IGZhbHNlO1xufTtcblxuLyoqXG4gKiBFeGVjdXRlcyBhIHBlbmRpbmcgY2FsbGJhY2sgZm9yIHRoaXMgUHJvbWlzZS4gSW52b2tlcyBhbiB7QGNvZGUgb25GdWxmaWxsZWR9XG4gKiBvciB7QGNvZGUgb25SZWplY3RlZH0gY2FsbGJhY2sgYmFzZWQgb24gdGhlIHJlc29sdmVkIHN0YXRlIG9mIHRoZSBQcm9taXNlLlxuICpcbiAqIEBwYXJhbSB7IUNhbmNlbGxhYmxlUHJvbWlzZS5DYWxsYmFja0VudHJ5X30gY2FsbGJhY2tFbnRyeSBBbiBlbnRyeSBjb250YWluaW5nIHRoZVxuICogICAgIG9uRnVsZmlsbGVkIGFuZC9vciBvblJlamVjdGVkIGNhbGxiYWNrcyBmb3IgdGhpcyBzdGVwLlxuICogQHBhcmFtIHtDYW5jZWxsYWJsZVByb21pc2UuU3RhdGVffSBzdGF0ZSBUaGUgcmVzb2x1dGlvbiBzdGF0dXMgb2YgdGhlIFByb21pc2UsXG4gKiAgICAgZWl0aGVyIEZVTEZJTExFRCBvciBSRUpFQ1RFRC5cbiAqIEBwYXJhbSB7Kn0gcmVzdWx0IFRoZSByZXNvbHZlZCByZXN1bHQgb2YgdGhlIFByb21pc2UuXG4gKiBAcHJpdmF0ZVxuICovXG5DYW5jZWxsYWJsZVByb21pc2UucHJvdG90eXBlLmV4ZWN1dGVDYWxsYmFja18gPSBmdW5jdGlvbiAoY2FsbGJhY2tFbnRyeSwgc3RhdGUsIHJlc3VsdCkge1xuICBpZiAoc3RhdGUgPT09IENhbmNlbGxhYmxlUHJvbWlzZS5TdGF0ZV8uRlVMRklMTEVEKSB7XG4gICAgY2FsbGJhY2tFbnRyeS5vbkZ1bGZpbGxlZChyZXN1bHQpO1xuICB9IGVsc2Uge1xuICAgIHRoaXMucmVtb3ZlVW5oYW5kbGVkUmVqZWN0aW9uXygpO1xuICAgIGNhbGxiYWNrRW50cnkub25SZWplY3RlZChyZXN1bHQpO1xuICB9XG59O1xuXG4vKipcbiAqIE1hcmtzIHRoaXMgcmVqZWN0ZWQgUHJvbWlzZSBhcyBoYXZpbmcgYmVpbmcgaGFuZGxlZC4gQWxzbyBtYXJrcyBhbnkgcGFyZW50XG4gKiBQcm9taXNlcyBpbiB0aGUgcmVqZWN0ZWQgc3RhdGUgYXMgaGFuZGxlZC4gVGhlIHJlamVjdGlvbiBoYW5kbGVyIHdpbGwgbm9cbiAqIGxvbmdlciBiZSBpbnZva2VkIGZvciB0aGlzIFByb21pc2UgKGlmIGl0IGhhcyBub3QgYmVlbiBjYWxsZWQgYWxyZWFkeSkuXG4gKlxuICogQHByaXZhdGVcbiAqL1xuQ2FuY2VsbGFibGVQcm9taXNlLnByb3RvdHlwZS5yZW1vdmVVbmhhbmRsZWRSZWplY3Rpb25fID0gZnVuY3Rpb24gKCkge1xuICB2YXIgcDtcbiAgaWYgKENhbmNlbGxhYmxlUHJvbWlzZS5VTkhBTkRMRURfUkVKRUNUSU9OX0RFTEFZID4gMCkge1xuICAgIGZvciAocCA9IHRoaXM7IHAgJiYgcC51bmhhbmRsZWRSZWplY3Rpb25JZF87IHAgPSBwLnBhcmVudF8pIHtcbiAgICAgIGNsZWFyVGltZW91dChwLnVuaGFuZGxlZFJlamVjdGlvbklkXyk7XG4gICAgICBwLnVuaGFuZGxlZFJlamVjdGlvbklkXyA9IDA7XG4gICAgfVxuICB9IGVsc2UgaWYgKENhbmNlbGxhYmxlUHJvbWlzZS5VTkhBTkRMRURfUkVKRUNUSU9OX0RFTEFZID09PSAwKSB7XG4gICAgZm9yIChwID0gdGhpczsgcCAmJiBwLmhhZFVuaGFuZGxlZFJlamVjdGlvbl87IHAgPSBwLnBhcmVudF8pIHtcbiAgICAgIHAuaGFkVW5oYW5kbGVkUmVqZWN0aW9uXyA9IGZhbHNlO1xuICAgIH1cbiAgfVxufTtcblxuLyoqXG4gKiBNYXJrcyB0aGlzIHJlamVjdGVkIFByb21pc2UgYXMgdW5oYW5kbGVkLiBJZiBubyB7QGNvZGUgb25SZWplY3RlZH0gY2FsbGJhY2tcbiAqIGlzIGNhbGxlZCBmb3IgdGhpcyBQcm9taXNlIGJlZm9yZSB0aGUge0Bjb2RlIFVOSEFORExFRF9SRUpFQ1RJT05fREVMQVl9XG4gKiBleHBpcmVzLCB0aGUgcmVhc29uIHdpbGwgYmUgcGFzc2VkIHRvIHRoZSB1bmhhbmRsZWQgcmVqZWN0aW9uIGhhbmRsZXIuIFRoZVxuICogaGFuZGxlciB0eXBpY2FsbHkgcmV0aHJvd3MgdGhlIHJlamVjdGlvbiByZWFzb24gc28gdGhhdCBpdCBiZWNvbWVzIHZpc2libGUgaW5cbiAqIHRoZSBkZXZlbG9wZXIgY29uc29sZS5cbiAqXG4gKiBAcGFyYW0geyFDYW5jZWxsYWJsZVByb21pc2V9IHByb21pc2UgVGhlIHJlamVjdGVkIFByb21pc2UuXG4gKiBAcGFyYW0geyp9IHJlYXNvbiBUaGUgUHJvbWlzZSByZWplY3Rpb24gcmVhc29uLlxuICogQHByaXZhdGVcbiAqL1xuQ2FuY2VsbGFibGVQcm9taXNlLmFkZFVuaGFuZGxlZFJlamVjdGlvbl8gPSBmdW5jdGlvbiAocHJvbWlzZSwgcmVhc29uKSB7XG4gIGlmIChDYW5jZWxsYWJsZVByb21pc2UuVU5IQU5ETEVEX1JFSkVDVElPTl9ERUxBWSA+IDApIHtcbiAgICBwcm9taXNlLnVuaGFuZGxlZFJlamVjdGlvbklkXyA9IHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgQ2FuY2VsbGFibGVQcm9taXNlLmhhbmRsZVJlamVjdGlvbl8uY2FsbChudWxsLCByZWFzb24pO1xuICAgIH0sIENhbmNlbGxhYmxlUHJvbWlzZS5VTkhBTkRMRURfUkVKRUNUSU9OX0RFTEFZKTtcbiAgfSBlbHNlIGlmIChDYW5jZWxsYWJsZVByb21pc2UuVU5IQU5ETEVEX1JFSkVDVElPTl9ERUxBWSA9PT0gMCkge1xuICAgIHByb21pc2UuaGFkVW5oYW5kbGVkUmVqZWN0aW9uXyA9IHRydWU7XG4gICAgX21ldGFsLmFzeW5jLnJ1bihmdW5jdGlvbiAoKSB7XG4gICAgICBpZiAocHJvbWlzZS5oYWRVbmhhbmRsZWRSZWplY3Rpb25fKSB7XG4gICAgICAgIENhbmNlbGxhYmxlUHJvbWlzZS5oYW5kbGVSZWplY3Rpb25fLmNhbGwobnVsbCwgcmVhc29uKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxufTtcblxuLyoqXG4gKiBBIG1ldGhvZCB0aGF0IGlzIGludm9rZWQgd2l0aCB0aGUgcmVqZWN0aW9uIHJlYXNvbnMgZm9yIFByb21pc2VzIHRoYXQgYXJlXG4gKiByZWplY3RlZCBidXQgaGF2ZSBubyB7QGNvZGUgb25SZWplY3RlZH0gY2FsbGJhY2tzIHJlZ2lzdGVyZWQgeWV0LlxuICogQHR5cGUge2Z1bmN0aW9uKCopfVxuICogQHByaXZhdGVcbiAqL1xuQ2FuY2VsbGFibGVQcm9taXNlLmhhbmRsZVJlamVjdGlvbl8gPSBfbWV0YWwuYXN5bmMudGhyb3dFeGNlcHRpb247XG5cbi8qKlxuICogU2V0cyBhIGhhbmRsZXIgdGhhdCB3aWxsIGJlIGNhbGxlZCB3aXRoIHJlYXNvbnMgZnJvbSB1bmhhbmRsZWQgcmVqZWN0ZWRcbiAqIFByb21pc2VzLiBJZiB0aGUgcmVqZWN0ZWQgUHJvbWlzZSAob3Igb25lIG9mIGl0cyBkZXNjZW5kYW50cykgaGFzIGFuXG4gKiB7QGNvZGUgb25SZWplY3RlZH0gY2FsbGJhY2sgcmVnaXN0ZXJlZCwgdGhlIHJlamVjdGlvbiB3aWxsIGJlIGNvbnNpZGVyZWRcbiAqIGhhbmRsZWQsIGFuZCB0aGUgcmVqZWN0aW9uIGhhbmRsZXIgd2lsbCBub3QgYmUgY2FsbGVkLlxuICpcbiAqIEJ5IGRlZmF1bHQsIHVuaGFuZGxlZCByZWplY3Rpb25zIGFyZSByZXRocm93biBzbyB0aGF0IHRoZSBlcnJvciBtYXkgYmVcbiAqIGNhcHR1cmVkIGJ5IHRoZSBkZXZlbG9wZXIgY29uc29sZSBvciBhIHtAY29kZSB3aW5kb3cub25lcnJvcn0gaGFuZGxlci5cbiAqXG4gKiBAcGFyYW0ge2Z1bmN0aW9uKCopfSBoYW5kbGVyIEEgZnVuY3Rpb24gdGhhdCB3aWxsIGJlIGNhbGxlZCB3aXRoIHJlYXNvbnMgZnJvbVxuICogICAgIHJlamVjdGVkIFByb21pc2VzLiBEZWZhdWx0cyB0byB7QGNvZGUgYXN5bmMudGhyb3dFeGNlcHRpb259LlxuICovXG5DYW5jZWxsYWJsZVByb21pc2Uuc2V0VW5oYW5kbGVkUmVqZWN0aW9uSGFuZGxlciA9IGZ1bmN0aW9uIChoYW5kbGVyKSB7XG4gIENhbmNlbGxhYmxlUHJvbWlzZS5oYW5kbGVSZWplY3Rpb25fID0gaGFuZGxlcjtcbn07XG5cbi8qKlxuICogRXJyb3IgdXNlZCBhcyBhIHJlamVjdGlvbiByZWFzb24gZm9yIGNhbmNlbGVkIFByb21pc2VzLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nPX0gb3B0X21lc3NhZ2VcbiAqIEBjb25zdHJ1Y3RvclxuICogQGV4dGVuZHMge0Vycm9yfVxuICogQGZpbmFsXG4gKi9cbkNhbmNlbGxhYmxlUHJvbWlzZS5DYW5jZWxsYXRpb25FcnJvciA9IGZ1bmN0aW9uIChfRXJyb3IpIHtcbiAgX2luaGVyaXRzKF9jbGFzcywgX0Vycm9yKTtcblxuICBmdW5jdGlvbiBfY2xhc3Mob3B0X21lc3NhZ2UpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgX2NsYXNzKTtcblxuICAgIHZhciBfdGhpcyA9IF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIF9FcnJvci5jYWxsKHRoaXMsIG9wdF9tZXNzYWdlKSk7XG5cbiAgICBpZiAob3B0X21lc3NhZ2UpIHtcbiAgICAgIF90aGlzLm1lc3NhZ2UgPSBvcHRfbWVzc2FnZTtcbiAgICB9XG4gICAgcmV0dXJuIF90aGlzO1xuICB9XG5cbiAgcmV0dXJuIF9jbGFzcztcbn0oRXJyb3IpO1xuXG4vKiogQG92ZXJyaWRlICovXG5DYW5jZWxsYWJsZVByb21pc2UuQ2FuY2VsbGF0aW9uRXJyb3IucHJvdG90eXBlLm5hbWUgPSAnY2FuY2VsJztcblxuZXhwb3J0cy5DYW5jZWxsYWJsZVByb21pc2UgPSBDYW5jZWxsYWJsZVByb21pc2U7XG5leHBvcnRzLmRlZmF1bHQgPSBDYW5jZWxsYWJsZVByb21pc2U7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L21ldGFsLXByb21pc2UvbGliL3Byb21pc2UvUHJvbWlzZS5qc1xuLy8gbW9kdWxlIGlkID0gMzlcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcblx0dmFsdWU6IHRydWVcbn0pO1xuXG52YXIgX2NyZWF0ZUNsYXNzID0gZnVuY3Rpb24gKCkgeyBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH0gcmV0dXJuIGZ1bmN0aW9uIChDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfTsgfSgpO1xuXG52YXIgX21ldGFsID0gcmVxdWlyZSgnbWV0YWwnKTtcblxudmFyIF9tZXRhbDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9tZXRhbCk7XG5cbnZhciBfU3RvcmFnZU1lY2hhbmlzbSA9IHJlcXVpcmUoJy4vbWVjaGFuaXNtL1N0b3JhZ2VNZWNoYW5pc20nKTtcblxudmFyIF9TdG9yYWdlTWVjaGFuaXNtMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX1N0b3JhZ2VNZWNoYW5pc20pO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG52YXIgU3RvcmFnZSA9IGZ1bmN0aW9uICgpIHtcblxuXHQvKipcbiAgKiBQcm92aWRlcyBhIGNvbnZlbmllbnQgQVBJIGZvciBkYXRhIHBlcnNpc3RlbmNlIHVzaW5nIGEgc2VsZWN0ZWQgZGF0YVxuICAqIHN0b3JhZ2UgbWVjaGFuaXNtLlxuICAqIEBwYXJhbSB7IVN0b3JhZ2VNZWNoYW5pc219IG1lY2hhbmlzbSBUaGUgdW5kZXJseWluZyBzdG9yYWdlIG1lY2hhbmlzbS5cbiAgKiBAY29uc3RydWN0b3JcbiAgKi9cblx0ZnVuY3Rpb24gU3RvcmFnZShtZWNoYW5pc20pIHtcblx0XHRfY2xhc3NDYWxsQ2hlY2sodGhpcywgU3RvcmFnZSk7XG5cblx0XHRhc3NlcnRNZWNoYW5pc21EZWZBbmROb3ROdWxsKG1lY2hhbmlzbSk7XG5cdFx0YXNzZXJ0TWVjaGFuaXNtSW5zdGFuY2VPZihtZWNoYW5pc20pO1xuXG5cdFx0LyoqXG4gICAqIFRoZSBtZWNoYW5pc20gdXNlZCB0byBwZXJzaXN0IGtleS12YWx1ZSBwYWlycy5cbiAgICogQHR5cGUge1N0b3JhZ2VNZWNoYW5pc219XG4gICAqIEBwcm90ZWN0ZWRcbiAgICovXG5cdFx0dGhpcy5tZWNoYW5pc20gPSBtZWNoYW5pc207XG5cdH1cblxuXHQvKipcbiAgKiBDbGVhciBhbGwgaXRlbXMgZnJvbSB0aGUgZGF0YSBzdG9yYWdlLlxuICAqL1xuXG5cblx0X2NyZWF0ZUNsYXNzKFN0b3JhZ2UsIFt7XG5cdFx0a2V5OiAnY2xlYXInLFxuXHRcdHZhbHVlOiBmdW5jdGlvbiBjbGVhcigpIHtcblx0XHRcdHRoaXMubWVjaGFuaXNtLmNsZWFyKCk7XG5cdFx0fVxuXG5cdFx0LyoqXG4gICAqIFNldHMgYW4gaXRlbSBpbiB0aGUgZGF0YSBzdG9yYWdlLlxuICAgKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgdG8gc2V0LlxuICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBzZXJpYWxpemUgdG8gYSBzdHJpbmcgYW5kIHNhdmUuXG4gICAqL1xuXG5cdH0sIHtcblx0XHRrZXk6ICdzZXQnLFxuXHRcdHZhbHVlOiBmdW5jdGlvbiBzZXQoa2V5LCB2YWx1ZSkge1xuXHRcdFx0aWYgKCFfbWV0YWwyLmRlZmF1bHQuaXNEZWYodmFsdWUpKSB7XG5cdFx0XHRcdHRoaXMubWVjaGFuaXNtLnJlbW92ZShrZXkpO1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cdFx0XHR0aGlzLm1lY2hhbmlzbS5zZXQoa2V5LCBKU09OLnN0cmluZ2lmeSh2YWx1ZSkpO1xuXHRcdH1cblxuXHRcdC8qKlxuICAgKiBHZXRzIGFuIGl0ZW0gZnJvbSB0aGUgZGF0YSBzdG9yYWdlLlxuICAgKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgdG8gZ2V0LlxuICAgKiBAcmV0dXJuIHsqfSBEZXNlcmlhbGl6ZWQgdmFsdWUgb3IgdW5kZWZpbmVkIGlmIG5vdCBmb3VuZC5cbiAgICovXG5cblx0fSwge1xuXHRcdGtleTogJ2dldCcsXG5cdFx0dmFsdWU6IGZ1bmN0aW9uIGdldChrZXkpIHtcblx0XHRcdHZhciBqc29uO1xuXHRcdFx0dHJ5IHtcblx0XHRcdFx0anNvbiA9IHRoaXMubWVjaGFuaXNtLmdldChrZXkpO1xuXHRcdFx0fSBjYXRjaCAoZSkge1xuXHRcdFx0XHRyZXR1cm4gdW5kZWZpbmVkO1xuXHRcdFx0fVxuXHRcdFx0aWYgKF9tZXRhbDIuZGVmYXVsdC5pc051bGwoanNvbikpIHtcblx0XHRcdFx0cmV0dXJuIHVuZGVmaW5lZDtcblx0XHRcdH1cblx0XHRcdHRyeSB7XG5cdFx0XHRcdHJldHVybiBKU09OLnBhcnNlKGpzb24pO1xuXHRcdFx0fSBjYXRjaCAoZSkge1xuXHRcdFx0XHR0aHJvdyBTdG9yYWdlLkVycm9yQ29kZS5JTlZBTElEX1ZBTFVFO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8qKlxuICAgKiBSZXR1cm5zIHRoZSBsaXN0IG9mIGtleXMgc3RvcmVkIGluIHRoZSBTdG9yYWdlIG9iamVjdC5cbiAgICogQHBhcmFtIHshQXJyYXk8c3RyaW5nPn0ga2V5c1xuICAgKi9cblxuXHR9LCB7XG5cdFx0a2V5OiAna2V5cycsXG5cdFx0dmFsdWU6IGZ1bmN0aW9uIGtleXMoKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5tZWNoYW5pc20ua2V5cygpO1xuXHRcdH1cblxuXHRcdC8qKlxuICAgKiBSZW1vdmVzIGFuIGl0ZW0gZnJvbSB0aGUgZGF0YSBzdG9yYWdlLlxuICAgKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgdG8gcmVtb3ZlLlxuICAgKi9cblxuXHR9LCB7XG5cdFx0a2V5OiAncmVtb3ZlJyxcblx0XHR2YWx1ZTogZnVuY3Rpb24gcmVtb3ZlKGtleSkge1xuXHRcdFx0dGhpcy5tZWNoYW5pc20ucmVtb3ZlKGtleSk7XG5cdFx0fVxuXG5cdFx0LyoqXG4gICAqIFJldHVybnMgdGhlIG51bWJlciBvZiBkYXRhIGl0ZW1zIHN0b3JlZCBpbiB0aGUgU3RvcmFnZSBvYmplY3QuXG4gICAqIEByZXR1cm4ge251bWJlcn1cbiAgICovXG5cblx0fSwge1xuXHRcdGtleTogJ3NpemUnLFxuXHRcdHZhbHVlOiBmdW5jdGlvbiBzaXplKCkge1xuXHRcdFx0cmV0dXJuIHRoaXMubWVjaGFuaXNtLnNpemUoKTtcblx0XHR9XG5cblx0XHQvKipcbiAgICogUmV0dXJucyB0aGUgbGlzdCBvZiB2YWx1ZXMgc3RvcmVkIGluIHRoZSBTdG9yYWdlIG9iamVjdC5cbiAgICogQHBhcmFtIHshQXJyYXk8c3RyaW5nPn0gdmFsdWVzXG4gICAqL1xuXG5cdH0sIHtcblx0XHRrZXk6ICd2YWx1ZXMnLFxuXHRcdHZhbHVlOiBmdW5jdGlvbiB2YWx1ZXMoKSB7XG5cdFx0XHR2YXIgX3RoaXMgPSB0aGlzO1xuXG5cdFx0XHRyZXR1cm4gdGhpcy5rZXlzKCkubWFwKGZ1bmN0aW9uIChrZXkpIHtcblx0XHRcdFx0cmV0dXJuIF90aGlzLmdldChrZXkpO1xuXHRcdFx0fSk7XG5cdFx0fVxuXHR9XSk7XG5cblx0cmV0dXJuIFN0b3JhZ2U7XG59KCk7XG5cbi8qKlxuICogRXJyb3JzIHRocm93biBieSB0aGUgc3RvcmFnZS5cbiAqIEBlbnVtIHtzdHJpbmd9XG4gKi9cblxuXG5TdG9yYWdlLkVycm9yQ29kZSA9IHtcblx0SU5WQUxJRF9WQUxVRTogJ1N0b3JhZ2U6IEludmFsaWQgdmFsdWUgd2FzIGVuY291bnRlcmVkJ1xufTtcblxuZnVuY3Rpb24gYXNzZXJ0TWVjaGFuaXNtRGVmQW5kTm90TnVsbChtZWNoYW5pc20pIHtcblx0aWYgKCFfbWV0YWwyLmRlZmF1bHQuaXNEZWZBbmROb3ROdWxsKG1lY2hhbmlzbSkpIHtcblx0XHR0aHJvdyBFcnJvcignU3RvcmFnZSBtZWNoYW5pc20gaXMgcmVxdWlyZWQnKTtcblx0fVxufVxuXG5mdW5jdGlvbiBhc3NlcnRNZWNoYW5pc21JbnN0YW5jZU9mKG1lY2hhbmlzbSkge1xuXHRpZiAoIShtZWNoYW5pc20gaW5zdGFuY2VvZiBfU3RvcmFnZU1lY2hhbmlzbTIuZGVmYXVsdCkpIHtcblx0XHR0aHJvdyBFcnJvcignU3RvcmFnZSBtZWNoYW5pc20gbXVzdCBtZSBhbiBpbXBsZW1lbnRhdGlvbiBvZiBTdG9yYWdlTWVjaGFuaXNtJyk7XG5cdH1cbn1cblxuZXhwb3J0cy5kZWZhdWx0ID0gU3RvcmFnZTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vbWV0YWwtc3RvcmFnZS9saWIvU3RvcmFnZS5qc1xuLy8gbW9kdWxlIGlkID0gNDBcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5Mb2NhbFN0b3JhZ2VNZWNoYW5pc20gPSBleHBvcnRzLlN0b3JhZ2VNZWNoYW5pc20gPSBleHBvcnRzLlN0b3JhZ2UgPSB1bmRlZmluZWQ7XG5cbnZhciBfU3RvcmFnZSA9IHJlcXVpcmUoJy4uL1N0b3JhZ2UnKTtcblxudmFyIF9TdG9yYWdlMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX1N0b3JhZ2UpO1xuXG52YXIgX1N0b3JhZ2VNZWNoYW5pc20gPSByZXF1aXJlKCcuLi9tZWNoYW5pc20vU3RvcmFnZU1lY2hhbmlzbScpO1xuXG52YXIgX1N0b3JhZ2VNZWNoYW5pc20yID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfU3RvcmFnZU1lY2hhbmlzbSk7XG5cbnZhciBfTG9jYWxTdG9yYWdlTWVjaGFuaXNtID0gcmVxdWlyZSgnLi4vbWVjaGFuaXNtL0xvY2FsU3RvcmFnZU1lY2hhbmlzbScpO1xuXG52YXIgX0xvY2FsU3RvcmFnZU1lY2hhbmlzbTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9Mb2NhbFN0b3JhZ2VNZWNoYW5pc20pO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG5leHBvcnRzLlN0b3JhZ2UgPSBfU3RvcmFnZTIuZGVmYXVsdDtcbmV4cG9ydHMuU3RvcmFnZU1lY2hhbmlzbSA9IF9TdG9yYWdlTWVjaGFuaXNtMi5kZWZhdWx0O1xuZXhwb3J0cy5Mb2NhbFN0b3JhZ2VNZWNoYW5pc20gPSBfTG9jYWxTdG9yYWdlTWVjaGFuaXNtMi5kZWZhdWx0O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9tZXRhbC1zdG9yYWdlL2xpYi9hbGwvc3RvcmFnZS5qc1xuLy8gbW9kdWxlIGlkID0gNDFcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcblx0dmFsdWU6IHRydWVcbn0pO1xuXG52YXIgX2NyZWF0ZUNsYXNzID0gZnVuY3Rpb24gKCkgeyBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH0gcmV0dXJuIGZ1bmN0aW9uIChDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfTsgfSgpO1xuXG52YXIgX1N0b3JhZ2VNZWNoYW5pc20yID0gcmVxdWlyZSgnLi9TdG9yYWdlTWVjaGFuaXNtJyk7XG5cbnZhciBfU3RvcmFnZU1lY2hhbmlzbTMgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9TdG9yYWdlTWVjaGFuaXNtMik7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbmZ1bmN0aW9uIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHNlbGYsIGNhbGwpIHsgaWYgKCFzZWxmKSB7IHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFwiKTsgfSByZXR1cm4gY2FsbCAmJiAodHlwZW9mIGNhbGwgPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIGNhbGwgPT09IFwiZnVuY3Rpb25cIikgPyBjYWxsIDogc2VsZjsgfVxuXG5mdW5jdGlvbiBfaW5oZXJpdHMoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHsgaWYgKHR5cGVvZiBzdXBlckNsYXNzICE9PSBcImZ1bmN0aW9uXCIgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb24sIG5vdCBcIiArIHR5cGVvZiBzdXBlckNsYXNzKTsgfSBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MgJiYgc3VwZXJDbGFzcy5wcm90b3R5cGUsIHsgY29uc3RydWN0b3I6IHsgdmFsdWU6IHN1YkNsYXNzLCBlbnVtZXJhYmxlOiBmYWxzZSwgd3JpdGFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH0pOyBpZiAoc3VwZXJDbGFzcykgT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LnNldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKSA6IHN1YkNsYXNzLl9fcHJvdG9fXyA9IHN1cGVyQ2xhc3M7IH1cblxuLyoqXG4gKiBBYnN0cmFjdCBpbnRlcmZhY2UgZm9yIHN0b3JpbmcgYW5kIHJldHJpZXZpbmcgZGF0YSB1c2luZyBzb21lIHBlcnNpc3RlbmNlXG4gKiBtZWNoYW5pc20uXG4gKiBAY29uc3RydWN0b3JcbiAqL1xudmFyIExvY2FsU3RvcmFnZU1lY2hhbmlzbSA9IGZ1bmN0aW9uIChfU3RvcmFnZU1lY2hhbmlzbSkge1xuXHRfaW5oZXJpdHMoTG9jYWxTdG9yYWdlTWVjaGFuaXNtLCBfU3RvcmFnZU1lY2hhbmlzbSk7XG5cblx0ZnVuY3Rpb24gTG9jYWxTdG9yYWdlTWVjaGFuaXNtKCkge1xuXHRcdF9jbGFzc0NhbGxDaGVjayh0aGlzLCBMb2NhbFN0b3JhZ2VNZWNoYW5pc20pO1xuXG5cdFx0cmV0dXJuIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIChMb2NhbFN0b3JhZ2VNZWNoYW5pc20uX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihMb2NhbFN0b3JhZ2VNZWNoYW5pc20pKS5hcHBseSh0aGlzLCBhcmd1bWVudHMpKTtcblx0fVxuXG5cdF9jcmVhdGVDbGFzcyhMb2NhbFN0b3JhZ2VNZWNoYW5pc20sIFt7XG5cdFx0a2V5OiAnc3RvcmFnZScsXG5cblx0XHQvKipcbiAgICogUmV0dXJucyByZWZlcmVuY2UgZm9yIGdsb2JhbCBsb2NhbCBzdG9yYWdlLiBieSBkZWZhdWx0XG4gICAqL1xuXHRcdHZhbHVlOiBmdW5jdGlvbiBzdG9yYWdlKCkge1xuXHRcdFx0cmV0dXJuIExvY2FsU3RvcmFnZU1lY2hhbmlzbS5nbG9iYWxzLmxvY2FsU3RvcmFnZTtcblx0XHR9XG5cblx0XHQvKipcbiAgICogQGluaGVyaXREb2NcbiAgICovXG5cblx0fSwge1xuXHRcdGtleTogJ2NsZWFyJyxcblx0XHR2YWx1ZTogZnVuY3Rpb24gY2xlYXIoKSB7XG5cdFx0XHR0aGlzLnN0b3JhZ2UoKS5jbGVhcigpO1xuXHRcdH1cblxuXHRcdC8qKlxuICAgKiBAaW5oZXJpdERvY1xuICAgKi9cblxuXHR9LCB7XG5cdFx0a2V5OiAna2V5cycsXG5cdFx0dmFsdWU6IGZ1bmN0aW9uIGtleXMoKSB7XG5cdFx0XHRyZXR1cm4gT2JqZWN0LmtleXModGhpcy5zdG9yYWdlKCkpO1xuXHRcdH1cblxuXHRcdC8qKlxuICAgKiBAaW5oZXJpdERvY1xuICAgKi9cblxuXHR9LCB7XG5cdFx0a2V5OiAnZ2V0Jyxcblx0XHR2YWx1ZTogZnVuY3Rpb24gZ2V0KGtleSkge1xuXHRcdFx0cmV0dXJuIHRoaXMuc3RvcmFnZSgpLmdldEl0ZW0oa2V5KTtcblx0XHR9XG5cblx0XHQvKipcbiAgICogQGluaGVyaXREb2NcbiAgICovXG5cblx0fSwge1xuXHRcdGtleTogJ3JlbW92ZScsXG5cblxuXHRcdC8qKlxuICAgKiBAaW5oZXJpdERvY1xuICAgKi9cblx0XHR2YWx1ZTogZnVuY3Rpb24gcmVtb3ZlKGtleSkge1xuXHRcdFx0dGhpcy5zdG9yYWdlKCkucmVtb3ZlSXRlbShrZXkpO1xuXHRcdH1cblxuXHRcdC8qKlxuICAgKiBAaW5oZXJpdERvY1xuICAgKi9cblxuXHR9LCB7XG5cdFx0a2V5OiAnc2V0Jyxcblx0XHR2YWx1ZTogZnVuY3Rpb24gc2V0KGtleSwgdmFsdWUpIHtcblx0XHRcdHRoaXMuc3RvcmFnZSgpLnNldEl0ZW0oa2V5LCB2YWx1ZSk7XG5cdFx0fVxuXG5cdFx0LyoqXG4gICAqIEBpbmhlcml0RG9jXG4gICAqL1xuXG5cdH0sIHtcblx0XHRrZXk6ICdzaXplJyxcblx0XHR2YWx1ZTogZnVuY3Rpb24gc2l6ZSgpIHtcblx0XHRcdHJldHVybiB0aGlzLnN0b3JhZ2UoKS5sZW5ndGg7XG5cdFx0fVxuXHR9XSwgW3tcblx0XHRrZXk6ICdpc1N1cHBvcnRlZCcsXG5cdFx0dmFsdWU6IGZ1bmN0aW9uIGlzU3VwcG9ydGVkKCkge1xuXHRcdFx0cmV0dXJuIHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmIHR5cGVvZiB3aW5kb3cubG9jYWxTdG9yYWdlICE9PSAndW5kZWZpbmVkJztcblx0XHR9XG5cdH1dKTtcblxuXHRyZXR1cm4gTG9jYWxTdG9yYWdlTWVjaGFuaXNtO1xufShfU3RvcmFnZU1lY2hhbmlzbTMuZGVmYXVsdCk7XG5cbmlmIChMb2NhbFN0b3JhZ2VNZWNoYW5pc20uaXNTdXBwb3J0ZWQoKSkge1xuXHRMb2NhbFN0b3JhZ2VNZWNoYW5pc20uZ2xvYmFscyA9IHtcblx0XHRsb2NhbFN0b3JhZ2U6IHdpbmRvdy5sb2NhbFN0b3JhZ2Vcblx0fTtcbn1cblxuZXhwb3J0cy5kZWZhdWx0ID0gTG9jYWxTdG9yYWdlTWVjaGFuaXNtO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9tZXRhbC1zdG9yYWdlL2xpYi9tZWNoYW5pc20vTG9jYWxTdG9yYWdlTWVjaGFuaXNtLmpzXG4vLyBtb2R1bGUgaWQgPSA0MlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuXHR2YWx1ZTogdHJ1ZVxufSk7XG5cbnZhciBfbWV0YWwgPSByZXF1aXJlKCdtZXRhbCcpO1xuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG5mdW5jdGlvbiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihzZWxmLCBjYWxsKSB7IGlmICghc2VsZikgeyB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXCJ0aGlzIGhhc24ndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuJ3QgYmVlbiBjYWxsZWRcIik7IH0gcmV0dXJuIGNhbGwgJiYgKHR5cGVvZiBjYWxsID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBjYWxsID09PSBcImZ1bmN0aW9uXCIpID8gY2FsbCA6IHNlbGY7IH1cblxuZnVuY3Rpb24gX2luaGVyaXRzKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7IGlmICh0eXBlb2Ygc3VwZXJDbGFzcyAhPT0gXCJmdW5jdGlvblwiICYmIHN1cGVyQ2xhc3MgIT09IG51bGwpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uLCBub3QgXCIgKyB0eXBlb2Ygc3VwZXJDbGFzcyk7IH0gc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzICYmIHN1cGVyQ2xhc3MucHJvdG90eXBlLCB7IGNvbnN0cnVjdG9yOiB7IHZhbHVlOiBzdWJDbGFzcywgZW51bWVyYWJsZTogZmFsc2UsIHdyaXRhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUgfSB9KTsgaWYgKHN1cGVyQ2xhc3MpIE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5zZXRQcm90b3R5cGVPZihzdWJDbGFzcywgc3VwZXJDbGFzcykgOiBzdWJDbGFzcy5fX3Byb3RvX18gPSBzdXBlckNsYXNzOyB9XG5cbi8qKlxuICogQSBjYWNoZWQgcmVmZXJlbmNlIHRvIHRoZSBjcmVhdGUgZnVuY3Rpb24uXG4gKi9cbnZhciBjcmVhdGUgPSBPYmplY3QuY3JlYXRlO1xuXG4vKipcbiAqIENhc2UgaW5zZW5zaXRpdmUgc3RyaW5nIE11bHRpbWFwIGltcGxlbWVudGF0aW9uLiBBbGxvd3MgbXVsdGlwbGUgdmFsdWVzIGZvclxuICogdGhlIHNhbWUga2V5IG5hbWUuXG4gKiBAZXh0ZW5kcyB7RGlzcG9zYWJsZX1cbiAqL1xuXG52YXIgTXVsdGlNYXAgPSBmdW5jdGlvbiAoX0Rpc3Bvc2FibGUpIHtcblx0X2luaGVyaXRzKE11bHRpTWFwLCBfRGlzcG9zYWJsZSk7XG5cblx0ZnVuY3Rpb24gTXVsdGlNYXAoKSB7XG5cdFx0X2NsYXNzQ2FsbENoZWNrKHRoaXMsIE11bHRpTWFwKTtcblxuXHRcdHZhciBfdGhpcyA9IF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIF9EaXNwb3NhYmxlLmNhbGwodGhpcykpO1xuXG5cdFx0X3RoaXMua2V5cyA9IGNyZWF0ZShudWxsKTtcblx0XHRfdGhpcy52YWx1ZXMgPSBjcmVhdGUobnVsbCk7XG5cdFx0cmV0dXJuIF90aGlzO1xuXHR9XG5cblx0LyoqXG4gICogQWRkcyB2YWx1ZSB0byBhIGtleSBuYW1lLlxuICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lXG4gICogQHBhcmFtIHsqfSB2YWx1ZVxuICAqIEBjaGFpbmFibGVcbiAgKi9cblxuXG5cdE11bHRpTWFwLnByb3RvdHlwZS5hZGQgPSBmdW5jdGlvbiBhZGQobmFtZSwgdmFsdWUpIHtcblx0XHR0aGlzLmtleXNbbmFtZS50b0xvd2VyQ2FzZSgpXSA9IG5hbWU7XG5cdFx0dGhpcy52YWx1ZXNbbmFtZS50b0xvd2VyQ2FzZSgpXSA9IHRoaXMudmFsdWVzW25hbWUudG9Mb3dlckNhc2UoKV0gfHwgW107XG5cdFx0dGhpcy52YWx1ZXNbbmFtZS50b0xvd2VyQ2FzZSgpXS5wdXNoKHZhbHVlKTtcblx0XHRyZXR1cm4gdGhpcztcblx0fTtcblxuXHQvKipcbiAgKiBDbGVhcnMgbWFwIG5hbWVzIGFuZCB2YWx1ZXMuXG4gICogQGNoYWluYWJsZVxuICAqL1xuXG5cblx0TXVsdGlNYXAucHJvdG90eXBlLmNsZWFyID0gZnVuY3Rpb24gY2xlYXIoKSB7XG5cdFx0dGhpcy5rZXlzID0gY3JlYXRlKG51bGwpO1xuXHRcdHRoaXMudmFsdWVzID0gY3JlYXRlKG51bGwpO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9O1xuXG5cdC8qKlxuICAqIENoZWNrcyBpZiBtYXAgY29udGFpbnMgYSB2YWx1ZSB0byB0aGUga2V5IG5hbWUuXG4gICogQHBhcmFtIHtzdHJpbmd9IG5hbWVcbiAgKiBAcmV0dXJuIHtib29sZWFufVxuICAqIEBjaGFpbmFibGVcbiAgKi9cblxuXG5cdE11bHRpTWFwLnByb3RvdHlwZS5jb250YWlucyA9IGZ1bmN0aW9uIGNvbnRhaW5zKG5hbWUpIHtcblx0XHRyZXR1cm4gbmFtZS50b0xvd2VyQ2FzZSgpIGluIHRoaXMudmFsdWVzO1xuXHR9O1xuXG5cdC8qKlxuICAqIEBpbmhlcml0RG9jXG4gICovXG5cblxuXHRNdWx0aU1hcC5wcm90b3R5cGUuZGlzcG9zZUludGVybmFsID0gZnVuY3Rpb24gZGlzcG9zZUludGVybmFsKCkge1xuXHRcdHRoaXMudmFsdWVzID0gbnVsbDtcblx0fTtcblxuXHQvKipcbiAgKiBDcmVhdGVzIGEgYE11bHRpTWFwYCBpbnN0YW5jZSBmcm9tIHRoZSBnaXZlbiBvYmplY3QuXG4gICogQHBhcmFtIHshT2JqZWN0fSBvYmpcbiAgKiBAcmV0dXJuIHshTXVsdGlNYXB9XG4gICovXG5cblxuXHRNdWx0aU1hcC5mcm9tT2JqZWN0ID0gZnVuY3Rpb24gZnJvbU9iamVjdChvYmopIHtcblx0XHR2YXIgbWFwID0gbmV3IE11bHRpTWFwKCk7XG5cdFx0dmFyIGtleXMgPSBPYmplY3Qua2V5cyhvYmopO1xuXHRcdGZvciAodmFyIGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7IGkrKykge1xuXHRcdFx0bWFwLnNldChrZXlzW2ldLCBvYmpba2V5c1tpXV0pO1xuXHRcdH1cblx0XHRyZXR1cm4gbWFwO1xuXHR9O1xuXG5cdC8qKlxuICAqIEdldHMgdGhlIGZpcnN0IGFkZGVkIHZhbHVlIGZyb20gYSBrZXkgbmFtZS5cbiAgKiBAcGFyYW0ge3N0cmluZ30gbmFtZVxuICAqIEByZXR1cm4geyp9XG4gICogQGNoYWluYWJsZVxuICAqL1xuXG5cblx0TXVsdGlNYXAucHJvdG90eXBlLmdldCA9IGZ1bmN0aW9uIGdldChuYW1lKSB7XG5cdFx0dmFyIHZhbHVlcyA9IHRoaXMudmFsdWVzW25hbWUudG9Mb3dlckNhc2UoKV07XG5cdFx0aWYgKHZhbHVlcykge1xuXHRcdFx0cmV0dXJuIHZhbHVlc1swXTtcblx0XHR9XG5cdH07XG5cblx0LyoqXG4gICogR2V0cyBhbGwgdmFsdWVzIGZyb20gYSBrZXkgbmFtZS5cbiAgKiBAcGFyYW0ge3N0cmluZ30gbmFtZVxuICAqIEByZXR1cm4ge0FycmF5LjwqPn1cbiAgKi9cblxuXG5cdE11bHRpTWFwLnByb3RvdHlwZS5nZXRBbGwgPSBmdW5jdGlvbiBnZXRBbGwobmFtZSkge1xuXHRcdHJldHVybiB0aGlzLnZhbHVlc1tuYW1lLnRvTG93ZXJDYXNlKCldO1xuXHR9O1xuXG5cdC8qKlxuICAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgbWFwIGlzIGVtcHR5LCBmYWxzZSBvdGhlcndpc2UuXG4gICogQHJldHVybiB7Ym9vbGVhbn1cbiAgKi9cblxuXG5cdE11bHRpTWFwLnByb3RvdHlwZS5pc0VtcHR5ID0gZnVuY3Rpb24gaXNFbXB0eSgpIHtcblx0XHRyZXR1cm4gdGhpcy5zaXplKCkgPT09IDA7XG5cdH07XG5cblx0LyoqXG4gICogR2V0cyBhcnJheSBvZiBrZXkgbmFtZXMuXG4gICogQHJldHVybiB7QXJyYXkuPHN0cmluZz59XG4gICovXG5cblxuXHRNdWx0aU1hcC5wcm90b3R5cGUubmFtZXMgPSBmdW5jdGlvbiBuYW1lcygpIHtcblx0XHR2YXIgX3RoaXMyID0gdGhpcztcblxuXHRcdHJldHVybiBPYmplY3Qua2V5cyh0aGlzLnZhbHVlcykubWFwKGZ1bmN0aW9uIChrZXkpIHtcblx0XHRcdHJldHVybiBfdGhpczIua2V5c1trZXldO1xuXHRcdH0pO1xuXHR9O1xuXG5cdC8qKlxuICAqIFJlbW92ZXMgYWxsIHZhbHVlcyBmcm9tIGEga2V5IG5hbWUuXG4gICogQHBhcmFtIHtzdHJpbmd9IG5hbWVcbiAgKiBAY2hhaW5hYmxlXG4gICovXG5cblxuXHRNdWx0aU1hcC5wcm90b3R5cGUucmVtb3ZlID0gZnVuY3Rpb24gcmVtb3ZlKG5hbWUpIHtcblx0XHRkZWxldGUgdGhpcy5rZXlzW25hbWUudG9Mb3dlckNhc2UoKV07XG5cdFx0ZGVsZXRlIHRoaXMudmFsdWVzW25hbWUudG9Mb3dlckNhc2UoKV07XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH07XG5cblx0LyoqXG4gICogU2V0cyB0aGUgdmFsdWUgb2YgYSBrZXkgbmFtZS4gUmVsZXZhbnQgdG8gcmVwbGFjZSB0aGUgY3VycmVudCB2YWx1ZXMgd2l0aFxuICAqIGEgbmV3IG9uZS5cbiAgKiBAcGFyYW0ge3N0cmluZ30gbmFtZVxuICAqIEBwYXJhbSB7Kn0gdmFsdWVcbiAgKiBAY2hhaW5hYmxlXG4gICovXG5cblxuXHRNdWx0aU1hcC5wcm90b3R5cGUuc2V0ID0gZnVuY3Rpb24gc2V0KG5hbWUsIHZhbHVlKSB7XG5cdFx0dGhpcy5rZXlzW25hbWUudG9Mb3dlckNhc2UoKV0gPSBuYW1lO1xuXHRcdHRoaXMudmFsdWVzW25hbWUudG9Mb3dlckNhc2UoKV0gPSBbdmFsdWVdO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9O1xuXG5cdC8qKlxuICAqIEdldHMgdGhlIHNpemUgb2YgdGhlIG1hcCBrZXkgbmFtZXMuXG4gICogQHJldHVybiB7bnVtYmVyfVxuICAqL1xuXG5cblx0TXVsdGlNYXAucHJvdG90eXBlLnNpemUgPSBmdW5jdGlvbiBzaXplKCkge1xuXHRcdHJldHVybiB0aGlzLm5hbWVzKCkubGVuZ3RoO1xuXHR9O1xuXG5cdC8qKlxuICAqIFJldHVybnMgdGhlIHBhcnNlZCB2YWx1ZXMgYXMgYSBzdHJpbmcuXG4gICogQHJldHVybiB7c3RyaW5nfVxuICAqL1xuXG5cblx0TXVsdGlNYXAucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gdG9TdHJpbmcoKSB7XG5cdFx0cmV0dXJuIEpTT04uc3RyaW5naWZ5KHRoaXMudmFsdWVzKTtcblx0fTtcblxuXHRyZXR1cm4gTXVsdGlNYXA7XG59KF9tZXRhbC5EaXNwb3NhYmxlKTtcblxuZXhwb3J0cy5kZWZhdWx0ID0gTXVsdGlNYXA7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L21ldGFsLXN0cnVjdHMvbGliL011bHRpTWFwLmpzXG4vLyBtb2R1bGUgaWQgPSA0M1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuXHR2YWx1ZTogdHJ1ZVxufSk7XG5cbnZhciBfbWV0YWwgPSByZXF1aXJlKCdtZXRhbCcpO1xuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG4vKipcbiAqIEdlbmVyaWMgdHJlZSBub2RlIGRhdGEgc3RydWN0dXJlIHdpdGggYXJiaXRyYXJ5IG51bWJlciBvZiBjaGlsZCBub2Rlcy5cbiAqIEBwYXJhbSB7Vn0gdmFsdWUgVmFsdWUuXG4gKiBAY29uc3RydWN0b3JcbiAqL1xudmFyIFRyZWVOb2RlID0gZnVuY3Rpb24gKCkge1xuXHRmdW5jdGlvbiBUcmVlTm9kZSh2YWx1ZSkge1xuXHRcdF9jbGFzc0NhbGxDaGVjayh0aGlzLCBUcmVlTm9kZSk7XG5cblx0XHQvKipcbiAgICogVGhlIHZhbHVlLlxuICAgKiBAcHJpdmF0ZSB7Vn1cbiAgICovXG5cdFx0dGhpcy52YWx1ZV8gPSB2YWx1ZTtcblxuXHRcdC8qKlxuICAgKiBSZWZlcmVuY2UgdG8gdGhlIHBhcmVudCBub2RlIG9yIG51bGwgaWYgaXQgaGFzIG5vIHBhcmVudC5cbiAgICogQHByaXZhdGUge1RyZWVOb2RlfVxuICAgKi9cblx0XHR0aGlzLnBhcmVudF8gPSBudWxsO1xuXG5cdFx0LyoqXG4gICAqIENoaWxkIG5vZGVzIG9yIG51bGwgaW4gY2FzZSBvZiBsZWFmIG5vZGUuXG4gICAqIEBwcml2YXRlIHtBcnJheTwhVHJlZU5vZGU+fVxuICAgKi9cblx0XHR0aGlzLmNoaWxkcmVuXyA9IG51bGw7XG5cdH1cblxuXHQvKipcbiAgKiBBcHBlbmRzIGEgY2hpbGQgbm9kZSB0byB0aGlzIG5vZGUuXG4gICogQHBhcmFtIHshVHJlZU5vZGV9IGNoaWxkIE9ycGhhbiBjaGlsZCBub2RlLlxuICAqL1xuXG5cblx0VHJlZU5vZGUucHJvdG90eXBlLmFkZENoaWxkID0gZnVuY3Rpb24gYWRkQ2hpbGQoY2hpbGQpIHtcblx0XHRhc3NlcnRDaGlsZEhhc05vUGFyZW50KGNoaWxkKTtcblx0XHRjaGlsZC5zZXRQYXJlbnQodGhpcyk7XG5cdFx0dGhpcy5jaGlsZHJlbl8gPSB0aGlzLmNoaWxkcmVuXyB8fCBbXTtcblx0XHR0aGlzLmNoaWxkcmVuXy5wdXNoKGNoaWxkKTtcblx0fTtcblxuXHQvKipcbiAgKiBUZWxscyB3aGV0aGVyIHRoaXMgbm9kZSBpcyB0aGUgYW5jZXN0b3Igb2YgdGhlIGdpdmVuIG5vZGUuXG4gICogQHBhcmFtIHshVHJlZU5vZGV9IG5vZGUgQSBub2RlLlxuICAqIEByZXR1cm4ge2Jvb2xlYW59IFdoZXRoZXIgdGhpcyBub2RlIGlzIHRoZSBhbmNlc3RvciBvZiB7QGNvZGUgbm9kZX0uXG4gICovXG5cblxuXHRUcmVlTm9kZS5wcm90b3R5cGUuY29udGFpbnMgPSBmdW5jdGlvbiBjb250YWlucyhub2RlKSB7XG5cdFx0dmFyIGN1cnJlbnQgPSBub2RlLmdldFBhcmVudCgpO1xuXHRcdHdoaWxlIChjdXJyZW50KSB7XG5cdFx0XHRpZiAoY3VycmVudCA9PT0gdGhpcykge1xuXHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdH1cblx0XHRcdGN1cnJlbnQgPSBjdXJyZW50LmdldFBhcmVudCgpO1xuXHRcdH1cblx0XHRyZXR1cm4gZmFsc2U7XG5cdH07XG5cblx0LyoqXG4gICogQHJldHVybiB7IUFycmF5PFRyZWVOb2RlPn0gQWxsIGFuY2VzdG9yIG5vZGVzIGluIGJvdHRvbS11cCBvcmRlci5cbiAgKi9cblxuXG5cdFRyZWVOb2RlLnByb3RvdHlwZS5nZXRBbmNlc3RvcnMgPSBmdW5jdGlvbiBnZXRBbmNlc3RvcnMoKSB7XG5cdFx0dmFyIGFuY2VzdG9ycyA9IFtdO1xuXHRcdHZhciBub2RlID0gdGhpcy5nZXRQYXJlbnQoKTtcblx0XHR3aGlsZSAobm9kZSkge1xuXHRcdFx0YW5jZXN0b3JzLnB1c2gobm9kZSk7XG5cdFx0XHRub2RlID0gbm9kZS5nZXRQYXJlbnQoKTtcblx0XHR9XG5cdFx0cmV0dXJuIGFuY2VzdG9ycztcblx0fTtcblxuXHQvKipcbiAgKiBHZXRzIHRoZSBjaGlsZCBub2RlIG9mIHRoaXMgbm9kZSBhdCB0aGUgZ2l2ZW4gaW5kZXguXG4gICogQHBhcmFtIHtudW1iZXJ9IGluZGV4IENoaWxkIGluZGV4LlxuICAqIEByZXR1cm4gez9UcmVlTm9kZX0gVGhlIG5vZGUgYXQgdGhlIGdpdmVuIGluZGV4XG4gICogb3IgbnVsbCBpZiBub3QgZm91bmQuXG4gICovXG5cblxuXHRUcmVlTm9kZS5wcm90b3R5cGUuZ2V0Q2hpbGRBdCA9IGZ1bmN0aW9uIGdldENoaWxkQXQoaW5kZXgpIHtcblx0XHRyZXR1cm4gdGhpcy5nZXRDaGlsZHJlbigpW2luZGV4XSB8fCBudWxsO1xuXHR9O1xuXG5cdC8qKlxuICAqIEByZXR1cm4gez9BcnJheTwhVHJlZU5vZGU+fSBDaGlsZCBub2RlcyBvciBudWxsIGluIGNhc2Ugb2YgbGVhZiBub2RlLlxuICAqL1xuXG5cblx0VHJlZU5vZGUucHJvdG90eXBlLmdldENoaWxkcmVuID0gZnVuY3Rpb24gZ2V0Q2hpbGRyZW4oKSB7XG5cdFx0cmV0dXJuIHRoaXMuY2hpbGRyZW5fIHx8IFRyZWVOb2RlLkVNUFRZX0FSUkFZO1xuXHR9O1xuXG5cdC8qKlxuICAqIEByZXR1cm4ge251bWJlcn0gVGhlIG51bWJlciBvZiBjaGlsZHJlbi5cbiAgKi9cblxuXG5cdFRyZWVOb2RlLnByb3RvdHlwZS5nZXRDaGlsZENvdW50ID0gZnVuY3Rpb24gZ2V0Q2hpbGRDb3VudCgpIHtcblx0XHRyZXR1cm4gdGhpcy5nZXRDaGlsZHJlbigpLmxlbmd0aDtcblx0fTtcblxuXHQvKipcbiAgKiBAcmV0dXJuIHtudW1iZXJ9IFRoZSBudW1iZXIgb2YgYW5jZXN0b3JzIG9mIHRoZSBub2RlLlxuICAqL1xuXG5cblx0VHJlZU5vZGUucHJvdG90eXBlLmdldERlcHRoID0gZnVuY3Rpb24gZ2V0RGVwdGgoKSB7XG5cdFx0dmFyIGRlcHRoID0gMDtcblx0XHR2YXIgbm9kZSA9IHRoaXM7XG5cdFx0d2hpbGUgKG5vZGUuZ2V0UGFyZW50KCkpIHtcblx0XHRcdGRlcHRoKys7XG5cdFx0XHRub2RlID0gbm9kZS5nZXRQYXJlbnQoKTtcblx0XHR9XG5cdFx0cmV0dXJuIGRlcHRoO1xuXHR9O1xuXG5cdC8qKlxuICAqIEByZXR1cm4gez9UcmVlTm9kZX0gUGFyZW50IG5vZGUgb3IgbnVsbCBpZiBpdCBoYXMgbm8gcGFyZW50LlxuICAqL1xuXG5cblx0VHJlZU5vZGUucHJvdG90eXBlLmdldFBhcmVudCA9IGZ1bmN0aW9uIGdldFBhcmVudCgpIHtcblx0XHRyZXR1cm4gdGhpcy5wYXJlbnRfO1xuXHR9O1xuXG5cdC8qKlxuICAqIEByZXR1cm4geyFUcmVlTm9kZX0gVGhlIHJvb3Qgb2YgdGhlIHRyZWUgc3RydWN0dXJlLCBpLmUuIHRoZSBmYXJ0aGVzdFxuICAqIGFuY2VzdG9yIG9mIHRoZSBub2RlIG9yIHRoZSBub2RlIGl0c2VsZiBpZiBpdCBoYXMgbm8gcGFyZW50cy5cbiAgKi9cblxuXG5cdFRyZWVOb2RlLnByb3RvdHlwZS5nZXRSb290ID0gZnVuY3Rpb24gZ2V0Um9vdCgpIHtcblx0XHR2YXIgcm9vdCA9IHRoaXM7XG5cdFx0d2hpbGUgKHJvb3QuZ2V0UGFyZW50KCkpIHtcblx0XHRcdHJvb3QgPSByb290LmdldFBhcmVudCgpO1xuXHRcdH1cblx0XHRyZXR1cm4gcm9vdDtcblx0fTtcblxuXHQvKipcbiAgKiBHZXRzIHRoZSB2YWx1ZS5cbiAgKiBAcmV0dXJuIHtWfSBUaGUgdmFsdWUuXG4gICovXG5cblxuXHRUcmVlTm9kZS5wcm90b3R5cGUuZ2V0VmFsdWUgPSBmdW5jdGlvbiBnZXRWYWx1ZSgpIHtcblx0XHRyZXR1cm4gdGhpcy52YWx1ZV87XG5cdH07XG5cblx0LyoqXG4gICogQHJldHVybiB7Ym9vbGVhbn0gV2hldGhlciB0aGUgbm9kZSBpcyBhIGxlYWYgbm9kZS5cbiAgKi9cblxuXG5cdFRyZWVOb2RlLnByb3RvdHlwZS5pc0xlYWYgPSBmdW5jdGlvbiBpc0xlYWYoKSB7XG5cdFx0cmV0dXJuICF0aGlzLmdldENoaWxkQ291bnQoKTtcblx0fTtcblxuXHQvKipcbiAgKiBSZW1vdmVzIHRoZSBnaXZlbiBjaGlsZCBub2RlIG9mIHRoaXMgbm9kZS5cbiAgKiBAcGFyYW0ge1RyZWVOb2RlfSBjaGlsZCBUaGUgbm9kZSB0byByZW1vdmUuXG4gICogQHJldHVybiB7VHJlZU5vZGV9IFRoZSByZW1vdmVkIG5vZGUgaWYgYW55LCBudWxsIG90aGVyd2lzZS5cbiAgKi9cblxuXG5cdFRyZWVOb2RlLnByb3RvdHlwZS5yZW1vdmVDaGlsZCA9IGZ1bmN0aW9uIHJlbW92ZUNoaWxkKGNoaWxkKSB7XG5cdFx0aWYgKF9tZXRhbC5hcnJheS5yZW1vdmUodGhpcy5nZXRDaGlsZHJlbigpLCBjaGlsZCkpIHtcblx0XHRcdHJldHVybiBjaGlsZDtcblx0XHR9XG5cdFx0cmV0dXJuIG51bGw7XG5cdH07XG5cblx0LyoqXG4gICogU2V0cyB0aGUgcGFyZW50IG5vZGUgb2YgdGhpcyBub2RlLiBUaGUgY2FsbGVycyBtdXN0IGVuc3VyZSB0aGF0IHRoZVxuICAqIHBhcmVudCBub2RlIGFuZCBvbmx5IHRoYXQgaGFzIHRoaXMgbm9kZSBhbW9uZyBpdHMgY2hpbGRyZW4uXG4gICogQHBhcmFtIHtUcmVlTm9kZX0gcGFyZW50IFRoZSBwYXJlbnQgdG8gc2V0LiBJZiBudWxsLCB0aGUgbm9kZSB3aWxsIGJlXG4gICogZGV0YWNoZWQgZnJvbSB0aGUgdHJlZS5cbiAgKiBAcHJvdGVjdGVkXG4gICovXG5cblxuXHRUcmVlTm9kZS5wcm90b3R5cGUuc2V0UGFyZW50ID0gZnVuY3Rpb24gc2V0UGFyZW50KHBhcmVudCkge1xuXHRcdHRoaXMucGFyZW50XyA9IHBhcmVudDtcblx0fTtcblxuXHQvKipcbiAgKiBUcmF2ZXJzZXMgdGhlIHN1YnRyZWUuIFRoZSBmaXJzdCBjYWxsYmFjayBzdGFydHMgd2l0aCB0aGlzIG5vZGUsXG4gICogYW5kIHZpc2l0cyB0aGUgZGVzY2VuZGFudCBub2RlcyBkZXB0aC1maXJzdCwgaW4gcHJlb3JkZXIuXG4gICogVGhlIHNlY29uZCBjYWxsYmFjaywgc3RhcnRzIHdpdGggZGVlcGVzdCBjaGlsZCB0aGVuIHZpc2l0c1xuICAqIHRoZSBhbmNlc3RvciBub2RlcyBkZXB0aC1maXJzdCwgaW4gcG9zdG9yZGVyLiBFLmcuXG4gICpcbiAgKiAgXHQgQVxuICAqICAgIC8gXFxcbiAgKiAgIEIgICBDXG4gICogIC8gICAvIFxcXG4gICogRCAgIEUgICBGXG4gICpcbiAgKiBwcmVvcmRlciAtPiBbJ0EnLCAnQicsICdEJywgJ0MnLCAnRScsICdGJ11cbiAgKiBwb3N0b3JkZXIgLT4gWydEJywgJ0InLCAnRScsICdGJywgJ0MnLCAnQSddXG4gICpcbiAgKiBAcGFyYW0ge2Z1bmN0aW9uPX0gb3B0X3ByZW9yZGVyRm4gVGhlIGNhbGxiYWNrIHRvIGV4ZWN1dGUgd2hlbiB2aXNpdGluZyBhIG5vZGUuXG4gICogQHBhcmFtIHtmdW5jdGlvbj19IG9wdF9wb3N0b3JkZXJGbiBUaGUgY2FsbGJhY2sgdG8gZXhlY3V0ZSBiZWZvcmUgbGVhdmluZyBhIG5vZGUuXG4gICovXG5cblxuXHRUcmVlTm9kZS5wcm90b3R5cGUudHJhdmVyc2UgPSBmdW5jdGlvbiB0cmF2ZXJzZShvcHRfcHJlb3JkZXJGbiwgb3B0X3Bvc3RvcmRlckZuKSB7XG5cdFx0aWYgKG9wdF9wcmVvcmRlckZuKSB7XG5cdFx0XHRvcHRfcHJlb3JkZXJGbih0aGlzKTtcblx0XHR9XG5cdFx0dGhpcy5nZXRDaGlsZHJlbigpLmZvckVhY2goZnVuY3Rpb24gKGNoaWxkKSB7XG5cdFx0XHRyZXR1cm4gY2hpbGQudHJhdmVyc2Uob3B0X3ByZW9yZGVyRm4sIG9wdF9wb3N0b3JkZXJGbik7XG5cdFx0fSk7XG5cdFx0aWYgKG9wdF9wb3N0b3JkZXJGbikge1xuXHRcdFx0b3B0X3Bvc3RvcmRlckZuKHRoaXMpO1xuXHRcdH1cblx0fTtcblxuXHRyZXR1cm4gVHJlZU5vZGU7XG59KCk7XG5cbi8qKlxuICogQ29uc3RhbnQgZm9yIGVtcHR5IGFycmF5IHRvIGF2b2lkIHVubmVjZXNzYXJ5IGFsbG9jYXRpb25zLlxuICogQHByaXZhdGVcbiAqL1xuXG5cblRyZWVOb2RlLkVNUFRZX0FSUkFZID0gW107XG5cbi8qKlxuICogQXNzZXJ0cyB0aGF0IGNoaWxkIGhhcyBubyBwYXJlbnQuXG4gKiBAcGFyYW0ge1RyZWVOb2RlfSBjaGlsZCBBIGNoaWxkLlxuICogQHByaXZhdGVcbiAqL1xudmFyIGFzc2VydENoaWxkSGFzTm9QYXJlbnQgPSBmdW5jdGlvbiBhc3NlcnRDaGlsZEhhc05vUGFyZW50KGNoaWxkKSB7XG5cdGlmIChjaGlsZC5nZXRQYXJlbnQoKSkge1xuXHRcdHRocm93IG5ldyBFcnJvcignQ2Fubm90IGFkZCBjaGlsZCB3aXRoIHBhcmVudC4nKTtcblx0fVxufTtcblxuZXhwb3J0cy5kZWZhdWx0ID0gVHJlZU5vZGU7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L21ldGFsLXN0cnVjdHMvbGliL1RyZWVOb2RlLmpzXG4vLyBtb2R1bGUgaWQgPSA0NFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuXHR2YWx1ZTogdHJ1ZVxufSk7XG5cbnZhciBfc2xpY2VkVG9BcnJheSA9IGZ1bmN0aW9uICgpIHsgZnVuY3Rpb24gc2xpY2VJdGVyYXRvcihhcnIsIGkpIHsgdmFyIF9hcnIgPSBbXTsgdmFyIF9uID0gdHJ1ZTsgdmFyIF9kID0gZmFsc2U7IHZhciBfZSA9IHVuZGVmaW5lZDsgdHJ5IHsgZm9yICh2YXIgX2kgPSBhcnJbU3ltYm9sLml0ZXJhdG9yXSgpLCBfczsgIShfbiA9IChfcyA9IF9pLm5leHQoKSkuZG9uZSk7IF9uID0gdHJ1ZSkgeyBfYXJyLnB1c2goX3MudmFsdWUpOyBpZiAoaSAmJiBfYXJyLmxlbmd0aCA9PT0gaSkgYnJlYWs7IH0gfSBjYXRjaCAoZXJyKSB7IF9kID0gdHJ1ZTsgX2UgPSBlcnI7IH0gZmluYWxseSB7IHRyeSB7IGlmICghX24gJiYgX2lbXCJyZXR1cm5cIl0pIF9pW1wicmV0dXJuXCJdKCk7IH0gZmluYWxseSB7IGlmIChfZCkgdGhyb3cgX2U7IH0gfSByZXR1cm4gX2FycjsgfSByZXR1cm4gZnVuY3Rpb24gKGFyciwgaSkgeyBpZiAoQXJyYXkuaXNBcnJheShhcnIpKSB7IHJldHVybiBhcnI7IH0gZWxzZSBpZiAoU3ltYm9sLml0ZXJhdG9yIGluIE9iamVjdChhcnIpKSB7IHJldHVybiBzbGljZUl0ZXJhdG9yKGFyciwgaSk7IH0gZWxzZSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJJbnZhbGlkIGF0dGVtcHQgdG8gZGVzdHJ1Y3R1cmUgbm9uLWl0ZXJhYmxlIGluc3RhbmNlXCIpOyB9IH07IH0oKTtcblxudmFyIF9jcmVhdGVDbGFzcyA9IGZ1bmN0aW9uICgpIHsgZnVuY3Rpb24gZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsgfSB9IHJldHVybiBmdW5jdGlvbiAoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyByZXR1cm4gQ29uc3RydWN0b3I7IH07IH0oKTtcblxudmFyIF9tZXRhbCA9IHJlcXVpcmUoJ21ldGFsJyk7XG5cbnZhciBfcGFyc2UgPSByZXF1aXJlKCcuL3BhcnNlJyk7XG5cbnZhciBfcGFyc2UyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfcGFyc2UpO1xuXG52YXIgX21ldGFsU3RydWN0cyA9IHJlcXVpcmUoJ21ldGFsLXN0cnVjdHMnKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxudmFyIHBhcnNlRm5fID0gX3BhcnNlMi5kZWZhdWx0O1xuXG52YXIgVXJpID0gZnVuY3Rpb24gKCkge1xuXG5cdC8qKlxuICAqIFRoaXMgY2xhc3MgY29udGFpbnMgc2V0dGVycyBhbmQgZ2V0dGVycyBmb3IgdGhlIHBhcnRzIG9mIHRoZSBVUkkuXG4gICogVGhlIGZvbGxvd2luZyBmaWd1cmUgZGlzcGxheXMgYW4gZXhhbXBsZSBVUklzIGFuZCB0aGVpciBjb21wb25lbnQgcGFydHMuXG4gICpcbiAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXRoXG4gICpcdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAg4pSM4pSA4pSA4pSA4pS04pSA4pSA4pSA4pSA4pSQXG4gICpcdCAgYWJjOi8vZXhhbXBsZS5jb206MTIzL3BhdGgvZGF0YT9rZXk9dmFsdWUjZnJhZ2lkMVxuICAqXHQgIOKUlOKUrOKUmCAgIOKUlOKUgOKUgOKUgOKUgOKUrOKUgOKUgOKUgOKUgOKUmCDilJTilKzilJggICAgICAgICAgIOKUlOKUgOKUgOKUgOKUrOKUgOKUgOKUgOKUmCDilJTilIDilIDilKzilIDilIDilJhcbiAgKiBwcm90b2NvbCAgaG9zdG5hbWUgIHBvcnQgICAgICAgICAgICBzZWFyY2ggICAgaGFzaFxuICAqICAgICAgICAgIOKUlOKUgOKUgOKUgOKUgOKUgOKUgOKUrOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUmFxuICAqICAgICAgICAgICAgICAgIGhvc3RcbiAgKlxuICAqIEBwYXJhbSB7Kj19IG9wdF91cmkgT3B0aW9uYWwgc3RyaW5nIFVSSSB0byBwYXJzZVxuICAqIEBjb25zdHJ1Y3RvclxuICAqL1xuXHRmdW5jdGlvbiBVcmkoKSB7XG5cdFx0dmFyIG9wdF91cmkgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6ICcnO1xuXG5cdFx0X2NsYXNzQ2FsbENoZWNrKHRoaXMsIFVyaSk7XG5cblx0XHR0aGlzLnVybCA9IFVyaS5wYXJzZSh0aGlzLm1heWJlQWRkUHJvdG9jb2xBbmRIb3N0bmFtZV8ob3B0X3VyaSkpO1xuXHR9XG5cblx0LyoqXG4gICogQWRkcyBwYXJhbWV0ZXJzIHRvIHVyaSBmcm9tIGEgPGNvZGU+TXVsdGlNYXA8L2NvZGU+IGFzIHNvdXJjZS5cbiAgKiBAcGFyYW0ge011bHRpTWFwfSBtdWx0aW1hcCBUaGUgPGNvZGU+TXVsdGlNYXA8L2NvZGU+IGNvbnRhaW5pbmcgdGhlXG4gICogICBwYXJhbWV0ZXJzLlxuICAqIEBwcm90ZWN0ZWRcbiAgKiBAY2hhaW5hYmxlXG4gICovXG5cblxuXHRfY3JlYXRlQ2xhc3MoVXJpLCBbe1xuXHRcdGtleTogJ2FkZFBhcmFtZXRlcnNGcm9tTXVsdGlNYXAnLFxuXHRcdHZhbHVlOiBmdW5jdGlvbiBhZGRQYXJhbWV0ZXJzRnJvbU11bHRpTWFwKG11bHRpbWFwKSB7XG5cdFx0XHR2YXIgX3RoaXMgPSB0aGlzO1xuXG5cdFx0XHRtdWx0aW1hcC5uYW1lcygpLmZvckVhY2goZnVuY3Rpb24gKG5hbWUpIHtcblx0XHRcdFx0bXVsdGltYXAuZ2V0QWxsKG5hbWUpLmZvckVhY2goZnVuY3Rpb24gKHZhbHVlKSB7XG5cdFx0XHRcdFx0X3RoaXMuYWRkUGFyYW1ldGVyVmFsdWUobmFtZSwgdmFsdWUpO1xuXHRcdFx0XHR9KTtcblx0XHRcdH0pO1xuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fVxuXG5cdFx0LyoqXG4gICAqIEFkZHMgdGhlIHZhbHVlIG9mIHRoZSBuYW1lZCBxdWVyeSBwYXJhbWV0ZXJzLlxuICAgKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBwYXJhbWV0ZXIgdG8gc2V0LlxuICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSBuZXcgdmFsdWUuIFdpbGwgYmUgZXhwbGljaXRseSBjYXN0ZWQgdG8gU3RyaW5nLlxuICAgKiBAY2hhaW5hYmxlXG4gICAqL1xuXG5cdH0sIHtcblx0XHRrZXk6ICdhZGRQYXJhbWV0ZXJWYWx1ZScsXG5cdFx0dmFsdWU6IGZ1bmN0aW9uIGFkZFBhcmFtZXRlclZhbHVlKG5hbWUsIHZhbHVlKSB7XG5cdFx0XHR0aGlzLmVuc3VyZVF1ZXJ5SW5pdGlhbGl6ZWRfKCk7XG5cdFx0XHRpZiAoKDAsIF9tZXRhbC5pc0RlZikodmFsdWUpKSB7XG5cdFx0XHRcdHZhbHVlID0gU3RyaW5nKHZhbHVlKTtcblx0XHRcdH1cblx0XHRcdHRoaXMucXVlcnkuYWRkKG5hbWUsIHZhbHVlKTtcblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH1cblxuXHRcdC8qKlxuICAgKiBBZGRzIHRoZSB2YWx1ZXMgb2YgdGhlIG5hbWVkIHF1ZXJ5IHBhcmFtZXRlci5cbiAgICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUgcGFyYW1ldGVyIHRvIHNldC5cbiAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgbmV3IHZhbHVlLlxuICAgKiBAY2hhaW5hYmxlXG4gICAqL1xuXG5cdH0sIHtcblx0XHRrZXk6ICdhZGRQYXJhbWV0ZXJWYWx1ZXMnLFxuXHRcdHZhbHVlOiBmdW5jdGlvbiBhZGRQYXJhbWV0ZXJWYWx1ZXMobmFtZSwgdmFsdWVzKSB7XG5cdFx0XHR2YXIgX3RoaXMyID0gdGhpcztcblxuXHRcdFx0dmFsdWVzLmZvckVhY2goZnVuY3Rpb24gKHZhbHVlKSB7XG5cdFx0XHRcdHJldHVybiBfdGhpczIuYWRkUGFyYW1ldGVyVmFsdWUobmFtZSwgdmFsdWUpO1xuXHRcdFx0fSk7XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9XG5cblx0XHQvKipcbiAgICogRW5zdXJlcyBxdWVyeSBpbnRlcm5hbCBtYXAgaXMgaW5pdGlhbGl6ZWQgYW5kIHN5bmNlZCB3aXRoIGluaXRpYWwgdmFsdWVcbiAgICogZXh0cmFjdGVkIGZyb20gVVJJIHNlYXJjaCBwYXJ0LlxuICAgKiBAcHJvdGVjdGVkXG4gICAqL1xuXG5cdH0sIHtcblx0XHRrZXk6ICdlbnN1cmVRdWVyeUluaXRpYWxpemVkXycsXG5cdFx0dmFsdWU6IGZ1bmN0aW9uIGVuc3VyZVF1ZXJ5SW5pdGlhbGl6ZWRfKCkge1xuXHRcdFx0dmFyIF90aGlzMyA9IHRoaXM7XG5cblx0XHRcdGlmICh0aGlzLnF1ZXJ5KSB7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblx0XHRcdHRoaXMucXVlcnkgPSBuZXcgX21ldGFsU3RydWN0cy5NdWx0aU1hcCgpO1xuXHRcdFx0dmFyIHNlYXJjaCA9IHRoaXMudXJsLnNlYXJjaDtcblx0XHRcdGlmIChzZWFyY2gpIHtcblx0XHRcdFx0c2VhcmNoLnN1YnN0cmluZygxKS5zcGxpdCgnJicpLmZvckVhY2goZnVuY3Rpb24gKHBhcmFtKSB7XG5cdFx0XHRcdFx0dmFyIF9wYXJhbSRzcGxpdCA9IHBhcmFtLnNwbGl0KCc9JyksXG5cdFx0XHRcdFx0ICAgIF9wYXJhbSRzcGxpdDIgPSBfc2xpY2VkVG9BcnJheShfcGFyYW0kc3BsaXQsIDIpLFxuXHRcdFx0XHRcdCAgICBrZXkgPSBfcGFyYW0kc3BsaXQyWzBdLFxuXHRcdFx0XHRcdCAgICB2YWx1ZSA9IF9wYXJhbSRzcGxpdDJbMV07XG5cblx0XHRcdFx0XHRpZiAoKDAsIF9tZXRhbC5pc0RlZikodmFsdWUpKSB7XG5cdFx0XHRcdFx0XHR2YWx1ZSA9IFVyaS51cmxEZWNvZGUodmFsdWUpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRfdGhpczMuYWRkUGFyYW1ldGVyVmFsdWUoa2V5LCB2YWx1ZSk7XG5cdFx0XHRcdH0pO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8qKlxuICAgKiBHZXRzIHRoZSBoYXNoIHBhcnQgb2YgdXJpLlxuICAgKiBAcmV0dXJuIHtzdHJpbmd9XG4gICAqL1xuXG5cdH0sIHtcblx0XHRrZXk6ICdnZXRIYXNoJyxcblx0XHR2YWx1ZTogZnVuY3Rpb24gZ2V0SGFzaCgpIHtcblx0XHRcdHJldHVybiB0aGlzLnVybC5oYXNoIHx8ICcnO1xuXHRcdH1cblxuXHRcdC8qKlxuICAgKiBHZXRzIHRoZSBob3N0IHBhcnQgb2YgdXJpLiBFLmcuIDxjb2RlPltob3N0bmFtZV06W3BvcnRdPC9jb2RlPi5cbiAgICogQHJldHVybiB7c3RyaW5nfVxuICAgKi9cblxuXHR9LCB7XG5cdFx0a2V5OiAnZ2V0SG9zdCcsXG5cdFx0dmFsdWU6IGZ1bmN0aW9uIGdldEhvc3QoKSB7XG5cdFx0XHR2YXIgaG9zdCA9IHRoaXMuZ2V0SG9zdG5hbWUoKTtcblx0XHRcdGlmIChob3N0KSB7XG5cdFx0XHRcdHZhciBwb3J0ID0gdGhpcy5nZXRQb3J0KCk7XG5cdFx0XHRcdGlmIChwb3J0ICYmIHBvcnQgIT09ICc4MCcpIHtcblx0XHRcdFx0XHRob3N0ICs9ICc6JyArIHBvcnQ7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdHJldHVybiBob3N0O1xuXHRcdH1cblxuXHRcdC8qKlxuICAgKiBHZXRzIHRoZSBob3N0bmFtZSBwYXJ0IG9mIHVyaSB3aXRob3V0IHByb3RvY29sIGFuZCBwb3J0LlxuICAgKiBAcmV0dXJuIHtzdHJpbmd9XG4gICAqL1xuXG5cdH0sIHtcblx0XHRrZXk6ICdnZXRIb3N0bmFtZScsXG5cdFx0dmFsdWU6IGZ1bmN0aW9uIGdldEhvc3RuYW1lKCkge1xuXHRcdFx0dmFyIGhvc3RuYW1lID0gdGhpcy51cmwuaG9zdG5hbWU7XG5cdFx0XHRpZiAoaG9zdG5hbWUgPT09IFVyaS5IT1NUTkFNRV9QTEFDRUhPTERFUikge1xuXHRcdFx0XHRyZXR1cm4gJyc7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gaG9zdG5hbWU7XG5cdFx0fVxuXG5cdFx0LyoqXG4gICAqIEdldHMgdGhlIG9yaWdpbiBwYXJ0IG9mIHVyaS4gRS5nLiA8Y29kZT5odHRwOi8vW2hvc3RuYW1lXTpbcG9ydF08L2NvZGU+LlxuICAgKiBAcmV0dXJuIHtzdHJpbmd9XG4gICAqL1xuXG5cdH0sIHtcblx0XHRrZXk6ICdnZXRPcmlnaW4nLFxuXHRcdHZhbHVlOiBmdW5jdGlvbiBnZXRPcmlnaW4oKSB7XG5cdFx0XHR2YXIgaG9zdCA9IHRoaXMuZ2V0SG9zdCgpO1xuXHRcdFx0aWYgKGhvc3QpIHtcblx0XHRcdFx0cmV0dXJuIHRoaXMuZ2V0UHJvdG9jb2woKSArICcvLycgKyBob3N0O1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuICcnO1xuXHRcdH1cblxuXHRcdC8qKlxuICAgKiBSZXR1cm5zIHRoZSBmaXJzdCB2YWx1ZSBmb3IgYSBnaXZlbiBwYXJhbWV0ZXIgb3IgdW5kZWZpbmVkIGlmIHRoZSBnaXZlblxuICAgKiBwYXJhbWV0ZXIgbmFtZSBkb2VzIG5vdCBhcHBlYXIgaW4gdGhlIHF1ZXJ5IHN0cmluZy5cbiAgICogQHBhcmFtIHtzdHJpbmd9IHBhcmFtTmFtZSBVbmVzY2FwZWQgcGFyYW1ldGVyIG5hbWUuXG4gICAqIEByZXR1cm4ge3N0cmluZ3x1bmRlZmluZWR9IFRoZSBmaXJzdCB2YWx1ZSBmb3IgYSBnaXZlbiBwYXJhbWV0ZXIgb3JcbiAgICogICB1bmRlZmluZWQgaWYgdGhlIGdpdmVuIHBhcmFtZXRlciBuYW1lIGRvZXMgbm90IGFwcGVhciBpbiB0aGUgcXVlcnlcbiAgICogICBzdHJpbmcuXG4gICAqL1xuXG5cdH0sIHtcblx0XHRrZXk6ICdnZXRQYXJhbWV0ZXJWYWx1ZScsXG5cdFx0dmFsdWU6IGZ1bmN0aW9uIGdldFBhcmFtZXRlclZhbHVlKG5hbWUpIHtcblx0XHRcdHRoaXMuZW5zdXJlUXVlcnlJbml0aWFsaXplZF8oKTtcblx0XHRcdHJldHVybiB0aGlzLnF1ZXJ5LmdldChuYW1lKTtcblx0XHR9XG5cblx0XHQvKipcbiAgICogUmV0dXJucyB0aGUgdmFsdWU8Yj5zPC9iPiBmb3IgYSBnaXZlbiBwYXJhbWV0ZXIgYXMgYSBsaXN0IG9mIGRlY29kZWRcbiAgICogcXVlcnkgcGFyYW1ldGVyIHZhbHVlcy5cbiAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgVGhlIHBhcmFtZXRlciB0byBnZXQgdmFsdWVzIGZvci5cbiAgICogQHJldHVybiB7IUFycmF5PD8+fSBUaGUgdmFsdWVzIGZvciBhIGdpdmVuIHBhcmFtZXRlciBhcyBhIGxpc3Qgb2YgZGVjb2RlZFxuICAgKiAgIHF1ZXJ5IHBhcmFtZXRlciB2YWx1ZXMuXG4gICAqL1xuXG5cdH0sIHtcblx0XHRrZXk6ICdnZXRQYXJhbWV0ZXJWYWx1ZXMnLFxuXHRcdHZhbHVlOiBmdW5jdGlvbiBnZXRQYXJhbWV0ZXJWYWx1ZXMobmFtZSkge1xuXHRcdFx0dGhpcy5lbnN1cmVRdWVyeUluaXRpYWxpemVkXygpO1xuXHRcdFx0cmV0dXJuIHRoaXMucXVlcnkuZ2V0QWxsKG5hbWUpO1xuXHRcdH1cblxuXHRcdC8qKlxuICAgKiBSZXR1cm5zIHRoZSBuYW1lPGI+czwvYj4gb2YgdGhlIHBhcmFtZXRlcnMuXG4gICAqIEByZXR1cm4geyFBcnJheTxzdHJpbmc+fSBUaGUgbmFtZXMgZm9yIHRoZSBwYXJhbWV0ZXJzIGFzIGEgbGlzdCBvZlxuICAgKiAgIHN0cmluZ3MuXG4gICAqL1xuXG5cdH0sIHtcblx0XHRrZXk6ICdnZXRQYXJhbWV0ZXJOYW1lcycsXG5cdFx0dmFsdWU6IGZ1bmN0aW9uIGdldFBhcmFtZXRlck5hbWVzKCkge1xuXHRcdFx0dGhpcy5lbnN1cmVRdWVyeUluaXRpYWxpemVkXygpO1xuXHRcdFx0cmV0dXJuIHRoaXMucXVlcnkubmFtZXMoKTtcblx0XHR9XG5cblx0XHQvKipcbiAgICogR2V0cyB0aGUgZnVuY3Rpb24gY3VycmVudGx5IGJlaW5nIHVzZWQgdG8gcGFyc2UgVVJJcy5cbiAgICogQHJldHVybiB7IWZ1bmN0aW9uKCl9XG4gICAqL1xuXG5cdH0sIHtcblx0XHRrZXk6ICdnZXRQYXRobmFtZScsXG5cblxuXHRcdC8qKlxuICAgKiBHZXRzIHRoZSBwYXRobmFtZSBwYXJ0IG9mIHVyaS5cbiAgICogQHJldHVybiB7c3RyaW5nfVxuICAgKi9cblx0XHR2YWx1ZTogZnVuY3Rpb24gZ2V0UGF0aG5hbWUoKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy51cmwucGF0aG5hbWU7XG5cdFx0fVxuXG5cdFx0LyoqXG4gICAqIEdldHMgdGhlIHBvcnQgbnVtYmVyIHBhcnQgb2YgdXJpIGFzIHN0cmluZy5cbiAgICogQHJldHVybiB7c3RyaW5nfVxuICAgKi9cblxuXHR9LCB7XG5cdFx0a2V5OiAnZ2V0UG9ydCcsXG5cdFx0dmFsdWU6IGZ1bmN0aW9uIGdldFBvcnQoKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy51cmwucG9ydDtcblx0XHR9XG5cblx0XHQvKipcbiAgICogR2V0cyB0aGUgcHJvdG9jb2wgcGFydCBvZiB1cmkuIEUuZy4gPGNvZGU+aHR0cDo8L2NvZGU+LlxuICAgKiBAcmV0dXJuIHtzdHJpbmd9XG4gICAqL1xuXG5cdH0sIHtcblx0XHRrZXk6ICdnZXRQcm90b2NvbCcsXG5cdFx0dmFsdWU6IGZ1bmN0aW9uIGdldFByb3RvY29sKCkge1xuXHRcdFx0cmV0dXJuIHRoaXMudXJsLnByb3RvY29sO1xuXHRcdH1cblxuXHRcdC8qKlxuICAgKiBHZXRzIHRoZSBzZWFyY2ggcGFydCBvZiB1cmkuIFNlYXJjaCB2YWx1ZSBpcyByZXRyaWV2ZWQgZnJvbSBxdWVyeVxuICAgKiBwYXJhbWV0ZXJzLlxuICAgKiBAcmV0dXJuIHtzdHJpbmd9XG4gICAqL1xuXG5cdH0sIHtcblx0XHRrZXk6ICdnZXRTZWFyY2gnLFxuXHRcdHZhbHVlOiBmdW5jdGlvbiBnZXRTZWFyY2goKSB7XG5cdFx0XHR2YXIgX3RoaXM0ID0gdGhpcztcblxuXHRcdFx0dmFyIHNlYXJjaCA9ICcnO1xuXHRcdFx0dmFyIHF1ZXJ5c3RyaW5nID0gJyc7XG5cdFx0XHR0aGlzLmdldFBhcmFtZXRlck5hbWVzKCkuZm9yRWFjaChmdW5jdGlvbiAobmFtZSkge1xuXHRcdFx0XHRfdGhpczQuZ2V0UGFyYW1ldGVyVmFsdWVzKG5hbWUpLmZvckVhY2goZnVuY3Rpb24gKHZhbHVlKSB7XG5cdFx0XHRcdFx0cXVlcnlzdHJpbmcgKz0gbmFtZTtcblx0XHRcdFx0XHRpZiAoKDAsIF9tZXRhbC5pc0RlZikodmFsdWUpKSB7XG5cdFx0XHRcdFx0XHRxdWVyeXN0cmluZyArPSAnPScgKyBlbmNvZGVVUklDb21wb25lbnQodmFsdWUpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRxdWVyeXN0cmluZyArPSAnJic7XG5cdFx0XHRcdH0pO1xuXHRcdFx0fSk7XG5cdFx0XHRxdWVyeXN0cmluZyA9IHF1ZXJ5c3RyaW5nLnNsaWNlKDAsIC0xKTtcblx0XHRcdGlmIChxdWVyeXN0cmluZykge1xuXHRcdFx0XHRzZWFyY2ggKz0gJz8nICsgcXVlcnlzdHJpbmc7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gc2VhcmNoO1xuXHRcdH1cblxuXHRcdC8qKlxuICAgKiBDaGVja3MgaWYgdXJpIGNvbnRhaW5zIHRoZSBwYXJhbWV0ZXIuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59XG4gICAqL1xuXG5cdH0sIHtcblx0XHRrZXk6ICdoYXNQYXJhbWV0ZXInLFxuXHRcdHZhbHVlOiBmdW5jdGlvbiBoYXNQYXJhbWV0ZXIobmFtZSkge1xuXHRcdFx0dGhpcy5lbnN1cmVRdWVyeUluaXRpYWxpemVkXygpO1xuXHRcdFx0cmV0dXJuIHRoaXMucXVlcnkuY29udGFpbnMobmFtZSk7XG5cdFx0fVxuXG5cdFx0LyoqXG4gICAqIE1ha2VzIHRoaXMgVVJMIHVuaXF1ZSBieSBhZGRpbmcgYSByYW5kb20gcGFyYW0gdG8gaXQuIFVzZWZ1bCBmb3IgYXZvaWRpbmdcbiAgICogY2FjaGUuXG4gICAqL1xuXG5cdH0sIHtcblx0XHRrZXk6ICdtYWtlVW5pcXVlJyxcblx0XHR2YWx1ZTogZnVuY3Rpb24gbWFrZVVuaXF1ZSgpIHtcblx0XHRcdHRoaXMuc2V0UGFyYW1ldGVyVmFsdWUoVXJpLlJBTkRPTV9QQVJBTSwgX21ldGFsLnN0cmluZy5nZXRSYW5kb21TdHJpbmcoKSk7XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9XG5cblx0XHQvKipcbiAgICogTWF5YmUgYWRkcyBwcm90b2NvbCBhbmQgYSBob3N0bmFtZSBwbGFjZWhvbGRlciBvbiBhIHBhcmlhbCBVUkkgaWYgbmVlZGVkLlxuICAgKiBSZWxldmVudCBmb3IgY29tcGF0aWJpbGl0eSB3aXRoIDxjb2RlPlVSTDwvY29kZT4gbmF0aXZlIG9iamVjdC5cbiAgICogQHBhcmFtIHtzdHJpbmc9fSBvcHRfdXJpXG4gICAqIEByZXR1cm4ge3N0cmluZ30gVVJJIHdpdGggcHJvdG9jb2wgYW5kIGhvc3RuYW1lIHBsYWNlaG9sZGVyLlxuICAgKi9cblxuXHR9LCB7XG5cdFx0a2V5OiAnbWF5YmVBZGRQcm90b2NvbEFuZEhvc3RuYW1lXycsXG5cdFx0dmFsdWU6IGZ1bmN0aW9uIG1heWJlQWRkUHJvdG9jb2xBbmRIb3N0bmFtZV8ob3B0X3VyaSkge1xuXHRcdFx0dmFyIHVybCA9IG9wdF91cmk7XG5cdFx0XHRpZiAob3B0X3VyaS5pbmRleE9mKCc6Ly8nKSA9PT0gLTEgJiYgb3B0X3VyaS5pbmRleE9mKCdqYXZhc2NyaXB0OicpICE9PSAwKSB7XG5cdFx0XHRcdC8vIGpzaGludCBpZ25vcmU6bGluZVxuXG5cdFx0XHRcdHVybCA9IFVyaS5ERUZBVUxUX1BST1RPQ09MO1xuXHRcdFx0XHRpZiAob3B0X3VyaVswXSAhPT0gJy8nIHx8IG9wdF91cmlbMV0gIT09ICcvJykge1xuXHRcdFx0XHRcdHVybCArPSAnLy8nO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0c3dpdGNoIChvcHRfdXJpLmNoYXJBdCgwKSkge1xuXHRcdFx0XHRcdGNhc2UgJy4nOlxuXHRcdFx0XHRcdGNhc2UgJz8nOlxuXHRcdFx0XHRcdGNhc2UgJyMnOlxuXHRcdFx0XHRcdFx0dXJsICs9IFVyaS5IT1NUTkFNRV9QTEFDRUhPTERFUjtcblx0XHRcdFx0XHRcdHVybCArPSAnLyc7XG5cdFx0XHRcdFx0XHR1cmwgKz0gb3B0X3VyaTtcblx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdGNhc2UgJyc6XG5cdFx0XHRcdFx0Y2FzZSAnLyc6XG5cdFx0XHRcdFx0XHRpZiAob3B0X3VyaVsxXSAhPT0gJy8nKSB7XG5cdFx0XHRcdFx0XHRcdHVybCArPSBVcmkuSE9TVE5BTUVfUExBQ0VIT0xERVI7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR1cmwgKz0gb3B0X3VyaTtcblx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdGRlZmF1bHQ6XG5cdFx0XHRcdFx0XHR1cmwgKz0gb3B0X3VyaTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHVybDtcblx0XHR9XG5cblx0XHQvKipcbiAgICogUGFyc2VzIHRoZSBnaXZlbiB1cmkgc3RyaW5nIGludG8gYW4gb2JqZWN0LlxuICAgKiBAcGFyYW0geyo9fSBvcHRfdXJpIE9wdGlvbmFsIHN0cmluZyBVUkkgdG8gcGFyc2VcbiAgICovXG5cblx0fSwge1xuXHRcdGtleTogJ3JlbW92ZVBhcmFtZXRlcicsXG5cblxuXHRcdC8qKlxuICAgKiBSZW1vdmVzIHRoZSBuYW1lZCBxdWVyeSBwYXJhbWV0ZXIuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIFRoZSBwYXJhbWV0ZXIgdG8gcmVtb3ZlLlxuICAgKiBAY2hhaW5hYmxlXG4gICAqL1xuXHRcdHZhbHVlOiBmdW5jdGlvbiByZW1vdmVQYXJhbWV0ZXIobmFtZSkge1xuXHRcdFx0dGhpcy5lbnN1cmVRdWVyeUluaXRpYWxpemVkXygpO1xuXHRcdFx0dGhpcy5xdWVyeS5yZW1vdmUobmFtZSk7XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9XG5cblx0XHQvKipcbiAgICogUmVtb3ZlcyB1bmlxdWVuZXNzIHBhcmFtZXRlciBvZiB0aGUgdXJpLlxuICAgKiBAY2hhaW5hYmxlXG4gICAqL1xuXG5cdH0sIHtcblx0XHRrZXk6ICdyZW1vdmVVbmlxdWUnLFxuXHRcdHZhbHVlOiBmdW5jdGlvbiByZW1vdmVVbmlxdWUoKSB7XG5cdFx0XHR0aGlzLnJlbW92ZVBhcmFtZXRlcihVcmkuUkFORE9NX1BBUkFNKTtcblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH1cblxuXHRcdC8qKlxuICAgKiBTZXRzIHRoZSBoYXNoLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gaGFzaFxuICAgKiBAY2hhaW5hYmxlXG4gICAqL1xuXG5cdH0sIHtcblx0XHRrZXk6ICdzZXRIYXNoJyxcblx0XHR2YWx1ZTogZnVuY3Rpb24gc2V0SGFzaChoYXNoKSB7XG5cdFx0XHR0aGlzLnVybC5oYXNoID0gaGFzaDtcblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH1cblxuXHRcdC8qKlxuICAgKiBTZXRzIHRoZSBob3N0bmFtZS5cbiAgICogQHBhcmFtIHtzdHJpbmd9IGhvc3RuYW1lXG4gICAqIEBjaGFpbmFibGVcbiAgICovXG5cblx0fSwge1xuXHRcdGtleTogJ3NldEhvc3RuYW1lJyxcblx0XHR2YWx1ZTogZnVuY3Rpb24gc2V0SG9zdG5hbWUoaG9zdG5hbWUpIHtcblx0XHRcdHRoaXMudXJsLmhvc3RuYW1lID0gaG9zdG5hbWU7XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9XG5cblx0XHQvKipcbiAgICogU2V0cyB0aGUgdmFsdWUgb2YgdGhlIG5hbWVkIHF1ZXJ5IHBhcmFtZXRlcnMsIGNsZWFyaW5nIHByZXZpb3VzIHZhbHVlc1xuICAgKiBmb3IgdGhhdCBrZXkuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIHBhcmFtZXRlciB0byBzZXQuXG4gICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIG5ldyB2YWx1ZS5cbiAgICogQGNoYWluYWJsZVxuICAgKi9cblxuXHR9LCB7XG5cdFx0a2V5OiAnc2V0UGFyYW1ldGVyVmFsdWUnLFxuXHRcdHZhbHVlOiBmdW5jdGlvbiBzZXRQYXJhbWV0ZXJWYWx1ZShuYW1lLCB2YWx1ZSkge1xuXHRcdFx0dGhpcy5yZW1vdmVQYXJhbWV0ZXIobmFtZSk7XG5cdFx0XHR0aGlzLmFkZFBhcmFtZXRlclZhbHVlKG5hbWUsIHZhbHVlKTtcblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH1cblxuXHRcdC8qKlxuICAgKiBTZXRzIHRoZSB2YWx1ZXMgb2YgdGhlIG5hbWVkIHF1ZXJ5IHBhcmFtZXRlcnMsIGNsZWFyaW5nIHByZXZpb3VzIHZhbHVlc1xuICAgKiBmb3IgdGhhdCBrZXkuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIHBhcmFtZXRlciB0byBzZXQuXG4gICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIG5ldyB2YWx1ZS5cbiAgICogQGNoYWluYWJsZVxuICAgKi9cblxuXHR9LCB7XG5cdFx0a2V5OiAnc2V0UGFyYW1ldGVyVmFsdWVzJyxcblx0XHR2YWx1ZTogZnVuY3Rpb24gc2V0UGFyYW1ldGVyVmFsdWVzKG5hbWUsIHZhbHVlcykge1xuXHRcdFx0dmFyIF90aGlzNSA9IHRoaXM7XG5cblx0XHRcdHRoaXMucmVtb3ZlUGFyYW1ldGVyKG5hbWUpO1xuXHRcdFx0dmFsdWVzLmZvckVhY2goZnVuY3Rpb24gKHZhbHVlKSB7XG5cdFx0XHRcdHJldHVybiBfdGhpczUuYWRkUGFyYW1ldGVyVmFsdWUobmFtZSwgdmFsdWUpO1xuXHRcdFx0fSk7XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9XG5cblx0XHQvKipcbiAgICogU2V0cyB0aGUgcGF0aG5hbWUuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBwYXRobmFtZVxuICAgKiBAY2hhaW5hYmxlXG4gICAqL1xuXG5cdH0sIHtcblx0XHRrZXk6ICdzZXRQYXRobmFtZScsXG5cdFx0dmFsdWU6IGZ1bmN0aW9uIHNldFBhdGhuYW1lKHBhdGhuYW1lKSB7XG5cdFx0XHR0aGlzLnVybC5wYXRobmFtZSA9IHBhdGhuYW1lO1xuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fVxuXG5cdFx0LyoqXG4gICAqIFNldHMgdGhlIHBvcnQgbnVtYmVyLlxuICAgKiBAcGFyYW0geyp9IHBvcnQgUG9ydCBudW1iZXIuXG4gICAqIEBjaGFpbmFibGVcbiAgICovXG5cblx0fSwge1xuXHRcdGtleTogJ3NldFBvcnQnLFxuXHRcdHZhbHVlOiBmdW5jdGlvbiBzZXRQb3J0KHBvcnQpIHtcblx0XHRcdHRoaXMudXJsLnBvcnQgPSBwb3J0O1xuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fVxuXG5cdFx0LyoqXG4gICAqIFNldHMgdGhlIGZ1bmN0aW9uIHRoYXQgd2lsbCBiZSB1c2VkIGZvciBwYXJzaW5nIHRoZSBvcmlnaW5hbCBzdHJpbmcgdXJpXG4gICAqIGludG8gYW4gb2JqZWN0LlxuICAgKiBAcGFyYW0geyFmdW5jdGlvbigpfSBwYXJzZUZuXG4gICAqL1xuXG5cdH0sIHtcblx0XHRrZXk6ICdzZXRQcm90b2NvbCcsXG5cblxuXHRcdC8qKlxuICAgKiBTZXRzIHRoZSBwcm90b2NvbC4gSWYgbWlzc2luZyA8Y29kZT5odHRwOjwvY29kZT4gaXMgdXNlZCBhcyBkZWZhdWx0LlxuICAgKiBAcGFyYW0ge3N0cmluZ30gcHJvdG9jb2xcbiAgICogQGNoYWluYWJsZVxuICAgKi9cblx0XHR2YWx1ZTogZnVuY3Rpb24gc2V0UHJvdG9jb2wocHJvdG9jb2wpIHtcblx0XHRcdHRoaXMudXJsLnByb3RvY29sID0gcHJvdG9jb2w7XG5cdFx0XHRpZiAodGhpcy51cmwucHJvdG9jb2xbdGhpcy51cmwucHJvdG9jb2wubGVuZ3RoIC0gMV0gIT09ICc6Jykge1xuXHRcdFx0XHR0aGlzLnVybC5wcm90b2NvbCArPSAnOic7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9XG5cblx0XHQvKipcbiAgICogQHJldHVybiB7c3RyaW5nfSBUaGUgc3RyaW5nIGZvcm0gb2YgdGhlIHVybC5cbiAgICogQG92ZXJyaWRlXG4gICAqL1xuXG5cdH0sIHtcblx0XHRrZXk6ICd0b1N0cmluZycsXG5cdFx0dmFsdWU6IGZ1bmN0aW9uIHRvU3RyaW5nKCkge1xuXHRcdFx0dmFyIGhyZWYgPSAnJztcblx0XHRcdHZhciBob3N0ID0gdGhpcy5nZXRIb3N0KCk7XG5cdFx0XHRpZiAoaG9zdCkge1xuXHRcdFx0XHRocmVmICs9IHRoaXMuZ2V0UHJvdG9jb2woKSArICcvLyc7XG5cdFx0XHR9XG5cdFx0XHRocmVmICs9IGhvc3QgKyB0aGlzLmdldFBhdGhuYW1lKCkgKyB0aGlzLmdldFNlYXJjaCgpICsgdGhpcy5nZXRIYXNoKCk7XG5cdFx0XHRyZXR1cm4gaHJlZjtcblx0XHR9XG5cblx0XHQvKipcbiAgICogSm9pbnMgdGhlIGdpdmVuIHBhdGhzLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gYmFzZVBhdGhcbiAgICogQHBhcmFtIHsuLi5zdHJpbmd9IC4uLnBhdGhzIEFueSBudW1iZXIgb2YgcGF0aHMgdG8gYmUgam9pbmVkIHdpdGggdGhlIGJhc2UgdXJsLlxuICAgKiBAc3RhdGljXG4gICAqL1xuXG5cdH1dLCBbe1xuXHRcdGtleTogJ2dldFBhcnNlRm4nLFxuXHRcdHZhbHVlOiBmdW5jdGlvbiBnZXRQYXJzZUZuKCkge1xuXHRcdFx0cmV0dXJuIHBhcnNlRm5fO1xuXHRcdH1cblx0fSwge1xuXHRcdGtleTogJ3BhcnNlJyxcblx0XHR2YWx1ZTogZnVuY3Rpb24gcGFyc2Uob3B0X3VyaSkge1xuXHRcdFx0cmV0dXJuIHBhcnNlRm5fKG9wdF91cmkpO1xuXHRcdH1cblx0fSwge1xuXHRcdGtleTogJ3NldFBhcnNlRm4nLFxuXHRcdHZhbHVlOiBmdW5jdGlvbiBzZXRQYXJzZUZuKHBhcnNlRm4pIHtcblx0XHRcdHBhcnNlRm5fID0gcGFyc2VGbjtcblx0XHR9XG5cdH0sIHtcblx0XHRrZXk6ICdqb2luUGF0aHMnLFxuXHRcdHZhbHVlOiBmdW5jdGlvbiBqb2luUGF0aHMoYmFzZVBhdGgpIHtcblx0XHRcdGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBwYXRocyA9IEFycmF5KF9sZW4gPiAxID8gX2xlbiAtIDEgOiAwKSwgX2tleSA9IDE7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcblx0XHRcdFx0cGF0aHNbX2tleSAtIDFdID0gYXJndW1lbnRzW19rZXldO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAoYmFzZVBhdGguY2hhckF0KGJhc2VQYXRoLmxlbmd0aCAtIDEpID09PSAnLycpIHtcblx0XHRcdFx0YmFzZVBhdGggPSBiYXNlUGF0aC5zdWJzdHJpbmcoMCwgYmFzZVBhdGgubGVuZ3RoIC0gMSk7XG5cdFx0XHR9XG5cdFx0XHRwYXRocyA9IHBhdGhzLm1hcChmdW5jdGlvbiAocGF0aCkge1xuXHRcdFx0XHRyZXR1cm4gcGF0aC5jaGFyQXQoMCkgPT09ICcvJyA/IHBhdGguc3Vic3RyaW5nKDEpIDogcGF0aDtcblx0XHRcdH0pO1xuXHRcdFx0cmV0dXJuIFtiYXNlUGF0aF0uY29uY2F0KHBhdGhzKS5qb2luKCcvJykucmVwbGFjZSgvXFwvJC8sICcnKTtcblx0XHR9XG5cblx0XHQvKipcbiAgICogVVJMLWRlY29kZXMgdGhlIHN0cmluZy4gV2UgbmVlZCB0byBzcGVjaWFsbHkgaGFuZGxlICcrJ3MgYmVjYXVzZVxuICAgKiB0aGUgamF2YXNjcmlwdCBsaWJyYXJ5IGRvZXNuJ3QgY29udmVydCB0aGVtIHRvIHNwYWNlcy5cbiAgICogQHBhcmFtIHtzdHJpbmd9IHN0ciBUaGUgc3RyaW5nIHRvIHVybCBkZWNvZGUuXG4gICAqIEByZXR1cm4ge3N0cmluZ30gVGhlIGRlY29kZWQge0Bjb2RlIHN0cn0uXG4gICAqL1xuXG5cdH0sIHtcblx0XHRrZXk6ICd1cmxEZWNvZGUnLFxuXHRcdHZhbHVlOiBmdW5jdGlvbiB1cmxEZWNvZGUoc3RyKSB7XG5cdFx0XHRyZXR1cm4gZGVjb2RlVVJJQ29tcG9uZW50KHN0ci5yZXBsYWNlKC9cXCsvZywgJyAnKSk7XG5cdFx0fVxuXHR9XSk7XG5cblx0cmV0dXJuIFVyaTtcbn0oKTtcblxuLyoqXG4gKiBEZWZhdWx0IHByb3RvY29sIHZhbHVlLlxuICogQHR5cGUge3N0cmluZ31cbiAqIEBkZWZhdWx0IGh0dHA6XG4gKiBAc3RhdGljXG4gKi9cblxuXG52YXIgaXNTZWN1cmUgPSBmdW5jdGlvbiBpc1NlY3VyZSgpIHtcblx0cmV0dXJuIHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmIHdpbmRvdy5sb2NhdGlvbiAmJiB3aW5kb3cubG9jYXRpb24ucHJvdG9jb2wgJiYgd2luZG93LmxvY2F0aW9uLnByb3RvY29sLmluZGV4T2YoJ2h0dHBzJykgPT09IDA7XG59O1xuXG5VcmkuREVGQVVMVF9QUk9UT0NPTCA9IGlzU2VjdXJlKCkgPyAnaHR0cHM6JyA6ICdodHRwOic7XG5cbi8qKlxuICogSG9zdG5hbWUgcGxhY2Vob2xkZXIuIFJlbGV2YW50IHRvIGludGVybmFsIHVzYWdlIG9ubHkuXG4gKiBAdHlwZSB7c3RyaW5nfVxuICogQHN0YXRpY1xuICovXG5VcmkuSE9TVE5BTUVfUExBQ0VIT0xERVIgPSAnaG9zdG5hbWUnICsgRGF0ZS5ub3coKTtcblxuLyoqXG4gKiBOYW1lIHVzZWQgYnkgdGhlIHBhcmFtIGdlbmVyYXRlZCBieSBgbWFrZVVuaXF1ZWAuXG4gKiBAdHlwZSB7c3RyaW5nfVxuICogQHN0YXRpY1xuICovXG5VcmkuUkFORE9NX1BBUkFNID0gJ3p4JztcblxuZXhwb3J0cy5kZWZhdWx0ID0gVXJpO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9tZXRhbC11cmkvbGliL1VyaS5qc1xuLy8gbW9kdWxlIGlkID0gNDVcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcblx0dmFsdWU6IHRydWVcbn0pO1xuXG52YXIgX21ldGFsID0gcmVxdWlyZSgnbWV0YWwnKTtcblxudmFyIF9wYXJzZUZyb21BbmNob3IgPSByZXF1aXJlKCcuL3BhcnNlRnJvbUFuY2hvcicpO1xuXG52YXIgX3BhcnNlRnJvbUFuY2hvcjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9wYXJzZUZyb21BbmNob3IpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG4vKipcbiAqIFBhcnNlcyB0aGUgZ2l2ZW4gdXJpIHN0cmluZyBpbnRvIGFuIG9iamVjdC4gVGhlIFVSTCBmdW5jdGlvbiB3aWxsIGJlIHVzZWRcbiAqIHdoZW4gcHJlc2VudCwgb3RoZXJ3aXNlIHdlJ2xsIGZhbGwgYmFjayB0byB0aGUgYW5jaG9yIG5vZGUgZWxlbWVudC5cbiAqIEBwYXJhbSB7Kj19IG9wdF91cmkgT3B0aW9uYWwgc3RyaW5nIFVSSSB0byBwYXJzZVxuICovXG5mdW5jdGlvbiBwYXJzZShvcHRfdXJpKSB7XG5cdGlmICgoMCwgX21ldGFsLmlzRnVuY3Rpb24pKFVSTCkgJiYgVVJMLmxlbmd0aCkge1xuXHRcdHZhciB1cmwgPSBuZXcgVVJMKG9wdF91cmkpO1xuXG5cdFx0Ly8gU2FmYXJpIEJyb3dzZXJzIHdpbGwgY2FwIHBvcnQgdG8gdGhlIG1heCAxNi1iaXQgdW5zaWduZWQgaW50ZWdlciAoNjU1MzUpIGluc3RlYWRcblx0XHQvLyBvZiB0aHJvd2luZyBhIFR5cGVFcnJvciBhcyBwZXIgc3BlYy4gSXQgd2lsbCBzdGlsbCBrZWVwIHRoZSBwb3J0IG51bWJlciBpbiB0aGVcblx0XHQvLyBocmVmIGF0dHJpYnV0ZSwgc28gd2UgY2FuIHVzZSB0aGlzIG1pc21hdGNoIHRvIHJhaXNlIHRoZSBleHBlY3RlZCBleGNlcHRpb24uXG5cdFx0aWYgKHVybC5wb3J0ICYmIHVybC5ocmVmLmluZGV4T2YodXJsLnBvcnQpID09PSAtMSkge1xuXHRcdFx0dGhyb3cgbmV3IFR5cGVFcnJvcihvcHRfdXJpICsgJyBpcyBub3QgYSB2YWxpZCBVUkwnKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gdXJsO1xuXHR9IGVsc2Uge1xuXHRcdHJldHVybiAoMCwgX3BhcnNlRnJvbUFuY2hvcjIuZGVmYXVsdCkob3B0X3VyaSk7XG5cdH1cbn1cblxuZXhwb3J0cy5kZWZhdWx0ID0gcGFyc2U7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L21ldGFsLXVyaS9saWIvcGFyc2UuanNcbi8vIG1vZHVsZSBpZCA9IDQ2XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBQYXJzZXMgdGhlIGdpdmVuIHVyaSBzdHJpbmcgaW50byBhbiBvYmplY3QuXG4gKiBAcGFyYW0geyo9fSBvcHRfdXJpIE9wdGlvbmFsIHN0cmluZyBVUkkgdG8gcGFyc2VcbiAqL1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcblx0dmFsdWU6IHRydWVcbn0pO1xuZnVuY3Rpb24gcGFyc2VGcm9tQW5jaG9yKG9wdF91cmkpIHtcblx0dmFyIGxpbmsgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdhJyk7XG5cdGxpbmsuaHJlZiA9IG9wdF91cmk7XG5cblx0aWYgKGxpbmsucHJvdG9jb2wgPT09ICc6JyB8fCAhLzovLnRlc3QobGluay5ocmVmKSkge1xuXHRcdHRocm93IG5ldyBUeXBlRXJyb3Iob3B0X3VyaSArICcgaXMgbm90IGEgdmFsaWQgVVJMJyk7XG5cdH1cblxuXHRyZXR1cm4ge1xuXHRcdGhhc2g6IGxpbmsuaGFzaCxcblx0XHRob3N0bmFtZTogbGluay5ob3N0bmFtZSxcblx0XHRwYXNzd29yZDogbGluay5wYXNzd29yZCxcblx0XHRwYXRobmFtZTogbGluay5wYXRobmFtZVswXSA9PT0gJy8nID8gbGluay5wYXRobmFtZSA6ICcvJyArIGxpbmsucGF0aG5hbWUsXG5cdFx0cG9ydDogbGluay5wb3J0LFxuXHRcdHByb3RvY29sOiBsaW5rLnByb3RvY29sLFxuXHRcdHNlYXJjaDogbGluay5zZWFyY2gsXG5cdFx0dXNlcm5hbWU6IGxpbmsudXNlcm5hbWVcblx0fTtcbn1cblxuZXhwb3J0cy5kZWZhdWx0ID0gcGFyc2VGcm9tQW5jaG9yO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9tZXRhbC11cmkvbGliL3BhcnNlRnJvbUFuY2hvci5qc1xuLy8gbW9kdWxlIGlkID0gNDdcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcblx0dmFsdWU6IHRydWVcbn0pO1xuXG52YXIgX2NyZWF0ZUNsYXNzID0gZnVuY3Rpb24gKCkgeyBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH0gcmV0dXJuIGZ1bmN0aW9uIChDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfTsgfSgpO1xuXG52YXIgX2NvcmUgPSByZXF1aXJlKCcuLi9jb3JlJyk7XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbnZhciBhcnJheSA9IGZ1bmN0aW9uICgpIHtcblx0ZnVuY3Rpb24gYXJyYXkoKSB7XG5cdFx0X2NsYXNzQ2FsbENoZWNrKHRoaXMsIGFycmF5KTtcblx0fVxuXG5cdF9jcmVhdGVDbGFzcyhhcnJheSwgbnVsbCwgW3tcblx0XHRrZXk6ICdlcXVhbCcsXG5cblx0XHQvKipcbiAgICogQ2hlY2tzIGlmIHRoZSBnaXZlbiBhcnJheXMgaGF2ZSB0aGUgc2FtZSBjb250ZW50LlxuICAgKiBAcGFyYW0geyFBcnJheTwqPn0gYXJyMVxuICAgKiBAcGFyYW0geyFBcnJheTwqPn0gYXJyMlxuICAgKiBAcmV0dXJuIHtib29sZWFufVxuICAgKi9cblx0XHR2YWx1ZTogZnVuY3Rpb24gZXF1YWwoYXJyMSwgYXJyMikge1xuXHRcdFx0aWYgKGFycjEgPT09IGFycjIpIHtcblx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHR9XG5cdFx0XHRpZiAoYXJyMS5sZW5ndGggIT09IGFycjIubGVuZ3RoKSB7XG5cdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdH1cblx0XHRcdGZvciAodmFyIGkgPSAwOyBpIDwgYXJyMS5sZW5ndGg7IGkrKykge1xuXHRcdFx0XHRpZiAoYXJyMVtpXSAhPT0gYXJyMltpXSkge1xuXHRcdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0fVxuXG5cdFx0LyoqXG4gICAqIFJldHVybnMgdGhlIGZpcnN0IHZhbHVlIGluIHRoZSBnaXZlbiBhcnJheSB0aGF0IGlzbid0IHVuZGVmaW5lZC5cbiAgICogQHBhcmFtIHshQXJyYXl9IGFyclxuICAgKiBAcmV0dXJuIHsqfVxuICAgKi9cblxuXHR9LCB7XG5cdFx0a2V5OiAnZmlyc3REZWZpbmVkVmFsdWUnLFxuXHRcdHZhbHVlOiBmdW5jdGlvbiBmaXJzdERlZmluZWRWYWx1ZShhcnIpIHtcblx0XHRcdGZvciAodmFyIGkgPSAwOyBpIDwgYXJyLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRcdGlmIChhcnJbaV0gIT09IHVuZGVmaW5lZCkge1xuXHRcdFx0XHRcdHJldHVybiBhcnJbaV07XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cblx0XHQvKipcbiAgICogVHJhbnNmb3JtcyB0aGUgaW5wdXQgbmVzdGVkIGFycmF5IHRvIGJlY29tZSBmbGF0LlxuICAgKiBAcGFyYW0ge0FycmF5LjwqfEFycmF5LjwqPj59IGFyciBOZXN0ZWQgYXJyYXkgdG8gZmxhdHRlbi5cbiAgICogQHBhcmFtIHtBcnJheS48Kj59IG9wdF9vdXRwdXQgT3B0aW9uYWwgb3V0cHV0IGFycmF5LlxuICAgKiBAcmV0dXJuIHtBcnJheS48Kj59IEZsYXQgYXJyYXkuXG4gICAqL1xuXG5cdH0sIHtcblx0XHRrZXk6ICdmbGF0dGVuJyxcblx0XHR2YWx1ZTogZnVuY3Rpb24gZmxhdHRlbihhcnIsIG9wdF9vdXRwdXQpIHtcblx0XHRcdHZhciBvdXRwdXQgPSBvcHRfb3V0cHV0IHx8IFtdO1xuXHRcdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBhcnIubGVuZ3RoOyBpKyspIHtcblx0XHRcdFx0aWYgKEFycmF5LmlzQXJyYXkoYXJyW2ldKSkge1xuXHRcdFx0XHRcdGFycmF5LmZsYXR0ZW4oYXJyW2ldLCBvdXRwdXQpO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdG91dHB1dC5wdXNoKGFycltpXSk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdHJldHVybiBvdXRwdXQ7XG5cdFx0fVxuXG5cdFx0LyoqXG4gICAqIFJlbW92ZXMgdGhlIGZpcnN0IG9jY3VycmVuY2Ugb2YgYSBwYXJ0aWN1bGFyIHZhbHVlIGZyb20gYW4gYXJyYXkuXG4gICAqIEBwYXJhbSB7QXJyYXkuPFQ+fSBhcnIgQXJyYXkgZnJvbSB3aGljaCB0byByZW1vdmUgdmFsdWUuXG4gICAqIEBwYXJhbSB7VH0gb2JqIE9iamVjdCB0byByZW1vdmUuXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59IFRydWUgaWYgYW4gZWxlbWVudCB3YXMgcmVtb3ZlZC5cbiAgICogQHRlbXBsYXRlIFRcbiAgICovXG5cblx0fSwge1xuXHRcdGtleTogJ3JlbW92ZScsXG5cdFx0dmFsdWU6IGZ1bmN0aW9uIHJlbW92ZShhcnIsIG9iaikge1xuXHRcdFx0dmFyIGkgPSBhcnIuaW5kZXhPZihvYmopO1xuXHRcdFx0dmFyIHJ2ID0gdm9pZCAwO1xuXHRcdFx0aWYgKHJ2ID0gaSA+PSAwKSB7XG5cdFx0XHRcdGFycmF5LnJlbW92ZUF0KGFyciwgaSk7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gcnY7XG5cdFx0fVxuXG5cdFx0LyoqXG4gICAqIFJlbW92ZXMgZnJvbSBhbiBhcnJheSB0aGUgZWxlbWVudCBhdCBpbmRleCBpXG4gICAqIEBwYXJhbSB7QXJyYXl9IGFyciBBcnJheSBvciBhcnJheSBsaWtlIG9iamVjdCBmcm9tIHdoaWNoIHRvIHJlbW92ZSB2YWx1ZS5cbiAgICogQHBhcmFtIHtudW1iZXJ9IGkgVGhlIGluZGV4IHRvIHJlbW92ZS5cbiAgICogQHJldHVybiB7Ym9vbGVhbn0gVHJ1ZSBpZiBhbiBlbGVtZW50IHdhcyByZW1vdmVkLlxuICAgKi9cblxuXHR9LCB7XG5cdFx0a2V5OiAncmVtb3ZlQXQnLFxuXHRcdHZhbHVlOiBmdW5jdGlvbiByZW1vdmVBdChhcnIsIGkpIHtcblx0XHRcdHJldHVybiBBcnJheS5wcm90b3R5cGUuc3BsaWNlLmNhbGwoYXJyLCBpLCAxKS5sZW5ndGggPT09IDE7XG5cdFx0fVxuXG5cdFx0LyoqXG4gICAqIFNsaWNlcyB0aGUgZ2l2ZW4gYXJyYXksIGp1c3QgbGlrZSBBcnJheS5wcm90b3R5cGUuc2xpY2UsIGJ1dCB0aGlzXG4gICAqIGlzIGZhc3RlciBhbmQgd29ya2luZyBvbiBhbGwgYXJyYXktbGlrZSBvYmplY3RzIChsaWtlIGFyZ3VtZW50cykuXG4gICAqIEBwYXJhbSB7IU9iamVjdH0gYXJyIEFycmF5LWxpa2Ugb2JqZWN0IHRvIHNsaWNlLlxuICAgKiBAcGFyYW0ge251bWJlcn0gc3RhcnQgVGhlIGluZGV4IHRoYXQgc2hvdWxkIHN0YXJ0IHRoZSBzbGljZS5cbiAgICogQHBhcmFtIHtudW1iZXI9fSBvcHRfZW5kIFRoZSBpbmRleCB3aGVyZSB0aGUgc2xpY2Ugc2hvdWxkIGVuZCwgbm90XG4gICAqICAgaW5jbHVkZWQgaW4gdGhlIGZpbmFsIGFycmF5LiBJZiBub3QgZ2l2ZW4sIGFsbCBlbGVtZW50cyBhZnRlciB0aGVcbiAgICogICBzdGFydCBpbmRleCB3aWxsIGJlIGluY2x1ZGVkLlxuICAgKiBAcmV0dXJuIHshQXJyYXl9XG4gICAqL1xuXG5cdH0sIHtcblx0XHRrZXk6ICdzbGljZScsXG5cdFx0dmFsdWU6IGZ1bmN0aW9uIHNsaWNlKGFyciwgc3RhcnQsIG9wdF9lbmQpIHtcblx0XHRcdHZhciBzbGljZWQgPSBbXTtcblx0XHRcdHZhciBlbmQgPSAoMCwgX2NvcmUuaXNEZWYpKG9wdF9lbmQpID8gb3B0X2VuZCA6IGFyci5sZW5ndGg7XG5cdFx0XHRmb3IgKHZhciBpID0gc3RhcnQ7IGkgPCBlbmQ7IGkrKykge1xuXHRcdFx0XHRzbGljZWQucHVzaChhcnJbaV0pO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHNsaWNlZDtcblx0XHR9XG5cdH1dKTtcblxuXHRyZXR1cm4gYXJyYXk7XG59KCk7XG5cbmV4cG9ydHMuZGVmYXVsdCA9IGFycmF5O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9tZXRhbC9saWIvYXJyYXkvYXJyYXkuanNcbi8vIG1vZHVsZSBpZCA9IDQ4XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qIVxuICogUG9seWZpbGwgZnJvbSBHb29nbGUncyBDbG9zdXJlIExpYnJhcnkuXG4gKiBDb3B5cmlnaHQgMjAxMyBUaGUgQ2xvc3VyZSBMaWJyYXJ5IEF1dGhvcnMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcblx0dmFsdWU6IHRydWVcbn0pO1xudmFyIGFzeW5jID0ge307XG5cbi8qKlxuICogVGhyb3cgYW4gaXRlbSB3aXRob3V0IGludGVycnVwdGluZyB0aGUgY3VycmVudCBleGVjdXRpb24gY29udGV4dC4gIEZvclxuICogZXhhbXBsZSwgaWYgcHJvY2Vzc2luZyBhIGdyb3VwIG9mIGl0ZW1zIGluIGEgbG9vcCwgc29tZXRpbWVzIGl0IGlzIHVzZWZ1bFxuICogdG8gcmVwb3J0IGFuIGVycm9yIHdoaWxlIHN0aWxsIGFsbG93aW5nIHRoZSByZXN0IG9mIHRoZSBiYXRjaCB0byBiZVxuICogcHJvY2Vzc2VkLlxuICogQHBhcmFtIHsqfSBleGNlcHRpb25cbiAqL1xuYXN5bmMudGhyb3dFeGNlcHRpb24gPSBmdW5jdGlvbiAoZXhjZXB0aW9uKSB7XG5cdC8vIEVhY2ggdGhyb3cgbmVlZHMgdG8gYmUgaW4gaXRzIG93biBjb250ZXh0LlxuXHRhc3luYy5uZXh0VGljayhmdW5jdGlvbiAoKSB7XG5cdFx0dGhyb3cgZXhjZXB0aW9uO1xuXHR9KTtcbn07XG5cbi8qKlxuICogRmlyZXMgdGhlIHByb3ZpZGVkIGNhbGxiYWNrIGp1c3QgYmVmb3JlIHRoZSBjdXJyZW50IGNhbGxzdGFjayB1bndpbmRzLCBvciBhc1xuICogc29vbiBhcyBwb3NzaWJsZSBhZnRlciB0aGUgY3VycmVudCBKUyBleGVjdXRpb24gY29udGV4dC5cbiAqIEBwYXJhbSB7ZnVuY3Rpb24odGhpczpUSElTKX0gY2FsbGJhY2tcbiAqIEBwYXJhbSB7VEhJUz19IG9wdF9jb250ZXh0IE9iamVjdCB0byB1c2UgYXMgdGhlIFwidGhpcyB2YWx1ZVwiIHdoZW4gY2FsbGluZ1xuICogICAgIHRoZSBwcm92aWRlZCBmdW5jdGlvbi5cbiAqIEB0ZW1wbGF0ZSBUSElTXG4gKi9cbmFzeW5jLnJ1biA9IGZ1bmN0aW9uIChjYWxsYmFjaywgb3B0X2NvbnRleHQpIHtcblx0aWYgKCFhc3luYy5ydW4ud29ya1F1ZXVlU2NoZWR1bGVkXykge1xuXHRcdC8vIE5vdGhpbmcgaXMgY3VycmVudGx5IHNjaGVkdWxlZCwgc2NoZWR1bGUgaXQgbm93LlxuXHRcdGFzeW5jLm5leHRUaWNrKGFzeW5jLnJ1bi5wcm9jZXNzV29ya1F1ZXVlKTtcblx0XHRhc3luYy5ydW4ud29ya1F1ZXVlU2NoZWR1bGVkXyA9IHRydWU7XG5cdH1cblxuXHRhc3luYy5ydW4ud29ya1F1ZXVlXy5wdXNoKG5ldyBhc3luYy5ydW4uV29ya0l0ZW1fKGNhbGxiYWNrLCBvcHRfY29udGV4dCkpO1xufTtcblxuLyoqIEBwcml2YXRlIHtib29sZWFufSAqL1xuYXN5bmMucnVuLndvcmtRdWV1ZVNjaGVkdWxlZF8gPSBmYWxzZTtcblxuLyoqIEBwcml2YXRlIHshQXJyYXkuPCFhc3luYy5ydW4uV29ya0l0ZW1fPn0gKi9cbmFzeW5jLnJ1bi53b3JrUXVldWVfID0gW107XG5cbi8qKlxuICogUnVuIGFueSBwZW5kaW5nIGFzeW5jLnJ1biB3b3JrIGl0ZW1zLiBUaGlzIGZ1bmN0aW9uIGlzIG5vdCBpbnRlbmRlZFxuICogZm9yIGdlbmVyYWwgdXNlLCBidXQgZm9yIHVzZSBieSBlbnRyeSBwb2ludCBoYW5kbGVycyB0byBydW4gaXRlbXMgYWhlYWQgb2ZcbiAqIGFzeW5jLm5leHRUaWNrLlxuICovXG5hc3luYy5ydW4ucHJvY2Vzc1dvcmtRdWV1ZSA9IGZ1bmN0aW9uICgpIHtcblx0Ly8gTk9URTogYWRkaXRpb25hbCB3b3JrIHF1ZXVlIGl0ZW1zIG1heSBiZSBwdXNoZWQgd2hpbGUgcHJvY2Vzc2luZy5cblx0d2hpbGUgKGFzeW5jLnJ1bi53b3JrUXVldWVfLmxlbmd0aCkge1xuXHRcdC8vIERvbid0IGxldCB0aGUgd29yayBxdWV1ZSBncm93IGluZGVmaW5pdGVseS5cblx0XHR2YXIgd29ya0l0ZW1zID0gYXN5bmMucnVuLndvcmtRdWV1ZV87XG5cdFx0YXN5bmMucnVuLndvcmtRdWV1ZV8gPSBbXTtcblx0XHRmb3IgKHZhciBpID0gMDsgaSA8IHdvcmtJdGVtcy5sZW5ndGg7IGkrKykge1xuXHRcdFx0dmFyIHdvcmtJdGVtID0gd29ya0l0ZW1zW2ldO1xuXHRcdFx0dHJ5IHtcblx0XHRcdFx0d29ya0l0ZW0uZm4uY2FsbCh3b3JrSXRlbS5zY29wZSk7XG5cdFx0XHR9IGNhdGNoIChlKSB7XG5cdFx0XHRcdGFzeW5jLnRocm93RXhjZXB0aW9uKGUpO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdC8vIFRoZXJlIGFyZSBubyBtb3JlIHdvcmsgaXRlbXMsIHJlc2V0IHRoZSB3b3JrIHF1ZXVlLlxuXHRhc3luYy5ydW4ud29ya1F1ZXVlU2NoZWR1bGVkXyA9IGZhbHNlO1xufTtcblxuLyoqXG4gKiBAY29uc3RydWN0b3JcbiAqIEBmaW5hbFxuICogQHN0cnVjdFxuICogQHByaXZhdGVcbiAqXG4gKiBAcGFyYW0ge2Z1bmN0aW9uKCl9IGZuXG4gKiBAcGFyYW0ge09iamVjdHxudWxsfHVuZGVmaW5lZH0gc2NvcGVcbiAqL1xuYXN5bmMucnVuLldvcmtJdGVtXyA9IGZ1bmN0aW9uIChmbiwgc2NvcGUpIHtcblx0LyoqIEBjb25zdCAqL1xuXHR0aGlzLmZuID0gZm47XG5cdC8qKiBAY29uc3QgKi9cblx0dGhpcy5zY29wZSA9IHNjb3BlO1xufTtcblxuLyoqXG4gKiBGaXJlcyB0aGUgcHJvdmlkZWQgY2FsbGJhY2tzIGFzIHNvb24gYXMgcG9zc2libGUgYWZ0ZXIgdGhlIGN1cnJlbnQgSlNcbiAqIGV4ZWN1dGlvbiBjb250ZXh0LiBzZXRUaW1lb3V0KOKApiwgMCkgYWx3YXlzIHRha2VzIGF0IGxlYXN0IDVtcyBmb3IgbGVnYWN5XG4gKiByZWFzb25zLlxuICogQHBhcmFtIHtmdW5jdGlvbih0aGlzOlNDT1BFKX0gY2FsbGJhY2sgQ2FsbGJhY2sgZnVuY3Rpb24gdG8gZmlyZSBhcyBzb29uIGFzXG4gKiAgICAgcG9zc2libGUuXG4gKiBAcGFyYW0ge1NDT1BFPX0gb3B0X2NvbnRleHQgT2JqZWN0IGluIHdob3NlIHNjb3BlIHRvIGNhbGwgdGhlIGxpc3RlbmVyLlxuICogQHRlbXBsYXRlIFNDT1BFXG4gKi9cbmFzeW5jLm5leHRUaWNrID0gZnVuY3Rpb24gKGNhbGxiYWNrLCBvcHRfY29udGV4dCkge1xuXHR2YXIgY2IgPSBjYWxsYmFjaztcblx0aWYgKG9wdF9jb250ZXh0KSB7XG5cdFx0Y2IgPSBjYWxsYmFjay5iaW5kKG9wdF9jb250ZXh0KTtcblx0fVxuXHRjYiA9IGFzeW5jLm5leHRUaWNrLndyYXBDYWxsYmFja18oY2IpO1xuXHQvLyBJbnRyb2R1Y2VkIGFuZCBjdXJyZW50bHkgb25seSBzdXBwb3J0ZWQgYnkgSUUxMC5cblx0Ly8gVmVyaWZ5IGlmIHZhcmlhYmxlIGlzIGRlZmluZWQgb24gdGhlIGN1cnJlbnQgcnVudGltZSAoaS5lLiwgbm9kZSwgYnJvd3NlcikuXG5cdC8vIENhbid0IHVzZSB0eXBlb2YgZW5jbG9zZWQgaW4gYSBmdW5jdGlvbiAoc3VjaCBhcyBjb3JlLmlzRnVuY3Rpb24pIG9yIGFuXG5cdC8vIGV4Y2VwdGlvbiB3aWxsIGJlIHRocm93biB3aGVuIHRoZSBmdW5jdGlvbiBpcyBjYWxsZWQgb24gYW4gZW52aXJvbm1lbnRcblx0Ly8gd2hlcmUgdGhlIHZhcmlhYmxlIGlzIHVuZGVmaW5lZC5cblx0aWYgKHR5cGVvZiBzZXRJbW1lZGlhdGUgPT09ICdmdW5jdGlvbicpIHtcblx0XHRzZXRJbW1lZGlhdGUoY2IpO1xuXHRcdHJldHVybjtcblx0fVxuXHQvLyBMb29rIGZvciBhbmQgY2FjaGUgdGhlIGN1c3RvbSBmYWxsYmFjayB2ZXJzaW9uIG9mIHNldEltbWVkaWF0ZS5cblx0aWYgKCFhc3luYy5uZXh0VGljay5zZXRJbW1lZGlhdGVfKSB7XG5cdFx0YXN5bmMubmV4dFRpY2suc2V0SW1tZWRpYXRlXyA9IGFzeW5jLm5leHRUaWNrLmdldFNldEltbWVkaWF0ZUVtdWxhdG9yXygpO1xuXHR9XG5cdGFzeW5jLm5leHRUaWNrLnNldEltbWVkaWF0ZV8oY2IpO1xufTtcblxuLyoqXG4gKiBDYWNoZSBmb3IgdGhlIHNldEltbWVkaWF0ZSBpbXBsZW1lbnRhdGlvbi5cbiAqIEB0eXBlIHtmdW5jdGlvbihmdW5jdGlvbigpKX1cbiAqIEBwcml2YXRlXG4gKi9cbmFzeW5jLm5leHRUaWNrLnNldEltbWVkaWF0ZV8gPSBudWxsO1xuXG4vKipcbiAqIERldGVybWluZXMgdGhlIGJlc3QgcG9zc2libGUgaW1wbGVtZW50YXRpb24gdG8gcnVuIGEgZnVuY3Rpb24gYXMgc29vbiBhc1xuICogdGhlIEpTIGV2ZW50IGxvb3AgaXMgaWRsZS5cbiAqIEByZXR1cm4ge2Z1bmN0aW9uKGZ1bmN0aW9uKCkpfSBUaGUgXCJzZXRJbW1lZGlhdGVcIiBpbXBsZW1lbnRhdGlvbi5cbiAqIEBwcml2YXRlXG4gKi9cbmFzeW5jLm5leHRUaWNrLmdldFNldEltbWVkaWF0ZUVtdWxhdG9yXyA9IGZ1bmN0aW9uICgpIHtcblx0Ly8gQ3JlYXRlIGEgcHJpdmF0ZSBtZXNzYWdlIGNoYW5uZWwgYW5kIHVzZSBpdCB0byBwb3N0TWVzc2FnZSBlbXB0eSBtZXNzYWdlc1xuXHQvLyB0byBvdXJzZWx2ZXMuXG5cdHZhciBDaGFubmVsID0gdm9pZCAwO1xuXG5cdC8vIFZlcmlmeSBpZiB2YXJpYWJsZSBpcyBkZWZpbmVkIG9uIHRoZSBjdXJyZW50IHJ1bnRpbWUgKGkuZS4sIG5vZGUsIGJyb3dzZXIpLlxuXHQvLyBDYW4ndCB1c2UgdHlwZW9mIGVuY2xvc2VkIGluIGEgZnVuY3Rpb24gKHN1Y2ggYXMgY29yZS5pc0Z1bmN0aW9uKSBvciBhblxuXHQvLyBleGNlcHRpb24gd2lsbCBiZSB0aHJvd24gd2hlbiB0aGUgZnVuY3Rpb24gaXMgY2FsbGVkIG9uIGFuIGVudmlyb25tZW50XG5cdC8vIHdoZXJlIHRoZSB2YXJpYWJsZSBpcyB1bmRlZmluZWQuXG5cdGlmICh0eXBlb2YgTWVzc2FnZUNoYW5uZWwgPT09ICdmdW5jdGlvbicpIHtcblx0XHRDaGFubmVsID0gTWVzc2FnZUNoYW5uZWw7XG5cdH1cblxuXHQvLyBJZiBNZXNzYWdlQ2hhbm5lbCBpcyBub3QgYXZhaWxhYmxlIGFuZCB3ZSBhcmUgaW4gYSBicm93c2VyLCBpbXBsZW1lbnRcblx0Ly8gYW4gaWZyYW1lIGJhc2VkIHBvbHlmaWxsIGluIGJyb3dzZXJzIHRoYXQgaGF2ZSBwb3N0TWVzc2FnZSBhbmRcblx0Ly8gZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lci4gVGhlIGxhdHRlciBleGNsdWRlcyBJRTggYmVjYXVzZSBpdCBoYXMgYVxuXHQvLyBzeW5jaHJvbm91cyBwb3N0TWVzc2FnZSBpbXBsZW1lbnRhdGlvbi5cblx0aWYgKHR5cGVvZiBDaGFubmVsID09PSAndW5kZWZpbmVkJyAmJiB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiB3aW5kb3cucG9zdE1lc3NhZ2UgJiYgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIpIHtcblx0XHQvKiogQGNvbnN0cnVjdG9yICovXG5cdFx0Q2hhbm5lbCA9IGZ1bmN0aW9uIENoYW5uZWwoKSB7XG5cdFx0XHQvLyBNYWtlIGFuIGVtcHR5LCBpbnZpc2libGUgaWZyYW1lLlxuXHRcdFx0dmFyIGlmcmFtZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2lmcmFtZScpO1xuXHRcdFx0aWZyYW1lLnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XG5cdFx0XHRpZnJhbWUuc3JjID0gJyc7XG5cdFx0XHRkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuYXBwZW5kQ2hpbGQoaWZyYW1lKTtcblx0XHRcdHZhciB3aW4gPSBpZnJhbWUuY29udGVudFdpbmRvdztcblx0XHRcdHZhciBkb2MgPSB3aW4uZG9jdW1lbnQ7XG5cdFx0XHRkb2Mub3BlbigpO1xuXHRcdFx0ZG9jLndyaXRlKCcnKTtcblx0XHRcdGRvYy5jbG9zZSgpO1xuXHRcdFx0dmFyIG1lc3NhZ2UgPSAnY2FsbEltbWVkaWF0ZScgKyBNYXRoLnJhbmRvbSgpO1xuXHRcdFx0dmFyIG9yaWdpbiA9IHdpbi5sb2NhdGlvbi5wcm90b2NvbCArICcvLycgKyB3aW4ubG9jYXRpb24uaG9zdDtcblx0XHRcdHZhciBvbm1lc3NhZ2UgPSBmdW5jdGlvbiAoZSkge1xuXHRcdFx0XHQvLyBWYWxpZGF0ZSBvcmlnaW4gYW5kIG1lc3NhZ2UgdG8gbWFrZSBzdXJlIHRoYXQgdGhpcyBtZXNzYWdlIHdhc1xuXHRcdFx0XHQvLyBpbnRlbmRlZCBmb3IgdXMuXG5cdFx0XHRcdGlmIChlLm9yaWdpbiAhPT0gb3JpZ2luICYmIGUuZGF0YSAhPT0gbWVzc2FnZSkge1xuXHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0fVxuXHRcdFx0XHR0aGlzLnBvcnQxLm9ubWVzc2FnZSgpO1xuXHRcdFx0fS5iaW5kKHRoaXMpO1xuXHRcdFx0d2luLmFkZEV2ZW50TGlzdGVuZXIoJ21lc3NhZ2UnLCBvbm1lc3NhZ2UsIGZhbHNlKTtcblx0XHRcdHRoaXMucG9ydDEgPSB7fTtcblx0XHRcdHRoaXMucG9ydDIgPSB7XG5cdFx0XHRcdHBvc3RNZXNzYWdlOiBmdW5jdGlvbiBwb3N0TWVzc2FnZSgpIHtcblx0XHRcdFx0XHR3aW4ucG9zdE1lc3NhZ2UobWVzc2FnZSwgb3JpZ2luKTtcblx0XHRcdFx0fVxuXHRcdFx0fTtcblx0XHR9O1xuXHR9XG5cdGlmICh0eXBlb2YgQ2hhbm5lbCAhPT0gJ3VuZGVmaW5lZCcpIHtcblx0XHR2YXIgY2hhbm5lbCA9IG5ldyBDaGFubmVsKCk7XG5cdFx0Ly8gVXNlIGEgZmlmbyBsaW5rZWQgbGlzdCB0byBjYWxsIGNhbGxiYWNrcyBpbiB0aGUgcmlnaHQgb3JkZXIuXG5cdFx0dmFyIGhlYWQgPSB7fTtcblx0XHR2YXIgdGFpbCA9IGhlYWQ7XG5cdFx0Y2hhbm5lbC5wb3J0MS5vbm1lc3NhZ2UgPSBmdW5jdGlvbiAoKSB7XG5cdFx0XHRoZWFkID0gaGVhZC5uZXh0O1xuXHRcdFx0dmFyIGNiID0gaGVhZC5jYjtcblx0XHRcdGhlYWQuY2IgPSBudWxsO1xuXHRcdFx0Y2IoKTtcblx0XHR9O1xuXHRcdHJldHVybiBmdW5jdGlvbiAoY2IpIHtcblx0XHRcdHRhaWwubmV4dCA9IHtcblx0XHRcdFx0Y2I6IGNiXG5cdFx0XHR9O1xuXHRcdFx0dGFpbCA9IHRhaWwubmV4dDtcblx0XHRcdGNoYW5uZWwucG9ydDIucG9zdE1lc3NhZ2UoMCk7XG5cdFx0fTtcblx0fVxuXHQvLyBJbXBsZW1lbnRhdGlvbiBmb3IgSUU2LTg6IFNjcmlwdCBlbGVtZW50cyBmaXJlIGFuIGFzeW5jaHJvbm91c1xuXHQvLyBvbnJlYWR5c3RhdGVjaGFuZ2UgZXZlbnQgd2hlbiBpbnNlcnRlZCBpbnRvIHRoZSBET00uXG5cdGlmICh0eXBlb2YgZG9jdW1lbnQgIT09ICd1bmRlZmluZWQnICYmICdvbnJlYWR5c3RhdGVjaGFuZ2UnIGluIGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3NjcmlwdCcpKSB7XG5cdFx0cmV0dXJuIGZ1bmN0aW9uIChjYikge1xuXHRcdFx0dmFyIHNjcmlwdCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3NjcmlwdCcpO1xuXHRcdFx0c2NyaXB0Lm9ucmVhZHlzdGF0ZWNoYW5nZSA9IGZ1bmN0aW9uICgpIHtcblx0XHRcdFx0Ly8gQ2xlYW4gdXAgYW5kIGNhbGwgdGhlIGNhbGxiYWNrLlxuXHRcdFx0XHRzY3JpcHQub25yZWFkeXN0YXRlY2hhbmdlID0gbnVsbDtcblx0XHRcdFx0c2NyaXB0LnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoc2NyaXB0KTtcblx0XHRcdFx0c2NyaXB0ID0gbnVsbDtcblx0XHRcdFx0Y2IoKTtcblx0XHRcdFx0Y2IgPSBudWxsO1xuXHRcdFx0fTtcblx0XHRcdGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5hcHBlbmRDaGlsZChzY3JpcHQpO1xuXHRcdH07XG5cdH1cblx0Ly8gRmFsbCBiYWNrIHRvIHNldFRpbWVvdXQgd2l0aCAwLiBJbiBicm93c2VycyB0aGlzIGNyZWF0ZXMgYSBkZWxheSBvZiA1bXNcblx0Ly8gb3IgbW9yZS5cblx0cmV0dXJuIGZ1bmN0aW9uIChjYikge1xuXHRcdHNldFRpbWVvdXQoY2IsIDApO1xuXHR9O1xufTtcblxuLyoqXG4gKiBIZWxwZXIgZnVuY3Rpb24gdGhhdCBpcyBvdmVycmlkZWQgdG8gcHJvdGVjdCBjYWxsYmFja3Mgd2l0aCBlbnRyeSBwb2ludFxuICogbW9uaXRvciBpZiB0aGUgYXBwbGljYXRpb24gbW9uaXRvcnMgZW50cnkgcG9pbnRzLlxuICogQHBhcmFtIHtmdW5jdGlvbigpfSBjYWxsYmFjayBDYWxsYmFjayBmdW5jdGlvbiB0byBmaXJlIGFzIHNvb24gYXMgcG9zc2libGUuXG4gKiBAcmV0dXJuIHtmdW5jdGlvbigpfSBUaGUgd3JhcHBlZCBjYWxsYmFjay5cbiAqIEBwcml2YXRlXG4gKi9cbmFzeW5jLm5leHRUaWNrLndyYXBDYWxsYmFja18gPSBmdW5jdGlvbiAob3B0X3JldHVyblZhbHVlKSB7XG5cdHJldHVybiBvcHRfcmV0dXJuVmFsdWU7XG59O1xuXG5leHBvcnRzLmRlZmF1bHQgPSBhc3luYztcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vbWV0YWwvbGliL2FzeW5jL2FzeW5jLmpzXG4vLyBtb2R1bGUgaWQgPSA0OVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIndXNlIHN0cmljdCc7XG5cbi8qKlxuICogQSBjb2xsZWN0aW9uIG9mIGNvcmUgdXRpbGl0eSBmdW5jdGlvbnMuXG4gKiBAY29uc3RcbiAqL1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuXG52YXIgX3R5cGVvZiA9IHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID09PSBcInN5bWJvbFwiID8gZnVuY3Rpb24gKG9iaikgeyByZXR1cm4gdHlwZW9mIG9iajsgfSA6IGZ1bmN0aW9uIChvYmopIHsgcmV0dXJuIG9iaiAmJiB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgb2JqLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiYgb2JqICE9PSBTeW1ib2wucHJvdG90eXBlID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvYmo7IH07XG5cbmV4cG9ydHMuYWJzdHJhY3RNZXRob2QgPSBhYnN0cmFjdE1ldGhvZDtcbmV4cG9ydHMuZGlzYWJsZUNvbXBhdGliaWxpdHlNb2RlID0gZGlzYWJsZUNvbXBhdGliaWxpdHlNb2RlO1xuZXhwb3J0cy5lbmFibGVDb21wYXRpYmlsaXR5TW9kZSA9IGVuYWJsZUNvbXBhdGliaWxpdHlNb2RlO1xuZXhwb3J0cy5nZXRDb21wYXRpYmlsaXR5TW9kZURhdGEgPSBnZXRDb21wYXRpYmlsaXR5TW9kZURhdGE7XG5leHBvcnRzLmdldEZ1bmN0aW9uTmFtZSA9IGdldEZ1bmN0aW9uTmFtZTtcbmV4cG9ydHMuZ2V0U3RhdGljUHJvcGVydHkgPSBnZXRTdGF0aWNQcm9wZXJ0eTtcbmV4cG9ydHMuZ2V0VWlkID0gZ2V0VWlkO1xuZXhwb3J0cy5pZGVudGl0eUZ1bmN0aW9uID0gaWRlbnRpdHlGdW5jdGlvbjtcbmV4cG9ydHMuaXNCb29sZWFuID0gaXNCb29sZWFuO1xuZXhwb3J0cy5pc0RlZiA9IGlzRGVmO1xuZXhwb3J0cy5pc0RlZkFuZE5vdE51bGwgPSBpc0RlZkFuZE5vdE51bGw7XG5leHBvcnRzLmlzRG9jdW1lbnQgPSBpc0RvY3VtZW50O1xuZXhwb3J0cy5pc0RvY3VtZW50RnJhZ21lbnQgPSBpc0RvY3VtZW50RnJhZ21lbnQ7XG5leHBvcnRzLmlzRWxlbWVudCA9IGlzRWxlbWVudDtcbmV4cG9ydHMuaXNGdW5jdGlvbiA9IGlzRnVuY3Rpb247XG5leHBvcnRzLmlzTnVsbCA9IGlzTnVsbDtcbmV4cG9ydHMuaXNOdW1iZXIgPSBpc051bWJlcjtcbmV4cG9ydHMuaXNXaW5kb3cgPSBpc1dpbmRvdztcbmV4cG9ydHMuaXNPYmplY3QgPSBpc09iamVjdDtcbmV4cG9ydHMuaXNQcm9taXNlID0gaXNQcm9taXNlO1xuZXhwb3J0cy5pc1N0cmluZyA9IGlzU3RyaW5nO1xuZXhwb3J0cy5pc1NlcnZlclNpZGUgPSBpc1NlcnZlclNpZGU7XG5leHBvcnRzLm51bGxGdW5jdGlvbiA9IG51bGxGdW5jdGlvbjtcbnZhciBjb21wYXRpYmlsaXR5TW9kZURhdGFfID0gdm9pZCAwO1xuXG4vKipcbiAqIENvdW50ZXIgZm9yIHVuaXF1ZSBpZC5cbiAqIEB0eXBlIHtOdW1iZXJ9XG4gKiBAcHJpdmF0ZVxuICovXG52YXIgdW5pcXVlSWRDb3VudGVyXyA9IDE7XG5cbi8qKlxuICogVW5pcXVlIGlkIHByb3BlcnR5IHByZWZpeC5cbiAqIEB0eXBlIHtTdHJpbmd9XG4gKiBAcHJvdGVjdGVkXG4gKi9cbnZhciBVSURfUFJPUEVSVFkgPSBleHBvcnRzLlVJRF9QUk9QRVJUWSA9ICdjb3JlXycgKyAoTWF0aC5yYW5kb20oKSAqIDFlOSA+Pj4gMCk7XG5cbi8qKlxuICogV2hlbiBkZWZpbmluZyBhIGNsYXNzIEZvbyB3aXRoIGFuIGFic3RyYWN0IG1ldGhvZCBiYXIoKSwgeW91IGNhbiBkbzpcbiAqIEZvby5wcm90b3R5cGUuYmFyID0gYWJzdHJhY3RNZXRob2RcbiAqXG4gKiBOb3cgaWYgYSBzdWJjbGFzcyBvZiBGb28gZmFpbHMgdG8gb3ZlcnJpZGUgYmFyKCksIGFuIGVycm9yIHdpbGwgYmUgdGhyb3duXG4gKiB3aGVuIGJhcigpIGlzIGludm9rZWQuXG4gKlxuICogQHR5cGUgeyFGdW5jdGlvbn1cbiAqIEB0aHJvd3Mge0Vycm9yfSB3aGVuIGludm9rZWQgdG8gaW5kaWNhdGUgdGhlIG1ldGhvZCBzaG91bGQgYmUgb3ZlcnJpZGRlbi5cbiAqL1xuZnVuY3Rpb24gYWJzdHJhY3RNZXRob2QoKSB7XG4gIHRocm93IEVycm9yKCdVbmltcGxlbWVudGVkIGFic3RyYWN0IG1ldGhvZCcpO1xufVxuXG4vKipcbiAqIERpc2FibGVzIE1ldGFsLmpzJ3MgY29tcGF0aWJpbGl0eSBtb2RlLlxuICovXG5mdW5jdGlvbiBkaXNhYmxlQ29tcGF0aWJpbGl0eU1vZGUoKSB7XG4gIGNvbXBhdGliaWxpdHlNb2RlRGF0YV8gPSB1bmRlZmluZWQ7XG59XG5cbi8qKlxuICogRW5hYmxlcyBNZXRhbC5qcydzIGNvbXBhdGliaWxpdHkgbW9kZSB3aXRoIHRoZSBmb2xsb3dpbmcgZmVhdHVyZXMgZnJvbSByY1xuICogYW5kIDEueCB2ZXJzaW9uczpcbiAqICAgICAtIFVzaW5nIFwia2V5XCIgdG8gcmVmZXJlbmNlIGNvbXBvbmVudCBpbnN0YW5jZXMuIEluIHRoZSBjdXJyZW50IHZlcnNpb25cbiAqICAgICAgIHRoaXMgc2hvdWxkIGJlIGRvbmUgdmlhIFwicmVmXCIgaW5zdGVhZC4gVGhpcyBhbGxvd3Mgb2xkIGNvZGUgc3RpbGxcbiAqICAgICAgIHVzaW5nIFwia2V5XCIgdG8ga2VlcCB3b3JraW5nIGxpa2UgYmVmb3JlLiBOT1RFOiB0aGlzIG1heSBjYXVzZVxuICogICAgICAgcHJvYmxlbXMsIHNpbmNlIFwia2V5XCIgaXMgbWVhbnQgdG8gYmUgdXNlZCBkaWZmZXJlbnRseS4gT25seSB1c2UgdGhpc1xuICogICAgICAgaWYgaXQncyBub3QgcG9zc2libGUgdG8gdXBncmFkZSB0aGUgY29kZSB0byB1c2UgXCJyZWZcIiBpbnN0ZWFkLlxuICogQHBhcmFtIHtPYmplY3Q9fSBvcHRfZGF0YSBPcHRpb25hbCBvYmplY3Qgd2l0aCBkYXRhIHRvIHNwZWNpZnkgbW9yZVxuICogICAgIGRldGFpbHMsIHN1Y2ggYXM6XG4gKiAgICAgICAgIC0gcmVuZGVyZXJzIHtBcnJheX0gdGhlIHRlbXBsYXRlIHJlbmRlcmVycyB0aGF0IHNob3VsZCBiZSBpblxuICogICAgICAgICAgIGNvbXBhdGliaWxpdHkgbW9kZSwgZWl0aGVyIHRoZWlyIGNvbnN0cnVjdG9ycyBvciBzdHJpbmdzXG4gKiAgICAgICAgICAgcmVwcmVzZW50aW5nIHRoZW0gKGUuZy4gJ3NveScgb3IgJ2pzeCcpLiBCeSBkZWZhdWx0LCBhbGwgdGhlIG9uZXNcbiAqICAgICAgICAgICB0aGF0IGV4dGVuZCBmcm9tIEluY3JlbWVudGFsRG9tUmVuZGVyZXIuXG4gKiBAdHlwZSB7T2JqZWN0fVxuICovXG5mdW5jdGlvbiBlbmFibGVDb21wYXRpYmlsaXR5TW9kZSgpIHtcbiAgdmFyIG9wdF9kYXRhID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiB7fTtcblxuICBjb21wYXRpYmlsaXR5TW9kZURhdGFfID0gb3B0X2RhdGE7XG59XG5cbi8qKlxuICogUmV0dXJucyB0aGUgZGF0YSB1c2VkIGZvciBjb21wYXRpYmlsaXR5IG1vZGUsIG9yIG5vdGhpbmcgaWYgaXQgaGFzbid0IGJlZW5cbiAqIGVuYWJsZWQuXG4gKiBAcmV0dXJuIHtPYmplY3R9XG4gKi9cbmZ1bmN0aW9uIGdldENvbXBhdGliaWxpdHlNb2RlRGF0YSgpIHtcbiAgLy8gQ29tcGF0aWJpbGl0eSBtb2RlIGNhbiBiZSBzZXQgdmlhIHRoZSBfX01FVEFMX0NPTVBBVElCSUxJVFlfXyBnbG9iYWwgdmFyLlxuICBpZiAoY29tcGF0aWJpbGl0eU1vZGVEYXRhXyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmIHdpbmRvdy5fX01FVEFMX0NPTVBBVElCSUxJVFlfXykge1xuICAgICAgZW5hYmxlQ29tcGF0aWJpbGl0eU1vZGUod2luZG93Ll9fTUVUQUxfQ09NUEFUSUJJTElUWV9fKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGNvbXBhdGliaWxpdHlNb2RlRGF0YV87XG59XG5cbi8qKlxuICogUmV0dXJucyB0aGUgZmlyc3QgYXJndW1lbnQgaWYgaXQncyB0cnV0aHksIG9yIHRoZSBzZWNvbmQgb3RoZXJ3aXNlLlxuICogQHBhcmFtIHsqfSBhXG4gKiBAcGFyYW0geyp9IGJcbiAqIEByZXR1cm4geyp9XG4gKiBAcHJvdGVjdGVkXG4gKi9cbmZ1bmN0aW9uIGdldEZpcnN0VHJ1dGh5XyhhLCBiKSB7XG4gIHJldHVybiBhIHx8IGI7XG59XG5cbi8qKlxuICogR2V0cyB0aGUgbmFtZSBvZiB0aGUgZ2l2ZW4gZnVuY3Rpb24uIElmIHRoZSBjdXJyZW50IGJyb3dzZXIgZG9lc24ndFxuICogc3VwcG9ydCB0aGUgYG5hbWVgIHByb3BlcnR5LCB0aGlzIHdpbGwgY2FsY3VsYXRlIGl0IGZyb20gdGhlIGZ1bmN0aW9uJ3NcbiAqIGNvbnRlbnQgc3RyaW5nLlxuICogQHBhcmFtIHshZnVuY3Rpb24oKX0gZm5cbiAqIEByZXR1cm4ge3N0cmluZ31cbiAqL1xuZnVuY3Rpb24gZ2V0RnVuY3Rpb25OYW1lKGZuKSB7XG4gIGlmICghZm4ubmFtZSkge1xuICAgIHZhciBzdHIgPSBmbi50b1N0cmluZygpO1xuICAgIGZuLm5hbWUgPSBzdHIuc3Vic3RyaW5nKDksIHN0ci5pbmRleE9mKCcoJykpO1xuICB9XG4gIHJldHVybiBmbi5uYW1lO1xufVxuXG4vKipcbiAqIEdldHMgdGhlIHZhbHVlIG9mIGEgc3RhdGljIHByb3BlcnR5IGluIHRoZSBnaXZlbiBjbGFzcy4gVGhlIHZhbHVlIHdpbGwgYmVcbiAqIGluaGVyaXRlZCBmcm9tIGFuY2VzdG9ycyBhcyBleHBlY3RlZCwgdW5sZXNzIGEgY3VzdG9tIG1lcmdlIGZ1bmN0aW9uIGlzIGdpdmVuLFxuICogd2hpY2ggY2FuIGNoYW5nZSBob3cgdGhlIHN1cGVyIGNsYXNzZXMnIHZhbHVlIGZvciB0aGF0IHByb3BlcnR5IHdpbGwgYmUgbWVyZ2VkXG4gKiB0b2dldGhlci5cbiAqIFRoZSBmaW5hbCBtZXJnZWQgdmFsdWUgd2lsbCBiZSBzdG9yZWQgaW4gYW5vdGhlciBwcm9wZXJ0eSwgc28gdGhhdCBpdCB3b24ndFxuICogYmUgcmVjYWxjdWxhdGVkIGV2ZW4gaWYgdGhpcyBmdW5jdGlvbiBpcyBjYWxsZWQgbXVsdGlwbGUgdGltZXMuXG4gKiBAcGFyYW0geyFmdW5jdGlvbigpfSBjdG9yIENsYXNzIGNvbnN0cnVjdG9yLlxuICogQHBhcmFtIHtzdHJpbmd9IHByb3BlcnR5TmFtZSBQcm9wZXJ0eSBuYW1lIHRvIGJlIG1lcmdlZC5cbiAqIEBwYXJhbSB7ZnVuY3Rpb24oKiwgKik6Kj19IG9wdF9tZXJnZUZuIEZ1bmN0aW9uIHRoYXQgcmVjZWl2ZXMgdGhlIG1lcmdlZFxuICogICAgIHZhbHVlIG9mIHRoZSBwcm9wZXJ0eSBzbyBmYXIgYW5kIHRoZSBuZXh0IHZhbHVlIHRvIGJlIG1lcmdlZCB0byBpdC5cbiAqICAgICBTaG91bGQgcmV0dXJuIHRoZXNlIHR3byBtZXJnZWQgdG9nZXRoZXIuIElmIG5vdCBwYXNzZWQgdGhlIGZpbmFsIHByb3BlcnR5XG4gKiAgICAgd2lsbCBiZSB0aGUgZmlyc3QgdHJ1dGh5IHZhbHVlIGFtb25nIGFuY2VzdG9ycy5cbiAqL1xuZnVuY3Rpb24gZ2V0U3RhdGljUHJvcGVydHkoY3RvciwgcHJvcGVydHlOYW1lLCBvcHRfbWVyZ2VGbikge1xuICB2YXIgbWVyZ2VkTmFtZSA9IHByb3BlcnR5TmFtZSArICdfTUVSR0VEJztcbiAgaWYgKCFjdG9yLmhhc093blByb3BlcnR5KG1lcmdlZE5hbWUpKSB7XG4gICAgdmFyIG1lcmdlZCA9IGN0b3IuaGFzT3duUHJvcGVydHkocHJvcGVydHlOYW1lKSA/IGN0b3JbcHJvcGVydHlOYW1lXSA6IG51bGw7XG4gICAgaWYgKGN0b3IuX19wcm90b19fICYmICFjdG9yLl9fcHJvdG9fXy5pc1Byb3RvdHlwZU9mKEZ1bmN0aW9uKSkge1xuICAgICAgdmFyIG1lcmdlRm4gPSBvcHRfbWVyZ2VGbiB8fCBnZXRGaXJzdFRydXRoeV87XG4gICAgICBtZXJnZWQgPSBtZXJnZUZuKG1lcmdlZCwgZ2V0U3RhdGljUHJvcGVydHkoY3Rvci5fX3Byb3RvX18sIHByb3BlcnR5TmFtZSwgbWVyZ2VGbikpO1xuICAgIH1cbiAgICBjdG9yW21lcmdlZE5hbWVdID0gbWVyZ2VkO1xuICB9XG4gIHJldHVybiBjdG9yW21lcmdlZE5hbWVdO1xufVxuXG4vKipcbiAqIEdldHMgYW4gdW5pcXVlIGlkLiBJZiBgb3B0X29iamVjdGAgYXJndW1lbnQgaXMgcGFzc2VkLCB0aGUgb2JqZWN0IGlzXG4gKiBtdXRhdGVkIHdpdGggYW4gdW5pcXVlIGlkLiBDb25zZWN1dGl2ZSBjYWxscyB3aXRoIHRoZSBzYW1lIG9iamVjdFxuICogcmVmZXJlbmNlIHdvbid0IG11dGF0ZSB0aGUgb2JqZWN0IGFnYWluLCBpbnN0ZWFkIHRoZSBjdXJyZW50IG9iamVjdCB1aWRcbiAqIHJldHVybnMuIFNlZSB7QGxpbmsgVUlEX1BST1BFUlRZfS5cbiAqIEBwYXJhbSB7T2JqZWN0PX0gb3B0X29iamVjdCBPcHRpb25hbCBvYmplY3QgdG8gYmUgbXV0YXRlZCB3aXRoIHRoZSB1aWQuIElmXG4gKiAgICAgbm90IHNwZWNpZmllZCB0aGlzIG1ldGhvZCBvbmx5IHJldHVybnMgdGhlIHVpZC5cbiAqIEBwYXJhbSB7Ym9vbGVhbj19IG9wdF9ub0luaGVyaXRhbmNlIE9wdGlvbmFsIGZsYWcgaW5kaWNhdGluZyBpZiB0aGlzXG4gKiAgICAgb2JqZWN0J3MgdWlkIHByb3BlcnR5IGNhbiBiZSBpbmhlcml0ZWQgZnJvbSBwYXJlbnRzIG9yIG5vdC5cbiAqIEB0aHJvd3Mge0Vycm9yfSB3aGVuIGludm9rZWQgdG8gaW5kaWNhdGUgdGhlIG1ldGhvZCBzaG91bGQgYmUgb3ZlcnJpZGRlbi5cbiAqL1xuZnVuY3Rpb24gZ2V0VWlkKG9wdF9vYmplY3QsIG9wdF9ub0luaGVyaXRhbmNlKSB7XG4gIGlmIChvcHRfb2JqZWN0KSB7XG4gICAgdmFyIGlkID0gb3B0X29iamVjdFtVSURfUFJPUEVSVFldO1xuICAgIGlmIChvcHRfbm9Jbmhlcml0YW5jZSAmJiAhb3B0X29iamVjdC5oYXNPd25Qcm9wZXJ0eShVSURfUFJPUEVSVFkpKSB7XG4gICAgICBpZCA9IG51bGw7XG4gICAgfVxuICAgIHJldHVybiBpZCB8fCAob3B0X29iamVjdFtVSURfUFJPUEVSVFldID0gdW5pcXVlSWRDb3VudGVyXysrKTtcbiAgfVxuICByZXR1cm4gdW5pcXVlSWRDb3VudGVyXysrO1xufVxuXG4vKipcbiAqIFRoZSBpZGVudGl0eSBmdW5jdGlvbi4gUmV0dXJucyBpdHMgZmlyc3QgYXJndW1lbnQuXG4gKiBAcGFyYW0geyo9fSBvcHRfcmV0dXJuVmFsdWUgVGhlIHNpbmdsZSB2YWx1ZSB0aGF0IHdpbGwgYmUgcmV0dXJuZWQuXG4gKiBAcmV0dXJuIHs/fSBUaGUgZmlyc3QgYXJndW1lbnQuXG4gKi9cbmZ1bmN0aW9uIGlkZW50aXR5RnVuY3Rpb24ob3B0X3JldHVyblZhbHVlKSB7XG4gIHJldHVybiBvcHRfcmV0dXJuVmFsdWU7XG59XG5cbi8qKlxuICogUmV0dXJucyB0cnVlIGlmIHRoZSBzcGVjaWZpZWQgdmFsdWUgaXMgYSBib29sZWFuLlxuICogQHBhcmFtIHs/fSB2YWwgVmFyaWFibGUgdG8gdGVzdC5cbiAqIEByZXR1cm4ge2Jvb2xlYW59IFdoZXRoZXIgdmFyaWFibGUgaXMgYm9vbGVhbi5cbiAqL1xuZnVuY3Rpb24gaXNCb29sZWFuKHZhbCkge1xuICByZXR1cm4gdHlwZW9mIHZhbCA9PT0gJ2Jvb2xlYW4nO1xufVxuXG4vKipcbiAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgc3BlY2lmaWVkIHZhbHVlIGlzIG5vdCB1bmRlZmluZWQuXG4gKiBAcGFyYW0gez99IHZhbCBWYXJpYWJsZSB0byB0ZXN0LlxuICogQHJldHVybiB7Ym9vbGVhbn0gV2hldGhlciB2YXJpYWJsZSBpcyBkZWZpbmVkLlxuICovXG5mdW5jdGlvbiBpc0RlZih2YWwpIHtcbiAgcmV0dXJuIHZhbCAhPT0gdW5kZWZpbmVkO1xufVxuXG4vKipcbiAqIFJldHVybnMgdHJ1ZSBpZiB2YWx1ZSBpcyBub3QgdW5kZWZpbmVkIG9yIG51bGwuXG4gKiBAcGFyYW0geyp9IHZhbFxuICogQHJldHVybiB7Ym9vbGVhbn1cbiAqL1xuZnVuY3Rpb24gaXNEZWZBbmROb3ROdWxsKHZhbCkge1xuICByZXR1cm4gaXNEZWYodmFsKSAmJiAhaXNOdWxsKHZhbCk7XG59XG5cbi8qKlxuICogUmV0dXJucyB0cnVlIGlmIHZhbHVlIGlzIGEgZG9jdW1lbnQuXG4gKiBAcGFyYW0geyp9IHZhbFxuICogQHJldHVybiB7Ym9vbGVhbn1cbiAqL1xuZnVuY3Rpb24gaXNEb2N1bWVudCh2YWwpIHtcbiAgcmV0dXJuIHZhbCAmJiAodHlwZW9mIHZhbCA9PT0gJ3VuZGVmaW5lZCcgPyAndW5kZWZpbmVkJyA6IF90eXBlb2YodmFsKSkgPT09ICdvYmplY3QnICYmIHZhbC5ub2RlVHlwZSA9PT0gOTtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIHRydWUgaWYgdmFsdWUgaXMgYSBkb2N1bWVudC1mcmFnbWVudC5cbiAqIEBwYXJhbSB7Kn0gdmFsXG4gKiBAcmV0dXJuIHtib29sZWFufVxuICovXG5mdW5jdGlvbiBpc0RvY3VtZW50RnJhZ21lbnQodmFsKSB7XG4gIHJldHVybiB2YWwgJiYgKHR5cGVvZiB2YWwgPT09ICd1bmRlZmluZWQnID8gJ3VuZGVmaW5lZCcgOiBfdHlwZW9mKHZhbCkpID09PSAnb2JqZWN0JyAmJiB2YWwubm9kZVR5cGUgPT09IDExO1xufVxuXG4vKipcbiAqIFJldHVybnMgdHJ1ZSBpZiB2YWx1ZSBpcyBhIGRvbSBlbGVtZW50LlxuICogQHBhcmFtIHsqfSB2YWxcbiAqIEByZXR1cm4ge2Jvb2xlYW59XG4gKi9cbmZ1bmN0aW9uIGlzRWxlbWVudCh2YWwpIHtcbiAgcmV0dXJuIHZhbCAmJiAodHlwZW9mIHZhbCA9PT0gJ3VuZGVmaW5lZCcgPyAndW5kZWZpbmVkJyA6IF90eXBlb2YodmFsKSkgPT09ICdvYmplY3QnICYmIHZhbC5ub2RlVHlwZSA9PT0gMTtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIHRydWUgaWYgdGhlIHNwZWNpZmllZCB2YWx1ZSBpcyBhIGZ1bmN0aW9uLlxuICogQHBhcmFtIHs/fSB2YWwgVmFyaWFibGUgdG8gdGVzdC5cbiAqIEByZXR1cm4ge2Jvb2xlYW59IFdoZXRoZXIgdmFyaWFibGUgaXMgYSBmdW5jdGlvbi5cbiAqL1xuZnVuY3Rpb24gaXNGdW5jdGlvbih2YWwpIHtcbiAgcmV0dXJuIHR5cGVvZiB2YWwgPT09ICdmdW5jdGlvbic7XG59XG5cbi8qKlxuICogUmV0dXJucyB0cnVlIGlmIHZhbHVlIGlzIG51bGwuXG4gKiBAcGFyYW0geyp9IHZhbFxuICogQHJldHVybiB7Ym9vbGVhbn1cbiAqL1xuZnVuY3Rpb24gaXNOdWxsKHZhbCkge1xuICByZXR1cm4gdmFsID09PSBudWxsO1xufVxuXG4vKipcbiAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgc3BlY2lmaWVkIHZhbHVlIGlzIGEgbnVtYmVyLlxuICogQHBhcmFtIHs/fSB2YWwgVmFyaWFibGUgdG8gdGVzdC5cbiAqIEByZXR1cm4ge2Jvb2xlYW59IFdoZXRoZXIgdmFyaWFibGUgaXMgYSBudW1iZXIuXG4gKi9cbmZ1bmN0aW9uIGlzTnVtYmVyKHZhbCkge1xuICByZXR1cm4gdHlwZW9mIHZhbCA9PT0gJ251bWJlcic7XG59XG5cbi8qKlxuICogUmV0dXJucyB0cnVlIGlmIHZhbHVlIGlzIGEgd2luZG93LlxuICogQHBhcmFtIHsqfSB2YWxcbiAqIEByZXR1cm4ge2Jvb2xlYW59XG4gKi9cbmZ1bmN0aW9uIGlzV2luZG93KHZhbCkge1xuICByZXR1cm4gdmFsICE9PSBudWxsICYmIHZhbCA9PT0gdmFsLndpbmRvdztcbn1cblxuLyoqXG4gKiBSZXR1cm5zIHRydWUgaWYgdGhlIHNwZWNpZmllZCB2YWx1ZSBpcyBhbiBvYmplY3QuIFRoaXMgaW5jbHVkZXMgYXJyYXlzXG4gKiBhbmQgZnVuY3Rpb25zLlxuICogQHBhcmFtIHs/fSB2YWwgVmFyaWFibGUgdG8gdGVzdC5cbiAqIEByZXR1cm4ge2Jvb2xlYW59IFdoZXRoZXIgdmFyaWFibGUgaXMgYW4gb2JqZWN0LlxuICovXG5mdW5jdGlvbiBpc09iamVjdCh2YWwpIHtcbiAgdmFyIHR5cGUgPSB0eXBlb2YgdmFsID09PSAndW5kZWZpbmVkJyA/ICd1bmRlZmluZWQnIDogX3R5cGVvZih2YWwpO1xuICByZXR1cm4gdHlwZSA9PT0gJ29iamVjdCcgJiYgdmFsICE9PSBudWxsIHx8IHR5cGUgPT09ICdmdW5jdGlvbic7XG59XG5cbi8qKlxuICogUmV0dXJucyB0cnVlIGlmIHZhbHVlIGlzIGEgUHJvbWlzZS5cbiAqIEBwYXJhbSB7Kn0gdmFsXG4gKiBAcmV0dXJuIHtib29sZWFufVxuICovXG5mdW5jdGlvbiBpc1Byb21pc2UodmFsKSB7XG4gIHJldHVybiB2YWwgJiYgKHR5cGVvZiB2YWwgPT09ICd1bmRlZmluZWQnID8gJ3VuZGVmaW5lZCcgOiBfdHlwZW9mKHZhbCkpID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgdmFsLnRoZW4gPT09ICdmdW5jdGlvbic7XG59XG5cbi8qKlxuICogUmV0dXJucyB0cnVlIGlmIHZhbHVlIGlzIGEgc3RyaW5nLlxuICogQHBhcmFtIHsqfSB2YWxcbiAqIEByZXR1cm4ge2Jvb2xlYW59XG4gKi9cbmZ1bmN0aW9uIGlzU3RyaW5nKHZhbCkge1xuICByZXR1cm4gdHlwZW9mIHZhbCA9PT0gJ3N0cmluZycgfHwgdmFsIGluc3RhbmNlb2YgU3RyaW5nO1xufVxuXG4vKipcbiAqIFNldHMgdG8gdHJ1ZSBpZiBydW5uaW5nIGluc2lkZSBOb2RlLmpzIGVudmlyb25tZW50IHdpdGggZXh0cmEgY2hlY2sgZm9yXG4gKiBgcHJvY2Vzcy5icm93c2VyYCB0byBza2lwIEthcm1hIHJ1bm5lciBlbnZpcm9ubWVudC4gS2FybWEgZW52aXJvbm1lbnQgaGFzXG4gKiBgcHJvY2Vzc2AgZGVmaW5lZCBldmVuIHRob3VnaCBpdCBydW5zIG9uIHRoZSBicm93c2VyLlxuICogQHJldHVybiB7Ym9vbGVhbn1cbiAqL1xuZnVuY3Rpb24gaXNTZXJ2ZXJTaWRlKCkge1xuICByZXR1cm4gdHlwZW9mIHByb2Nlc3MgIT09ICd1bmRlZmluZWQnICYmIHR5cGVvZiBwcm9jZXNzLmVudiAhPT0gJ3VuZGVmaW5lZCcgJiYgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICd0ZXN0JyAmJiAhcHJvY2Vzcy5icm93c2VyO1xufVxuXG4vKipcbiAqIE51bGwgZnVuY3Rpb24gdXNlZCBmb3IgZGVmYXVsdCB2YWx1ZXMgb2YgY2FsbGJhY2tzLCBldGMuXG4gKiBAcmV0dXJuIHt2b2lkfSBOb3RoaW5nLlxuICovXG5mdW5jdGlvbiBudWxsRnVuY3Rpb24oKSB7fVxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9tZXRhbC9saWIvY29yZU5hbWVkLmpzXG4vLyBtb2R1bGUgaWQgPSA1MFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIndXNlIHN0cmljdCc7XG5cbi8qKlxuICogRGlzcG9zYWJsZSB1dGlsaXR5LiBXaGVuIGluaGVyaXRlZCBwcm92aWRlcyB0aGUgYGRpc3Bvc2VgIGZ1bmN0aW9uIHRvIGl0c1xuICogc3ViY2xhc3MsIHdoaWNoIGlzIHJlc3BvbnNpYmxlIGZvciBkaXNwb3Npbmcgb2YgYW55IG9iamVjdCByZWZlcmVuY2VzXG4gKiB3aGVuIGFuIGluc3RhbmNlIHdvbid0IGJlIHVzZWQgYW55bW9yZS4gU3ViY2xhc3NlcyBzaG91bGQgb3ZlcnJpZGVcbiAqIGBkaXNwb3NlSW50ZXJuYWxgIHRvIGltcGxlbWVudCBhbnkgc3BlY2lmaWMgZGlzcG9zaW5nIGxvZ2ljLlxuICogQGNvbnN0cnVjdG9yXG4gKi9cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG5cdHZhbHVlOiB0cnVlXG59KTtcblxudmFyIF9jcmVhdGVDbGFzcyA9IGZ1bmN0aW9uICgpIHsgZnVuY3Rpb24gZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsgfSB9IHJldHVybiBmdW5jdGlvbiAoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyByZXR1cm4gQ29uc3RydWN0b3I7IH07IH0oKTtcblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxudmFyIERpc3Bvc2FibGUgPSBmdW5jdGlvbiAoKSB7XG5cdGZ1bmN0aW9uIERpc3Bvc2FibGUoKSB7XG5cdFx0X2NsYXNzQ2FsbENoZWNrKHRoaXMsIERpc3Bvc2FibGUpO1xuXG5cdFx0LyoqXG4gICAqIEZsYWcgaW5kaWNhdGluZyBpZiB0aGlzIGluc3RhbmNlIGhhcyBhbHJlYWR5IGJlZW4gZGlzcG9zZWQuXG4gICAqIEB0eXBlIHtib29sZWFufVxuICAgKiBAcHJvdGVjdGVkXG4gICAqL1xuXHRcdHRoaXMuZGlzcG9zZWRfID0gZmFsc2U7XG5cdH1cblxuXHQvKipcbiAgKiBEaXNwb3NlcyBvZiB0aGlzIGluc3RhbmNlJ3Mgb2JqZWN0IHJlZmVyZW5jZXMuIENhbGxzIGBkaXNwb3NlSW50ZXJuYWxgLlxuICAqL1xuXG5cblx0X2NyZWF0ZUNsYXNzKERpc3Bvc2FibGUsIFt7XG5cdFx0a2V5OiAnZGlzcG9zZScsXG5cdFx0dmFsdWU6IGZ1bmN0aW9uIGRpc3Bvc2UoKSB7XG5cdFx0XHRpZiAoIXRoaXMuZGlzcG9zZWRfKSB7XG5cdFx0XHRcdHRoaXMuZGlzcG9zZUludGVybmFsKCk7XG5cdFx0XHRcdHRoaXMuZGlzcG9zZWRfID0gdHJ1ZTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHQvKipcbiAgICogU3ViY2xhc3NlcyBzaG91bGQgb3ZlcnJpZGUgdGhpcyBtZXRob2QgdG8gaW1wbGVtZW50IGFueSBzcGVjaWZpY1xuICAgKiBkaXNwb3NpbmcgbG9naWMgKGxpa2UgY2xlYXJpbmcgcmVmZXJlbmNlcyBhbmQgY2FsbGluZyBgZGlzcG9zZWAgb24gb3RoZXJcbiAgICogZGlzcG9zYWJsZXMpLlxuICAgKi9cblxuXHR9LCB7XG5cdFx0a2V5OiAnZGlzcG9zZUludGVybmFsJyxcblx0XHR2YWx1ZTogZnVuY3Rpb24gZGlzcG9zZUludGVybmFsKCkge31cblxuXHRcdC8qKlxuICAgKiBDaGVja3MgaWYgdGhpcyBpbnN0YW5jZSBoYXMgYWxyZWFkeSBiZWVuIGRpc3Bvc2VkLlxuICAgKiBAcmV0dXJuIHtib29sZWFufVxuICAgKi9cblxuXHR9LCB7XG5cdFx0a2V5OiAnaXNEaXNwb3NlZCcsXG5cdFx0dmFsdWU6IGZ1bmN0aW9uIGlzRGlzcG9zZWQoKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5kaXNwb3NlZF87XG5cdFx0fVxuXHR9XSk7XG5cblx0cmV0dXJuIERpc3Bvc2FibGU7XG59KCk7XG5cbmV4cG9ydHMuZGVmYXVsdCA9IERpc3Bvc2FibGU7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L21ldGFsL2xpYi9kaXNwb3NhYmxlL0Rpc3Bvc2FibGUuanNcbi8vIG1vZHVsZSBpZCA9IDUxXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG5cdHZhbHVlOiB0cnVlXG59KTtcblxudmFyIF9jcmVhdGVDbGFzcyA9IGZ1bmN0aW9uICgpIHsgZnVuY3Rpb24gZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsgfSB9IHJldHVybiBmdW5jdGlvbiAoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyByZXR1cm4gQ29uc3RydWN0b3I7IH07IH0oKTtcblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxudmFyIG9iamVjdCA9IGZ1bmN0aW9uICgpIHtcblx0ZnVuY3Rpb24gb2JqZWN0KCkge1xuXHRcdF9jbGFzc0NhbGxDaGVjayh0aGlzLCBvYmplY3QpO1xuXHR9XG5cblx0X2NyZWF0ZUNsYXNzKG9iamVjdCwgbnVsbCwgW3tcblx0XHRrZXk6ICdtaXhpbicsXG5cblx0XHQvKipcbiAgICogQ29waWVzIGFsbCB0aGUgbWVtYmVycyBvZiBhIHNvdXJjZSBvYmplY3QgdG8gYSB0YXJnZXQgb2JqZWN0LlxuICAgKiBAcGFyYW0ge09iamVjdH0gdGFyZ2V0IFRhcmdldCBvYmplY3QuXG4gICAqIEBwYXJhbSB7Li4uT2JqZWN0fSB2YXJfYXJncyBUaGUgb2JqZWN0cyBmcm9tIHdoaWNoIHZhbHVlcyB3aWxsIGJlIGNvcGllZC5cbiAgICogQHJldHVybiB7T2JqZWN0fSBSZXR1cm5zIHRoZSB0YXJnZXQgb2JqZWN0IHJlZmVyZW5jZS5cbiAgICovXG5cdFx0dmFsdWU6IGZ1bmN0aW9uIG1peGluKHRhcmdldCkge1xuXHRcdFx0dmFyIGtleSA9IHZvaWQgMCxcblx0XHRcdCAgICBzb3VyY2UgPSB2b2lkIDA7XG5cdFx0XHRmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuXHRcdFx0XHRzb3VyY2UgPSBhcmd1bWVudHNbaV07XG5cdFx0XHRcdGZvciAoa2V5IGluIHNvdXJjZSkge1xuXHRcdFx0XHRcdHRhcmdldFtrZXldID0gc291cmNlW2tleV07XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdHJldHVybiB0YXJnZXQ7XG5cdFx0fVxuXG5cdFx0LyoqXG4gICAqIFJldHVybnMgYW4gb2JqZWN0IGJhc2VkIG9uIGl0cyBmdWxseSBxdWFsaWZpZWQgZXh0ZXJuYWwgbmFtZS5cbiAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgVGhlIGZ1bGx5IHF1YWxpZmllZCBuYW1lLlxuICAgKiBAcGFyYW0ge29iamVjdD19IG9wdF9vYmogVGhlIG9iamVjdCB3aXRoaW4gd2hpY2ggdG8gbG9vazsgZGVmYXVsdCBpc1xuICAgKiAgICAgPGNvZGU+d2luZG93PC9jb2RlPi5cbiAgICogQHJldHVybiB7P30gVGhlIHZhbHVlIChvYmplY3Qgb3IgcHJpbWl0aXZlKSBvciwgaWYgbm90IGZvdW5kLCB1bmRlZmluZWQuXG4gICAqL1xuXG5cdH0sIHtcblx0XHRrZXk6ICdnZXRPYmplY3RCeU5hbWUnLFxuXHRcdHZhbHVlOiBmdW5jdGlvbiBnZXRPYmplY3RCeU5hbWUobmFtZSwgb3B0X29iaikge1xuXHRcdFx0dmFyIHNjb3BlID0gb3B0X29iaiB8fCB3aW5kb3c7XG5cdFx0XHR2YXIgcGFydHMgPSBuYW1lLnNwbGl0KCcuJyk7XG5cdFx0XHRyZXR1cm4gcGFydHMucmVkdWNlKGZ1bmN0aW9uIChwYXJ0LCBrZXkpIHtcblx0XHRcdFx0cmV0dXJuIHBhcnRba2V5XTtcblx0XHRcdH0sIHNjb3BlKTtcblx0XHR9XG5cblx0XHQvKipcbiAgICogUmV0dXJucyBhIG5ldyBvYmplY3Qgd2l0aCB0aGUgc2FtZSBrZXlzIGFzIHRoZSBnaXZlbiBvbmUsIGJ1dCB3aXRoXG4gICAqIHRoZWlyIHZhbHVlcyBzZXQgdG8gdGhlIHJldHVybiB2YWx1ZXMgb2YgdGhlIHNwZWNpZmllZCBmdW5jdGlvbi5cbiAgICogQHBhcmFtIHshT2JqZWN0fSBvYmpcbiAgICogQHBhcmFtIHshZnVuY3Rpb24oc3RyaW5nLCAqKX0gZm5cbiAgICogQHJldHVybiB7IU9iamVjdH1cbiAgICovXG5cblx0fSwge1xuXHRcdGtleTogJ21hcCcsXG5cdFx0dmFsdWU6IGZ1bmN0aW9uIG1hcChvYmosIGZuKSB7XG5cdFx0XHR2YXIgbWFwcGVkT2JqID0ge307XG5cdFx0XHR2YXIga2V5cyA9IE9iamVjdC5rZXlzKG9iaik7XG5cdFx0XHRmb3IgKHZhciBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyBpKyspIHtcblx0XHRcdFx0bWFwcGVkT2JqW2tleXNbaV1dID0gZm4oa2V5c1tpXSwgb2JqW2tleXNbaV1dKTtcblx0XHRcdH1cblx0XHRcdHJldHVybiBtYXBwZWRPYmo7XG5cdFx0fVxuXG5cdFx0LyoqXG4gICAqIENoZWNrcyBpZiB0aGUgdHdvIGdpdmVuIG9iamVjdHMgYXJlIGVxdWFsLiBUaGlzIGlzIGRvbmUgdmlhIGEgc2hhbGxvd1xuICAgKiBjaGVjaywgaW5jbHVkaW5nIG9ubHkgdGhlIGtleXMgZGlyZWN0bHkgY29udGFpbmVkIGJ5IHRoZSAyIG9iamVjdHMuXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59XG4gICAqL1xuXG5cdH0sIHtcblx0XHRrZXk6ICdzaGFsbG93RXF1YWwnLFxuXHRcdHZhbHVlOiBmdW5jdGlvbiBzaGFsbG93RXF1YWwob2JqMSwgb2JqMikge1xuXHRcdFx0aWYgKG9iajEgPT09IG9iajIpIHtcblx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHR9XG5cblx0XHRcdHZhciBrZXlzMSA9IE9iamVjdC5rZXlzKG9iajEpO1xuXHRcdFx0dmFyIGtleXMyID0gT2JqZWN0LmtleXMob2JqMik7XG5cdFx0XHRpZiAoa2V5czEubGVuZ3RoICE9PSBrZXlzMi5sZW5ndGgpIHtcblx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0fVxuXG5cdFx0XHRmb3IgKHZhciBpID0gMDsgaSA8IGtleXMxLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRcdGlmIChvYmoxW2tleXMxW2ldXSAhPT0gb2JqMltrZXlzMVtpXV0pIHtcblx0XHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdHJldHVybiB0cnVlO1xuXHRcdH1cblx0fV0pO1xuXG5cdHJldHVybiBvYmplY3Q7XG59KCk7XG5cbmV4cG9ydHMuZGVmYXVsdCA9IG9iamVjdDtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vbWV0YWwvbGliL29iamVjdC9vYmplY3QuanNcbi8vIG1vZHVsZSBpZCA9IDUyXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG5cdHZhbHVlOiB0cnVlXG59KTtcblxudmFyIF9jcmVhdGVDbGFzcyA9IGZ1bmN0aW9uICgpIHsgZnVuY3Rpb24gZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsgfSB9IHJldHVybiBmdW5jdGlvbiAoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyByZXR1cm4gQ29uc3RydWN0b3I7IH07IH0oKTtcblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxudmFyIHN0cmluZyA9IGZ1bmN0aW9uICgpIHtcblx0ZnVuY3Rpb24gc3RyaW5nKCkge1xuXHRcdF9jbGFzc0NhbGxDaGVjayh0aGlzLCBzdHJpbmcpO1xuXHR9XG5cblx0X2NyZWF0ZUNsYXNzKHN0cmluZywgbnVsbCwgW3tcblx0XHRrZXk6ICdjYXNlSW5zZW5zaXRpdmVDb21wYXJlJyxcblxuXHRcdC8qKlxuICAgKiBDb21wYXJlcyB0aGUgZ2l2ZW4gc3RyaW5ncyB3aXRob3V0IHRha2luZyB0aGUgY2FzZSBpbnRvIGFjY291bnQuXG4gICAqIEBwYXJhbSB7c3RyaW5nfG51bWJlcn0gc3RyMVxuICAgKiBAcGFyYW0ge3N0cmluZ3xudW1iZXJ9IHN0cjJcbiAgICogQHJldHVybiB7bnVtYmVyfSBFaXRoZXIgLTEsIDAgb3IgMSwgYWNjb3JkaW5nIHRvIGlmIHRoZSBmaXJzdCBzdHJpbmcgaXNcbiAgICogICAgIFwic21hbGxlclwiLCBlcXVhbCBvciBcImJpZ2dlclwiIHRoYW4gdGhlIHNlY29uZCBnaXZlbiBzdHJpbmcuXG4gICAqL1xuXHRcdHZhbHVlOiBmdW5jdGlvbiBjYXNlSW5zZW5zaXRpdmVDb21wYXJlKHN0cjEsIHN0cjIpIHtcblx0XHRcdHZhciB0ZXN0MSA9IFN0cmluZyhzdHIxKS50b0xvd2VyQ2FzZSgpO1xuXHRcdFx0dmFyIHRlc3QyID0gU3RyaW5nKHN0cjIpLnRvTG93ZXJDYXNlKCk7XG5cblx0XHRcdGlmICh0ZXN0MSA8IHRlc3QyKSB7XG5cdFx0XHRcdHJldHVybiAtMTtcblx0XHRcdH0gZWxzZSBpZiAodGVzdDEgPT09IHRlc3QyKSB7XG5cdFx0XHRcdHJldHVybiAwO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0cmV0dXJuIDE7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0LyoqXG4gICAqIFJlbW92ZXMgdGhlIGJyZWFraW5nIHNwYWNlcyBmcm9tIHRoZSBsZWZ0IGFuZCByaWdodCBvZiB0aGUgc3RyaW5nIGFuZFxuICAgKiBjb2xsYXBzZXMgdGhlIHNlcXVlbmNlcyBvZiBicmVha2luZyBzcGFjZXMgaW4gdGhlIG1pZGRsZSBpbnRvIHNpbmdsZSBzcGFjZXMuXG4gICAqIFRoZSBvcmlnaW5hbCBhbmQgdGhlIHJlc3VsdCBzdHJpbmdzIHJlbmRlciB0aGUgc2FtZSB3YXkgaW4gSFRNTC5cbiAgICogQHBhcmFtIHtzdHJpbmd9IHN0ciBBIHN0cmluZyBpbiB3aGljaCB0byBjb2xsYXBzZSBzcGFjZXMuXG4gICAqIEByZXR1cm4ge3N0cmluZ30gQ29weSBvZiB0aGUgc3RyaW5nIHdpdGggbm9ybWFsaXplZCBicmVha2luZyBzcGFjZXMuXG4gICAqL1xuXG5cdH0sIHtcblx0XHRrZXk6ICdjb2xsYXBzZUJyZWFraW5nU3BhY2VzJyxcblx0XHR2YWx1ZTogZnVuY3Rpb24gY29sbGFwc2VCcmVha2luZ1NwYWNlcyhzdHIpIHtcblx0XHRcdHJldHVybiBzdHIucmVwbGFjZSgvW1xcdFxcclxcbiBdKy9nLCAnICcpLnJlcGxhY2UoL15bXFx0XFxyXFxuIF0rfFtcXHRcXHJcXG4gXSskL2csICcnKTtcblx0XHR9XG5cblx0XHQvKipcbiAgKiBFc2NhcGVzIGNoYXJhY3RlcnMgaW4gdGhlIHN0cmluZyB0aGF0IGFyZSBub3Qgc2FmZSB0byB1c2UgaW4gYSBSZWdFeHAuXG4gICogQHBhcmFtIHsqfSBzdHIgVGhlIHN0cmluZyB0byBlc2NhcGUuIElmIG5vdCBhIHN0cmluZywgaXQgd2lsbCBiZSBjYXN0ZWRcbiAgKiAgICAgdG8gb25lLlxuICAqIEByZXR1cm4ge3N0cmluZ30gQSBSZWdFeHAgc2FmZSwgZXNjYXBlZCBjb3B5IG9mIHtAY29kZSBzfS5cbiAgKi9cblxuXHR9LCB7XG5cdFx0a2V5OiAnZXNjYXBlUmVnZXgnLFxuXHRcdHZhbHVlOiBmdW5jdGlvbiBlc2NhcGVSZWdleChzdHIpIHtcblx0XHRcdHJldHVybiBTdHJpbmcoc3RyKS5yZXBsYWNlKC8oWy0oKVxcW1xcXXt9Kz8qLiRcXF58LDojPCFcXFxcXSkvZywgJ1xcXFwkMScpLnJlcGxhY2UoL1xceDA4L2csICdcXFxceDA4Jyk7XG5cdFx0fVxuXG5cdFx0LyoqXG4gICogUmV0dXJucyBhIHN0cmluZyB3aXRoIGF0IGxlYXN0IDY0LWJpdHMgb2YgcmFuZG9tbmVzcy5cbiAgKiBAcmV0dXJuIHtzdHJpbmd9IEEgcmFuZG9tIHN0cmluZywgZS5nLiBzbjFzN3ZiNGdjaWMuXG4gICovXG5cblx0fSwge1xuXHRcdGtleTogJ2dldFJhbmRvbVN0cmluZycsXG5cdFx0dmFsdWU6IGZ1bmN0aW9uIGdldFJhbmRvbVN0cmluZygpIHtcblx0XHRcdHZhciB4ID0gMjE0NzQ4MzY0ODtcblx0XHRcdHJldHVybiBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiB4KS50b1N0cmluZygzNikgKyBNYXRoLmFicyhNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiB4KSBeIERhdGUubm93KCkpLnRvU3RyaW5nKDM2KTtcblx0XHR9XG5cblx0XHQvKipcbiAgICogQ2FsY3VsYXRlcyB0aGUgaGFzaGNvZGUgZm9yIGEgc3RyaW5nLiBUaGUgaGFzaGNvZGUgdmFsdWUgaXMgY29tcHV0ZWQgYnlcbiAgICogdGhlIHN1bSBhbGdvcml0aG06IHNbMF0qMzFeKG4tMSkgKyBzWzFdKjMxXihuLTIpICsgLi4uICsgc1tuLTFdLiBBIG5pY2VcbiAgICogcHJvcGVydHkgb2YgdXNpbmcgMzEgcHJpbWUgaXMgdGhhdCB0aGUgbXVsdGlwbGljYXRpb24gY2FuIGJlIHJlcGxhY2VkIGJ5XG4gICAqIGEgc2hpZnQgYW5kIGEgc3VidHJhY3Rpb24gZm9yIGJldHRlciBwZXJmb3JtYW5jZTogMzEqaSA9PSAoaTw8NSktaS5cbiAgICogTW9kZXJuIFZNcyBkbyB0aGlzIHNvcnQgb2Ygb3B0aW1pemF0aW9uIGF1dG9tYXRpY2FsbHkuXG4gICAqIEBwYXJhbSB7U3RyaW5nfSB2YWwgVGFyZ2V0IHN0cmluZy5cbiAgICogQHJldHVybiB7TnVtYmVyfSBSZXR1cm5zIHRoZSBzdHJpbmcgaGFzaGNvZGUuXG4gICAqL1xuXG5cdH0sIHtcblx0XHRrZXk6ICdoYXNoQ29kZScsXG5cdFx0dmFsdWU6IGZ1bmN0aW9uIGhhc2hDb2RlKHZhbCkge1xuXHRcdFx0dmFyIGhhc2ggPSAwO1xuXHRcdFx0Zm9yICh2YXIgaSA9IDAsIGxlbiA9IHZhbC5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuXHRcdFx0XHRoYXNoID0gMzEgKiBoYXNoICsgdmFsLmNoYXJDb2RlQXQoaSk7XG5cdFx0XHRcdGhhc2ggJT0gMHgxMDAwMDAwMDA7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gaGFzaDtcblx0XHR9XG5cblx0XHQvKipcbiAgICogUmVwbGFjZXMgaW50ZXJ2YWwgaW50byB0aGUgc3RyaW5nIHdpdGggc3BlY2lmaWVkIHZhbHVlLCBlLmcuXG4gICAqIGByZXBsYWNlSW50ZXJ2YWwoXCJhYmNkZVwiLCAxLCA0LCBcIlwiKWAgcmV0dXJucyBcImFlXCIuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBzdHIgVGhlIGlucHV0IHN0cmluZy5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IHN0YXJ0IFN0YXJ0IGludGVydmFsIHBvc2l0aW9uIHRvIGJlIHJlcGxhY2VkLlxuICAgKiBAcGFyYW0ge051bWJlcn0gZW5kIEVuZCBpbnRlcnZhbCBwb3NpdGlvbiB0byBiZSByZXBsYWNlZC5cbiAgICogQHBhcmFtIHtzdHJpbmd9IHZhbHVlIFRoZSB2YWx1ZSB0aGF0IHJlcGxhY2VzIHRoZSBzcGVjaWZpZWQgaW50ZXJ2YWwuXG4gICAqIEByZXR1cm4ge3N0cmluZ31cbiAgICovXG5cblx0fSwge1xuXHRcdGtleTogJ3JlcGxhY2VJbnRlcnZhbCcsXG5cdFx0dmFsdWU6IGZ1bmN0aW9uIHJlcGxhY2VJbnRlcnZhbChzdHIsIHN0YXJ0LCBlbmQsIHZhbHVlKSB7XG5cdFx0XHRyZXR1cm4gc3RyLnN1YnN0cmluZygwLCBzdGFydCkgKyB2YWx1ZSArIHN0ci5zdWJzdHJpbmcoZW5kKTtcblx0XHR9XG5cdH1dKTtcblxuXHRyZXR1cm4gc3RyaW5nO1xufSgpO1xuXG5leHBvcnRzLmRlZmF1bHQgPSBzdHJpbmc7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L21ldGFsL2xpYi9zdHJpbmcvc3RyaW5nLmpzXG4vLyBtb2R1bGUgaWQgPSA1M1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvLyBDb3B5cmlnaHQgSm95ZW50LCBJbmMuIGFuZCBvdGhlciBOb2RlIGNvbnRyaWJ1dG9ycy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYVxuLy8gY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZVxuLy8gXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nXG4vLyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsXG4vLyBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0XG4vLyBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGVcbi8vIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkXG4vLyBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTXG4vLyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4vLyBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOXG4vLyBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSxcbi8vIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUlxuLy8gT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRVxuLy8gVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cblxuLy8gcmVzb2x2ZXMgLiBhbmQgLi4gZWxlbWVudHMgaW4gYSBwYXRoIGFycmF5IHdpdGggZGlyZWN0b3J5IG5hbWVzIHRoZXJlXG4vLyBtdXN0IGJlIG5vIHNsYXNoZXMsIGVtcHR5IGVsZW1lbnRzLCBvciBkZXZpY2UgbmFtZXMgKGM6XFwpIGluIHRoZSBhcnJheVxuLy8gKHNvIGFsc28gbm8gbGVhZGluZyBhbmQgdHJhaWxpbmcgc2xhc2hlcyAtIGl0IGRvZXMgbm90IGRpc3Rpbmd1aXNoXG4vLyByZWxhdGl2ZSBhbmQgYWJzb2x1dGUgcGF0aHMpXG5mdW5jdGlvbiBub3JtYWxpemVBcnJheShwYXJ0cywgYWxsb3dBYm92ZVJvb3QpIHtcbiAgLy8gaWYgdGhlIHBhdGggdHJpZXMgdG8gZ28gYWJvdmUgdGhlIHJvb3QsIGB1cGAgZW5kcyB1cCA+IDBcbiAgdmFyIHVwID0gMDtcbiAgZm9yICh2YXIgaSA9IHBhcnRzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgdmFyIGxhc3QgPSBwYXJ0c1tpXTtcbiAgICBpZiAobGFzdCA9PT0gJy4nKSB7XG4gICAgICBwYXJ0cy5zcGxpY2UoaSwgMSk7XG4gICAgfSBlbHNlIGlmIChsYXN0ID09PSAnLi4nKSB7XG4gICAgICBwYXJ0cy5zcGxpY2UoaSwgMSk7XG4gICAgICB1cCsrO1xuICAgIH0gZWxzZSBpZiAodXApIHtcbiAgICAgIHBhcnRzLnNwbGljZShpLCAxKTtcbiAgICAgIHVwLS07XG4gICAgfVxuICB9XG5cbiAgLy8gaWYgdGhlIHBhdGggaXMgYWxsb3dlZCB0byBnbyBhYm92ZSB0aGUgcm9vdCwgcmVzdG9yZSBsZWFkaW5nIC4uc1xuICBpZiAoYWxsb3dBYm92ZVJvb3QpIHtcbiAgICBmb3IgKDsgdXAtLTsgdXApIHtcbiAgICAgIHBhcnRzLnVuc2hpZnQoJy4uJyk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHBhcnRzO1xufVxuXG4vLyBTcGxpdCBhIGZpbGVuYW1lIGludG8gW3Jvb3QsIGRpciwgYmFzZW5hbWUsIGV4dF0sIHVuaXggdmVyc2lvblxuLy8gJ3Jvb3QnIGlzIGp1c3QgYSBzbGFzaCwgb3Igbm90aGluZy5cbnZhciBzcGxpdFBhdGhSZSA9XG4gICAgL14oXFwvP3wpKFtcXHNcXFNdKj8pKCg/OlxcLnsxLDJ9fFteXFwvXSs/fCkoXFwuW14uXFwvXSp8KSkoPzpbXFwvXSopJC87XG52YXIgc3BsaXRQYXRoID0gZnVuY3Rpb24oZmlsZW5hbWUpIHtcbiAgcmV0dXJuIHNwbGl0UGF0aFJlLmV4ZWMoZmlsZW5hbWUpLnNsaWNlKDEpO1xufTtcblxuLy8gcGF0aC5yZXNvbHZlKFtmcm9tIC4uLl0sIHRvKVxuLy8gcG9zaXggdmVyc2lvblxuZXhwb3J0cy5yZXNvbHZlID0gZnVuY3Rpb24oKSB7XG4gIHZhciByZXNvbHZlZFBhdGggPSAnJyxcbiAgICAgIHJlc29sdmVkQWJzb2x1dGUgPSBmYWxzZTtcblxuICBmb3IgKHZhciBpID0gYXJndW1lbnRzLmxlbmd0aCAtIDE7IGkgPj0gLTEgJiYgIXJlc29sdmVkQWJzb2x1dGU7IGktLSkge1xuICAgIHZhciBwYXRoID0gKGkgPj0gMCkgPyBhcmd1bWVudHNbaV0gOiBwcm9jZXNzLmN3ZCgpO1xuXG4gICAgLy8gU2tpcCBlbXB0eSBhbmQgaW52YWxpZCBlbnRyaWVzXG4gICAgaWYgKHR5cGVvZiBwYXRoICE9PSAnc3RyaW5nJykge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQXJndW1lbnRzIHRvIHBhdGgucmVzb2x2ZSBtdXN0IGJlIHN0cmluZ3MnKTtcbiAgICB9IGVsc2UgaWYgKCFwYXRoKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICByZXNvbHZlZFBhdGggPSBwYXRoICsgJy8nICsgcmVzb2x2ZWRQYXRoO1xuICAgIHJlc29sdmVkQWJzb2x1dGUgPSBwYXRoLmNoYXJBdCgwKSA9PT0gJy8nO1xuICB9XG5cbiAgLy8gQXQgdGhpcyBwb2ludCB0aGUgcGF0aCBzaG91bGQgYmUgcmVzb2x2ZWQgdG8gYSBmdWxsIGFic29sdXRlIHBhdGgsIGJ1dFxuICAvLyBoYW5kbGUgcmVsYXRpdmUgcGF0aHMgdG8gYmUgc2FmZSAobWlnaHQgaGFwcGVuIHdoZW4gcHJvY2Vzcy5jd2QoKSBmYWlscylcblxuICAvLyBOb3JtYWxpemUgdGhlIHBhdGhcbiAgcmVzb2x2ZWRQYXRoID0gbm9ybWFsaXplQXJyYXkoZmlsdGVyKHJlc29sdmVkUGF0aC5zcGxpdCgnLycpLCBmdW5jdGlvbihwKSB7XG4gICAgcmV0dXJuICEhcDtcbiAgfSksICFyZXNvbHZlZEFic29sdXRlKS5qb2luKCcvJyk7XG5cbiAgcmV0dXJuICgocmVzb2x2ZWRBYnNvbHV0ZSA/ICcvJyA6ICcnKSArIHJlc29sdmVkUGF0aCkgfHwgJy4nO1xufTtcblxuLy8gcGF0aC5ub3JtYWxpemUocGF0aClcbi8vIHBvc2l4IHZlcnNpb25cbmV4cG9ydHMubm9ybWFsaXplID0gZnVuY3Rpb24ocGF0aCkge1xuICB2YXIgaXNBYnNvbHV0ZSA9IGV4cG9ydHMuaXNBYnNvbHV0ZShwYXRoKSxcbiAgICAgIHRyYWlsaW5nU2xhc2ggPSBzdWJzdHIocGF0aCwgLTEpID09PSAnLyc7XG5cbiAgLy8gTm9ybWFsaXplIHRoZSBwYXRoXG4gIHBhdGggPSBub3JtYWxpemVBcnJheShmaWx0ZXIocGF0aC5zcGxpdCgnLycpLCBmdW5jdGlvbihwKSB7XG4gICAgcmV0dXJuICEhcDtcbiAgfSksICFpc0Fic29sdXRlKS5qb2luKCcvJyk7XG5cbiAgaWYgKCFwYXRoICYmICFpc0Fic29sdXRlKSB7XG4gICAgcGF0aCA9ICcuJztcbiAgfVxuICBpZiAocGF0aCAmJiB0cmFpbGluZ1NsYXNoKSB7XG4gICAgcGF0aCArPSAnLyc7XG4gIH1cblxuICByZXR1cm4gKGlzQWJzb2x1dGUgPyAnLycgOiAnJykgKyBwYXRoO1xufTtcblxuLy8gcG9zaXggdmVyc2lvblxuZXhwb3J0cy5pc0Fic29sdXRlID0gZnVuY3Rpb24ocGF0aCkge1xuICByZXR1cm4gcGF0aC5jaGFyQXQoMCkgPT09ICcvJztcbn07XG5cbi8vIHBvc2l4IHZlcnNpb25cbmV4cG9ydHMuam9pbiA9IGZ1bmN0aW9uKCkge1xuICB2YXIgcGF0aHMgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDApO1xuICByZXR1cm4gZXhwb3J0cy5ub3JtYWxpemUoZmlsdGVyKHBhdGhzLCBmdW5jdGlvbihwLCBpbmRleCkge1xuICAgIGlmICh0eXBlb2YgcCAhPT0gJ3N0cmluZycpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0FyZ3VtZW50cyB0byBwYXRoLmpvaW4gbXVzdCBiZSBzdHJpbmdzJyk7XG4gICAgfVxuICAgIHJldHVybiBwO1xuICB9KS5qb2luKCcvJykpO1xufTtcblxuXG4vLyBwYXRoLnJlbGF0aXZlKGZyb20sIHRvKVxuLy8gcG9zaXggdmVyc2lvblxuZXhwb3J0cy5yZWxhdGl2ZSA9IGZ1bmN0aW9uKGZyb20sIHRvKSB7XG4gIGZyb20gPSBleHBvcnRzLnJlc29sdmUoZnJvbSkuc3Vic3RyKDEpO1xuICB0byA9IGV4cG9ydHMucmVzb2x2ZSh0bykuc3Vic3RyKDEpO1xuXG4gIGZ1bmN0aW9uIHRyaW0oYXJyKSB7XG4gICAgdmFyIHN0YXJ0ID0gMDtcbiAgICBmb3IgKDsgc3RhcnQgPCBhcnIubGVuZ3RoOyBzdGFydCsrKSB7XG4gICAgICBpZiAoYXJyW3N0YXJ0XSAhPT0gJycpIGJyZWFrO1xuICAgIH1cblxuICAgIHZhciBlbmQgPSBhcnIubGVuZ3RoIC0gMTtcbiAgICBmb3IgKDsgZW5kID49IDA7IGVuZC0tKSB7XG4gICAgICBpZiAoYXJyW2VuZF0gIT09ICcnKSBicmVhaztcbiAgICB9XG5cbiAgICBpZiAoc3RhcnQgPiBlbmQpIHJldHVybiBbXTtcbiAgICByZXR1cm4gYXJyLnNsaWNlKHN0YXJ0LCBlbmQgLSBzdGFydCArIDEpO1xuICB9XG5cbiAgdmFyIGZyb21QYXJ0cyA9IHRyaW0oZnJvbS5zcGxpdCgnLycpKTtcbiAgdmFyIHRvUGFydHMgPSB0cmltKHRvLnNwbGl0KCcvJykpO1xuXG4gIHZhciBsZW5ndGggPSBNYXRoLm1pbihmcm9tUGFydHMubGVuZ3RoLCB0b1BhcnRzLmxlbmd0aCk7XG4gIHZhciBzYW1lUGFydHNMZW5ndGggPSBsZW5ndGg7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICBpZiAoZnJvbVBhcnRzW2ldICE9PSB0b1BhcnRzW2ldKSB7XG4gICAgICBzYW1lUGFydHNMZW5ndGggPSBpO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG5cbiAgdmFyIG91dHB1dFBhcnRzID0gW107XG4gIGZvciAodmFyIGkgPSBzYW1lUGFydHNMZW5ndGg7IGkgPCBmcm9tUGFydHMubGVuZ3RoOyBpKyspIHtcbiAgICBvdXRwdXRQYXJ0cy5wdXNoKCcuLicpO1xuICB9XG5cbiAgb3V0cHV0UGFydHMgPSBvdXRwdXRQYXJ0cy5jb25jYXQodG9QYXJ0cy5zbGljZShzYW1lUGFydHNMZW5ndGgpKTtcblxuICByZXR1cm4gb3V0cHV0UGFydHMuam9pbignLycpO1xufTtcblxuZXhwb3J0cy5zZXAgPSAnLyc7XG5leHBvcnRzLmRlbGltaXRlciA9ICc6JztcblxuZXhwb3J0cy5kaXJuYW1lID0gZnVuY3Rpb24ocGF0aCkge1xuICB2YXIgcmVzdWx0ID0gc3BsaXRQYXRoKHBhdGgpLFxuICAgICAgcm9vdCA9IHJlc3VsdFswXSxcbiAgICAgIGRpciA9IHJlc3VsdFsxXTtcblxuICBpZiAoIXJvb3QgJiYgIWRpcikge1xuICAgIC8vIE5vIGRpcm5hbWUgd2hhdHNvZXZlclxuICAgIHJldHVybiAnLic7XG4gIH1cblxuICBpZiAoZGlyKSB7XG4gICAgLy8gSXQgaGFzIGEgZGlybmFtZSwgc3RyaXAgdHJhaWxpbmcgc2xhc2hcbiAgICBkaXIgPSBkaXIuc3Vic3RyKDAsIGRpci5sZW5ndGggLSAxKTtcbiAgfVxuXG4gIHJldHVybiByb290ICsgZGlyO1xufTtcblxuXG5leHBvcnRzLmJhc2VuYW1lID0gZnVuY3Rpb24ocGF0aCwgZXh0KSB7XG4gIHZhciBmID0gc3BsaXRQYXRoKHBhdGgpWzJdO1xuICAvLyBUT0RPOiBtYWtlIHRoaXMgY29tcGFyaXNvbiBjYXNlLWluc2Vuc2l0aXZlIG9uIHdpbmRvd3M/XG4gIGlmIChleHQgJiYgZi5zdWJzdHIoLTEgKiBleHQubGVuZ3RoKSA9PT0gZXh0KSB7XG4gICAgZiA9IGYuc3Vic3RyKDAsIGYubGVuZ3RoIC0gZXh0Lmxlbmd0aCk7XG4gIH1cbiAgcmV0dXJuIGY7XG59O1xuXG5cbmV4cG9ydHMuZXh0bmFtZSA9IGZ1bmN0aW9uKHBhdGgpIHtcbiAgcmV0dXJuIHNwbGl0UGF0aChwYXRoKVszXTtcbn07XG5cbmZ1bmN0aW9uIGZpbHRlciAoeHMsIGYpIHtcbiAgICBpZiAoeHMuZmlsdGVyKSByZXR1cm4geHMuZmlsdGVyKGYpO1xuICAgIHZhciByZXMgPSBbXTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHhzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmIChmKHhzW2ldLCBpLCB4cykpIHJlcy5wdXNoKHhzW2ldKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlcztcbn1cblxuLy8gU3RyaW5nLnByb3RvdHlwZS5zdWJzdHIgLSBuZWdhdGl2ZSBpbmRleCBkb24ndCB3b3JrIGluIElFOFxudmFyIHN1YnN0ciA9ICdhYicuc3Vic3RyKC0xKSA9PT0gJ2InXG4gICAgPyBmdW5jdGlvbiAoc3RyLCBzdGFydCwgbGVuKSB7IHJldHVybiBzdHIuc3Vic3RyKHN0YXJ0LCBsZW4pIH1cbiAgICA6IGZ1bmN0aW9uIChzdHIsIHN0YXJ0LCBsZW4pIHtcbiAgICAgICAgaWYgKHN0YXJ0IDwgMCkgc3RhcnQgPSBzdHIubGVuZ3RoICsgc3RhcnQ7XG4gICAgICAgIHJldHVybiBzdHIuc3Vic3RyKHN0YXJ0LCBsZW4pO1xuICAgIH1cbjtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9wYXRoLWJyb3dzZXJpZnkvaW5kZXguanNcbi8vIG1vZHVsZSBpZCA9IDU0XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qISBodHRwczovL210aHMuYmUvcHVueWNvZGUgdjEuMy4yIGJ5IEBtYXRoaWFzICovXG47KGZ1bmN0aW9uKHJvb3QpIHtcblxuXHQvKiogRGV0ZWN0IGZyZWUgdmFyaWFibGVzICovXG5cdHZhciBmcmVlRXhwb3J0cyA9IHR5cGVvZiBleHBvcnRzID09ICdvYmplY3QnICYmIGV4cG9ydHMgJiZcblx0XHQhZXhwb3J0cy5ub2RlVHlwZSAmJiBleHBvcnRzO1xuXHR2YXIgZnJlZU1vZHVsZSA9IHR5cGVvZiBtb2R1bGUgPT0gJ29iamVjdCcgJiYgbW9kdWxlICYmXG5cdFx0IW1vZHVsZS5ub2RlVHlwZSAmJiBtb2R1bGU7XG5cdHZhciBmcmVlR2xvYmFsID0gdHlwZW9mIGdsb2JhbCA9PSAnb2JqZWN0JyAmJiBnbG9iYWw7XG5cdGlmIChcblx0XHRmcmVlR2xvYmFsLmdsb2JhbCA9PT0gZnJlZUdsb2JhbCB8fFxuXHRcdGZyZWVHbG9iYWwud2luZG93ID09PSBmcmVlR2xvYmFsIHx8XG5cdFx0ZnJlZUdsb2JhbC5zZWxmID09PSBmcmVlR2xvYmFsXG5cdCkge1xuXHRcdHJvb3QgPSBmcmVlR2xvYmFsO1xuXHR9XG5cblx0LyoqXG5cdCAqIFRoZSBgcHVueWNvZGVgIG9iamVjdC5cblx0ICogQG5hbWUgcHVueWNvZGVcblx0ICogQHR5cGUgT2JqZWN0XG5cdCAqL1xuXHR2YXIgcHVueWNvZGUsXG5cblx0LyoqIEhpZ2hlc3QgcG9zaXRpdmUgc2lnbmVkIDMyLWJpdCBmbG9hdCB2YWx1ZSAqL1xuXHRtYXhJbnQgPSAyMTQ3NDgzNjQ3LCAvLyBha2EuIDB4N0ZGRkZGRkYgb3IgMl4zMS0xXG5cblx0LyoqIEJvb3RzdHJpbmcgcGFyYW1ldGVycyAqL1xuXHRiYXNlID0gMzYsXG5cdHRNaW4gPSAxLFxuXHR0TWF4ID0gMjYsXG5cdHNrZXcgPSAzOCxcblx0ZGFtcCA9IDcwMCxcblx0aW5pdGlhbEJpYXMgPSA3Mixcblx0aW5pdGlhbE4gPSAxMjgsIC8vIDB4ODBcblx0ZGVsaW1pdGVyID0gJy0nLCAvLyAnXFx4MkQnXG5cblx0LyoqIFJlZ3VsYXIgZXhwcmVzc2lvbnMgKi9cblx0cmVnZXhQdW55Y29kZSA9IC9eeG4tLS8sXG5cdHJlZ2V4Tm9uQVNDSUkgPSAvW15cXHgyMC1cXHg3RV0vLCAvLyB1bnByaW50YWJsZSBBU0NJSSBjaGFycyArIG5vbi1BU0NJSSBjaGFyc1xuXHRyZWdleFNlcGFyYXRvcnMgPSAvW1xceDJFXFx1MzAwMlxcdUZGMEVcXHVGRjYxXS9nLCAvLyBSRkMgMzQ5MCBzZXBhcmF0b3JzXG5cblx0LyoqIEVycm9yIG1lc3NhZ2VzICovXG5cdGVycm9ycyA9IHtcblx0XHQnb3ZlcmZsb3cnOiAnT3ZlcmZsb3c6IGlucHV0IG5lZWRzIHdpZGVyIGludGVnZXJzIHRvIHByb2Nlc3MnLFxuXHRcdCdub3QtYmFzaWMnOiAnSWxsZWdhbCBpbnB1dCA+PSAweDgwIChub3QgYSBiYXNpYyBjb2RlIHBvaW50KScsXG5cdFx0J2ludmFsaWQtaW5wdXQnOiAnSW52YWxpZCBpbnB1dCdcblx0fSxcblxuXHQvKiogQ29udmVuaWVuY2Ugc2hvcnRjdXRzICovXG5cdGJhc2VNaW51c1RNaW4gPSBiYXNlIC0gdE1pbixcblx0Zmxvb3IgPSBNYXRoLmZsb29yLFxuXHRzdHJpbmdGcm9tQ2hhckNvZGUgPSBTdHJpbmcuZnJvbUNoYXJDb2RlLFxuXG5cdC8qKiBUZW1wb3JhcnkgdmFyaWFibGUgKi9cblx0a2V5O1xuXG5cdC8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG5cdC8qKlxuXHQgKiBBIGdlbmVyaWMgZXJyb3IgdXRpbGl0eSBmdW5jdGlvbi5cblx0ICogQHByaXZhdGVcblx0ICogQHBhcmFtIHtTdHJpbmd9IHR5cGUgVGhlIGVycm9yIHR5cGUuXG5cdCAqIEByZXR1cm5zIHtFcnJvcn0gVGhyb3dzIGEgYFJhbmdlRXJyb3JgIHdpdGggdGhlIGFwcGxpY2FibGUgZXJyb3IgbWVzc2FnZS5cblx0ICovXG5cdGZ1bmN0aW9uIGVycm9yKHR5cGUpIHtcblx0XHR0aHJvdyBSYW5nZUVycm9yKGVycm9yc1t0eXBlXSk7XG5cdH1cblxuXHQvKipcblx0ICogQSBnZW5lcmljIGBBcnJheSNtYXBgIHV0aWxpdHkgZnVuY3Rpb24uXG5cdCAqIEBwcml2YXRlXG5cdCAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBpdGVyYXRlIG92ZXIuXG5cdCAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrIFRoZSBmdW5jdGlvbiB0aGF0IGdldHMgY2FsbGVkIGZvciBldmVyeSBhcnJheVxuXHQgKiBpdGVtLlxuXHQgKiBAcmV0dXJucyB7QXJyYXl9IEEgbmV3IGFycmF5IG9mIHZhbHVlcyByZXR1cm5lZCBieSB0aGUgY2FsbGJhY2sgZnVuY3Rpb24uXG5cdCAqL1xuXHRmdW5jdGlvbiBtYXAoYXJyYXksIGZuKSB7XG5cdFx0dmFyIGxlbmd0aCA9IGFycmF5Lmxlbmd0aDtcblx0XHR2YXIgcmVzdWx0ID0gW107XG5cdFx0d2hpbGUgKGxlbmd0aC0tKSB7XG5cdFx0XHRyZXN1bHRbbGVuZ3RoXSA9IGZuKGFycmF5W2xlbmd0aF0pO1xuXHRcdH1cblx0XHRyZXR1cm4gcmVzdWx0O1xuXHR9XG5cblx0LyoqXG5cdCAqIEEgc2ltcGxlIGBBcnJheSNtYXBgLWxpa2Ugd3JhcHBlciB0byB3b3JrIHdpdGggZG9tYWluIG5hbWUgc3RyaW5ncyBvciBlbWFpbFxuXHQgKiBhZGRyZXNzZXMuXG5cdCAqIEBwcml2YXRlXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBkb21haW4gVGhlIGRvbWFpbiBuYW1lIG9yIGVtYWlsIGFkZHJlc3MuXG5cdCAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrIFRoZSBmdW5jdGlvbiB0aGF0IGdldHMgY2FsbGVkIGZvciBldmVyeVxuXHQgKiBjaGFyYWN0ZXIuXG5cdCAqIEByZXR1cm5zIHtBcnJheX0gQSBuZXcgc3RyaW5nIG9mIGNoYXJhY3RlcnMgcmV0dXJuZWQgYnkgdGhlIGNhbGxiYWNrXG5cdCAqIGZ1bmN0aW9uLlxuXHQgKi9cblx0ZnVuY3Rpb24gbWFwRG9tYWluKHN0cmluZywgZm4pIHtcblx0XHR2YXIgcGFydHMgPSBzdHJpbmcuc3BsaXQoJ0AnKTtcblx0XHR2YXIgcmVzdWx0ID0gJyc7XG5cdFx0aWYgKHBhcnRzLmxlbmd0aCA+IDEpIHtcblx0XHRcdC8vIEluIGVtYWlsIGFkZHJlc3Nlcywgb25seSB0aGUgZG9tYWluIG5hbWUgc2hvdWxkIGJlIHB1bnljb2RlZC4gTGVhdmVcblx0XHRcdC8vIHRoZSBsb2NhbCBwYXJ0IChpLmUuIGV2ZXJ5dGhpbmcgdXAgdG8gYEBgKSBpbnRhY3QuXG5cdFx0XHRyZXN1bHQgPSBwYXJ0c1swXSArICdAJztcblx0XHRcdHN0cmluZyA9IHBhcnRzWzFdO1xuXHRcdH1cblx0XHQvLyBBdm9pZCBgc3BsaXQocmVnZXgpYCBmb3IgSUU4IGNvbXBhdGliaWxpdHkuIFNlZSAjMTcuXG5cdFx0c3RyaW5nID0gc3RyaW5nLnJlcGxhY2UocmVnZXhTZXBhcmF0b3JzLCAnXFx4MkUnKTtcblx0XHR2YXIgbGFiZWxzID0gc3RyaW5nLnNwbGl0KCcuJyk7XG5cdFx0dmFyIGVuY29kZWQgPSBtYXAobGFiZWxzLCBmbikuam9pbignLicpO1xuXHRcdHJldHVybiByZXN1bHQgKyBlbmNvZGVkO1xuXHR9XG5cblx0LyoqXG5cdCAqIENyZWF0ZXMgYW4gYXJyYXkgY29udGFpbmluZyB0aGUgbnVtZXJpYyBjb2RlIHBvaW50cyBvZiBlYWNoIFVuaWNvZGVcblx0ICogY2hhcmFjdGVyIGluIHRoZSBzdHJpbmcuIFdoaWxlIEphdmFTY3JpcHQgdXNlcyBVQ1MtMiBpbnRlcm5hbGx5LFxuXHQgKiB0aGlzIGZ1bmN0aW9uIHdpbGwgY29udmVydCBhIHBhaXIgb2Ygc3Vycm9nYXRlIGhhbHZlcyAoZWFjaCBvZiB3aGljaFxuXHQgKiBVQ1MtMiBleHBvc2VzIGFzIHNlcGFyYXRlIGNoYXJhY3RlcnMpIGludG8gYSBzaW5nbGUgY29kZSBwb2ludCxcblx0ICogbWF0Y2hpbmcgVVRGLTE2LlxuXHQgKiBAc2VlIGBwdW55Y29kZS51Y3MyLmVuY29kZWBcblx0ICogQHNlZSA8aHR0cHM6Ly9tYXRoaWFzYnluZW5zLmJlL25vdGVzL2phdmFzY3JpcHQtZW5jb2Rpbmc+XG5cdCAqIEBtZW1iZXJPZiBwdW55Y29kZS51Y3MyXG5cdCAqIEBuYW1lIGRlY29kZVxuXHQgKiBAcGFyYW0ge1N0cmluZ30gc3RyaW5nIFRoZSBVbmljb2RlIGlucHV0IHN0cmluZyAoVUNTLTIpLlxuXHQgKiBAcmV0dXJucyB7QXJyYXl9IFRoZSBuZXcgYXJyYXkgb2YgY29kZSBwb2ludHMuXG5cdCAqL1xuXHRmdW5jdGlvbiB1Y3MyZGVjb2RlKHN0cmluZykge1xuXHRcdHZhciBvdXRwdXQgPSBbXSxcblx0XHQgICAgY291bnRlciA9IDAsXG5cdFx0ICAgIGxlbmd0aCA9IHN0cmluZy5sZW5ndGgsXG5cdFx0ICAgIHZhbHVlLFxuXHRcdCAgICBleHRyYTtcblx0XHR3aGlsZSAoY291bnRlciA8IGxlbmd0aCkge1xuXHRcdFx0dmFsdWUgPSBzdHJpbmcuY2hhckNvZGVBdChjb3VudGVyKyspO1xuXHRcdFx0aWYgKHZhbHVlID49IDB4RDgwMCAmJiB2YWx1ZSA8PSAweERCRkYgJiYgY291bnRlciA8IGxlbmd0aCkge1xuXHRcdFx0XHQvLyBoaWdoIHN1cnJvZ2F0ZSwgYW5kIHRoZXJlIGlzIGEgbmV4dCBjaGFyYWN0ZXJcblx0XHRcdFx0ZXh0cmEgPSBzdHJpbmcuY2hhckNvZGVBdChjb3VudGVyKyspO1xuXHRcdFx0XHRpZiAoKGV4dHJhICYgMHhGQzAwKSA9PSAweERDMDApIHsgLy8gbG93IHN1cnJvZ2F0ZVxuXHRcdFx0XHRcdG91dHB1dC5wdXNoKCgodmFsdWUgJiAweDNGRikgPDwgMTApICsgKGV4dHJhICYgMHgzRkYpICsgMHgxMDAwMCk7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0Ly8gdW5tYXRjaGVkIHN1cnJvZ2F0ZTsgb25seSBhcHBlbmQgdGhpcyBjb2RlIHVuaXQsIGluIGNhc2UgdGhlIG5leHRcblx0XHRcdFx0XHQvLyBjb2RlIHVuaXQgaXMgdGhlIGhpZ2ggc3Vycm9nYXRlIG9mIGEgc3Vycm9nYXRlIHBhaXJcblx0XHRcdFx0XHRvdXRwdXQucHVzaCh2YWx1ZSk7XG5cdFx0XHRcdFx0Y291bnRlci0tO1xuXHRcdFx0XHR9XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRvdXRwdXQucHVzaCh2YWx1ZSk7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHJldHVybiBvdXRwdXQ7XG5cdH1cblxuXHQvKipcblx0ICogQ3JlYXRlcyBhIHN0cmluZyBiYXNlZCBvbiBhbiBhcnJheSBvZiBudW1lcmljIGNvZGUgcG9pbnRzLlxuXHQgKiBAc2VlIGBwdW55Y29kZS51Y3MyLmRlY29kZWBcblx0ICogQG1lbWJlck9mIHB1bnljb2RlLnVjczJcblx0ICogQG5hbWUgZW5jb2RlXG5cdCAqIEBwYXJhbSB7QXJyYXl9IGNvZGVQb2ludHMgVGhlIGFycmF5IG9mIG51bWVyaWMgY29kZSBwb2ludHMuXG5cdCAqIEByZXR1cm5zIHtTdHJpbmd9IFRoZSBuZXcgVW5pY29kZSBzdHJpbmcgKFVDUy0yKS5cblx0ICovXG5cdGZ1bmN0aW9uIHVjczJlbmNvZGUoYXJyYXkpIHtcblx0XHRyZXR1cm4gbWFwKGFycmF5LCBmdW5jdGlvbih2YWx1ZSkge1xuXHRcdFx0dmFyIG91dHB1dCA9ICcnO1xuXHRcdFx0aWYgKHZhbHVlID4gMHhGRkZGKSB7XG5cdFx0XHRcdHZhbHVlIC09IDB4MTAwMDA7XG5cdFx0XHRcdG91dHB1dCArPSBzdHJpbmdGcm9tQ2hhckNvZGUodmFsdWUgPj4+IDEwICYgMHgzRkYgfCAweEQ4MDApO1xuXHRcdFx0XHR2YWx1ZSA9IDB4REMwMCB8IHZhbHVlICYgMHgzRkY7XG5cdFx0XHR9XG5cdFx0XHRvdXRwdXQgKz0gc3RyaW5nRnJvbUNoYXJDb2RlKHZhbHVlKTtcblx0XHRcdHJldHVybiBvdXRwdXQ7XG5cdFx0fSkuam9pbignJyk7XG5cdH1cblxuXHQvKipcblx0ICogQ29udmVydHMgYSBiYXNpYyBjb2RlIHBvaW50IGludG8gYSBkaWdpdC9pbnRlZ2VyLlxuXHQgKiBAc2VlIGBkaWdpdFRvQmFzaWMoKWBcblx0ICogQHByaXZhdGVcblx0ICogQHBhcmFtIHtOdW1iZXJ9IGNvZGVQb2ludCBUaGUgYmFzaWMgbnVtZXJpYyBjb2RlIHBvaW50IHZhbHVlLlxuXHQgKiBAcmV0dXJucyB7TnVtYmVyfSBUaGUgbnVtZXJpYyB2YWx1ZSBvZiBhIGJhc2ljIGNvZGUgcG9pbnQgKGZvciB1c2UgaW5cblx0ICogcmVwcmVzZW50aW5nIGludGVnZXJzKSBpbiB0aGUgcmFuZ2UgYDBgIHRvIGBiYXNlIC0gMWAsIG9yIGBiYXNlYCBpZlxuXHQgKiB0aGUgY29kZSBwb2ludCBkb2VzIG5vdCByZXByZXNlbnQgYSB2YWx1ZS5cblx0ICovXG5cdGZ1bmN0aW9uIGJhc2ljVG9EaWdpdChjb2RlUG9pbnQpIHtcblx0XHRpZiAoY29kZVBvaW50IC0gNDggPCAxMCkge1xuXHRcdFx0cmV0dXJuIGNvZGVQb2ludCAtIDIyO1xuXHRcdH1cblx0XHRpZiAoY29kZVBvaW50IC0gNjUgPCAyNikge1xuXHRcdFx0cmV0dXJuIGNvZGVQb2ludCAtIDY1O1xuXHRcdH1cblx0XHRpZiAoY29kZVBvaW50IC0gOTcgPCAyNikge1xuXHRcdFx0cmV0dXJuIGNvZGVQb2ludCAtIDk3O1xuXHRcdH1cblx0XHRyZXR1cm4gYmFzZTtcblx0fVxuXG5cdC8qKlxuXHQgKiBDb252ZXJ0cyBhIGRpZ2l0L2ludGVnZXIgaW50byBhIGJhc2ljIGNvZGUgcG9pbnQuXG5cdCAqIEBzZWUgYGJhc2ljVG9EaWdpdCgpYFxuXHQgKiBAcHJpdmF0ZVxuXHQgKiBAcGFyYW0ge051bWJlcn0gZGlnaXQgVGhlIG51bWVyaWMgdmFsdWUgb2YgYSBiYXNpYyBjb2RlIHBvaW50LlxuXHQgKiBAcmV0dXJucyB7TnVtYmVyfSBUaGUgYmFzaWMgY29kZSBwb2ludCB3aG9zZSB2YWx1ZSAod2hlbiB1c2VkIGZvclxuXHQgKiByZXByZXNlbnRpbmcgaW50ZWdlcnMpIGlzIGBkaWdpdGAsIHdoaWNoIG5lZWRzIHRvIGJlIGluIHRoZSByYW5nZVxuXHQgKiBgMGAgdG8gYGJhc2UgLSAxYC4gSWYgYGZsYWdgIGlzIG5vbi16ZXJvLCB0aGUgdXBwZXJjYXNlIGZvcm0gaXNcblx0ICogdXNlZDsgZWxzZSwgdGhlIGxvd2VyY2FzZSBmb3JtIGlzIHVzZWQuIFRoZSBiZWhhdmlvciBpcyB1bmRlZmluZWRcblx0ICogaWYgYGZsYWdgIGlzIG5vbi16ZXJvIGFuZCBgZGlnaXRgIGhhcyBubyB1cHBlcmNhc2UgZm9ybS5cblx0ICovXG5cdGZ1bmN0aW9uIGRpZ2l0VG9CYXNpYyhkaWdpdCwgZmxhZykge1xuXHRcdC8vICAwLi4yNSBtYXAgdG8gQVNDSUkgYS4ueiBvciBBLi5aXG5cdFx0Ly8gMjYuLjM1IG1hcCB0byBBU0NJSSAwLi45XG5cdFx0cmV0dXJuIGRpZ2l0ICsgMjIgKyA3NSAqIChkaWdpdCA8IDI2KSAtICgoZmxhZyAhPSAwKSA8PCA1KTtcblx0fVxuXG5cdC8qKlxuXHQgKiBCaWFzIGFkYXB0YXRpb24gZnVuY3Rpb24gYXMgcGVyIHNlY3Rpb24gMy40IG9mIFJGQyAzNDkyLlxuXHQgKiBodHRwOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmMzNDkyI3NlY3Rpb24tMy40XG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuXHRmdW5jdGlvbiBhZGFwdChkZWx0YSwgbnVtUG9pbnRzLCBmaXJzdFRpbWUpIHtcblx0XHR2YXIgayA9IDA7XG5cdFx0ZGVsdGEgPSBmaXJzdFRpbWUgPyBmbG9vcihkZWx0YSAvIGRhbXApIDogZGVsdGEgPj4gMTtcblx0XHRkZWx0YSArPSBmbG9vcihkZWx0YSAvIG51bVBvaW50cyk7XG5cdFx0Zm9yICgvKiBubyBpbml0aWFsaXphdGlvbiAqLzsgZGVsdGEgPiBiYXNlTWludXNUTWluICogdE1heCA+PiAxOyBrICs9IGJhc2UpIHtcblx0XHRcdGRlbHRhID0gZmxvb3IoZGVsdGEgLyBiYXNlTWludXNUTWluKTtcblx0XHR9XG5cdFx0cmV0dXJuIGZsb29yKGsgKyAoYmFzZU1pbnVzVE1pbiArIDEpICogZGVsdGEgLyAoZGVsdGEgKyBza2V3KSk7XG5cdH1cblxuXHQvKipcblx0ICogQ29udmVydHMgYSBQdW55Y29kZSBzdHJpbmcgb2YgQVNDSUktb25seSBzeW1ib2xzIHRvIGEgc3RyaW5nIG9mIFVuaWNvZGVcblx0ICogc3ltYm9scy5cblx0ICogQG1lbWJlck9mIHB1bnljb2RlXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBpbnB1dCBUaGUgUHVueWNvZGUgc3RyaW5nIG9mIEFTQ0lJLW9ubHkgc3ltYm9scy5cblx0ICogQHJldHVybnMge1N0cmluZ30gVGhlIHJlc3VsdGluZyBzdHJpbmcgb2YgVW5pY29kZSBzeW1ib2xzLlxuXHQgKi9cblx0ZnVuY3Rpb24gZGVjb2RlKGlucHV0KSB7XG5cdFx0Ly8gRG9uJ3QgdXNlIFVDUy0yXG5cdFx0dmFyIG91dHB1dCA9IFtdLFxuXHRcdCAgICBpbnB1dExlbmd0aCA9IGlucHV0Lmxlbmd0aCxcblx0XHQgICAgb3V0LFxuXHRcdCAgICBpID0gMCxcblx0XHQgICAgbiA9IGluaXRpYWxOLFxuXHRcdCAgICBiaWFzID0gaW5pdGlhbEJpYXMsXG5cdFx0ICAgIGJhc2ljLFxuXHRcdCAgICBqLFxuXHRcdCAgICBpbmRleCxcblx0XHQgICAgb2xkaSxcblx0XHQgICAgdyxcblx0XHQgICAgayxcblx0XHQgICAgZGlnaXQsXG5cdFx0ICAgIHQsXG5cdFx0ICAgIC8qKiBDYWNoZWQgY2FsY3VsYXRpb24gcmVzdWx0cyAqL1xuXHRcdCAgICBiYXNlTWludXNUO1xuXG5cdFx0Ly8gSGFuZGxlIHRoZSBiYXNpYyBjb2RlIHBvaW50czogbGV0IGBiYXNpY2AgYmUgdGhlIG51bWJlciBvZiBpbnB1dCBjb2RlXG5cdFx0Ly8gcG9pbnRzIGJlZm9yZSB0aGUgbGFzdCBkZWxpbWl0ZXIsIG9yIGAwYCBpZiB0aGVyZSBpcyBub25lLCB0aGVuIGNvcHlcblx0XHQvLyB0aGUgZmlyc3QgYmFzaWMgY29kZSBwb2ludHMgdG8gdGhlIG91dHB1dC5cblxuXHRcdGJhc2ljID0gaW5wdXQubGFzdEluZGV4T2YoZGVsaW1pdGVyKTtcblx0XHRpZiAoYmFzaWMgPCAwKSB7XG5cdFx0XHRiYXNpYyA9IDA7XG5cdFx0fVxuXG5cdFx0Zm9yIChqID0gMDsgaiA8IGJhc2ljOyArK2opIHtcblx0XHRcdC8vIGlmIGl0J3Mgbm90IGEgYmFzaWMgY29kZSBwb2ludFxuXHRcdFx0aWYgKGlucHV0LmNoYXJDb2RlQXQoaikgPj0gMHg4MCkge1xuXHRcdFx0XHRlcnJvcignbm90LWJhc2ljJyk7XG5cdFx0XHR9XG5cdFx0XHRvdXRwdXQucHVzaChpbnB1dC5jaGFyQ29kZUF0KGopKTtcblx0XHR9XG5cblx0XHQvLyBNYWluIGRlY29kaW5nIGxvb3A6IHN0YXJ0IGp1c3QgYWZ0ZXIgdGhlIGxhc3QgZGVsaW1pdGVyIGlmIGFueSBiYXNpYyBjb2RlXG5cdFx0Ly8gcG9pbnRzIHdlcmUgY29waWVkOyBzdGFydCBhdCB0aGUgYmVnaW5uaW5nIG90aGVyd2lzZS5cblxuXHRcdGZvciAoaW5kZXggPSBiYXNpYyA+IDAgPyBiYXNpYyArIDEgOiAwOyBpbmRleCA8IGlucHV0TGVuZ3RoOyAvKiBubyBmaW5hbCBleHByZXNzaW9uICovKSB7XG5cblx0XHRcdC8vIGBpbmRleGAgaXMgdGhlIGluZGV4IG9mIHRoZSBuZXh0IGNoYXJhY3RlciB0byBiZSBjb25zdW1lZC5cblx0XHRcdC8vIERlY29kZSBhIGdlbmVyYWxpemVkIHZhcmlhYmxlLWxlbmd0aCBpbnRlZ2VyIGludG8gYGRlbHRhYCxcblx0XHRcdC8vIHdoaWNoIGdldHMgYWRkZWQgdG8gYGlgLiBUaGUgb3ZlcmZsb3cgY2hlY2tpbmcgaXMgZWFzaWVyXG5cdFx0XHQvLyBpZiB3ZSBpbmNyZWFzZSBgaWAgYXMgd2UgZ28sIHRoZW4gc3VidHJhY3Qgb2ZmIGl0cyBzdGFydGluZ1xuXHRcdFx0Ly8gdmFsdWUgYXQgdGhlIGVuZCB0byBvYnRhaW4gYGRlbHRhYC5cblx0XHRcdGZvciAob2xkaSA9IGksIHcgPSAxLCBrID0gYmFzZTsgLyogbm8gY29uZGl0aW9uICovOyBrICs9IGJhc2UpIHtcblxuXHRcdFx0XHRpZiAoaW5kZXggPj0gaW5wdXRMZW5ndGgpIHtcblx0XHRcdFx0XHRlcnJvcignaW52YWxpZC1pbnB1dCcpO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0ZGlnaXQgPSBiYXNpY1RvRGlnaXQoaW5wdXQuY2hhckNvZGVBdChpbmRleCsrKSk7XG5cblx0XHRcdFx0aWYgKGRpZ2l0ID49IGJhc2UgfHwgZGlnaXQgPiBmbG9vcigobWF4SW50IC0gaSkgLyB3KSkge1xuXHRcdFx0XHRcdGVycm9yKCdvdmVyZmxvdycpO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0aSArPSBkaWdpdCAqIHc7XG5cdFx0XHRcdHQgPSBrIDw9IGJpYXMgPyB0TWluIDogKGsgPj0gYmlhcyArIHRNYXggPyB0TWF4IDogayAtIGJpYXMpO1xuXG5cdFx0XHRcdGlmIChkaWdpdCA8IHQpIHtcblx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGJhc2VNaW51c1QgPSBiYXNlIC0gdDtcblx0XHRcdFx0aWYgKHcgPiBmbG9vcihtYXhJbnQgLyBiYXNlTWludXNUKSkge1xuXHRcdFx0XHRcdGVycm9yKCdvdmVyZmxvdycpO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0dyAqPSBiYXNlTWludXNUO1xuXG5cdFx0XHR9XG5cblx0XHRcdG91dCA9IG91dHB1dC5sZW5ndGggKyAxO1xuXHRcdFx0YmlhcyA9IGFkYXB0KGkgLSBvbGRpLCBvdXQsIG9sZGkgPT0gMCk7XG5cblx0XHRcdC8vIGBpYCB3YXMgc3VwcG9zZWQgdG8gd3JhcCBhcm91bmQgZnJvbSBgb3V0YCB0byBgMGAsXG5cdFx0XHQvLyBpbmNyZW1lbnRpbmcgYG5gIGVhY2ggdGltZSwgc28gd2UnbGwgZml4IHRoYXQgbm93OlxuXHRcdFx0aWYgKGZsb29yKGkgLyBvdXQpID4gbWF4SW50IC0gbikge1xuXHRcdFx0XHRlcnJvcignb3ZlcmZsb3cnKTtcblx0XHRcdH1cblxuXHRcdFx0biArPSBmbG9vcihpIC8gb3V0KTtcblx0XHRcdGkgJT0gb3V0O1xuXG5cdFx0XHQvLyBJbnNlcnQgYG5gIGF0IHBvc2l0aW9uIGBpYCBvZiB0aGUgb3V0cHV0XG5cdFx0XHRvdXRwdXQuc3BsaWNlKGkrKywgMCwgbik7XG5cblx0XHR9XG5cblx0XHRyZXR1cm4gdWNzMmVuY29kZShvdXRwdXQpO1xuXHR9XG5cblx0LyoqXG5cdCAqIENvbnZlcnRzIGEgc3RyaW5nIG9mIFVuaWNvZGUgc3ltYm9scyAoZS5nLiBhIGRvbWFpbiBuYW1lIGxhYmVsKSB0byBhXG5cdCAqIFB1bnljb2RlIHN0cmluZyBvZiBBU0NJSS1vbmx5IHN5bWJvbHMuXG5cdCAqIEBtZW1iZXJPZiBwdW55Y29kZVxuXHQgKiBAcGFyYW0ge1N0cmluZ30gaW5wdXQgVGhlIHN0cmluZyBvZiBVbmljb2RlIHN5bWJvbHMuXG5cdCAqIEByZXR1cm5zIHtTdHJpbmd9IFRoZSByZXN1bHRpbmcgUHVueWNvZGUgc3RyaW5nIG9mIEFTQ0lJLW9ubHkgc3ltYm9scy5cblx0ICovXG5cdGZ1bmN0aW9uIGVuY29kZShpbnB1dCkge1xuXHRcdHZhciBuLFxuXHRcdCAgICBkZWx0YSxcblx0XHQgICAgaGFuZGxlZENQQ291bnQsXG5cdFx0ICAgIGJhc2ljTGVuZ3RoLFxuXHRcdCAgICBiaWFzLFxuXHRcdCAgICBqLFxuXHRcdCAgICBtLFxuXHRcdCAgICBxLFxuXHRcdCAgICBrLFxuXHRcdCAgICB0LFxuXHRcdCAgICBjdXJyZW50VmFsdWUsXG5cdFx0ICAgIG91dHB1dCA9IFtdLFxuXHRcdCAgICAvKiogYGlucHV0TGVuZ3RoYCB3aWxsIGhvbGQgdGhlIG51bWJlciBvZiBjb2RlIHBvaW50cyBpbiBgaW5wdXRgLiAqL1xuXHRcdCAgICBpbnB1dExlbmd0aCxcblx0XHQgICAgLyoqIENhY2hlZCBjYWxjdWxhdGlvbiByZXN1bHRzICovXG5cdFx0ICAgIGhhbmRsZWRDUENvdW50UGx1c09uZSxcblx0XHQgICAgYmFzZU1pbnVzVCxcblx0XHQgICAgcU1pbnVzVDtcblxuXHRcdC8vIENvbnZlcnQgdGhlIGlucHV0IGluIFVDUy0yIHRvIFVuaWNvZGVcblx0XHRpbnB1dCA9IHVjczJkZWNvZGUoaW5wdXQpO1xuXG5cdFx0Ly8gQ2FjaGUgdGhlIGxlbmd0aFxuXHRcdGlucHV0TGVuZ3RoID0gaW5wdXQubGVuZ3RoO1xuXG5cdFx0Ly8gSW5pdGlhbGl6ZSB0aGUgc3RhdGVcblx0XHRuID0gaW5pdGlhbE47XG5cdFx0ZGVsdGEgPSAwO1xuXHRcdGJpYXMgPSBpbml0aWFsQmlhcztcblxuXHRcdC8vIEhhbmRsZSB0aGUgYmFzaWMgY29kZSBwb2ludHNcblx0XHRmb3IgKGogPSAwOyBqIDwgaW5wdXRMZW5ndGg7ICsraikge1xuXHRcdFx0Y3VycmVudFZhbHVlID0gaW5wdXRbal07XG5cdFx0XHRpZiAoY3VycmVudFZhbHVlIDwgMHg4MCkge1xuXHRcdFx0XHRvdXRwdXQucHVzaChzdHJpbmdGcm9tQ2hhckNvZGUoY3VycmVudFZhbHVlKSk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0aGFuZGxlZENQQ291bnQgPSBiYXNpY0xlbmd0aCA9IG91dHB1dC5sZW5ndGg7XG5cblx0XHQvLyBgaGFuZGxlZENQQ291bnRgIGlzIHRoZSBudW1iZXIgb2YgY29kZSBwb2ludHMgdGhhdCBoYXZlIGJlZW4gaGFuZGxlZDtcblx0XHQvLyBgYmFzaWNMZW5ndGhgIGlzIHRoZSBudW1iZXIgb2YgYmFzaWMgY29kZSBwb2ludHMuXG5cblx0XHQvLyBGaW5pc2ggdGhlIGJhc2ljIHN0cmluZyAtIGlmIGl0IGlzIG5vdCBlbXB0eSAtIHdpdGggYSBkZWxpbWl0ZXJcblx0XHRpZiAoYmFzaWNMZW5ndGgpIHtcblx0XHRcdG91dHB1dC5wdXNoKGRlbGltaXRlcik7XG5cdFx0fVxuXG5cdFx0Ly8gTWFpbiBlbmNvZGluZyBsb29wOlxuXHRcdHdoaWxlIChoYW5kbGVkQ1BDb3VudCA8IGlucHV0TGVuZ3RoKSB7XG5cblx0XHRcdC8vIEFsbCBub24tYmFzaWMgY29kZSBwb2ludHMgPCBuIGhhdmUgYmVlbiBoYW5kbGVkIGFscmVhZHkuIEZpbmQgdGhlIG5leHRcblx0XHRcdC8vIGxhcmdlciBvbmU6XG5cdFx0XHRmb3IgKG0gPSBtYXhJbnQsIGogPSAwOyBqIDwgaW5wdXRMZW5ndGg7ICsraikge1xuXHRcdFx0XHRjdXJyZW50VmFsdWUgPSBpbnB1dFtqXTtcblx0XHRcdFx0aWYgKGN1cnJlbnRWYWx1ZSA+PSBuICYmIGN1cnJlbnRWYWx1ZSA8IG0pIHtcblx0XHRcdFx0XHRtID0gY3VycmVudFZhbHVlO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdC8vIEluY3JlYXNlIGBkZWx0YWAgZW5vdWdoIHRvIGFkdmFuY2UgdGhlIGRlY29kZXIncyA8bixpPiBzdGF0ZSB0byA8bSwwPixcblx0XHRcdC8vIGJ1dCBndWFyZCBhZ2FpbnN0IG92ZXJmbG93XG5cdFx0XHRoYW5kbGVkQ1BDb3VudFBsdXNPbmUgPSBoYW5kbGVkQ1BDb3VudCArIDE7XG5cdFx0XHRpZiAobSAtIG4gPiBmbG9vcigobWF4SW50IC0gZGVsdGEpIC8gaGFuZGxlZENQQ291bnRQbHVzT25lKSkge1xuXHRcdFx0XHRlcnJvcignb3ZlcmZsb3cnKTtcblx0XHRcdH1cblxuXHRcdFx0ZGVsdGEgKz0gKG0gLSBuKSAqIGhhbmRsZWRDUENvdW50UGx1c09uZTtcblx0XHRcdG4gPSBtO1xuXG5cdFx0XHRmb3IgKGogPSAwOyBqIDwgaW5wdXRMZW5ndGg7ICsraikge1xuXHRcdFx0XHRjdXJyZW50VmFsdWUgPSBpbnB1dFtqXTtcblxuXHRcdFx0XHRpZiAoY3VycmVudFZhbHVlIDwgbiAmJiArK2RlbHRhID4gbWF4SW50KSB7XG5cdFx0XHRcdFx0ZXJyb3IoJ292ZXJmbG93Jyk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpZiAoY3VycmVudFZhbHVlID09IG4pIHtcblx0XHRcdFx0XHQvLyBSZXByZXNlbnQgZGVsdGEgYXMgYSBnZW5lcmFsaXplZCB2YXJpYWJsZS1sZW5ndGggaW50ZWdlclxuXHRcdFx0XHRcdGZvciAocSA9IGRlbHRhLCBrID0gYmFzZTsgLyogbm8gY29uZGl0aW9uICovOyBrICs9IGJhc2UpIHtcblx0XHRcdFx0XHRcdHQgPSBrIDw9IGJpYXMgPyB0TWluIDogKGsgPj0gYmlhcyArIHRNYXggPyB0TWF4IDogayAtIGJpYXMpO1xuXHRcdFx0XHRcdFx0aWYgKHEgPCB0KSB7XG5cdFx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0cU1pbnVzVCA9IHEgLSB0O1xuXHRcdFx0XHRcdFx0YmFzZU1pbnVzVCA9IGJhc2UgLSB0O1xuXHRcdFx0XHRcdFx0b3V0cHV0LnB1c2goXG5cdFx0XHRcdFx0XHRcdHN0cmluZ0Zyb21DaGFyQ29kZShkaWdpdFRvQmFzaWModCArIHFNaW51c1QgJSBiYXNlTWludXNULCAwKSlcblx0XHRcdFx0XHRcdCk7XG5cdFx0XHRcdFx0XHRxID0gZmxvb3IocU1pbnVzVCAvIGJhc2VNaW51c1QpO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdG91dHB1dC5wdXNoKHN0cmluZ0Zyb21DaGFyQ29kZShkaWdpdFRvQmFzaWMocSwgMCkpKTtcblx0XHRcdFx0XHRiaWFzID0gYWRhcHQoZGVsdGEsIGhhbmRsZWRDUENvdW50UGx1c09uZSwgaGFuZGxlZENQQ291bnQgPT0gYmFzaWNMZW5ndGgpO1xuXHRcdFx0XHRcdGRlbHRhID0gMDtcblx0XHRcdFx0XHQrK2hhbmRsZWRDUENvdW50O1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdCsrZGVsdGE7XG5cdFx0XHQrK247XG5cblx0XHR9XG5cdFx0cmV0dXJuIG91dHB1dC5qb2luKCcnKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBDb252ZXJ0cyBhIFB1bnljb2RlIHN0cmluZyByZXByZXNlbnRpbmcgYSBkb21haW4gbmFtZSBvciBhbiBlbWFpbCBhZGRyZXNzXG5cdCAqIHRvIFVuaWNvZGUuIE9ubHkgdGhlIFB1bnljb2RlZCBwYXJ0cyBvZiB0aGUgaW5wdXQgd2lsbCBiZSBjb252ZXJ0ZWQsIGkuZS5cblx0ICogaXQgZG9lc24ndCBtYXR0ZXIgaWYgeW91IGNhbGwgaXQgb24gYSBzdHJpbmcgdGhhdCBoYXMgYWxyZWFkeSBiZWVuXG5cdCAqIGNvbnZlcnRlZCB0byBVbmljb2RlLlxuXHQgKiBAbWVtYmVyT2YgcHVueWNvZGVcblx0ICogQHBhcmFtIHtTdHJpbmd9IGlucHV0IFRoZSBQdW55Y29kZWQgZG9tYWluIG5hbWUgb3IgZW1haWwgYWRkcmVzcyB0b1xuXHQgKiBjb252ZXJ0IHRvIFVuaWNvZGUuXG5cdCAqIEByZXR1cm5zIHtTdHJpbmd9IFRoZSBVbmljb2RlIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBnaXZlbiBQdW55Y29kZVxuXHQgKiBzdHJpbmcuXG5cdCAqL1xuXHRmdW5jdGlvbiB0b1VuaWNvZGUoaW5wdXQpIHtcblx0XHRyZXR1cm4gbWFwRG9tYWluKGlucHV0LCBmdW5jdGlvbihzdHJpbmcpIHtcblx0XHRcdHJldHVybiByZWdleFB1bnljb2RlLnRlc3Qoc3RyaW5nKVxuXHRcdFx0XHQ/IGRlY29kZShzdHJpbmcuc2xpY2UoNCkudG9Mb3dlckNhc2UoKSlcblx0XHRcdFx0OiBzdHJpbmc7XG5cdFx0fSk7XG5cdH1cblxuXHQvKipcblx0ICogQ29udmVydHMgYSBVbmljb2RlIHN0cmluZyByZXByZXNlbnRpbmcgYSBkb21haW4gbmFtZSBvciBhbiBlbWFpbCBhZGRyZXNzIHRvXG5cdCAqIFB1bnljb2RlLiBPbmx5IHRoZSBub24tQVNDSUkgcGFydHMgb2YgdGhlIGRvbWFpbiBuYW1lIHdpbGwgYmUgY29udmVydGVkLFxuXHQgKiBpLmUuIGl0IGRvZXNuJ3QgbWF0dGVyIGlmIHlvdSBjYWxsIGl0IHdpdGggYSBkb21haW4gdGhhdCdzIGFscmVhZHkgaW5cblx0ICogQVNDSUkuXG5cdCAqIEBtZW1iZXJPZiBwdW55Y29kZVxuXHQgKiBAcGFyYW0ge1N0cmluZ30gaW5wdXQgVGhlIGRvbWFpbiBuYW1lIG9yIGVtYWlsIGFkZHJlc3MgdG8gY29udmVydCwgYXMgYVxuXHQgKiBVbmljb2RlIHN0cmluZy5cblx0ICogQHJldHVybnMge1N0cmluZ30gVGhlIFB1bnljb2RlIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBnaXZlbiBkb21haW4gbmFtZSBvclxuXHQgKiBlbWFpbCBhZGRyZXNzLlxuXHQgKi9cblx0ZnVuY3Rpb24gdG9BU0NJSShpbnB1dCkge1xuXHRcdHJldHVybiBtYXBEb21haW4oaW5wdXQsIGZ1bmN0aW9uKHN0cmluZykge1xuXHRcdFx0cmV0dXJuIHJlZ2V4Tm9uQVNDSUkudGVzdChzdHJpbmcpXG5cdFx0XHRcdD8gJ3huLS0nICsgZW5jb2RlKHN0cmluZylcblx0XHRcdFx0OiBzdHJpbmc7XG5cdFx0fSk7XG5cdH1cblxuXHQvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuXHQvKiogRGVmaW5lIHRoZSBwdWJsaWMgQVBJICovXG5cdHB1bnljb2RlID0ge1xuXHRcdC8qKlxuXHRcdCAqIEEgc3RyaW5nIHJlcHJlc2VudGluZyB0aGUgY3VycmVudCBQdW55Y29kZS5qcyB2ZXJzaW9uIG51bWJlci5cblx0XHQgKiBAbWVtYmVyT2YgcHVueWNvZGVcblx0XHQgKiBAdHlwZSBTdHJpbmdcblx0XHQgKi9cblx0XHQndmVyc2lvbic6ICcxLjMuMicsXG5cdFx0LyoqXG5cdFx0ICogQW4gb2JqZWN0IG9mIG1ldGhvZHMgdG8gY29udmVydCBmcm9tIEphdmFTY3JpcHQncyBpbnRlcm5hbCBjaGFyYWN0ZXJcblx0XHQgKiByZXByZXNlbnRhdGlvbiAoVUNTLTIpIHRvIFVuaWNvZGUgY29kZSBwb2ludHMsIGFuZCBiYWNrLlxuXHRcdCAqIEBzZWUgPGh0dHBzOi8vbWF0aGlhc2J5bmVucy5iZS9ub3Rlcy9qYXZhc2NyaXB0LWVuY29kaW5nPlxuXHRcdCAqIEBtZW1iZXJPZiBwdW55Y29kZVxuXHRcdCAqIEB0eXBlIE9iamVjdFxuXHRcdCAqL1xuXHRcdCd1Y3MyJzoge1xuXHRcdFx0J2RlY29kZSc6IHVjczJkZWNvZGUsXG5cdFx0XHQnZW5jb2RlJzogdWNzMmVuY29kZVxuXHRcdH0sXG5cdFx0J2RlY29kZSc6IGRlY29kZSxcblx0XHQnZW5jb2RlJzogZW5jb2RlLFxuXHRcdCd0b0FTQ0lJJzogdG9BU0NJSSxcblx0XHQndG9Vbmljb2RlJzogdG9Vbmljb2RlXG5cdH07XG5cblx0LyoqIEV4cG9zZSBgcHVueWNvZGVgICovXG5cdC8vIFNvbWUgQU1EIGJ1aWxkIG9wdGltaXplcnMsIGxpa2Ugci5qcywgY2hlY2sgZm9yIHNwZWNpZmljIGNvbmRpdGlvbiBwYXR0ZXJuc1xuXHQvLyBsaWtlIHRoZSBmb2xsb3dpbmc6XG5cdGlmIChcblx0XHR0eXBlb2YgZGVmaW5lID09ICdmdW5jdGlvbicgJiZcblx0XHR0eXBlb2YgZGVmaW5lLmFtZCA9PSAnb2JqZWN0JyAmJlxuXHRcdGRlZmluZS5hbWRcblx0KSB7XG5cdFx0ZGVmaW5lKCdwdW55Y29kZScsIGZ1bmN0aW9uKCkge1xuXHRcdFx0cmV0dXJuIHB1bnljb2RlO1xuXHRcdH0pO1xuXHR9IGVsc2UgaWYgKGZyZWVFeHBvcnRzICYmIGZyZWVNb2R1bGUpIHtcblx0XHRpZiAobW9kdWxlLmV4cG9ydHMgPT0gZnJlZUV4cG9ydHMpIHsgLy8gaW4gTm9kZS5qcyBvciBSaW5nb0pTIHYwLjguMCtcblx0XHRcdGZyZWVNb2R1bGUuZXhwb3J0cyA9IHB1bnljb2RlO1xuXHRcdH0gZWxzZSB7IC8vIGluIE5hcndoYWwgb3IgUmluZ29KUyB2MC43LjAtXG5cdFx0XHRmb3IgKGtleSBpbiBwdW55Y29kZSkge1xuXHRcdFx0XHRwdW55Y29kZS5oYXNPd25Qcm9wZXJ0eShrZXkpICYmIChmcmVlRXhwb3J0c1trZXldID0gcHVueWNvZGVba2V5XSk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9IGVsc2UgeyAvLyBpbiBSaGlubyBvciBhIHdlYiBicm93c2VyXG5cdFx0cm9vdC5wdW55Y29kZSA9IHB1bnljb2RlO1xuXHR9XG5cbn0odGhpcykpO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3B1bnljb2RlL3B1bnljb2RlLmpzXG4vLyBtb2R1bGUgaWQgPSA1NVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvLyBDb3B5cmlnaHQgSm95ZW50LCBJbmMuIGFuZCBvdGhlciBOb2RlIGNvbnRyaWJ1dG9ycy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYVxuLy8gY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZVxuLy8gXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nXG4vLyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsXG4vLyBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0XG4vLyBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGVcbi8vIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkXG4vLyBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTXG4vLyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4vLyBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOXG4vLyBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSxcbi8vIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUlxuLy8gT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRVxuLy8gVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cblxuJ3VzZSBzdHJpY3QnO1xuXG4vLyBJZiBvYmouaGFzT3duUHJvcGVydHkgaGFzIGJlZW4gb3ZlcnJpZGRlbiwgdGhlbiBjYWxsaW5nXG4vLyBvYmouaGFzT3duUHJvcGVydHkocHJvcCkgd2lsbCBicmVhay5cbi8vIFNlZTogaHR0cHM6Ly9naXRodWIuY29tL2pveWVudC9ub2RlL2lzc3Vlcy8xNzA3XG5mdW5jdGlvbiBoYXNPd25Qcm9wZXJ0eShvYmosIHByb3ApIHtcbiAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIHByb3ApO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKHFzLCBzZXAsIGVxLCBvcHRpb25zKSB7XG4gIHNlcCA9IHNlcCB8fCAnJic7XG4gIGVxID0gZXEgfHwgJz0nO1xuICB2YXIgb2JqID0ge307XG5cbiAgaWYgKHR5cGVvZiBxcyAhPT0gJ3N0cmluZycgfHwgcXMubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuIG9iajtcbiAgfVxuXG4gIHZhciByZWdleHAgPSAvXFwrL2c7XG4gIHFzID0gcXMuc3BsaXQoc2VwKTtcblxuICB2YXIgbWF4S2V5cyA9IDEwMDA7XG4gIGlmIChvcHRpb25zICYmIHR5cGVvZiBvcHRpb25zLm1heEtleXMgPT09ICdudW1iZXInKSB7XG4gICAgbWF4S2V5cyA9IG9wdGlvbnMubWF4S2V5cztcbiAgfVxuXG4gIHZhciBsZW4gPSBxcy5sZW5ndGg7XG4gIC8vIG1heEtleXMgPD0gMCBtZWFucyB0aGF0IHdlIHNob3VsZCBub3QgbGltaXQga2V5cyBjb3VudFxuICBpZiAobWF4S2V5cyA+IDAgJiYgbGVuID4gbWF4S2V5cykge1xuICAgIGxlbiA9IG1heEtleXM7XG4gIH1cblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgKytpKSB7XG4gICAgdmFyIHggPSBxc1tpXS5yZXBsYWNlKHJlZ2V4cCwgJyUyMCcpLFxuICAgICAgICBpZHggPSB4LmluZGV4T2YoZXEpLFxuICAgICAgICBrc3RyLCB2c3RyLCBrLCB2O1xuXG4gICAgaWYgKGlkeCA+PSAwKSB7XG4gICAgICBrc3RyID0geC5zdWJzdHIoMCwgaWR4KTtcbiAgICAgIHZzdHIgPSB4LnN1YnN0cihpZHggKyAxKTtcbiAgICB9IGVsc2Uge1xuICAgICAga3N0ciA9IHg7XG4gICAgICB2c3RyID0gJyc7XG4gICAgfVxuXG4gICAgayA9IGRlY29kZVVSSUNvbXBvbmVudChrc3RyKTtcbiAgICB2ID0gZGVjb2RlVVJJQ29tcG9uZW50KHZzdHIpO1xuXG4gICAgaWYgKCFoYXNPd25Qcm9wZXJ0eShvYmosIGspKSB7XG4gICAgICBvYmpba10gPSB2O1xuICAgIH0gZWxzZSBpZiAoaXNBcnJheShvYmpba10pKSB7XG4gICAgICBvYmpba10ucHVzaCh2KTtcbiAgICB9IGVsc2Uge1xuICAgICAgb2JqW2tdID0gW29ialtrXSwgdl07XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG9iajtcbn07XG5cbnZhciBpc0FycmF5ID0gQXJyYXkuaXNBcnJheSB8fCBmdW5jdGlvbiAoeHMpIHtcbiAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh4cykgPT09ICdbb2JqZWN0IEFycmF5XSc7XG59O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3F1ZXJ5c3RyaW5nLWVzMy9kZWNvZGUuanNcbi8vIG1vZHVsZSBpZCA9IDU2XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8vIENvcHlyaWdodCBKb3llbnQsIEluYy4gYW5kIG90aGVyIE5vZGUgY29udHJpYnV0b3JzLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhXG4vLyBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlXG4vLyBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmdcbi8vIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCxcbi8vIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXRcbi8vIHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZVxuLy8gZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWRcbi8vIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1Ncbi8vIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0Zcbi8vIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU5cbi8vIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLFxuLy8gREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SXG4vLyBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFXG4vLyBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBzdHJpbmdpZnlQcmltaXRpdmUgPSBmdW5jdGlvbih2KSB7XG4gIHN3aXRjaCAodHlwZW9mIHYpIHtcbiAgICBjYXNlICdzdHJpbmcnOlxuICAgICAgcmV0dXJuIHY7XG5cbiAgICBjYXNlICdib29sZWFuJzpcbiAgICAgIHJldHVybiB2ID8gJ3RydWUnIDogJ2ZhbHNlJztcblxuICAgIGNhc2UgJ251bWJlcic6XG4gICAgICByZXR1cm4gaXNGaW5pdGUodikgPyB2IDogJyc7XG5cbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuICcnO1xuICB9XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKG9iaiwgc2VwLCBlcSwgbmFtZSkge1xuICBzZXAgPSBzZXAgfHwgJyYnO1xuICBlcSA9IGVxIHx8ICc9JztcbiAgaWYgKG9iaiA9PT0gbnVsbCkge1xuICAgIG9iaiA9IHVuZGVmaW5lZDtcbiAgfVxuXG4gIGlmICh0eXBlb2Ygb2JqID09PSAnb2JqZWN0Jykge1xuICAgIHJldHVybiBtYXAob2JqZWN0S2V5cyhvYmopLCBmdW5jdGlvbihrKSB7XG4gICAgICB2YXIga3MgPSBlbmNvZGVVUklDb21wb25lbnQoc3RyaW5naWZ5UHJpbWl0aXZlKGspKSArIGVxO1xuICAgICAgaWYgKGlzQXJyYXkob2JqW2tdKSkge1xuICAgICAgICByZXR1cm4gbWFwKG9ialtrXSwgZnVuY3Rpb24odikge1xuICAgICAgICAgIHJldHVybiBrcyArIGVuY29kZVVSSUNvbXBvbmVudChzdHJpbmdpZnlQcmltaXRpdmUodikpO1xuICAgICAgICB9KS5qb2luKHNlcCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4ga3MgKyBlbmNvZGVVUklDb21wb25lbnQoc3RyaW5naWZ5UHJpbWl0aXZlKG9ialtrXSkpO1xuICAgICAgfVxuICAgIH0pLmpvaW4oc2VwKTtcblxuICB9XG5cbiAgaWYgKCFuYW1lKSByZXR1cm4gJyc7XG4gIHJldHVybiBlbmNvZGVVUklDb21wb25lbnQoc3RyaW5naWZ5UHJpbWl0aXZlKG5hbWUpKSArIGVxICtcbiAgICAgICAgIGVuY29kZVVSSUNvbXBvbmVudChzdHJpbmdpZnlQcmltaXRpdmUob2JqKSk7XG59O1xuXG52YXIgaXNBcnJheSA9IEFycmF5LmlzQXJyYXkgfHwgZnVuY3Rpb24gKHhzKSB7XG4gIHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoeHMpID09PSAnW29iamVjdCBBcnJheV0nO1xufTtcblxuZnVuY3Rpb24gbWFwICh4cywgZikge1xuICBpZiAoeHMubWFwKSByZXR1cm4geHMubWFwKGYpO1xuICB2YXIgcmVzID0gW107XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgeHMubGVuZ3RoOyBpKyspIHtcbiAgICByZXMucHVzaChmKHhzW2ldLCBpKSk7XG4gIH1cbiAgcmV0dXJuIHJlcztcbn1cblxudmFyIG9iamVjdEtleXMgPSBPYmplY3Qua2V5cyB8fCBmdW5jdGlvbiAob2JqKSB7XG4gIHZhciByZXMgPSBbXTtcbiAgZm9yICh2YXIga2V5IGluIG9iaikge1xuICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBrZXkpKSByZXMucHVzaChrZXkpO1xuICB9XG4gIHJldHVybiByZXM7XG59O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3F1ZXJ5c3RyaW5nLWVzMy9lbmNvZGUuanNcbi8vIG1vZHVsZSBpZCA9IDU3XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIid1c2Ugc3RyaWN0JztcblxuZXhwb3J0cy5kZWNvZGUgPSBleHBvcnRzLnBhcnNlID0gcmVxdWlyZSgnLi9kZWNvZGUnKTtcbmV4cG9ydHMuZW5jb2RlID0gZXhwb3J0cy5zdHJpbmdpZnkgPSByZXF1aXJlKCcuL2VuY29kZScpO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3F1ZXJ5c3RyaW5nLWVzMy9pbmRleC5qc1xuLy8gbW9kdWxlIGlkID0gNThcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiKGZ1bmN0aW9uIChnbG9iYWwsIHVuZGVmaW5lZCkge1xuICAgIFwidXNlIHN0cmljdFwiO1xuXG4gICAgaWYgKGdsb2JhbC5zZXRJbW1lZGlhdGUpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBuZXh0SGFuZGxlID0gMTsgLy8gU3BlYyBzYXlzIGdyZWF0ZXIgdGhhbiB6ZXJvXG4gICAgdmFyIHRhc2tzQnlIYW5kbGUgPSB7fTtcbiAgICB2YXIgY3VycmVudGx5UnVubmluZ0FUYXNrID0gZmFsc2U7XG4gICAgdmFyIGRvYyA9IGdsb2JhbC5kb2N1bWVudDtcbiAgICB2YXIgcmVnaXN0ZXJJbW1lZGlhdGU7XG5cbiAgICBmdW5jdGlvbiBzZXRJbW1lZGlhdGUoY2FsbGJhY2spIHtcbiAgICAgIC8vIENhbGxiYWNrIGNhbiBlaXRoZXIgYmUgYSBmdW5jdGlvbiBvciBhIHN0cmluZ1xuICAgICAgaWYgKHR5cGVvZiBjYWxsYmFjayAhPT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgIGNhbGxiYWNrID0gbmV3IEZ1bmN0aW9uKFwiXCIgKyBjYWxsYmFjayk7XG4gICAgICB9XG4gICAgICAvLyBDb3B5IGZ1bmN0aW9uIGFyZ3VtZW50c1xuICAgICAgdmFyIGFyZ3MgPSBuZXcgQXJyYXkoYXJndW1lbnRzLmxlbmd0aCAtIDEpO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcmdzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgYXJnc1tpXSA9IGFyZ3VtZW50c1tpICsgMV07XG4gICAgICB9XG4gICAgICAvLyBTdG9yZSBhbmQgcmVnaXN0ZXIgdGhlIHRhc2tcbiAgICAgIHZhciB0YXNrID0geyBjYWxsYmFjazogY2FsbGJhY2ssIGFyZ3M6IGFyZ3MgfTtcbiAgICAgIHRhc2tzQnlIYW5kbGVbbmV4dEhhbmRsZV0gPSB0YXNrO1xuICAgICAgcmVnaXN0ZXJJbW1lZGlhdGUobmV4dEhhbmRsZSk7XG4gICAgICByZXR1cm4gbmV4dEhhbmRsZSsrO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNsZWFySW1tZWRpYXRlKGhhbmRsZSkge1xuICAgICAgICBkZWxldGUgdGFza3NCeUhhbmRsZVtoYW5kbGVdO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHJ1bih0YXNrKSB7XG4gICAgICAgIHZhciBjYWxsYmFjayA9IHRhc2suY2FsbGJhY2s7XG4gICAgICAgIHZhciBhcmdzID0gdGFzay5hcmdzO1xuICAgICAgICBzd2l0Y2ggKGFyZ3MubGVuZ3RoKSB7XG4gICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgIGNhbGxiYWNrKCk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgY2FsbGJhY2soYXJnc1swXSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgY2FsbGJhY2soYXJnc1swXSwgYXJnc1sxXSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgY2FsbGJhY2soYXJnc1swXSwgYXJnc1sxXSwgYXJnc1syXSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIGNhbGxiYWNrLmFwcGx5KHVuZGVmaW5lZCwgYXJncyk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIHJ1bklmUHJlc2VudChoYW5kbGUpIHtcbiAgICAgICAgLy8gRnJvbSB0aGUgc3BlYzogXCJXYWl0IHVudGlsIGFueSBpbnZvY2F0aW9ucyBvZiB0aGlzIGFsZ29yaXRobSBzdGFydGVkIGJlZm9yZSB0aGlzIG9uZSBoYXZlIGNvbXBsZXRlZC5cIlxuICAgICAgICAvLyBTbyBpZiB3ZSdyZSBjdXJyZW50bHkgcnVubmluZyBhIHRhc2ssIHdlJ2xsIG5lZWQgdG8gZGVsYXkgdGhpcyBpbnZvY2F0aW9uLlxuICAgICAgICBpZiAoY3VycmVudGx5UnVubmluZ0FUYXNrKSB7XG4gICAgICAgICAgICAvLyBEZWxheSBieSBkb2luZyBhIHNldFRpbWVvdXQuIHNldEltbWVkaWF0ZSB3YXMgdHJpZWQgaW5zdGVhZCwgYnV0IGluIEZpcmVmb3ggNyBpdCBnZW5lcmF0ZWQgYVxuICAgICAgICAgICAgLy8gXCJ0b28gbXVjaCByZWN1cnNpb25cIiBlcnJvci5cbiAgICAgICAgICAgIHNldFRpbWVvdXQocnVuSWZQcmVzZW50LCAwLCBoYW5kbGUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdmFyIHRhc2sgPSB0YXNrc0J5SGFuZGxlW2hhbmRsZV07XG4gICAgICAgICAgICBpZiAodGFzaykge1xuICAgICAgICAgICAgICAgIGN1cnJlbnRseVJ1bm5pbmdBVGFzayA9IHRydWU7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgcnVuKHRhc2spO1xuICAgICAgICAgICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICAgICAgICAgIGNsZWFySW1tZWRpYXRlKGhhbmRsZSk7XG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnRseVJ1bm5pbmdBVGFzayA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGluc3RhbGxOZXh0VGlja0ltcGxlbWVudGF0aW9uKCkge1xuICAgICAgICByZWdpc3RlckltbWVkaWF0ZSA9IGZ1bmN0aW9uKGhhbmRsZSkge1xuICAgICAgICAgICAgcHJvY2Vzcy5uZXh0VGljayhmdW5jdGlvbiAoKSB7IHJ1bklmUHJlc2VudChoYW5kbGUpOyB9KTtcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjYW5Vc2VQb3N0TWVzc2FnZSgpIHtcbiAgICAgICAgLy8gVGhlIHRlc3QgYWdhaW5zdCBgaW1wb3J0U2NyaXB0c2AgcHJldmVudHMgdGhpcyBpbXBsZW1lbnRhdGlvbiBmcm9tIGJlaW5nIGluc3RhbGxlZCBpbnNpZGUgYSB3ZWIgd29ya2VyLFxuICAgICAgICAvLyB3aGVyZSBgZ2xvYmFsLnBvc3RNZXNzYWdlYCBtZWFucyBzb21ldGhpbmcgY29tcGxldGVseSBkaWZmZXJlbnQgYW5kIGNhbid0IGJlIHVzZWQgZm9yIHRoaXMgcHVycG9zZS5cbiAgICAgICAgaWYgKGdsb2JhbC5wb3N0TWVzc2FnZSAmJiAhZ2xvYmFsLmltcG9ydFNjcmlwdHMpIHtcbiAgICAgICAgICAgIHZhciBwb3N0TWVzc2FnZUlzQXN5bmNocm9ub3VzID0gdHJ1ZTtcbiAgICAgICAgICAgIHZhciBvbGRPbk1lc3NhZ2UgPSBnbG9iYWwub25tZXNzYWdlO1xuICAgICAgICAgICAgZ2xvYmFsLm9ubWVzc2FnZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHBvc3RNZXNzYWdlSXNBc3luY2hyb25vdXMgPSBmYWxzZTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBnbG9iYWwucG9zdE1lc3NhZ2UoXCJcIiwgXCIqXCIpO1xuICAgICAgICAgICAgZ2xvYmFsLm9ubWVzc2FnZSA9IG9sZE9uTWVzc2FnZTtcbiAgICAgICAgICAgIHJldHVybiBwb3N0TWVzc2FnZUlzQXN5bmNocm9ub3VzO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaW5zdGFsbFBvc3RNZXNzYWdlSW1wbGVtZW50YXRpb24oKSB7XG4gICAgICAgIC8vIEluc3RhbGxzIGFuIGV2ZW50IGhhbmRsZXIgb24gYGdsb2JhbGAgZm9yIHRoZSBgbWVzc2FnZWAgZXZlbnQ6IHNlZVxuICAgICAgICAvLyAqIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuL0RPTS93aW5kb3cucG9zdE1lc3NhZ2VcbiAgICAgICAgLy8gKiBodHRwOi8vd3d3LndoYXR3Zy5vcmcvc3BlY3Mvd2ViLWFwcHMvY3VycmVudC13b3JrL211bHRpcGFnZS9jb21tcy5odG1sI2Nyb3NzRG9jdW1lbnRNZXNzYWdlc1xuXG4gICAgICAgIHZhciBtZXNzYWdlUHJlZml4ID0gXCJzZXRJbW1lZGlhdGUkXCIgKyBNYXRoLnJhbmRvbSgpICsgXCIkXCI7XG4gICAgICAgIHZhciBvbkdsb2JhbE1lc3NhZ2UgPSBmdW5jdGlvbihldmVudCkge1xuICAgICAgICAgICAgaWYgKGV2ZW50LnNvdXJjZSA9PT0gZ2xvYmFsICYmXG4gICAgICAgICAgICAgICAgdHlwZW9mIGV2ZW50LmRhdGEgPT09IFwic3RyaW5nXCIgJiZcbiAgICAgICAgICAgICAgICBldmVudC5kYXRhLmluZGV4T2YobWVzc2FnZVByZWZpeCkgPT09IDApIHtcbiAgICAgICAgICAgICAgICBydW5JZlByZXNlbnQoK2V2ZW50LmRhdGEuc2xpY2UobWVzc2FnZVByZWZpeC5sZW5ndGgpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcblxuICAgICAgICBpZiAoZ2xvYmFsLmFkZEV2ZW50TGlzdGVuZXIpIHtcbiAgICAgICAgICAgIGdsb2JhbC5hZGRFdmVudExpc3RlbmVyKFwibWVzc2FnZVwiLCBvbkdsb2JhbE1lc3NhZ2UsIGZhbHNlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGdsb2JhbC5hdHRhY2hFdmVudChcIm9ubWVzc2FnZVwiLCBvbkdsb2JhbE1lc3NhZ2UpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmVnaXN0ZXJJbW1lZGlhdGUgPSBmdW5jdGlvbihoYW5kbGUpIHtcbiAgICAgICAgICAgIGdsb2JhbC5wb3N0TWVzc2FnZShtZXNzYWdlUHJlZml4ICsgaGFuZGxlLCBcIipcIik7XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaW5zdGFsbE1lc3NhZ2VDaGFubmVsSW1wbGVtZW50YXRpb24oKSB7XG4gICAgICAgIHZhciBjaGFubmVsID0gbmV3IE1lc3NhZ2VDaGFubmVsKCk7XG4gICAgICAgIGNoYW5uZWwucG9ydDEub25tZXNzYWdlID0gZnVuY3Rpb24oZXZlbnQpIHtcbiAgICAgICAgICAgIHZhciBoYW5kbGUgPSBldmVudC5kYXRhO1xuICAgICAgICAgICAgcnVuSWZQcmVzZW50KGhhbmRsZSk7XG4gICAgICAgIH07XG5cbiAgICAgICAgcmVnaXN0ZXJJbW1lZGlhdGUgPSBmdW5jdGlvbihoYW5kbGUpIHtcbiAgICAgICAgICAgIGNoYW5uZWwucG9ydDIucG9zdE1lc3NhZ2UoaGFuZGxlKTtcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpbnN0YWxsUmVhZHlTdGF0ZUNoYW5nZUltcGxlbWVudGF0aW9uKCkge1xuICAgICAgICB2YXIgaHRtbCA9IGRvYy5kb2N1bWVudEVsZW1lbnQ7XG4gICAgICAgIHJlZ2lzdGVySW1tZWRpYXRlID0gZnVuY3Rpb24oaGFuZGxlKSB7XG4gICAgICAgICAgICAvLyBDcmVhdGUgYSA8c2NyaXB0PiBlbGVtZW50OyBpdHMgcmVhZHlzdGF0ZWNoYW5nZSBldmVudCB3aWxsIGJlIGZpcmVkIGFzeW5jaHJvbm91c2x5IG9uY2UgaXQgaXMgaW5zZXJ0ZWRcbiAgICAgICAgICAgIC8vIGludG8gdGhlIGRvY3VtZW50LiBEbyBzbywgdGh1cyBxdWV1aW5nIHVwIHRoZSB0YXNrLiBSZW1lbWJlciB0byBjbGVhbiB1cCBvbmNlIGl0J3MgYmVlbiBjYWxsZWQuXG4gICAgICAgICAgICB2YXIgc2NyaXB0ID0gZG9jLmNyZWF0ZUVsZW1lbnQoXCJzY3JpcHRcIik7XG4gICAgICAgICAgICBzY3JpcHQub25yZWFkeXN0YXRlY2hhbmdlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHJ1bklmUHJlc2VudChoYW5kbGUpO1xuICAgICAgICAgICAgICAgIHNjcmlwdC5vbnJlYWR5c3RhdGVjaGFuZ2UgPSBudWxsO1xuICAgICAgICAgICAgICAgIGh0bWwucmVtb3ZlQ2hpbGQoc2NyaXB0KTtcbiAgICAgICAgICAgICAgICBzY3JpcHQgPSBudWxsO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGh0bWwuYXBwZW5kQ2hpbGQoc2NyaXB0KTtcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpbnN0YWxsU2V0VGltZW91dEltcGxlbWVudGF0aW9uKCkge1xuICAgICAgICByZWdpc3RlckltbWVkaWF0ZSA9IGZ1bmN0aW9uKGhhbmRsZSkge1xuICAgICAgICAgICAgc2V0VGltZW91dChydW5JZlByZXNlbnQsIDAsIGhhbmRsZSk7XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgLy8gSWYgc3VwcG9ydGVkLCB3ZSBzaG91bGQgYXR0YWNoIHRvIHRoZSBwcm90b3R5cGUgb2YgZ2xvYmFsLCBzaW5jZSB0aGF0IGlzIHdoZXJlIHNldFRpbWVvdXQgZXQgYWwuIGxpdmUuXG4gICAgdmFyIGF0dGFjaFRvID0gT2JqZWN0LmdldFByb3RvdHlwZU9mICYmIE9iamVjdC5nZXRQcm90b3R5cGVPZihnbG9iYWwpO1xuICAgIGF0dGFjaFRvID0gYXR0YWNoVG8gJiYgYXR0YWNoVG8uc2V0VGltZW91dCA/IGF0dGFjaFRvIDogZ2xvYmFsO1xuXG4gICAgLy8gRG9uJ3QgZ2V0IGZvb2xlZCBieSBlLmcuIGJyb3dzZXJpZnkgZW52aXJvbm1lbnRzLlxuICAgIGlmICh7fS50b1N0cmluZy5jYWxsKGdsb2JhbC5wcm9jZXNzKSA9PT0gXCJbb2JqZWN0IHByb2Nlc3NdXCIpIHtcbiAgICAgICAgLy8gRm9yIE5vZGUuanMgYmVmb3JlIDAuOVxuICAgICAgICBpbnN0YWxsTmV4dFRpY2tJbXBsZW1lbnRhdGlvbigpO1xuXG4gICAgfSBlbHNlIGlmIChjYW5Vc2VQb3N0TWVzc2FnZSgpKSB7XG4gICAgICAgIC8vIEZvciBub24tSUUxMCBtb2Rlcm4gYnJvd3NlcnNcbiAgICAgICAgaW5zdGFsbFBvc3RNZXNzYWdlSW1wbGVtZW50YXRpb24oKTtcblxuICAgIH0gZWxzZSBpZiAoZ2xvYmFsLk1lc3NhZ2VDaGFubmVsKSB7XG4gICAgICAgIC8vIEZvciB3ZWIgd29ya2Vycywgd2hlcmUgc3VwcG9ydGVkXG4gICAgICAgIGluc3RhbGxNZXNzYWdlQ2hhbm5lbEltcGxlbWVudGF0aW9uKCk7XG5cbiAgICB9IGVsc2UgaWYgKGRvYyAmJiBcIm9ucmVhZHlzdGF0ZWNoYW5nZVwiIGluIGRvYy5jcmVhdGVFbGVtZW50KFwic2NyaXB0XCIpKSB7XG4gICAgICAgIC8vIEZvciBJRSA24oCTOFxuICAgICAgICBpbnN0YWxsUmVhZHlTdGF0ZUNoYW5nZUltcGxlbWVudGF0aW9uKCk7XG5cbiAgICB9IGVsc2Uge1xuICAgICAgICAvLyBGb3Igb2xkZXIgYnJvd3NlcnNcbiAgICAgICAgaW5zdGFsbFNldFRpbWVvdXRJbXBsZW1lbnRhdGlvbigpO1xuICAgIH1cblxuICAgIGF0dGFjaFRvLnNldEltbWVkaWF0ZSA9IHNldEltbWVkaWF0ZTtcbiAgICBhdHRhY2hUby5jbGVhckltbWVkaWF0ZSA9IGNsZWFySW1tZWRpYXRlO1xufSh0eXBlb2Ygc2VsZiA9PT0gXCJ1bmRlZmluZWRcIiA/IHR5cGVvZiBnbG9iYWwgPT09IFwidW5kZWZpbmVkXCIgPyB0aGlzIDogZ2xvYmFsIDogc2VsZikpO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3NldGltbWVkaWF0ZS9zZXRJbW1lZGlhdGUuanNcbi8vIG1vZHVsZSBpZCA9IDU5XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBhcHBseSA9IEZ1bmN0aW9uLnByb3RvdHlwZS5hcHBseTtcblxuLy8gRE9NIEFQSXMsIGZvciBjb21wbGV0ZW5lc3NcblxuZXhwb3J0cy5zZXRUaW1lb3V0ID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiBuZXcgVGltZW91dChhcHBseS5jYWxsKHNldFRpbWVvdXQsIHdpbmRvdywgYXJndW1lbnRzKSwgY2xlYXJUaW1lb3V0KTtcbn07XG5leHBvcnRzLnNldEludGVydmFsID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiBuZXcgVGltZW91dChhcHBseS5jYWxsKHNldEludGVydmFsLCB3aW5kb3csIGFyZ3VtZW50cyksIGNsZWFySW50ZXJ2YWwpO1xufTtcbmV4cG9ydHMuY2xlYXJUaW1lb3V0ID1cbmV4cG9ydHMuY2xlYXJJbnRlcnZhbCA9IGZ1bmN0aW9uKHRpbWVvdXQpIHtcbiAgaWYgKHRpbWVvdXQpIHtcbiAgICB0aW1lb3V0LmNsb3NlKCk7XG4gIH1cbn07XG5cbmZ1bmN0aW9uIFRpbWVvdXQoaWQsIGNsZWFyRm4pIHtcbiAgdGhpcy5faWQgPSBpZDtcbiAgdGhpcy5fY2xlYXJGbiA9IGNsZWFyRm47XG59XG5UaW1lb3V0LnByb3RvdHlwZS51bnJlZiA9IFRpbWVvdXQucHJvdG90eXBlLnJlZiA9IGZ1bmN0aW9uKCkge307XG5UaW1lb3V0LnByb3RvdHlwZS5jbG9zZSA9IGZ1bmN0aW9uKCkge1xuICB0aGlzLl9jbGVhckZuLmNhbGwod2luZG93LCB0aGlzLl9pZCk7XG59O1xuXG4vLyBEb2VzIG5vdCBzdGFydCB0aGUgdGltZSwganVzdCBzZXRzIHVwIHRoZSBtZW1iZXJzIG5lZWRlZC5cbmV4cG9ydHMuZW5yb2xsID0gZnVuY3Rpb24oaXRlbSwgbXNlY3MpIHtcbiAgY2xlYXJUaW1lb3V0KGl0ZW0uX2lkbGVUaW1lb3V0SWQpO1xuICBpdGVtLl9pZGxlVGltZW91dCA9IG1zZWNzO1xufTtcblxuZXhwb3J0cy51bmVucm9sbCA9IGZ1bmN0aW9uKGl0ZW0pIHtcbiAgY2xlYXJUaW1lb3V0KGl0ZW0uX2lkbGVUaW1lb3V0SWQpO1xuICBpdGVtLl9pZGxlVGltZW91dCA9IC0xO1xufTtcblxuZXhwb3J0cy5fdW5yZWZBY3RpdmUgPSBleHBvcnRzLmFjdGl2ZSA9IGZ1bmN0aW9uKGl0ZW0pIHtcbiAgY2xlYXJUaW1lb3V0KGl0ZW0uX2lkbGVUaW1lb3V0SWQpO1xuXG4gIHZhciBtc2VjcyA9IGl0ZW0uX2lkbGVUaW1lb3V0O1xuICBpZiAobXNlY3MgPj0gMCkge1xuICAgIGl0ZW0uX2lkbGVUaW1lb3V0SWQgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uIG9uVGltZW91dCgpIHtcbiAgICAgIGlmIChpdGVtLl9vblRpbWVvdXQpXG4gICAgICAgIGl0ZW0uX29uVGltZW91dCgpO1xuICAgIH0sIG1zZWNzKTtcbiAgfVxufTtcblxuLy8gc2V0aW1tZWRpYXRlIGF0dGFjaGVzIGl0c2VsZiB0byB0aGUgZ2xvYmFsIG9iamVjdFxucmVxdWlyZShcInNldGltbWVkaWF0ZVwiKTtcbmV4cG9ydHMuc2V0SW1tZWRpYXRlID0gc2V0SW1tZWRpYXRlO1xuZXhwb3J0cy5jbGVhckltbWVkaWF0ZSA9IGNsZWFySW1tZWRpYXRlO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3RpbWVycy1icm93c2VyaWZ5L21haW4uanNcbi8vIG1vZHVsZSBpZCA9IDYwXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8vIENvcHlyaWdodCBKb3llbnQsIEluYy4gYW5kIG90aGVyIE5vZGUgY29udHJpYnV0b3JzLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhXG4vLyBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlXG4vLyBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmdcbi8vIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCxcbi8vIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXRcbi8vIHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZVxuLy8gZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWRcbi8vIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1Ncbi8vIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0Zcbi8vIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU5cbi8vIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLFxuLy8gREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SXG4vLyBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFXG4vLyBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBwdW55Y29kZSA9IHJlcXVpcmUoJ3B1bnljb2RlJyk7XG52YXIgdXRpbCA9IHJlcXVpcmUoJy4vdXRpbCcpO1xuXG5leHBvcnRzLnBhcnNlID0gdXJsUGFyc2U7XG5leHBvcnRzLnJlc29sdmUgPSB1cmxSZXNvbHZlO1xuZXhwb3J0cy5yZXNvbHZlT2JqZWN0ID0gdXJsUmVzb2x2ZU9iamVjdDtcbmV4cG9ydHMuZm9ybWF0ID0gdXJsRm9ybWF0O1xuXG5leHBvcnRzLlVybCA9IFVybDtcblxuZnVuY3Rpb24gVXJsKCkge1xuICB0aGlzLnByb3RvY29sID0gbnVsbDtcbiAgdGhpcy5zbGFzaGVzID0gbnVsbDtcbiAgdGhpcy5hdXRoID0gbnVsbDtcbiAgdGhpcy5ob3N0ID0gbnVsbDtcbiAgdGhpcy5wb3J0ID0gbnVsbDtcbiAgdGhpcy5ob3N0bmFtZSA9IG51bGw7XG4gIHRoaXMuaGFzaCA9IG51bGw7XG4gIHRoaXMuc2VhcmNoID0gbnVsbDtcbiAgdGhpcy5xdWVyeSA9IG51bGw7XG4gIHRoaXMucGF0aG5hbWUgPSBudWxsO1xuICB0aGlzLnBhdGggPSBudWxsO1xuICB0aGlzLmhyZWYgPSBudWxsO1xufVxuXG4vLyBSZWZlcmVuY2U6IFJGQyAzOTg2LCBSRkMgMTgwOCwgUkZDIDIzOTZcblxuLy8gZGVmaW5lIHRoZXNlIGhlcmUgc28gYXQgbGVhc3QgdGhleSBvbmx5IGhhdmUgdG8gYmVcbi8vIGNvbXBpbGVkIG9uY2Ugb24gdGhlIGZpcnN0IG1vZHVsZSBsb2FkLlxudmFyIHByb3RvY29sUGF0dGVybiA9IC9eKFthLXowLTkuKy1dKzopL2ksXG4gICAgcG9ydFBhdHRlcm4gPSAvOlswLTldKiQvLFxuXG4gICAgLy8gU3BlY2lhbCBjYXNlIGZvciBhIHNpbXBsZSBwYXRoIFVSTFxuICAgIHNpbXBsZVBhdGhQYXR0ZXJuID0gL14oXFwvXFwvPyg/IVxcLylbXlxcP1xcc10qKShcXD9bXlxcc10qKT8kLyxcblxuICAgIC8vIFJGQyAyMzk2OiBjaGFyYWN0ZXJzIHJlc2VydmVkIGZvciBkZWxpbWl0aW5nIFVSTHMuXG4gICAgLy8gV2UgYWN0dWFsbHkganVzdCBhdXRvLWVzY2FwZSB0aGVzZS5cbiAgICBkZWxpbXMgPSBbJzwnLCAnPicsICdcIicsICdgJywgJyAnLCAnXFxyJywgJ1xcbicsICdcXHQnXSxcblxuICAgIC8vIFJGQyAyMzk2OiBjaGFyYWN0ZXJzIG5vdCBhbGxvd2VkIGZvciB2YXJpb3VzIHJlYXNvbnMuXG4gICAgdW53aXNlID0gWyd7JywgJ30nLCAnfCcsICdcXFxcJywgJ14nLCAnYCddLmNvbmNhdChkZWxpbXMpLFxuXG4gICAgLy8gQWxsb3dlZCBieSBSRkNzLCBidXQgY2F1c2Ugb2YgWFNTIGF0dGFja3MuICBBbHdheXMgZXNjYXBlIHRoZXNlLlxuICAgIGF1dG9Fc2NhcGUgPSBbJ1xcJyddLmNvbmNhdCh1bndpc2UpLFxuICAgIC8vIENoYXJhY3RlcnMgdGhhdCBhcmUgbmV2ZXIgZXZlciBhbGxvd2VkIGluIGEgaG9zdG5hbWUuXG4gICAgLy8gTm90ZSB0aGF0IGFueSBpbnZhbGlkIGNoYXJzIGFyZSBhbHNvIGhhbmRsZWQsIGJ1dCB0aGVzZVxuICAgIC8vIGFyZSB0aGUgb25lcyB0aGF0IGFyZSAqZXhwZWN0ZWQqIHRvIGJlIHNlZW4sIHNvIHdlIGZhc3QtcGF0aFxuICAgIC8vIHRoZW0uXG4gICAgbm9uSG9zdENoYXJzID0gWyclJywgJy8nLCAnPycsICc7JywgJyMnXS5jb25jYXQoYXV0b0VzY2FwZSksXG4gICAgaG9zdEVuZGluZ0NoYXJzID0gWycvJywgJz8nLCAnIyddLFxuICAgIGhvc3RuYW1lTWF4TGVuID0gMjU1LFxuICAgIGhvc3RuYW1lUGFydFBhdHRlcm4gPSAvXlsrYS16MC05QS1aXy1dezAsNjN9JC8sXG4gICAgaG9zdG5hbWVQYXJ0U3RhcnQgPSAvXihbK2EtejAtOUEtWl8tXXswLDYzfSkoLiopJC8sXG4gICAgLy8gcHJvdG9jb2xzIHRoYXQgY2FuIGFsbG93IFwidW5zYWZlXCIgYW5kIFwidW53aXNlXCIgY2hhcnMuXG4gICAgdW5zYWZlUHJvdG9jb2wgPSB7XG4gICAgICAnamF2YXNjcmlwdCc6IHRydWUsXG4gICAgICAnamF2YXNjcmlwdDonOiB0cnVlXG4gICAgfSxcbiAgICAvLyBwcm90b2NvbHMgdGhhdCBuZXZlciBoYXZlIGEgaG9zdG5hbWUuXG4gICAgaG9zdGxlc3NQcm90b2NvbCA9IHtcbiAgICAgICdqYXZhc2NyaXB0JzogdHJ1ZSxcbiAgICAgICdqYXZhc2NyaXB0Oic6IHRydWVcbiAgICB9LFxuICAgIC8vIHByb3RvY29scyB0aGF0IGFsd2F5cyBjb250YWluIGEgLy8gYml0LlxuICAgIHNsYXNoZWRQcm90b2NvbCA9IHtcbiAgICAgICdodHRwJzogdHJ1ZSxcbiAgICAgICdodHRwcyc6IHRydWUsXG4gICAgICAnZnRwJzogdHJ1ZSxcbiAgICAgICdnb3BoZXInOiB0cnVlLFxuICAgICAgJ2ZpbGUnOiB0cnVlLFxuICAgICAgJ2h0dHA6JzogdHJ1ZSxcbiAgICAgICdodHRwczonOiB0cnVlLFxuICAgICAgJ2Z0cDonOiB0cnVlLFxuICAgICAgJ2dvcGhlcjonOiB0cnVlLFxuICAgICAgJ2ZpbGU6JzogdHJ1ZVxuICAgIH0sXG4gICAgcXVlcnlzdHJpbmcgPSByZXF1aXJlKCdxdWVyeXN0cmluZycpO1xuXG5mdW5jdGlvbiB1cmxQYXJzZSh1cmwsIHBhcnNlUXVlcnlTdHJpbmcsIHNsYXNoZXNEZW5vdGVIb3N0KSB7XG4gIGlmICh1cmwgJiYgdXRpbC5pc09iamVjdCh1cmwpICYmIHVybCBpbnN0YW5jZW9mIFVybCkgcmV0dXJuIHVybDtcblxuICB2YXIgdSA9IG5ldyBVcmw7XG4gIHUucGFyc2UodXJsLCBwYXJzZVF1ZXJ5U3RyaW5nLCBzbGFzaGVzRGVub3RlSG9zdCk7XG4gIHJldHVybiB1O1xufVxuXG5VcmwucHJvdG90eXBlLnBhcnNlID0gZnVuY3Rpb24odXJsLCBwYXJzZVF1ZXJ5U3RyaW5nLCBzbGFzaGVzRGVub3RlSG9zdCkge1xuICBpZiAoIXV0aWwuaXNTdHJpbmcodXJsKSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJQYXJhbWV0ZXIgJ3VybCcgbXVzdCBiZSBhIHN0cmluZywgbm90IFwiICsgdHlwZW9mIHVybCk7XG4gIH1cblxuICAvLyBDb3B5IGNocm9tZSwgSUUsIG9wZXJhIGJhY2tzbGFzaC1oYW5kbGluZyBiZWhhdmlvci5cbiAgLy8gQmFjayBzbGFzaGVzIGJlZm9yZSB0aGUgcXVlcnkgc3RyaW5nIGdldCBjb252ZXJ0ZWQgdG8gZm9yd2FyZCBzbGFzaGVzXG4gIC8vIFNlZTogaHR0cHM6Ly9jb2RlLmdvb2dsZS5jb20vcC9jaHJvbWl1bS9pc3N1ZXMvZGV0YWlsP2lkPTI1OTE2XG4gIHZhciBxdWVyeUluZGV4ID0gdXJsLmluZGV4T2YoJz8nKSxcbiAgICAgIHNwbGl0dGVyID1cbiAgICAgICAgICAocXVlcnlJbmRleCAhPT0gLTEgJiYgcXVlcnlJbmRleCA8IHVybC5pbmRleE9mKCcjJykpID8gJz8nIDogJyMnLFxuICAgICAgdVNwbGl0ID0gdXJsLnNwbGl0KHNwbGl0dGVyKSxcbiAgICAgIHNsYXNoUmVnZXggPSAvXFxcXC9nO1xuICB1U3BsaXRbMF0gPSB1U3BsaXRbMF0ucmVwbGFjZShzbGFzaFJlZ2V4LCAnLycpO1xuICB1cmwgPSB1U3BsaXQuam9pbihzcGxpdHRlcik7XG5cbiAgdmFyIHJlc3QgPSB1cmw7XG5cbiAgLy8gdHJpbSBiZWZvcmUgcHJvY2VlZGluZy5cbiAgLy8gVGhpcyBpcyB0byBzdXBwb3J0IHBhcnNlIHN0dWZmIGxpa2UgXCIgIGh0dHA6Ly9mb28uY29tICBcXG5cIlxuICByZXN0ID0gcmVzdC50cmltKCk7XG5cbiAgaWYgKCFzbGFzaGVzRGVub3RlSG9zdCAmJiB1cmwuc3BsaXQoJyMnKS5sZW5ndGggPT09IDEpIHtcbiAgICAvLyBUcnkgZmFzdCBwYXRoIHJlZ2V4cFxuICAgIHZhciBzaW1wbGVQYXRoID0gc2ltcGxlUGF0aFBhdHRlcm4uZXhlYyhyZXN0KTtcbiAgICBpZiAoc2ltcGxlUGF0aCkge1xuICAgICAgdGhpcy5wYXRoID0gcmVzdDtcbiAgICAgIHRoaXMuaHJlZiA9IHJlc3Q7XG4gICAgICB0aGlzLnBhdGhuYW1lID0gc2ltcGxlUGF0aFsxXTtcbiAgICAgIGlmIChzaW1wbGVQYXRoWzJdKSB7XG4gICAgICAgIHRoaXMuc2VhcmNoID0gc2ltcGxlUGF0aFsyXTtcbiAgICAgICAgaWYgKHBhcnNlUXVlcnlTdHJpbmcpIHtcbiAgICAgICAgICB0aGlzLnF1ZXJ5ID0gcXVlcnlzdHJpbmcucGFyc2UodGhpcy5zZWFyY2guc3Vic3RyKDEpKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLnF1ZXJ5ID0gdGhpcy5zZWFyY2guc3Vic3RyKDEpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKHBhcnNlUXVlcnlTdHJpbmcpIHtcbiAgICAgICAgdGhpcy5zZWFyY2ggPSAnJztcbiAgICAgICAgdGhpcy5xdWVyeSA9IHt9O1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICB9XG5cbiAgdmFyIHByb3RvID0gcHJvdG9jb2xQYXR0ZXJuLmV4ZWMocmVzdCk7XG4gIGlmIChwcm90bykge1xuICAgIHByb3RvID0gcHJvdG9bMF07XG4gICAgdmFyIGxvd2VyUHJvdG8gPSBwcm90by50b0xvd2VyQ2FzZSgpO1xuICAgIHRoaXMucHJvdG9jb2wgPSBsb3dlclByb3RvO1xuICAgIHJlc3QgPSByZXN0LnN1YnN0cihwcm90by5sZW5ndGgpO1xuICB9XG5cbiAgLy8gZmlndXJlIG91dCBpZiBpdCdzIGdvdCBhIGhvc3RcbiAgLy8gdXNlckBzZXJ2ZXIgaXMgKmFsd2F5cyogaW50ZXJwcmV0ZWQgYXMgYSBob3N0bmFtZSwgYW5kIHVybFxuICAvLyByZXNvbHV0aW9uIHdpbGwgdHJlYXQgLy9mb28vYmFyIGFzIGhvc3Q9Zm9vLHBhdGg9YmFyIGJlY2F1c2UgdGhhdCdzXG4gIC8vIGhvdyB0aGUgYnJvd3NlciByZXNvbHZlcyByZWxhdGl2ZSBVUkxzLlxuICBpZiAoc2xhc2hlc0Rlbm90ZUhvc3QgfHwgcHJvdG8gfHwgcmVzdC5tYXRjaCgvXlxcL1xcL1teQFxcL10rQFteQFxcL10rLykpIHtcbiAgICB2YXIgc2xhc2hlcyA9IHJlc3Quc3Vic3RyKDAsIDIpID09PSAnLy8nO1xuICAgIGlmIChzbGFzaGVzICYmICEocHJvdG8gJiYgaG9zdGxlc3NQcm90b2NvbFtwcm90b10pKSB7XG4gICAgICByZXN0ID0gcmVzdC5zdWJzdHIoMik7XG4gICAgICB0aGlzLnNsYXNoZXMgPSB0cnVlO1xuICAgIH1cbiAgfVxuXG4gIGlmICghaG9zdGxlc3NQcm90b2NvbFtwcm90b10gJiZcbiAgICAgIChzbGFzaGVzIHx8IChwcm90byAmJiAhc2xhc2hlZFByb3RvY29sW3Byb3RvXSkpKSB7XG5cbiAgICAvLyB0aGVyZSdzIGEgaG9zdG5hbWUuXG4gICAgLy8gdGhlIGZpcnN0IGluc3RhbmNlIG9mIC8sID8sIDssIG9yICMgZW5kcyB0aGUgaG9zdC5cbiAgICAvL1xuICAgIC8vIElmIHRoZXJlIGlzIGFuIEAgaW4gdGhlIGhvc3RuYW1lLCB0aGVuIG5vbi1ob3N0IGNoYXJzICphcmUqIGFsbG93ZWRcbiAgICAvLyB0byB0aGUgbGVmdCBvZiB0aGUgbGFzdCBAIHNpZ24sIHVubGVzcyBzb21lIGhvc3QtZW5kaW5nIGNoYXJhY3RlclxuICAgIC8vIGNvbWVzICpiZWZvcmUqIHRoZSBALXNpZ24uXG4gICAgLy8gVVJMcyBhcmUgb2Jub3hpb3VzLlxuICAgIC8vXG4gICAgLy8gZXg6XG4gICAgLy8gaHR0cDovL2FAYkBjLyA9PiB1c2VyOmFAYiBob3N0OmNcbiAgICAvLyBodHRwOi8vYUBiP0BjID0+IHVzZXI6YSBob3N0OmMgcGF0aDovP0BjXG5cbiAgICAvLyB2MC4xMiBUT0RPKGlzYWFjcyk6IFRoaXMgaXMgbm90IHF1aXRlIGhvdyBDaHJvbWUgZG9lcyB0aGluZ3MuXG4gICAgLy8gUmV2aWV3IG91ciB0ZXN0IGNhc2UgYWdhaW5zdCBicm93c2VycyBtb3JlIGNvbXByZWhlbnNpdmVseS5cblxuICAgIC8vIGZpbmQgdGhlIGZpcnN0IGluc3RhbmNlIG9mIGFueSBob3N0RW5kaW5nQ2hhcnNcbiAgICB2YXIgaG9zdEVuZCA9IC0xO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgaG9zdEVuZGluZ0NoYXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgaGVjID0gcmVzdC5pbmRleE9mKGhvc3RFbmRpbmdDaGFyc1tpXSk7XG4gICAgICBpZiAoaGVjICE9PSAtMSAmJiAoaG9zdEVuZCA9PT0gLTEgfHwgaGVjIDwgaG9zdEVuZCkpXG4gICAgICAgIGhvc3RFbmQgPSBoZWM7XG4gICAgfVxuXG4gICAgLy8gYXQgdGhpcyBwb2ludCwgZWl0aGVyIHdlIGhhdmUgYW4gZXhwbGljaXQgcG9pbnQgd2hlcmUgdGhlXG4gICAgLy8gYXV0aCBwb3J0aW9uIGNhbm5vdCBnbyBwYXN0LCBvciB0aGUgbGFzdCBAIGNoYXIgaXMgdGhlIGRlY2lkZXIuXG4gICAgdmFyIGF1dGgsIGF0U2lnbjtcbiAgICBpZiAoaG9zdEVuZCA9PT0gLTEpIHtcbiAgICAgIC8vIGF0U2lnbiBjYW4gYmUgYW55d2hlcmUuXG4gICAgICBhdFNpZ24gPSByZXN0Lmxhc3RJbmRleE9mKCdAJyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIGF0U2lnbiBtdXN0IGJlIGluIGF1dGggcG9ydGlvbi5cbiAgICAgIC8vIGh0dHA6Ly9hQGIvY0BkID0+IGhvc3Q6YiBhdXRoOmEgcGF0aDovY0BkXG4gICAgICBhdFNpZ24gPSByZXN0Lmxhc3RJbmRleE9mKCdAJywgaG9zdEVuZCk7XG4gICAgfVxuXG4gICAgLy8gTm93IHdlIGhhdmUgYSBwb3J0aW9uIHdoaWNoIGlzIGRlZmluaXRlbHkgdGhlIGF1dGguXG4gICAgLy8gUHVsbCB0aGF0IG9mZi5cbiAgICBpZiAoYXRTaWduICE9PSAtMSkge1xuICAgICAgYXV0aCA9IHJlc3Quc2xpY2UoMCwgYXRTaWduKTtcbiAgICAgIHJlc3QgPSByZXN0LnNsaWNlKGF0U2lnbiArIDEpO1xuICAgICAgdGhpcy5hdXRoID0gZGVjb2RlVVJJQ29tcG9uZW50KGF1dGgpO1xuICAgIH1cblxuICAgIC8vIHRoZSBob3N0IGlzIHRoZSByZW1haW5pbmcgdG8gdGhlIGxlZnQgb2YgdGhlIGZpcnN0IG5vbi1ob3N0IGNoYXJcbiAgICBob3N0RW5kID0gLTE7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBub25Ib3N0Q2hhcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBoZWMgPSByZXN0LmluZGV4T2Yobm9uSG9zdENoYXJzW2ldKTtcbiAgICAgIGlmIChoZWMgIT09IC0xICYmIChob3N0RW5kID09PSAtMSB8fCBoZWMgPCBob3N0RW5kKSlcbiAgICAgICAgaG9zdEVuZCA9IGhlYztcbiAgICB9XG4gICAgLy8gaWYgd2Ugc3RpbGwgaGF2ZSBub3QgaGl0IGl0LCB0aGVuIHRoZSBlbnRpcmUgdGhpbmcgaXMgYSBob3N0LlxuICAgIGlmIChob3N0RW5kID09PSAtMSlcbiAgICAgIGhvc3RFbmQgPSByZXN0Lmxlbmd0aDtcblxuICAgIHRoaXMuaG9zdCA9IHJlc3Quc2xpY2UoMCwgaG9zdEVuZCk7XG4gICAgcmVzdCA9IHJlc3Quc2xpY2UoaG9zdEVuZCk7XG5cbiAgICAvLyBwdWxsIG91dCBwb3J0LlxuICAgIHRoaXMucGFyc2VIb3N0KCk7XG5cbiAgICAvLyB3ZSd2ZSBpbmRpY2F0ZWQgdGhhdCB0aGVyZSBpcyBhIGhvc3RuYW1lLFxuICAgIC8vIHNvIGV2ZW4gaWYgaXQncyBlbXB0eSwgaXQgaGFzIHRvIGJlIHByZXNlbnQuXG4gICAgdGhpcy5ob3N0bmFtZSA9IHRoaXMuaG9zdG5hbWUgfHwgJyc7XG5cbiAgICAvLyBpZiBob3N0bmFtZSBiZWdpbnMgd2l0aCBbIGFuZCBlbmRzIHdpdGggXVxuICAgIC8vIGFzc3VtZSB0aGF0IGl0J3MgYW4gSVB2NiBhZGRyZXNzLlxuICAgIHZhciBpcHY2SG9zdG5hbWUgPSB0aGlzLmhvc3RuYW1lWzBdID09PSAnWycgJiZcbiAgICAgICAgdGhpcy5ob3N0bmFtZVt0aGlzLmhvc3RuYW1lLmxlbmd0aCAtIDFdID09PSAnXSc7XG5cbiAgICAvLyB2YWxpZGF0ZSBhIGxpdHRsZS5cbiAgICBpZiAoIWlwdjZIb3N0bmFtZSkge1xuICAgICAgdmFyIGhvc3RwYXJ0cyA9IHRoaXMuaG9zdG5hbWUuc3BsaXQoL1xcLi8pO1xuICAgICAgZm9yICh2YXIgaSA9IDAsIGwgPSBob3N0cGFydHMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgIHZhciBwYXJ0ID0gaG9zdHBhcnRzW2ldO1xuICAgICAgICBpZiAoIXBhcnQpIGNvbnRpbnVlO1xuICAgICAgICBpZiAoIXBhcnQubWF0Y2goaG9zdG5hbWVQYXJ0UGF0dGVybikpIHtcbiAgICAgICAgICB2YXIgbmV3cGFydCA9ICcnO1xuICAgICAgICAgIGZvciAodmFyIGogPSAwLCBrID0gcGFydC5sZW5ndGg7IGogPCBrOyBqKyspIHtcbiAgICAgICAgICAgIGlmIChwYXJ0LmNoYXJDb2RlQXQoaikgPiAxMjcpIHtcbiAgICAgICAgICAgICAgLy8gd2UgcmVwbGFjZSBub24tQVNDSUkgY2hhciB3aXRoIGEgdGVtcG9yYXJ5IHBsYWNlaG9sZGVyXG4gICAgICAgICAgICAgIC8vIHdlIG5lZWQgdGhpcyB0byBtYWtlIHN1cmUgc2l6ZSBvZiBob3N0bmFtZSBpcyBub3RcbiAgICAgICAgICAgICAgLy8gYnJva2VuIGJ5IHJlcGxhY2luZyBub24tQVNDSUkgYnkgbm90aGluZ1xuICAgICAgICAgICAgICBuZXdwYXJ0ICs9ICd4JztcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIG5ld3BhcnQgKz0gcGFydFtqXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgLy8gd2UgdGVzdCBhZ2FpbiB3aXRoIEFTQ0lJIGNoYXIgb25seVxuICAgICAgICAgIGlmICghbmV3cGFydC5tYXRjaChob3N0bmFtZVBhcnRQYXR0ZXJuKSkge1xuICAgICAgICAgICAgdmFyIHZhbGlkUGFydHMgPSBob3N0cGFydHMuc2xpY2UoMCwgaSk7XG4gICAgICAgICAgICB2YXIgbm90SG9zdCA9IGhvc3RwYXJ0cy5zbGljZShpICsgMSk7XG4gICAgICAgICAgICB2YXIgYml0ID0gcGFydC5tYXRjaChob3N0bmFtZVBhcnRTdGFydCk7XG4gICAgICAgICAgICBpZiAoYml0KSB7XG4gICAgICAgICAgICAgIHZhbGlkUGFydHMucHVzaChiaXRbMV0pO1xuICAgICAgICAgICAgICBub3RIb3N0LnVuc2hpZnQoYml0WzJdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChub3RIb3N0Lmxlbmd0aCkge1xuICAgICAgICAgICAgICByZXN0ID0gJy8nICsgbm90SG9zdC5qb2luKCcuJykgKyByZXN0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5ob3N0bmFtZSA9IHZhbGlkUGFydHMuam9pbignLicpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuaG9zdG5hbWUubGVuZ3RoID4gaG9zdG5hbWVNYXhMZW4pIHtcbiAgICAgIHRoaXMuaG9zdG5hbWUgPSAnJztcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gaG9zdG5hbWVzIGFyZSBhbHdheXMgbG93ZXIgY2FzZS5cbiAgICAgIHRoaXMuaG9zdG5hbWUgPSB0aGlzLmhvc3RuYW1lLnRvTG93ZXJDYXNlKCk7XG4gICAgfVxuXG4gICAgaWYgKCFpcHY2SG9zdG5hbWUpIHtcbiAgICAgIC8vIElETkEgU3VwcG9ydDogUmV0dXJucyBhIHB1bnljb2RlZCByZXByZXNlbnRhdGlvbiBvZiBcImRvbWFpblwiLlxuICAgICAgLy8gSXQgb25seSBjb252ZXJ0cyBwYXJ0cyBvZiB0aGUgZG9tYWluIG5hbWUgdGhhdFxuICAgICAgLy8gaGF2ZSBub24tQVNDSUkgY2hhcmFjdGVycywgaS5lLiBpdCBkb2Vzbid0IG1hdHRlciBpZlxuICAgICAgLy8geW91IGNhbGwgaXQgd2l0aCBhIGRvbWFpbiB0aGF0IGFscmVhZHkgaXMgQVNDSUktb25seS5cbiAgICAgIHRoaXMuaG9zdG5hbWUgPSBwdW55Y29kZS50b0FTQ0lJKHRoaXMuaG9zdG5hbWUpO1xuICAgIH1cblxuICAgIHZhciBwID0gdGhpcy5wb3J0ID8gJzonICsgdGhpcy5wb3J0IDogJyc7XG4gICAgdmFyIGggPSB0aGlzLmhvc3RuYW1lIHx8ICcnO1xuICAgIHRoaXMuaG9zdCA9IGggKyBwO1xuICAgIHRoaXMuaHJlZiArPSB0aGlzLmhvc3Q7XG5cbiAgICAvLyBzdHJpcCBbIGFuZCBdIGZyb20gdGhlIGhvc3RuYW1lXG4gICAgLy8gdGhlIGhvc3QgZmllbGQgc3RpbGwgcmV0YWlucyB0aGVtLCB0aG91Z2hcbiAgICBpZiAoaXB2Nkhvc3RuYW1lKSB7XG4gICAgICB0aGlzLmhvc3RuYW1lID0gdGhpcy5ob3N0bmFtZS5zdWJzdHIoMSwgdGhpcy5ob3N0bmFtZS5sZW5ndGggLSAyKTtcbiAgICAgIGlmIChyZXN0WzBdICE9PSAnLycpIHtcbiAgICAgICAgcmVzdCA9ICcvJyArIHJlc3Q7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLy8gbm93IHJlc3QgaXMgc2V0IHRvIHRoZSBwb3N0LWhvc3Qgc3R1ZmYuXG4gIC8vIGNob3Agb2ZmIGFueSBkZWxpbSBjaGFycy5cbiAgaWYgKCF1bnNhZmVQcm90b2NvbFtsb3dlclByb3RvXSkge1xuXG4gICAgLy8gRmlyc3QsIG1ha2UgMTAwJSBzdXJlIHRoYXQgYW55IFwiYXV0b0VzY2FwZVwiIGNoYXJzIGdldFxuICAgIC8vIGVzY2FwZWQsIGV2ZW4gaWYgZW5jb2RlVVJJQ29tcG9uZW50IGRvZXNuJ3QgdGhpbmsgdGhleVxuICAgIC8vIG5lZWQgdG8gYmUuXG4gICAgZm9yICh2YXIgaSA9IDAsIGwgPSBhdXRvRXNjYXBlLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgdmFyIGFlID0gYXV0b0VzY2FwZVtpXTtcbiAgICAgIGlmIChyZXN0LmluZGV4T2YoYWUpID09PSAtMSlcbiAgICAgICAgY29udGludWU7XG4gICAgICB2YXIgZXNjID0gZW5jb2RlVVJJQ29tcG9uZW50KGFlKTtcbiAgICAgIGlmIChlc2MgPT09IGFlKSB7XG4gICAgICAgIGVzYyA9IGVzY2FwZShhZSk7XG4gICAgICB9XG4gICAgICByZXN0ID0gcmVzdC5zcGxpdChhZSkuam9pbihlc2MpO1xuICAgIH1cbiAgfVxuXG5cbiAgLy8gY2hvcCBvZmYgZnJvbSB0aGUgdGFpbCBmaXJzdC5cbiAgdmFyIGhhc2ggPSByZXN0LmluZGV4T2YoJyMnKTtcbiAgaWYgKGhhc2ggIT09IC0xKSB7XG4gICAgLy8gZ290IGEgZnJhZ21lbnQgc3RyaW5nLlxuICAgIHRoaXMuaGFzaCA9IHJlc3Quc3Vic3RyKGhhc2gpO1xuICAgIHJlc3QgPSByZXN0LnNsaWNlKDAsIGhhc2gpO1xuICB9XG4gIHZhciBxbSA9IHJlc3QuaW5kZXhPZignPycpO1xuICBpZiAocW0gIT09IC0xKSB7XG4gICAgdGhpcy5zZWFyY2ggPSByZXN0LnN1YnN0cihxbSk7XG4gICAgdGhpcy5xdWVyeSA9IHJlc3Quc3Vic3RyKHFtICsgMSk7XG4gICAgaWYgKHBhcnNlUXVlcnlTdHJpbmcpIHtcbiAgICAgIHRoaXMucXVlcnkgPSBxdWVyeXN0cmluZy5wYXJzZSh0aGlzLnF1ZXJ5KTtcbiAgICB9XG4gICAgcmVzdCA9IHJlc3Quc2xpY2UoMCwgcW0pO1xuICB9IGVsc2UgaWYgKHBhcnNlUXVlcnlTdHJpbmcpIHtcbiAgICAvLyBubyBxdWVyeSBzdHJpbmcsIGJ1dCBwYXJzZVF1ZXJ5U3RyaW5nIHN0aWxsIHJlcXVlc3RlZFxuICAgIHRoaXMuc2VhcmNoID0gJyc7XG4gICAgdGhpcy5xdWVyeSA9IHt9O1xuICB9XG4gIGlmIChyZXN0KSB0aGlzLnBhdGhuYW1lID0gcmVzdDtcbiAgaWYgKHNsYXNoZWRQcm90b2NvbFtsb3dlclByb3RvXSAmJlxuICAgICAgdGhpcy5ob3N0bmFtZSAmJiAhdGhpcy5wYXRobmFtZSkge1xuICAgIHRoaXMucGF0aG5hbWUgPSAnLyc7XG4gIH1cblxuICAvL3RvIHN1cHBvcnQgaHR0cC5yZXF1ZXN0XG4gIGlmICh0aGlzLnBhdGhuYW1lIHx8IHRoaXMuc2VhcmNoKSB7XG4gICAgdmFyIHAgPSB0aGlzLnBhdGhuYW1lIHx8ICcnO1xuICAgIHZhciBzID0gdGhpcy5zZWFyY2ggfHwgJyc7XG4gICAgdGhpcy5wYXRoID0gcCArIHM7XG4gIH1cblxuICAvLyBmaW5hbGx5LCByZWNvbnN0cnVjdCB0aGUgaHJlZiBiYXNlZCBvbiB3aGF0IGhhcyBiZWVuIHZhbGlkYXRlZC5cbiAgdGhpcy5ocmVmID0gdGhpcy5mb3JtYXQoKTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vLyBmb3JtYXQgYSBwYXJzZWQgb2JqZWN0IGludG8gYSB1cmwgc3RyaW5nXG5mdW5jdGlvbiB1cmxGb3JtYXQob2JqKSB7XG4gIC8vIGVuc3VyZSBpdCdzIGFuIG9iamVjdCwgYW5kIG5vdCBhIHN0cmluZyB1cmwuXG4gIC8vIElmIGl0J3MgYW4gb2JqLCB0aGlzIGlzIGEgbm8tb3AuXG4gIC8vIHRoaXMgd2F5LCB5b3UgY2FuIGNhbGwgdXJsX2Zvcm1hdCgpIG9uIHN0cmluZ3NcbiAgLy8gdG8gY2xlYW4gdXAgcG90ZW50aWFsbHkgd29ua3kgdXJscy5cbiAgaWYgKHV0aWwuaXNTdHJpbmcob2JqKSkgb2JqID0gdXJsUGFyc2Uob2JqKTtcbiAgaWYgKCEob2JqIGluc3RhbmNlb2YgVXJsKSkgcmV0dXJuIFVybC5wcm90b3R5cGUuZm9ybWF0LmNhbGwob2JqKTtcbiAgcmV0dXJuIG9iai5mb3JtYXQoKTtcbn1cblxuVXJsLnByb3RvdHlwZS5mb3JtYXQgPSBmdW5jdGlvbigpIHtcbiAgdmFyIGF1dGggPSB0aGlzLmF1dGggfHwgJyc7XG4gIGlmIChhdXRoKSB7XG4gICAgYXV0aCA9IGVuY29kZVVSSUNvbXBvbmVudChhdXRoKTtcbiAgICBhdXRoID0gYXV0aC5yZXBsYWNlKC8lM0EvaSwgJzonKTtcbiAgICBhdXRoICs9ICdAJztcbiAgfVxuXG4gIHZhciBwcm90b2NvbCA9IHRoaXMucHJvdG9jb2wgfHwgJycsXG4gICAgICBwYXRobmFtZSA9IHRoaXMucGF0aG5hbWUgfHwgJycsXG4gICAgICBoYXNoID0gdGhpcy5oYXNoIHx8ICcnLFxuICAgICAgaG9zdCA9IGZhbHNlLFxuICAgICAgcXVlcnkgPSAnJztcblxuICBpZiAodGhpcy5ob3N0KSB7XG4gICAgaG9zdCA9IGF1dGggKyB0aGlzLmhvc3Q7XG4gIH0gZWxzZSBpZiAodGhpcy5ob3N0bmFtZSkge1xuICAgIGhvc3QgPSBhdXRoICsgKHRoaXMuaG9zdG5hbWUuaW5kZXhPZignOicpID09PSAtMSA/XG4gICAgICAgIHRoaXMuaG9zdG5hbWUgOlxuICAgICAgICAnWycgKyB0aGlzLmhvc3RuYW1lICsgJ10nKTtcbiAgICBpZiAodGhpcy5wb3J0KSB7XG4gICAgICBob3N0ICs9ICc6JyArIHRoaXMucG9ydDtcbiAgICB9XG4gIH1cblxuICBpZiAodGhpcy5xdWVyeSAmJlxuICAgICAgdXRpbC5pc09iamVjdCh0aGlzLnF1ZXJ5KSAmJlxuICAgICAgT2JqZWN0LmtleXModGhpcy5xdWVyeSkubGVuZ3RoKSB7XG4gICAgcXVlcnkgPSBxdWVyeXN0cmluZy5zdHJpbmdpZnkodGhpcy5xdWVyeSk7XG4gIH1cblxuICB2YXIgc2VhcmNoID0gdGhpcy5zZWFyY2ggfHwgKHF1ZXJ5ICYmICgnPycgKyBxdWVyeSkpIHx8ICcnO1xuXG4gIGlmIChwcm90b2NvbCAmJiBwcm90b2NvbC5zdWJzdHIoLTEpICE9PSAnOicpIHByb3RvY29sICs9ICc6JztcblxuICAvLyBvbmx5IHRoZSBzbGFzaGVkUHJvdG9jb2xzIGdldCB0aGUgLy8uICBOb3QgbWFpbHRvOiwgeG1wcDosIGV0Yy5cbiAgLy8gdW5sZXNzIHRoZXkgaGFkIHRoZW0gdG8gYmVnaW4gd2l0aC5cbiAgaWYgKHRoaXMuc2xhc2hlcyB8fFxuICAgICAgKCFwcm90b2NvbCB8fCBzbGFzaGVkUHJvdG9jb2xbcHJvdG9jb2xdKSAmJiBob3N0ICE9PSBmYWxzZSkge1xuICAgIGhvc3QgPSAnLy8nICsgKGhvc3QgfHwgJycpO1xuICAgIGlmIChwYXRobmFtZSAmJiBwYXRobmFtZS5jaGFyQXQoMCkgIT09ICcvJykgcGF0aG5hbWUgPSAnLycgKyBwYXRobmFtZTtcbiAgfSBlbHNlIGlmICghaG9zdCkge1xuICAgIGhvc3QgPSAnJztcbiAgfVxuXG4gIGlmIChoYXNoICYmIGhhc2guY2hhckF0KDApICE9PSAnIycpIGhhc2ggPSAnIycgKyBoYXNoO1xuICBpZiAoc2VhcmNoICYmIHNlYXJjaC5jaGFyQXQoMCkgIT09ICc/Jykgc2VhcmNoID0gJz8nICsgc2VhcmNoO1xuXG4gIHBhdGhuYW1lID0gcGF0aG5hbWUucmVwbGFjZSgvWz8jXS9nLCBmdW5jdGlvbihtYXRjaCkge1xuICAgIHJldHVybiBlbmNvZGVVUklDb21wb25lbnQobWF0Y2gpO1xuICB9KTtcbiAgc2VhcmNoID0gc2VhcmNoLnJlcGxhY2UoJyMnLCAnJTIzJyk7XG5cbiAgcmV0dXJuIHByb3RvY29sICsgaG9zdCArIHBhdGhuYW1lICsgc2VhcmNoICsgaGFzaDtcbn07XG5cbmZ1bmN0aW9uIHVybFJlc29sdmUoc291cmNlLCByZWxhdGl2ZSkge1xuICByZXR1cm4gdXJsUGFyc2Uoc291cmNlLCBmYWxzZSwgdHJ1ZSkucmVzb2x2ZShyZWxhdGl2ZSk7XG59XG5cblVybC5wcm90b3R5cGUucmVzb2x2ZSA9IGZ1bmN0aW9uKHJlbGF0aXZlKSB7XG4gIHJldHVybiB0aGlzLnJlc29sdmVPYmplY3QodXJsUGFyc2UocmVsYXRpdmUsIGZhbHNlLCB0cnVlKSkuZm9ybWF0KCk7XG59O1xuXG5mdW5jdGlvbiB1cmxSZXNvbHZlT2JqZWN0KHNvdXJjZSwgcmVsYXRpdmUpIHtcbiAgaWYgKCFzb3VyY2UpIHJldHVybiByZWxhdGl2ZTtcbiAgcmV0dXJuIHVybFBhcnNlKHNvdXJjZSwgZmFsc2UsIHRydWUpLnJlc29sdmVPYmplY3QocmVsYXRpdmUpO1xufVxuXG5VcmwucHJvdG90eXBlLnJlc29sdmVPYmplY3QgPSBmdW5jdGlvbihyZWxhdGl2ZSkge1xuICBpZiAodXRpbC5pc1N0cmluZyhyZWxhdGl2ZSkpIHtcbiAgICB2YXIgcmVsID0gbmV3IFVybCgpO1xuICAgIHJlbC5wYXJzZShyZWxhdGl2ZSwgZmFsc2UsIHRydWUpO1xuICAgIHJlbGF0aXZlID0gcmVsO1xuICB9XG5cbiAgdmFyIHJlc3VsdCA9IG5ldyBVcmwoKTtcbiAgdmFyIHRrZXlzID0gT2JqZWN0LmtleXModGhpcyk7XG4gIGZvciAodmFyIHRrID0gMDsgdGsgPCB0a2V5cy5sZW5ndGg7IHRrKyspIHtcbiAgICB2YXIgdGtleSA9IHRrZXlzW3RrXTtcbiAgICByZXN1bHRbdGtleV0gPSB0aGlzW3RrZXldO1xuICB9XG5cbiAgLy8gaGFzaCBpcyBhbHdheXMgb3ZlcnJpZGRlbiwgbm8gbWF0dGVyIHdoYXQuXG4gIC8vIGV2ZW4gaHJlZj1cIlwiIHdpbGwgcmVtb3ZlIGl0LlxuICByZXN1bHQuaGFzaCA9IHJlbGF0aXZlLmhhc2g7XG5cbiAgLy8gaWYgdGhlIHJlbGF0aXZlIHVybCBpcyBlbXB0eSwgdGhlbiB0aGVyZSdzIG5vdGhpbmcgbGVmdCB0byBkbyBoZXJlLlxuICBpZiAocmVsYXRpdmUuaHJlZiA9PT0gJycpIHtcbiAgICByZXN1bHQuaHJlZiA9IHJlc3VsdC5mb3JtYXQoKTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgLy8gaHJlZnMgbGlrZSAvL2Zvby9iYXIgYWx3YXlzIGN1dCB0byB0aGUgcHJvdG9jb2wuXG4gIGlmIChyZWxhdGl2ZS5zbGFzaGVzICYmICFyZWxhdGl2ZS5wcm90b2NvbCkge1xuICAgIC8vIHRha2UgZXZlcnl0aGluZyBleGNlcHQgdGhlIHByb3RvY29sIGZyb20gcmVsYXRpdmVcbiAgICB2YXIgcmtleXMgPSBPYmplY3Qua2V5cyhyZWxhdGl2ZSk7XG4gICAgZm9yICh2YXIgcmsgPSAwOyByayA8IHJrZXlzLmxlbmd0aDsgcmsrKykge1xuICAgICAgdmFyIHJrZXkgPSBya2V5c1tya107XG4gICAgICBpZiAocmtleSAhPT0gJ3Byb3RvY29sJylcbiAgICAgICAgcmVzdWx0W3JrZXldID0gcmVsYXRpdmVbcmtleV07XG4gICAgfVxuXG4gICAgLy91cmxQYXJzZSBhcHBlbmRzIHRyYWlsaW5nIC8gdG8gdXJscyBsaWtlIGh0dHA6Ly93d3cuZXhhbXBsZS5jb21cbiAgICBpZiAoc2xhc2hlZFByb3RvY29sW3Jlc3VsdC5wcm90b2NvbF0gJiZcbiAgICAgICAgcmVzdWx0Lmhvc3RuYW1lICYmICFyZXN1bHQucGF0aG5hbWUpIHtcbiAgICAgIHJlc3VsdC5wYXRoID0gcmVzdWx0LnBhdGhuYW1lID0gJy8nO1xuICAgIH1cblxuICAgIHJlc3VsdC5ocmVmID0gcmVzdWx0LmZvcm1hdCgpO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICBpZiAocmVsYXRpdmUucHJvdG9jb2wgJiYgcmVsYXRpdmUucHJvdG9jb2wgIT09IHJlc3VsdC5wcm90b2NvbCkge1xuICAgIC8vIGlmIGl0J3MgYSBrbm93biB1cmwgcHJvdG9jb2wsIHRoZW4gY2hhbmdpbmdcbiAgICAvLyB0aGUgcHJvdG9jb2wgZG9lcyB3ZWlyZCB0aGluZ3NcbiAgICAvLyBmaXJzdCwgaWYgaXQncyBub3QgZmlsZTosIHRoZW4gd2UgTVVTVCBoYXZlIGEgaG9zdCxcbiAgICAvLyBhbmQgaWYgdGhlcmUgd2FzIGEgcGF0aFxuICAgIC8vIHRvIGJlZ2luIHdpdGgsIHRoZW4gd2UgTVVTVCBoYXZlIGEgcGF0aC5cbiAgICAvLyBpZiBpdCBpcyBmaWxlOiwgdGhlbiB0aGUgaG9zdCBpcyBkcm9wcGVkLFxuICAgIC8vIGJlY2F1c2UgdGhhdCdzIGtub3duIHRvIGJlIGhvc3RsZXNzLlxuICAgIC8vIGFueXRoaW5nIGVsc2UgaXMgYXNzdW1lZCB0byBiZSBhYnNvbHV0ZS5cbiAgICBpZiAoIXNsYXNoZWRQcm90b2NvbFtyZWxhdGl2ZS5wcm90b2NvbF0pIHtcbiAgICAgIHZhciBrZXlzID0gT2JqZWN0LmtleXMocmVsYXRpdmUpO1xuICAgICAgZm9yICh2YXIgdiA9IDA7IHYgPCBrZXlzLmxlbmd0aDsgdisrKSB7XG4gICAgICAgIHZhciBrID0ga2V5c1t2XTtcbiAgICAgICAgcmVzdWx0W2tdID0gcmVsYXRpdmVba107XG4gICAgICB9XG4gICAgICByZXN1bHQuaHJlZiA9IHJlc3VsdC5mb3JtYXQoKTtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgcmVzdWx0LnByb3RvY29sID0gcmVsYXRpdmUucHJvdG9jb2w7XG4gICAgaWYgKCFyZWxhdGl2ZS5ob3N0ICYmICFob3N0bGVzc1Byb3RvY29sW3JlbGF0aXZlLnByb3RvY29sXSkge1xuICAgICAgdmFyIHJlbFBhdGggPSAocmVsYXRpdmUucGF0aG5hbWUgfHwgJycpLnNwbGl0KCcvJyk7XG4gICAgICB3aGlsZSAocmVsUGF0aC5sZW5ndGggJiYgIShyZWxhdGl2ZS5ob3N0ID0gcmVsUGF0aC5zaGlmdCgpKSk7XG4gICAgICBpZiAoIXJlbGF0aXZlLmhvc3QpIHJlbGF0aXZlLmhvc3QgPSAnJztcbiAgICAgIGlmICghcmVsYXRpdmUuaG9zdG5hbWUpIHJlbGF0aXZlLmhvc3RuYW1lID0gJyc7XG4gICAgICBpZiAocmVsUGF0aFswXSAhPT0gJycpIHJlbFBhdGgudW5zaGlmdCgnJyk7XG4gICAgICBpZiAocmVsUGF0aC5sZW5ndGggPCAyKSByZWxQYXRoLnVuc2hpZnQoJycpO1xuICAgICAgcmVzdWx0LnBhdGhuYW1lID0gcmVsUGF0aC5qb2luKCcvJyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlc3VsdC5wYXRobmFtZSA9IHJlbGF0aXZlLnBhdGhuYW1lO1xuICAgIH1cbiAgICByZXN1bHQuc2VhcmNoID0gcmVsYXRpdmUuc2VhcmNoO1xuICAgIHJlc3VsdC5xdWVyeSA9IHJlbGF0aXZlLnF1ZXJ5O1xuICAgIHJlc3VsdC5ob3N0ID0gcmVsYXRpdmUuaG9zdCB8fCAnJztcbiAgICByZXN1bHQuYXV0aCA9IHJlbGF0aXZlLmF1dGg7XG4gICAgcmVzdWx0Lmhvc3RuYW1lID0gcmVsYXRpdmUuaG9zdG5hbWUgfHwgcmVsYXRpdmUuaG9zdDtcbiAgICByZXN1bHQucG9ydCA9IHJlbGF0aXZlLnBvcnQ7XG4gICAgLy8gdG8gc3VwcG9ydCBodHRwLnJlcXVlc3RcbiAgICBpZiAocmVzdWx0LnBhdGhuYW1lIHx8IHJlc3VsdC5zZWFyY2gpIHtcbiAgICAgIHZhciBwID0gcmVzdWx0LnBhdGhuYW1lIHx8ICcnO1xuICAgICAgdmFyIHMgPSByZXN1bHQuc2VhcmNoIHx8ICcnO1xuICAgICAgcmVzdWx0LnBhdGggPSBwICsgcztcbiAgICB9XG4gICAgcmVzdWx0LnNsYXNoZXMgPSByZXN1bHQuc2xhc2hlcyB8fCByZWxhdGl2ZS5zbGFzaGVzO1xuICAgIHJlc3VsdC5ocmVmID0gcmVzdWx0LmZvcm1hdCgpO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICB2YXIgaXNTb3VyY2VBYnMgPSAocmVzdWx0LnBhdGhuYW1lICYmIHJlc3VsdC5wYXRobmFtZS5jaGFyQXQoMCkgPT09ICcvJyksXG4gICAgICBpc1JlbEFicyA9IChcbiAgICAgICAgICByZWxhdGl2ZS5ob3N0IHx8XG4gICAgICAgICAgcmVsYXRpdmUucGF0aG5hbWUgJiYgcmVsYXRpdmUucGF0aG5hbWUuY2hhckF0KDApID09PSAnLydcbiAgICAgICksXG4gICAgICBtdXN0RW5kQWJzID0gKGlzUmVsQWJzIHx8IGlzU291cmNlQWJzIHx8XG4gICAgICAgICAgICAgICAgICAgIChyZXN1bHQuaG9zdCAmJiByZWxhdGl2ZS5wYXRobmFtZSkpLFxuICAgICAgcmVtb3ZlQWxsRG90cyA9IG11c3RFbmRBYnMsXG4gICAgICBzcmNQYXRoID0gcmVzdWx0LnBhdGhuYW1lICYmIHJlc3VsdC5wYXRobmFtZS5zcGxpdCgnLycpIHx8IFtdLFxuICAgICAgcmVsUGF0aCA9IHJlbGF0aXZlLnBhdGhuYW1lICYmIHJlbGF0aXZlLnBhdGhuYW1lLnNwbGl0KCcvJykgfHwgW10sXG4gICAgICBwc3ljaG90aWMgPSByZXN1bHQucHJvdG9jb2wgJiYgIXNsYXNoZWRQcm90b2NvbFtyZXN1bHQucHJvdG9jb2xdO1xuXG4gIC8vIGlmIHRoZSB1cmwgaXMgYSBub24tc2xhc2hlZCB1cmwsIHRoZW4gcmVsYXRpdmVcbiAgLy8gbGlua3MgbGlrZSAuLi8uLiBzaG91bGQgYmUgYWJsZVxuICAvLyB0byBjcmF3bCB1cCB0byB0aGUgaG9zdG5hbWUsIGFzIHdlbGwuICBUaGlzIGlzIHN0cmFuZ2UuXG4gIC8vIHJlc3VsdC5wcm90b2NvbCBoYXMgYWxyZWFkeSBiZWVuIHNldCBieSBub3cuXG4gIC8vIExhdGVyIG9uLCBwdXQgdGhlIGZpcnN0IHBhdGggcGFydCBpbnRvIHRoZSBob3N0IGZpZWxkLlxuICBpZiAocHN5Y2hvdGljKSB7XG4gICAgcmVzdWx0Lmhvc3RuYW1lID0gJyc7XG4gICAgcmVzdWx0LnBvcnQgPSBudWxsO1xuICAgIGlmIChyZXN1bHQuaG9zdCkge1xuICAgICAgaWYgKHNyY1BhdGhbMF0gPT09ICcnKSBzcmNQYXRoWzBdID0gcmVzdWx0Lmhvc3Q7XG4gICAgICBlbHNlIHNyY1BhdGgudW5zaGlmdChyZXN1bHQuaG9zdCk7XG4gICAgfVxuICAgIHJlc3VsdC5ob3N0ID0gJyc7XG4gICAgaWYgKHJlbGF0aXZlLnByb3RvY29sKSB7XG4gICAgICByZWxhdGl2ZS5ob3N0bmFtZSA9IG51bGw7XG4gICAgICByZWxhdGl2ZS5wb3J0ID0gbnVsbDtcbiAgICAgIGlmIChyZWxhdGl2ZS5ob3N0KSB7XG4gICAgICAgIGlmIChyZWxQYXRoWzBdID09PSAnJykgcmVsUGF0aFswXSA9IHJlbGF0aXZlLmhvc3Q7XG4gICAgICAgIGVsc2UgcmVsUGF0aC51bnNoaWZ0KHJlbGF0aXZlLmhvc3QpO1xuICAgICAgfVxuICAgICAgcmVsYXRpdmUuaG9zdCA9IG51bGw7XG4gICAgfVxuICAgIG11c3RFbmRBYnMgPSBtdXN0RW5kQWJzICYmIChyZWxQYXRoWzBdID09PSAnJyB8fCBzcmNQYXRoWzBdID09PSAnJyk7XG4gIH1cblxuICBpZiAoaXNSZWxBYnMpIHtcbiAgICAvLyBpdCdzIGFic29sdXRlLlxuICAgIHJlc3VsdC5ob3N0ID0gKHJlbGF0aXZlLmhvc3QgfHwgcmVsYXRpdmUuaG9zdCA9PT0gJycpID9cbiAgICAgICAgICAgICAgICAgIHJlbGF0aXZlLmhvc3QgOiByZXN1bHQuaG9zdDtcbiAgICByZXN1bHQuaG9zdG5hbWUgPSAocmVsYXRpdmUuaG9zdG5hbWUgfHwgcmVsYXRpdmUuaG9zdG5hbWUgPT09ICcnKSA/XG4gICAgICAgICAgICAgICAgICAgICAgcmVsYXRpdmUuaG9zdG5hbWUgOiByZXN1bHQuaG9zdG5hbWU7XG4gICAgcmVzdWx0LnNlYXJjaCA9IHJlbGF0aXZlLnNlYXJjaDtcbiAgICByZXN1bHQucXVlcnkgPSByZWxhdGl2ZS5xdWVyeTtcbiAgICBzcmNQYXRoID0gcmVsUGF0aDtcbiAgICAvLyBmYWxsIHRocm91Z2ggdG8gdGhlIGRvdC1oYW5kbGluZyBiZWxvdy5cbiAgfSBlbHNlIGlmIChyZWxQYXRoLmxlbmd0aCkge1xuICAgIC8vIGl0J3MgcmVsYXRpdmVcbiAgICAvLyB0aHJvdyBhd2F5IHRoZSBleGlzdGluZyBmaWxlLCBhbmQgdGFrZSB0aGUgbmV3IHBhdGggaW5zdGVhZC5cbiAgICBpZiAoIXNyY1BhdGgpIHNyY1BhdGggPSBbXTtcbiAgICBzcmNQYXRoLnBvcCgpO1xuICAgIHNyY1BhdGggPSBzcmNQYXRoLmNvbmNhdChyZWxQYXRoKTtcbiAgICByZXN1bHQuc2VhcmNoID0gcmVsYXRpdmUuc2VhcmNoO1xuICAgIHJlc3VsdC5xdWVyeSA9IHJlbGF0aXZlLnF1ZXJ5O1xuICB9IGVsc2UgaWYgKCF1dGlsLmlzTnVsbE9yVW5kZWZpbmVkKHJlbGF0aXZlLnNlYXJjaCkpIHtcbiAgICAvLyBqdXN0IHB1bGwgb3V0IHRoZSBzZWFyY2guXG4gICAgLy8gbGlrZSBocmVmPSc/Zm9vJy5cbiAgICAvLyBQdXQgdGhpcyBhZnRlciB0aGUgb3RoZXIgdHdvIGNhc2VzIGJlY2F1c2UgaXQgc2ltcGxpZmllcyB0aGUgYm9vbGVhbnNcbiAgICBpZiAocHN5Y2hvdGljKSB7XG4gICAgICByZXN1bHQuaG9zdG5hbWUgPSByZXN1bHQuaG9zdCA9IHNyY1BhdGguc2hpZnQoKTtcbiAgICAgIC8vb2NjYXRpb25hbHkgdGhlIGF1dGggY2FuIGdldCBzdHVjayBvbmx5IGluIGhvc3RcbiAgICAgIC8vdGhpcyBlc3BlY2lhbGx5IGhhcHBlbnMgaW4gY2FzZXMgbGlrZVxuICAgICAgLy91cmwucmVzb2x2ZU9iamVjdCgnbWFpbHRvOmxvY2FsMUBkb21haW4xJywgJ2xvY2FsMkBkb21haW4yJylcbiAgICAgIHZhciBhdXRoSW5Ib3N0ID0gcmVzdWx0Lmhvc3QgJiYgcmVzdWx0Lmhvc3QuaW5kZXhPZignQCcpID4gMCA/XG4gICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdC5ob3N0LnNwbGl0KCdAJykgOiBmYWxzZTtcbiAgICAgIGlmIChhdXRoSW5Ib3N0KSB7XG4gICAgICAgIHJlc3VsdC5hdXRoID0gYXV0aEluSG9zdC5zaGlmdCgpO1xuICAgICAgICByZXN1bHQuaG9zdCA9IHJlc3VsdC5ob3N0bmFtZSA9IGF1dGhJbkhvc3Quc2hpZnQoKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmVzdWx0LnNlYXJjaCA9IHJlbGF0aXZlLnNlYXJjaDtcbiAgICByZXN1bHQucXVlcnkgPSByZWxhdGl2ZS5xdWVyeTtcbiAgICAvL3RvIHN1cHBvcnQgaHR0cC5yZXF1ZXN0XG4gICAgaWYgKCF1dGlsLmlzTnVsbChyZXN1bHQucGF0aG5hbWUpIHx8ICF1dGlsLmlzTnVsbChyZXN1bHQuc2VhcmNoKSkge1xuICAgICAgcmVzdWx0LnBhdGggPSAocmVzdWx0LnBhdGhuYW1lID8gcmVzdWx0LnBhdGhuYW1lIDogJycpICtcbiAgICAgICAgICAgICAgICAgICAgKHJlc3VsdC5zZWFyY2ggPyByZXN1bHQuc2VhcmNoIDogJycpO1xuICAgIH1cbiAgICByZXN1bHQuaHJlZiA9IHJlc3VsdC5mb3JtYXQoKTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgaWYgKCFzcmNQYXRoLmxlbmd0aCkge1xuICAgIC8vIG5vIHBhdGggYXQgYWxsLiAgZWFzeS5cbiAgICAvLyB3ZSd2ZSBhbHJlYWR5IGhhbmRsZWQgdGhlIG90aGVyIHN0dWZmIGFib3ZlLlxuICAgIHJlc3VsdC5wYXRobmFtZSA9IG51bGw7XG4gICAgLy90byBzdXBwb3J0IGh0dHAucmVxdWVzdFxuICAgIGlmIChyZXN1bHQuc2VhcmNoKSB7XG4gICAgICByZXN1bHQucGF0aCA9ICcvJyArIHJlc3VsdC5zZWFyY2g7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlc3VsdC5wYXRoID0gbnVsbDtcbiAgICB9XG4gICAgcmVzdWx0LmhyZWYgPSByZXN1bHQuZm9ybWF0KCk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIC8vIGlmIGEgdXJsIEVORHMgaW4gLiBvciAuLiwgdGhlbiBpdCBtdXN0IGdldCBhIHRyYWlsaW5nIHNsYXNoLlxuICAvLyBob3dldmVyLCBpZiBpdCBlbmRzIGluIGFueXRoaW5nIGVsc2Ugbm9uLXNsYXNoeSxcbiAgLy8gdGhlbiBpdCBtdXN0IE5PVCBnZXQgYSB0cmFpbGluZyBzbGFzaC5cbiAgdmFyIGxhc3QgPSBzcmNQYXRoLnNsaWNlKC0xKVswXTtcbiAgdmFyIGhhc1RyYWlsaW5nU2xhc2ggPSAoXG4gICAgICAocmVzdWx0Lmhvc3QgfHwgcmVsYXRpdmUuaG9zdCB8fCBzcmNQYXRoLmxlbmd0aCA+IDEpICYmXG4gICAgICAobGFzdCA9PT0gJy4nIHx8IGxhc3QgPT09ICcuLicpIHx8IGxhc3QgPT09ICcnKTtcblxuICAvLyBzdHJpcCBzaW5nbGUgZG90cywgcmVzb2x2ZSBkb3VibGUgZG90cyB0byBwYXJlbnQgZGlyXG4gIC8vIGlmIHRoZSBwYXRoIHRyaWVzIHRvIGdvIGFib3ZlIHRoZSByb290LCBgdXBgIGVuZHMgdXAgPiAwXG4gIHZhciB1cCA9IDA7XG4gIGZvciAodmFyIGkgPSBzcmNQYXRoLmxlbmd0aDsgaSA+PSAwOyBpLS0pIHtcbiAgICBsYXN0ID0gc3JjUGF0aFtpXTtcbiAgICBpZiAobGFzdCA9PT0gJy4nKSB7XG4gICAgICBzcmNQYXRoLnNwbGljZShpLCAxKTtcbiAgICB9IGVsc2UgaWYgKGxhc3QgPT09ICcuLicpIHtcbiAgICAgIHNyY1BhdGguc3BsaWNlKGksIDEpO1xuICAgICAgdXArKztcbiAgICB9IGVsc2UgaWYgKHVwKSB7XG4gICAgICBzcmNQYXRoLnNwbGljZShpLCAxKTtcbiAgICAgIHVwLS07XG4gICAgfVxuICB9XG5cbiAgLy8gaWYgdGhlIHBhdGggaXMgYWxsb3dlZCB0byBnbyBhYm92ZSB0aGUgcm9vdCwgcmVzdG9yZSBsZWFkaW5nIC4uc1xuICBpZiAoIW11c3RFbmRBYnMgJiYgIXJlbW92ZUFsbERvdHMpIHtcbiAgICBmb3IgKDsgdXAtLTsgdXApIHtcbiAgICAgIHNyY1BhdGgudW5zaGlmdCgnLi4nKTtcbiAgICB9XG4gIH1cblxuICBpZiAobXVzdEVuZEFicyAmJiBzcmNQYXRoWzBdICE9PSAnJyAmJlxuICAgICAgKCFzcmNQYXRoWzBdIHx8IHNyY1BhdGhbMF0uY2hhckF0KDApICE9PSAnLycpKSB7XG4gICAgc3JjUGF0aC51bnNoaWZ0KCcnKTtcbiAgfVxuXG4gIGlmIChoYXNUcmFpbGluZ1NsYXNoICYmIChzcmNQYXRoLmpvaW4oJy8nKS5zdWJzdHIoLTEpICE9PSAnLycpKSB7XG4gICAgc3JjUGF0aC5wdXNoKCcnKTtcbiAgfVxuXG4gIHZhciBpc0Fic29sdXRlID0gc3JjUGF0aFswXSA9PT0gJycgfHxcbiAgICAgIChzcmNQYXRoWzBdICYmIHNyY1BhdGhbMF0uY2hhckF0KDApID09PSAnLycpO1xuXG4gIC8vIHB1dCB0aGUgaG9zdCBiYWNrXG4gIGlmIChwc3ljaG90aWMpIHtcbiAgICByZXN1bHQuaG9zdG5hbWUgPSByZXN1bHQuaG9zdCA9IGlzQWJzb2x1dGUgPyAnJyA6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzcmNQYXRoLmxlbmd0aCA/IHNyY1BhdGguc2hpZnQoKSA6ICcnO1xuICAgIC8vb2NjYXRpb25hbHkgdGhlIGF1dGggY2FuIGdldCBzdHVjayBvbmx5IGluIGhvc3RcbiAgICAvL3RoaXMgZXNwZWNpYWxseSBoYXBwZW5zIGluIGNhc2VzIGxpa2VcbiAgICAvL3VybC5yZXNvbHZlT2JqZWN0KCdtYWlsdG86bG9jYWwxQGRvbWFpbjEnLCAnbG9jYWwyQGRvbWFpbjInKVxuICAgIHZhciBhdXRoSW5Ib3N0ID0gcmVzdWx0Lmhvc3QgJiYgcmVzdWx0Lmhvc3QuaW5kZXhPZignQCcpID4gMCA/XG4gICAgICAgICAgICAgICAgICAgICByZXN1bHQuaG9zdC5zcGxpdCgnQCcpIDogZmFsc2U7XG4gICAgaWYgKGF1dGhJbkhvc3QpIHtcbiAgICAgIHJlc3VsdC5hdXRoID0gYXV0aEluSG9zdC5zaGlmdCgpO1xuICAgICAgcmVzdWx0Lmhvc3QgPSByZXN1bHQuaG9zdG5hbWUgPSBhdXRoSW5Ib3N0LnNoaWZ0KCk7XG4gICAgfVxuICB9XG5cbiAgbXVzdEVuZEFicyA9IG11c3RFbmRBYnMgfHwgKHJlc3VsdC5ob3N0ICYmIHNyY1BhdGgubGVuZ3RoKTtcblxuICBpZiAobXVzdEVuZEFicyAmJiAhaXNBYnNvbHV0ZSkge1xuICAgIHNyY1BhdGgudW5zaGlmdCgnJyk7XG4gIH1cblxuICBpZiAoIXNyY1BhdGgubGVuZ3RoKSB7XG4gICAgcmVzdWx0LnBhdGhuYW1lID0gbnVsbDtcbiAgICByZXN1bHQucGF0aCA9IG51bGw7XG4gIH0gZWxzZSB7XG4gICAgcmVzdWx0LnBhdGhuYW1lID0gc3JjUGF0aC5qb2luKCcvJyk7XG4gIH1cblxuICAvL3RvIHN1cHBvcnQgcmVxdWVzdC5odHRwXG4gIGlmICghdXRpbC5pc051bGwocmVzdWx0LnBhdGhuYW1lKSB8fCAhdXRpbC5pc051bGwocmVzdWx0LnNlYXJjaCkpIHtcbiAgICByZXN1bHQucGF0aCA9IChyZXN1bHQucGF0aG5hbWUgPyByZXN1bHQucGF0aG5hbWUgOiAnJykgK1xuICAgICAgICAgICAgICAgICAgKHJlc3VsdC5zZWFyY2ggPyByZXN1bHQuc2VhcmNoIDogJycpO1xuICB9XG4gIHJlc3VsdC5hdXRoID0gcmVsYXRpdmUuYXV0aCB8fCByZXN1bHQuYXV0aDtcbiAgcmVzdWx0LnNsYXNoZXMgPSByZXN1bHQuc2xhc2hlcyB8fCByZWxhdGl2ZS5zbGFzaGVzO1xuICByZXN1bHQuaHJlZiA9IHJlc3VsdC5mb3JtYXQoKTtcbiAgcmV0dXJuIHJlc3VsdDtcbn07XG5cblVybC5wcm90b3R5cGUucGFyc2VIb3N0ID0gZnVuY3Rpb24oKSB7XG4gIHZhciBob3N0ID0gdGhpcy5ob3N0O1xuICB2YXIgcG9ydCA9IHBvcnRQYXR0ZXJuLmV4ZWMoaG9zdCk7XG4gIGlmIChwb3J0KSB7XG4gICAgcG9ydCA9IHBvcnRbMF07XG4gICAgaWYgKHBvcnQgIT09ICc6Jykge1xuICAgICAgdGhpcy5wb3J0ID0gcG9ydC5zdWJzdHIoMSk7XG4gICAgfVxuICAgIGhvc3QgPSBob3N0LnN1YnN0cigwLCBob3N0Lmxlbmd0aCAtIHBvcnQubGVuZ3RoKTtcbiAgfVxuICBpZiAoaG9zdCkgdGhpcy5ob3N0bmFtZSA9IGhvc3Q7XG59O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3VybC91cmwuanNcbi8vIG1vZHVsZSBpZCA9IDYxXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIGlzU3RyaW5nOiBmdW5jdGlvbihhcmcpIHtcbiAgICByZXR1cm4gdHlwZW9mKGFyZykgPT09ICdzdHJpbmcnO1xuICB9LFxuICBpc09iamVjdDogZnVuY3Rpb24oYXJnKSB7XG4gICAgcmV0dXJuIHR5cGVvZihhcmcpID09PSAnb2JqZWN0JyAmJiBhcmcgIT09IG51bGw7XG4gIH0sXG4gIGlzTnVsbDogZnVuY3Rpb24oYXJnKSB7XG4gICAgcmV0dXJuIGFyZyA9PT0gbnVsbDtcbiAgfSxcbiAgaXNOdWxsT3JVbmRlZmluZWQ6IGZ1bmN0aW9uKGFyZykge1xuICAgIHJldHVybiBhcmcgPT0gbnVsbDtcbiAgfVxufTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi91cmwvdXRpbC5qc1xuLy8gbW9kdWxlIGlkID0gNjJcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl19
